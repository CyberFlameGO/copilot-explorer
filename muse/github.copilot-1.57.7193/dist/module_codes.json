{
  "3": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getEngineURL = exports.TEST_ENGINE_PATHS = exports.OPENAI_PROXY_HOST = undefined;\nconst r = require(1133),\n  o = require(9189),\n  i = require(70);\nexports.OPENAI_PROXY_HOST = \"https://copilot-proxy.githubusercontent.com\";\nconst s = \"/v1/engines/copilot-codex\";\nexports.TEST_ENGINE_PATHS = [s];\nexports.getEngineURL = async function (e, n = \"\", a, c = \"\", l = \"\", u) {\n  return function (e, n) {\n    let o = function (e) {\n      return i.isRunningInTest(e) ? r.getConfig(e, r.ConfigKey.DebugTestOverrideProxyUrl) : r.getConfig(e, r.ConfigKey.DebugOverrideProxyUrl);\n    }(e);\n    0 == o.length && (o = exports.OPENAI_PROXY_HOST);\n    return `${o}${n}`;\n  }(e, await async function (e, t, n, i, a, c) {\n    const l = r.getConfig(e, r.ConfigKey.DebugOverrideEngine);\n    if (l) return `/v1/engines/${l}`;\n    const u = await e.get(o.Features).customEngine(t, n, i, a, c);\n    return \"\" !== u ? `/v1/engines/${u}` : s;\n  }(e, n, a, c, l, u));\n};",
  "19": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: !0,\n  code: require(412).validateUnion,\n  error: {\n    message: \"must match a schema in anyOf\"\n  }\n};\nexports.default = r;",
  "34": "var r;\nr = require(8249);\nrequire(4938);\n(function () {\n  var e = r,\n    t = e.lib.Hasher,\n    n = e.x64,\n    o = n.Word,\n    i = n.WordArray,\n    s = e.algo;\n  function a() {\n    return o.create.apply(o, arguments);\n  }\n  var c = [a(1116352408, 3609767458), a(1899447441, 602891725), a(3049323471, 3964484399), a(3921009573, 2173295548), a(961987163, 4081628472), a(1508970993, 3053834265), a(2453635748, 2937671579), a(2870763221, 3664609560), a(3624381080, 2734883394), a(310598401, 1164996542), a(607225278, 1323610764), a(1426881987, 3590304994), a(1925078388, 4068182383), a(2162078206, 991336113), a(2614888103, 633803317), a(3248222580, 3479774868), a(3835390401, 2666613458), a(4022224774, 944711139), a(264347078, 2341262773), a(604807628, 2007800933), a(770255983, 1495990901), a(1249150122, 1856431235), a(1555081692, 3175218132), a(1996064986, 2198950837), a(2554220882, 3999719339), a(2821834349, 766784016), a(2952996808, 2566594879), a(3210313671, 3203337956), a(3336571891, 1034457026), a(3584528711, 2466948901), a(113926993, 3758326383), a(338241895, 168717936), a(666307205, 1188179964), a(773529912, 1546045734), a(1294757372, 1522805485), a(1396182291, 2643833823), a(1695183700, 2343527390), a(1986661051, 1014477480), a(2177026350, 1206759142), a(2456956037, 344077627), a(2730485921, 1290863460), a(2820302411, 3158454273), a(3259730800, 3505952657), a(3345764771, 106217008), a(3516065817, 3606008344), a(3600352804, 1432725776), a(4094571909, 1467031594), a(275423344, 851169720), a(430227734, 3100823752), a(506948616, 1363258195), a(659060556, 3750685593), a(883997877, 3785050280), a(958139571, 3318307427), a(1322822218, 3812723403), a(1537002063, 2003034995), a(1747873779, 3602036899), a(1955562222, 1575990012), a(2024104815, 1125592928), a(2227730452, 2716904306), a(2361852424, 442776044), a(2428436474, 593698344), a(2756734187, 3733110249), a(3204031479, 2999351573), a(3329325298, 3815920427), a(3391569614, 3928383900), a(3515267271, 566280711), a(3940187606, 3454069534), a(4118630271, 4000239992), a(116418474, 1914138554), a(174292421, 2731055270), a(289380356, 3203993006), a(460393269, 320620315), a(685471733, 587496836), a(852142971, 1086792851), a(1017036298, 365543100), a(1126000580, 2618297676), a(1288033470, 3409855158), a(1501505948, 4234509866), a(1607167915, 987167468), a(1816402316, 1246189591)],\n    l = [];\n  !function () {\n    for (var e = 0; e < 80; e++) l[e] = a();\n  }();\n  var u = s.SHA512 = t.extend({\n    _doReset: function () {\n      this._hash = new i.init([new o.init(1779033703, 4089235720), new o.init(3144134277, 2227873595), new o.init(1013904242, 4271175723), new o.init(2773480762, 1595750129), new o.init(1359893119, 2917565137), new o.init(2600822924, 725511199), new o.init(528734635, 4215389547), new o.init(1541459225, 327033209)]);\n    },\n    _doProcessBlock: function (e, t) {\n      for (var n = this._hash.words, r = n[0], o = n[1], i = n[2], s = n[3], a = n[4], u = n[5], d = n[6], p = n[7], h = r.high, f = r.low, m = o.high, g = o.low, _ = i.high, y = i.low, v = s.high, b = s.low, w = a.high, x = a.low, E = u.high, C = u.low, S = d.high, T = d.low, k = p.high, I = p.low, P = h, A = f, O = m, N = g, R = _, M = y, L = v, $ = b, D = w, F = x, j = E, q = C, B = S, U = T, H = k, z = I, G = 0; G < 80; G++) {\n        var V,\n          W,\n          K = l[G];\n        if (G < 16) {\n          W = K.high = 0 | e[t + 2 * G];\n          V = K.low = 0 | e[t + 2 * G + 1];\n        } else {\n          var J = l[G - 15],\n            X = J.high,\n            Q = J.low,\n            Y = (X >>> 1 | Q << 31) ^ (X >>> 8 | Q << 24) ^ X >>> 7,\n            Z = (Q >>> 1 | X << 31) ^ (Q >>> 8 | X << 24) ^ (Q >>> 7 | X << 25),\n            ee = l[G - 2],\n            te = ee.high,\n            ne = ee.low,\n            re = (te >>> 19 | ne << 13) ^ (te << 3 | ne >>> 29) ^ te >>> 6,\n            oe = (ne >>> 19 | te << 13) ^ (ne << 3 | te >>> 29) ^ (ne >>> 6 | te << 26),\n            ie = l[G - 7],\n            se = ie.high,\n            ae = ie.low,\n            ce = l[G - 16],\n            le = ce.high,\n            ue = ce.low;\n          W = (W = (W = Y + se + ((V = Z + ae) >>> 0 < Z >>> 0 ? 1 : 0)) + re + ((V += oe) >>> 0 < oe >>> 0 ? 1 : 0)) + le + ((V += ue) >>> 0 < ue >>> 0 ? 1 : 0);\n          K.high = W;\n          K.low = V;\n        }\n        var de,\n          pe = D & j ^ ~D & B,\n          he = F & q ^ ~F & U,\n          fe = P & O ^ P & R ^ O & R,\n          me = A & N ^ A & M ^ N & M,\n          ge = (P >>> 28 | A << 4) ^ (P << 30 | A >>> 2) ^ (P << 25 | A >>> 7),\n          _e = (A >>> 28 | P << 4) ^ (A << 30 | P >>> 2) ^ (A << 25 | P >>> 7),\n          ye = (D >>> 14 | F << 18) ^ (D >>> 18 | F << 14) ^ (D << 23 | F >>> 9),\n          ve = (F >>> 14 | D << 18) ^ (F >>> 18 | D << 14) ^ (F << 23 | D >>> 9),\n          be = c[G],\n          we = be.high,\n          xe = be.low,\n          Ee = H + ye + ((de = z + ve) >>> 0 < z >>> 0 ? 1 : 0),\n          Ce = _e + me;\n        H = B;\n        z = U;\n        B = j;\n        U = q;\n        j = D;\n        q = F;\n        D = L + (Ee = (Ee = (Ee = Ee + pe + ((de += he) >>> 0 < he >>> 0 ? 1 : 0)) + we + ((de += xe) >>> 0 < xe >>> 0 ? 1 : 0)) + W + ((de += V) >>> 0 < V >>> 0 ? 1 : 0)) + ((F = $ + de | 0) >>> 0 < $ >>> 0 ? 1 : 0) | 0;\n        L = R;\n        $ = M;\n        R = O;\n        M = N;\n        O = P;\n        N = A;\n        P = Ee + (ge + fe + (Ce >>> 0 < _e >>> 0 ? 1 : 0)) + ((A = de + Ce | 0) >>> 0 < de >>> 0 ? 1 : 0) | 0;\n      }\n      f = r.low = f + A;\n      r.high = h + P + (f >>> 0 < A >>> 0 ? 1 : 0);\n      g = o.low = g + N;\n      o.high = m + O + (g >>> 0 < N >>> 0 ? 1 : 0);\n      y = i.low = y + M;\n      i.high = _ + R + (y >>> 0 < M >>> 0 ? 1 : 0);\n      b = s.low = b + $;\n      s.high = v + L + (b >>> 0 < $ >>> 0 ? 1 : 0);\n      x = a.low = x + F;\n      a.high = w + D + (x >>> 0 < F >>> 0 ? 1 : 0);\n      C = u.low = C + q;\n      u.high = E + j + (C >>> 0 < q >>> 0 ? 1 : 0);\n      T = d.low = T + U;\n      d.high = S + B + (T >>> 0 < U >>> 0 ? 1 : 0);\n      I = p.low = I + z;\n      p.high = k + H + (I >>> 0 < z >>> 0 ? 1 : 0);\n    },\n    _doFinalize: function () {\n      var e = this._data,\n        t = e.words,\n        n = 8 * this._nDataBytes,\n        r = 8 * e.sigBytes;\n      t[r >>> 5] |= 128 << 24 - r % 32;\n      t[30 + (r + 128 >>> 10 << 5)] = Math.floor(n / 4294967296);\n      t[31 + (r + 128 >>> 10 << 5)] = n;\n      e.sigBytes = 4 * t.length;\n      this._process();\n      return this._hash.toX32();\n    },\n    clone: function () {\n      var e = t.clone.call(this);\n      e._hash = this._hash.clone();\n      return e;\n    },\n    blockSize: 32\n  });\n  e.SHA512 = t._createHelper(u);\n  e.HmacSHA512 = t._createHmacHelper(u);\n})();\nmodule.exports = r.SHA512;",
  "39": "const r = require(6224),\n  o = require(3837);\nexports.init = function (e) {\n  e.inspectOpts = {};\n  const n = Object.keys(exports.inspectOpts);\n  for (let r = 0; r < n.length; r++) e.inspectOpts[n[r]] = exports.inspectOpts[n[r]];\n};\nexports.log = function (...e) {\n  return process.stderr.write(o.format(...e) + \"\\n\");\n};\nexports.formatArgs = function (n) {\n  const {\n    namespace: r,\n    useColors: o\n  } = this;\n  if (o) {\n    const t = this.color,\n      o = \"\u001b[3\" + (t < 8 ? t : \"8;5;\" + t),\n      i = `  ${o};1m${r} \u001b[0m`;\n    n[0] = i + n[0].split(\"\\n\").join(\"\\n\" + i);\n    n.push(o + \"m+\" + module.exports.humanize(this.diff) + \"\u001b[0m\");\n  } else n[0] = (exports.inspectOpts.hideDate ? \"\" : new Date().toISOString() + \" \") + r + \" \" + n[0];\n};\nexports.save = function (e) {\n  e ? process.env.DEBUG = e : delete process.env.DEBUG;\n};\nexports.load = function () {\n  return process.env.DEBUG;\n};\nexports.useColors = function () {\n  return \"colors\" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : r.isatty(process.stderr.fd);\n};\nexports.destroy = o.deprecate(() => {}, \"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\nexports.colors = [6, 2, 3, 4, 5, 1];\ntry {\n  const e = require(2130);\n  e && (e.stderr || e).level >= 2 && (exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);\n} catch (e) {}\nexports.inspectOpts = Object.keys(process.env).filter(e => /^debug_/i.test(e)).reduce((e, t) => {\n  const n = t.substring(6).toLowerCase().replace(/_([a-z])/g, (e, t) => t.toUpperCase());\n  let r = process.env[t];\n  r = !!/^(yes|on|true|enabled)$/i.test(r) || !/^(no|off|false|disabled)$/i.test(r) && (\"null\" === r ? null : Number(r));\n  e[n] = r;\n  return e;\n}, {});\nmodule.exports = require(2447)(exports);\nconst {\n  formatters: i\n} = module.exports;\ni.o = function (e) {\n  this.inspectOpts.colors = this.useColors;\n  return o.inspect(e, this.inspectOpts).split(\"\\n\").map(e => e.trim()).join(\" \");\n};\ni.O = function (e) {\n  this.inspectOpts.colors = this.useColors;\n  return o.inspect(e, this.inspectOpts);\n};",
  "47": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getGithubAccount = exports.getSession = undefined;\nconst r = require(9496),\n  o = [\"read:user\"];\nlet i,\n  s = !1;\nfunction a(e) {\n  if (\"true\" === process.env.CODESPACES && process.env.GITHUB_TOKEN) {\n    const e = process.env.GITHUB_USER || \"codespace-user\",\n      t = {\n        accessToken: process.env.GITHUB_TOKEN,\n        account: {\n          label: e\n        }\n      };\n    return Promise.resolve(t);\n  }\n  return r.authentication.getSession(\"github\", o, {\n    createIfNone: e\n  });\n}\nexports.getSession = async function () {\n  let e = await a(!1);\n  e || s || (s = !0, \"Sign in to GitHub\" === (await r.window.showInformationMessage(\"Sign in to access GitHub Copilot.\", \"Sign in to GitHub\")) && (e = await a(!0)));\n  e && (i = e.account);\n  return e;\n};\nexports.getGithubAccount = function () {\n  return i;\n};",
  "70": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.isVerboseLoggingEnabled = exports.isDebugEnabled = exports.shouldFailForDebugPurposes = exports.isRunningInTest = exports.RuntimeMode = undefined;\nclass RuntimeMode {\n  constructor(e) {\n    this.flags = e;\n  }\n  static fromEnvironment(e) {\n    return new RuntimeMode({\n      debug: (t = process.argv, r = process.env, t.includes(\"--debug\") || \"true\" === (null === (s = r.GITHUB_COPILOT_DEBUG) || undefined === s ? undefined : s.toLowerCase())),\n      verboseLogging: o(process.env),\n      testMode: e,\n      recordInput: i(process.argv, process.env)\n    });\n    var t, r, s;\n  }\n}\nfunction isRunningInTest(e) {\n  return e.get(RuntimeMode).flags.testMode;\n}\nfunction o(e) {\n  if (\"COPILOT_AGENT_VERBOSE\" in e) {\n    const t = e.COPILOT_AGENT_VERBOSE;\n    return \"1\" === t || \"true\" === t;\n  }\n  return !1;\n}\nfunction i(e, t) {\n  var n;\n  return e.includes(\"--record\") || \"true\" === (null === (n = t.GITHUB_COPILOT_RECORD) || undefined === n ? undefined : n.toLowerCase());\n}\nexports.RuntimeMode = RuntimeMode;\nexports.isRunningInTest = isRunningInTest;\nexports.shouldFailForDebugPurposes = function (e) {\n  return isRunningInTest(e);\n};\nexports.isDebugEnabled = function (e) {\n  return e.get(RuntimeMode).flags.debug;\n};\nexports.isVerboseLoggingEnabled = function (e) {\n  return e.get(RuntimeMode).flags.verboseLogging;\n};",
  "98": "module.exports = JSON.parse('{\"$schema\":\"http://json-schema.org/draft-07/schema#\",\"$id\":\"http://json-schema.org/draft-07/schema#\",\"title\":\"Core schema meta-schema\",\"definitions\":{\"schemaArray\":{\"type\":\"array\",\"minItems\":1,\"items\":{\"$ref\":\"#\"}},\"nonNegativeInteger\":{\"type\":\"integer\",\"minimum\":0},\"nonNegativeIntegerDefault0\":{\"allOf\":[{\"$ref\":\"#/definitions/nonNegativeInteger\"},{\"default\":0}]},\"simpleTypes\":{\"enum\":[\"array\",\"boolean\",\"integer\",\"null\",\"number\",\"object\",\"string\"]},\"stringArray\":{\"type\":\"array\",\"items\":{\"type\":\"string\"},\"uniqueItems\":true,\"default\":[]}},\"type\":[\"object\",\"boolean\"],\"properties\":{\"$id\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$schema\":{\"type\":\"string\",\"format\":\"uri\"},\"$ref\":{\"type\":\"string\",\"format\":\"uri-reference\"},\"$comment\":{\"type\":\"string\"},\"title\":{\"type\":\"string\"},\"description\":{\"type\":\"string\"},\"default\":true,\"readOnly\":{\"type\":\"boolean\",\"default\":false},\"examples\":{\"type\":\"array\",\"items\":true},\"multipleOf\":{\"type\":\"number\",\"exclusiveMinimum\":0},\"maximum\":{\"type\":\"number\"},\"exclusiveMaximum\":{\"type\":\"number\"},\"minimum\":{\"type\":\"number\"},\"exclusiveMinimum\":{\"type\":\"number\"},\"maxLength\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minLength\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"pattern\":{\"type\":\"string\",\"format\":\"regex\"},\"additionalItems\":{\"$ref\":\"#\"},\"items\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/schemaArray\"}],\"default\":true},\"maxItems\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minItems\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"uniqueItems\":{\"type\":\"boolean\",\"default\":false},\"contains\":{\"$ref\":\"#\"},\"maxProperties\":{\"$ref\":\"#/definitions/nonNegativeInteger\"},\"minProperties\":{\"$ref\":\"#/definitions/nonNegativeIntegerDefault0\"},\"required\":{\"$ref\":\"#/definitions/stringArray\"},\"additionalProperties\":{\"$ref\":\"#\"},\"definitions\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"properties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"default\":{}},\"patternProperties\":{\"type\":\"object\",\"additionalProperties\":{\"$ref\":\"#\"},\"propertyNames\":{\"format\":\"regex\"},\"default\":{}},\"dependencies\":{\"type\":\"object\",\"additionalProperties\":{\"anyOf\":[{\"$ref\":\"#\"},{\"$ref\":\"#/definitions/stringArray\"}]}},\"propertyNames\":{\"$ref\":\"#\"},\"const\":true,\"enum\":{\"type\":\"array\",\"items\":true,\"minItems\":1,\"uniqueItems\":true},\"type\":{\"anyOf\":[{\"$ref\":\"#/definitions/simpleTypes\"},{\"type\":\"array\",\"items\":{\"$ref\":\"#/definitions/simpleTypes\"},\"minItems\":1,\"uniqueItems\":true}]},\"format\":{\"type\":\"string\"},\"contentMediaType\":{\"type\":\"string\"},\"contentEncoding\":{\"type\":\"string\"},\"if\":{\"$ref\":\"#\"},\"then\":{\"$ref\":\"#\"},\"else\":{\"$ref\":\"#\"},\"allOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"anyOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"oneOf\":{\"$ref\":\"#/definitions/schemaArray\"},\"not\":{\"$ref\":\"#\"}},\"default\":true}');",
  "106": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.debounce = exports.Debouncer = undefined;\nexports.Debouncer = class {\n  async debounce(e) {\n    this.state && (clearTimeout(this.state.timer), this.state.reject(), this.state = undefined);\n    return new Promise((t, n) => {\n      this.state = {\n        timer: setTimeout(() => t(), e),\n        reject: n\n      };\n    });\n  }\n};\nexports.debounce = function (e, t) {\n  let n;\n  return (...r) => (n && clearTimeout(n), new Promise(o => {\n    n = setTimeout(() => {\n      const e = t(...r);\n      o(e);\n    }, e);\n  }));\n};",
  "130": "module.exports = {\n  i8: \"0.2.0\"\n};",
  "219": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ExpConfig = exports.ExpTreatmentVariables = undefined;\nconst r = require(6333),\n  o = require(6500);\nvar i;\n(i = exports.ExpTreatmentVariables || (exports.ExpTreatmentVariables = {})).AA = \"copilotaa\";\ni.CustomEngine = \"copilotcustomengine\";\ni.Fetcher = \"copilotfetcher\";\ni.OverrideBlockMode = \"copilotoverrideblockmode\";\ni.OverrideNumGhostCompletions = \"copilotoverridednumghostcompletions\";\ni.SuffixPercent = \"CopilotSuffixPercent\";\ni.BeforeRequestWaitMs = \"copilotlms\";\ni.NeighboringTabsOption = \"copilotneighboringtabs\";\ni.DebounceMs = \"copilotdebouncems\";\ni.DebouncePredict = \"copilotdebouncepredict\";\ni.ContextualFilterEnable = \"copilotcontextualfilterenable\";\ni.ContextualFilterAcceptThreshold = \"copilotcontextualfilteracceptthreshold\";\ni.disableLogProb = \"copilotLogProb\";\ni.RepetitionFilterMode = \"copilotrepetitionfiltermode\";\ni.GranularityTimePeriodSizeInH = \"copilottimeperiodsizeinh\";\ni.GranularityByCallBuckets = \"copilotbycallbuckets\";\ni.SuffixStartMode = \"copilotsuffixstartmode\";\ni.SuffixMatchThreshold = \"copilotsuffixmatchthreshold\";\ni.FimSuffixLengthThreshold = \"copilotfimsuffixlenthreshold\";\ni.MultiLogitBias = \"copilotlbeot\";\nclass ExpConfig {\n  constructor(e, t, n) {\n    this.variables = e;\n    this.assignmentContext = t;\n    this.features = n;\n  }\n  static createFallbackConfig(e, t) {\n    r.telemetryExpProblem(e, {\n      reason: t\n    });\n    return this.createEmptyConfig();\n  }\n  static createEmptyConfig() {\n    return new ExpConfig({}, \"\", \"\");\n  }\n  addToTelemetry(e) {\n    e.properties[o.ExpServiceTelemetryNames.featuresTelemetryPropertyName] = this.features;\n    e.properties[o.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName] = this.assignmentContext;\n  }\n}\nexports.ExpConfig = ExpConfig;",
  "256": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.decodeLocation = exports.encodeLocation = exports.completionContextForDocument = exports.CompletionContext = exports.completionTypeToString = exports.CompletionType = undefined;\nconst r = require(7373),\n  o = require(6403),\n  i = require(4197);\nvar s;\n!function (e) {\n  e[e.OPEN_COPILOT = 2] = \"OPEN_COPILOT\";\n  e[e.TODO_QUICK_FIX = 3] = \"TODO_QUICK_FIX\";\n  e[e.UNKNOWN_FUNCTION_QUICK_FIX = 4] = \"UNKNOWN_FUNCTION_QUICK_FIX\";\n}(s = exports.CompletionType || (exports.CompletionType = {}));\nexports.completionTypeToString = function (e) {\n  switch (e) {\n    case s.OPEN_COPILOT:\n      return \"open copilot\";\n    case s.TODO_QUICK_FIX:\n      return \"todo quick fix\";\n    case s.UNKNOWN_FUNCTION_QUICK_FIX:\n      return \"unknown function quick fix\";\n    default:\n      return \"unknown\";\n  }\n};\nclass CompletionContext {\n  constructor(e, t, n) {\n    this.prependToCompletion = \"\";\n    this.appendToCompletion = \"\";\n    this.indentation = null;\n    this.completionType = s.OPEN_COPILOT;\n    this.insertPosition = e.get(o.LocationFactory).position(t.line, t.character);\n    this.completionType = n;\n  }\n  static fromJSONParse(e, t) {\n    const n = e.get(o.LocationFactory).position(t.insertPosition.line, t.insertPosition.character),\n      r = new CompletionContext(e, n, t.completionType);\n    r.prependToCompletion = t.prependToCompletion;\n    r.appendToCompletion = t.appendToCompletion;\n    r.indentation = t.indentation;\n    return r;\n  }\n}\nexports.CompletionContext = CompletionContext;\nexports.completionContextForDocument = function (e, t, n) {\n  let r = n;\n  const o = t.lineAt(n.line);\n  o.isEmptyOrWhitespace || (r = o.range.end);\n  return new CompletionContext(e, r, s.OPEN_COPILOT);\n};\nlet c = 0;\nexports.encodeLocation = function (e, t) {\n  const n = e.toString().split(\"#\"),\n    o = n.length > 1 ? n[1] : \"\",\n    s = JSON.stringify([n[0], t, o]);\n  return r.URI.parse(`${i.CopilotScheme}:GitHub%20Copilot?${s}#${c++}`);\n};\nexports.decodeLocation = function (e, t) {\n  const [n, o, i] = JSON.parse(t.query);\n  return [r.URI.parse(i.length > 0 ? n + \"#\" + i : n), CompletionContext.fromJSONParse(e, o)];\n};",
  "298": "var r;\nr = require(8249);\n(function () {\n  var e = r,\n    t = e.lib.WordArray,\n    n = e.enc;\n  function o(e) {\n    return e << 8 & 4278255360 | e >>> 8 & 16711935;\n  }\n  n.Utf16 = n.Utf16BE = {\n    stringify: function (e) {\n      for (var t = e.words, n = e.sigBytes, r = [], o = 0; o < n; o += 2) {\n        var i = t[o >>> 2] >>> 16 - o % 4 * 8 & 65535;\n        r.push(String.fromCharCode(i));\n      }\n      return r.join(\"\");\n    },\n    parse: function (e) {\n      for (var n = e.length, r = [], o = 0; o < n; o++) r[o >>> 1] |= e.charCodeAt(o) << 16 - o % 2 * 16;\n      return t.create(r, 2 * n);\n    }\n  };\n  n.Utf16LE = {\n    stringify: function (e) {\n      for (var t = e.words, n = e.sigBytes, r = [], i = 0; i < n; i += 2) {\n        var s = o(t[i >>> 2] >>> 16 - i % 4 * 8 & 65535);\n        r.push(String.fromCharCode(s));\n      }\n      return r.join(\"\");\n    },\n    parse: function (e) {\n      for (var n = e.length, r = [], i = 0; i < n; i++) r[i >>> 1] |= o(e.charCodeAt(i) << 16 - i % 2 * 16);\n      return t.create(r, 2 * n);\n    }\n  };\n})();\nmodule.exports = r.enc.Utf16;",
  "299": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.Clock = undefined;\nexports.Clock = class {\n  now() {\n    return new Date();\n  }\n};",
  "313": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.assignDefaults = undefined;\nconst r = require(3487),\n  o = require(6776);\nfunction i(e, t, n) {\n  const {\n    gen: i,\n    compositeRule: s,\n    data: a,\n    opts: c\n  } = e;\n  if (undefined === n) return;\n  const l = r._`${a}${r.getProperty(t)}`;\n  if (s) return void o.checkStrictMode(e, `default is ignored for: ${l}`);\n  let u = r._`${l} === undefined`;\n  \"empty\" === c.useDefaults && (u = r._`${u} || ${l} === null || ${l} === \"\"`);\n  i.if(u, r._`${l} = ${r.stringify(n)}`);\n}\nexports.assignDefaults = function (e, t) {\n  const {\n    properties: n,\n    items: r\n  } = e.schema;\n  if (\"object\" === t && n) for (const t in n) i(e, t, n[t].default);else \"array\" === t && Array.isArray(r) && r.forEach((t, n) => i(e, n, t.default));\n};",
  "320": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      return e.call(this) || this;\n    }\n    o(t, e);\n    return t;\n  }(require(4101));\nmodule.exports = i;",
  "362": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.refreshToken = exports.CopilotTokenManagerFromGitHubToken = exports.FixedCopilotTokenManager = exports.CopilotTokenManager = exports.setTelemetryConfigFromTokenInfo = exports.extractTrackingIdFromToken = exports.authFromGitHubToken = exports.nowSeconds = exports.TOKEN_REFRESHED_EVENT = undefined;\nconst r = require(2361),\n  o = require(1133),\n  i = require(9899),\n  s = require(2279),\n  a = require(1547),\n  c = require(6333),\n  l = require(7057),\n  u = new i.Logger(i.LogLevel.INFO, \"auth\");\nlet d = 0;\nfunction nowSeconds() {\n  return Math.floor(Date.now() / 1e3);\n}\nasync function authFromGitHubToken(e, t) {\n  var n, r;\n  c.telemetry(e, \"auth.new_login\");\n  const i = null !== (r = null === (n = t.devOverride) || undefined === n ? undefined : n.copilotTokenUrl) && undefined !== r ? r : \"https://api.github.com/copilot_internal/v2/token\",\n    a = await e.get(s.Fetcher).fetch(i, {\n      headers: {\n        Authorization: `token ${t.token}`,\n        ...o.editorVersionHeaders(e)\n      }\n    });\n  if (!a) {\n    u.info(e, \"Failed to get copilot token\");\n    c.telemetryError(e, \"auth.request_failed\");\n    return {\n      kind: \"failure\",\n      reason: \"FailedToGetToken\"\n    };\n  }\n  const l = await a.json();\n  if (!l) {\n    u.info(e, \"Failed to get copilot token\");\n    c.telemetryError(e, \"auth.request_read_failed\");\n    return {\n      kind: \"failure\",\n      reason: \"FailedToGetToken\"\n    };\n  }\n  m(e, l.user_notification, t);\n  if (401 === a.status) return u.info(e, \"Failed to get copilot token due to 401 status\"), (0, c.telemetryError)(e, \"auth.unknown_401\"), {\n    kind: \"failure\",\n    reason: \"HTTP401\"\n  };\n  if (!a.ok || !l.token) {\n    u.info(e, `Invalid copilot token: missing token: ${a.status} ${a.statusText}`);\n    c.telemetryError(e, \"auth.invalid_token\", c.TelemetryData.createAndMarkAsIssued({\n      status: a.status.toString(),\n      status_text: a.statusText\n    }));\n    const n = l.error_details;\n    m(e, n, t);\n    return {\n      kind: \"failure\",\n      reason: \"NotAuthorized\",\n      ...n\n    };\n  }\n  const d = l.expires_at;\n  l.expires_at = nowSeconds() + l.refresh_in + 60;\n  e.get(c.TelemetryReporters).setToken(l);\n  setTelemetryConfigFromTokenInfo(l);\n  c.telemetry(e, \"auth.new_token\", c.TelemetryData.createAndMarkAsIssued({}, {\n    adjusted_expires_at: l.expires_at,\n    expires_at: d,\n    current_time: nowSeconds()\n  }));\n  return {\n    kind: \"success\",\n    ...l\n  };\n}\nexports.TOKEN_REFRESHED_EVENT = \"token_refreshed\";\nexports.nowSeconds = nowSeconds;\nexports.authFromGitHubToken = authFromGitHubToken;\nconst f = new Map();\nfunction m(e, t, n) {\n  if (!t) return;\n  const r = nowSeconds();\n  f.get(t.message) || (f.set(t.message, r), e.get(a.NotificationSender).showWarningMessage(t.message, {\n    title: t.title\n  }, {\n    title: \"Dismiss\"\n  }).catch(t => {\n    console.error(t);\n    u.error(e, `Error while sending notification: ${t.message}`);\n  }).then(async r => {\n    const i = (null == r ? undefined : r.title) === t.title,\n      a = i || \"Dismiss\" === (null == r ? undefined : r.title);\n    if (i) {\n      const n = e.get(o.EditorAndPluginInfo).getEditorPluginInfo(e),\n        r = t.url.replace(\"{EDITOR}\", encodeURIComponent(n.name + \"_\" + n.version));\n      await e.get(l.UrlOpener).open(r);\n    }\n    \"notification_id\" in t && a && (await async function (e, t, n) {\n      var r, i;\n      const a = null !== (i = null === (r = n.devOverride) || undefined === r ? undefined : r.notificationUrl) && undefined !== i ? i : \"https://api.github.com/copilot_internal/notification\",\n        c = await e.get(s.Fetcher).fetch(a, {\n          headers: {\n            Authorization: `token ${n.token}`,\n            ...o.editorVersionHeaders(e)\n          },\n          method: \"POST\",\n          body: JSON.stringify({\n            notification_id: t\n          })\n        });\n      c && c.ok || u.error(e, `Failed to send notification result to GitHub: ${null == c ? undefined : c.status} ${null == c ? undefined : c.statusText}`);\n    }(e, t.notification_id, n));\n  }));\n}\nfunction extractTrackingIdFromToken(e) {\n  const t = null == e ? undefined : e.split(\":\")[0],\n    n = null == t ? undefined : t.split(\";\");\n  for (const e of n) {\n    const [t, n] = e.split(\"=\");\n    if (\"tid\" === t) return n;\n  }\n}\nfunction setTelemetryConfigFromTokenInfo(e) {\n  const t = extractTrackingIdFromToken(e.token);\n  undefined !== t && c.setTelemetryConfig({\n    trackingId: t,\n    optedIn: \"enabled\" === e.telemetry || \"unconfigured\" === e.telemetry\n  });\n}\nexports.extractTrackingIdFromToken = extractTrackingIdFromToken;\nexports.setTelemetryConfigFromTokenInfo = setTelemetryConfigFromTokenInfo;\nclass CopilotTokenManager {\n  constructor() {\n    this.tokenRefreshEventEmitter = new r.EventEmitter();\n  }\n}\nfunction refreshToken(e, n, r) {\n  const o = nowSeconds();\n  d > 0 || (d++, setTimeout(async () => {\n    let r,\n      i = \"\";\n    try {\n      d--;\n      await n.getCopilotToken(e, !0);\n      r = \"success\";\n      n.tokenRefreshEventEmitter.emit(exports.TOKEN_REFRESHED_EVENT);\n    } catch (e) {\n      r = \"failure\";\n      i = e.toString();\n    }\n    const s = c.TelemetryData.createAndMarkAsIssued({\n      result: r\n    }, {\n      time_taken: nowSeconds() - o,\n      refresh_count: d\n    });\n    i && (s.properties.reason = i);\n    c.telemetry(e, \"auth.token_refresh\", s);\n  }, 1e3 * r));\n}\nexports.CopilotTokenManager = CopilotTokenManager;\nexports.FixedCopilotTokenManager = class extends CopilotTokenManager {\n  constructor(e) {\n    super();\n    this.tokenInfo = e;\n    this.wasReset = !1;\n    setTelemetryConfigFromTokenInfo(e);\n  }\n  async getGitHubToken() {\n    return Promise.resolve(\"token\");\n  }\n  async getCopilotToken(e, t) {\n    return this.tokenInfo;\n  }\n  resetCopilotToken(e, t) {\n    this.wasReset = !0;\n  }\n  async checkCopilotToken(e) {\n    return {\n      status: \"OK\",\n      telemetry: this.tokenInfo.telemetry\n    };\n  }\n};\nexports.CopilotTokenManagerFromGitHubToken = class extends CopilotTokenManager {\n  constructor(e) {\n    super();\n    this.githubToken = e;\n    this.copilotToken = undefined;\n  }\n  async getGitHubToken() {\n    return Promise.resolve(this.githubToken.token);\n  }\n  async getCopilotToken(e, t) {\n    var n;\n    if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds() || t) {\n      const t = await authFromGitHubToken(e, this.githubToken);\n      if (\"failure\" === t.kind) throw Error(`Failed to get copilot token: ${t.reason.toString()} ${null !== (n = t.message) && undefined !== n ? n : \"\"}`);\n      this.copilotToken = {\n        ...t\n      };\n      refreshToken(e, this, t.refresh_in);\n    }\n    return this.copilotToken;\n  }\n  async checkCopilotToken(e) {\n    if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds()) {\n      const t = await authFromGitHubToken(e, this.githubToken);\n      if (\"failure\" === t.kind) return t;\n      this.copilotToken = {\n        ...t\n      };\n      refreshToken(e, this, t.refresh_in);\n    }\n    return {\n      status: \"OK\",\n      telemetry: this.copilotToken.telemetry\n    };\n  }\n  resetCopilotToken(e, t) {\n    undefined !== t && c.telemetry(e, \"auth.reset_token_\" + t);\n    u.debug(e, `Resetting copilot token on HTTP error ${t || \"unknown\"}`);\n    this.copilotToken = undefined;\n  }\n};\nexports.refreshToken = refreshToken;",
  "385": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ExtensionTextDocumentManager = undefined;\nconst r = require(1017),\n  o = require(9496),\n  i = require(3136);\nclass ExtensionTextDocumentManager extends i.TextDocumentManager {\n  constructor() {\n    super(...arguments);\n    this.onDidFocusTextDocument = o.window.onDidChangeActiveTextEditor;\n    this.onDidChangeTextDocument = o.workspace.onDidChangeTextDocument;\n  }\n  get textDocuments() {\n    return o.workspace.textDocuments;\n  }\n  async getTextDocument(e) {\n    return o.workspace.openTextDocument(e);\n  }\n  async getRelativePath(e) {\n    var t, n, s;\n    const a = e;\n    if (a) {\n      if (a.isUntitled) return;\n      return null !== (s = i.getRelativePath(null !== (n = null === (t = o.workspace.workspaceFolders) || undefined === t ? undefined : t.map(e => e.uri)) && undefined !== n ? n : [], a.fileName)) && undefined !== s ? s : r.basename(a.fileName);\n    }\n  }\n  findNotebook(e) {\n    const t = e;\n    return o.workspace.notebookDocuments.find(e => e.getCells().some(e => e.document === t));\n  }\n}\nexports.ExtensionTextDocumentManager = ExtensionTextDocumentManager;",
  "406": "require(6252).install();",
  "412": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = require(2141);\nfunction hasPropFunc(e) {\n  return e.scopeValue(\"func\", {\n    ref: Object.prototype.hasOwnProperty,\n    code: r._`Object.prototype.hasOwnProperty`\n  });\n}\nfunction isOwnProperty(e, t, n) {\n  return r._`${hasPropFunc(e)}.call(${t}, ${n})`;\n}\nfunction noPropertyInData(e, t, n, o) {\n  const i = r._`${t}${r.getProperty(n)} === undefined`;\n  return o ? r.or(i, r.not(isOwnProperty(e, t, n))) : i;\n}\nfunction allSchemaProperties(e) {\n  return e ? Object.keys(e).filter(e => \"__proto__\" !== e) : [];\n}\nexports.checkReportMissingProp = function (e, t) {\n  const {\n    gen: n,\n    data: o,\n    it: i\n  } = e;\n  n.if(noPropertyInData(n, o, t, i.opts.ownProperties), () => {\n    e.setParams({\n      missingProperty: r._`${t}`\n    }, !0);\n    e.error();\n  });\n};\nexports.checkMissingProp = function ({\n  gen: e,\n  data: t,\n  it: {\n    opts: n\n  }\n}, o, i) {\n  return r.or(...o.map(o => r.and(noPropertyInData(e, t, o, n.ownProperties), r._`${i} = ${o}`)));\n};\nexports.reportMissingProp = function (e, t) {\n  e.setParams({\n    missingProperty: t\n  }, !0);\n  e.error();\n};\nexports.hasPropFunc = hasPropFunc;\nexports.isOwnProperty = isOwnProperty;\nexports.propertyInData = function (e, t, n, o) {\n  const i = r._`${t}${r.getProperty(n)} !== undefined`;\n  return o ? r._`${i} && ${isOwnProperty(e, t, n)}` : i;\n};\nexports.noPropertyInData = noPropertyInData;\nexports.allSchemaProperties = allSchemaProperties;\nexports.schemaProperties = function (e, t) {\n  return allSchemaProperties(t).filter(n => !o.alwaysValidSchema(e, t[n]));\n};\nexports.callValidateCode = function ({\n  schemaCode: e,\n  data: t,\n  it: {\n    gen: n,\n    topSchemaRef: o,\n    schemaPath: s,\n    errorPath: a\n  },\n  it: c\n}, l, u, d) {\n  const p = d ? r._`${e}, ${t}, ${o}${s}` : t,\n    h = [[i.default.instancePath, r.strConcat(i.default.instancePath, a)], [i.default.parentData, c.parentData], [i.default.parentDataProperty, c.parentDataProperty], [i.default.rootData, i.default.rootData]];\n  c.opts.dynamicRef && h.push([i.default.dynamicAnchors, i.default.dynamicAnchors]);\n  const f = r._`${p}, ${n.object(...h)}`;\n  return u !== r.nil ? r._`${l}.call(${u}, ${f})` : r._`${l}(${f})`;\n};\nexports.usePattern = function ({\n  gen: e,\n  it: {\n    opts: t\n  }\n}, n) {\n  const o = t.unicodeRegExp ? \"u\" : \"\";\n  return e.scopeValue(\"pattern\", {\n    key: n,\n    ref: new RegExp(n, o),\n    code: r._`new RegExp(${n}, ${o})`\n  });\n};\nexports.validateArray = function (e) {\n  const {\n      gen: t,\n      data: n,\n      keyword: i,\n      it: s\n    } = e,\n    a = t.name(\"valid\");\n  if (s.allErrors) {\n    const e = t.let(\"valid\", !0);\n    c(() => t.assign(e, !1));\n    return e;\n  }\n  t.var(a, !0);\n  c(() => t.break());\n  return a;\n  function c(s) {\n    const c = t.const(\"len\", r._`${n}.length`);\n    t.forRange(\"i\", 0, c, n => {\n      e.subschema({\n        keyword: i,\n        dataProp: n,\n        dataPropType: o.Type.Num\n      }, a);\n      t.if(r.not(a), s);\n    });\n  }\n};\nexports.validateUnion = function (e) {\n  const {\n    gen: t,\n    schema: n,\n    keyword: i,\n    it: s\n  } = e;\n  if (!Array.isArray(n)) throw new Error(\"ajv implementation error\");\n  if (n.some(e => o.alwaysValidSchema(s, e)) && !s.opts.unevaluated) return;\n  const a = t.let(\"valid\", !1),\n    c = t.name(\"_valid\");\n  t.block(() => n.forEach((n, o) => {\n    const s = e.subschema({\n      keyword: i,\n      schemaProp: o,\n      compositeRule: !0\n    }, c);\n    t.assign(a, r._`${a} || ${c}`);\n    e.mergeValidEvaluated(s, c) || t.if(r.not(a));\n  }));\n  e.result(a, () => e.reset(), () => e.error(!0));\n};",
  "420": "function t(e) {\n  var t = new Error(\"Cannot find module '\" + e + \"'\");\n  throw t.code = \"MODULE_NOT_FOUND\", t;\n}\nt.keys = () => [];\nt.resolve = t;\nt.id = 420;\nmodule.exports = t;",
  "430": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = {\n    keyword: \"multipleOf\",\n    type: \"number\",\n    schemaType: \"number\",\n    $data: !0,\n    error: {\n      message: ({\n        schemaCode: e\n      }) => r.str`must be multiple of ${e}`,\n      params: ({\n        schemaCode: e\n      }) => r._`{multipleOf: ${e}}`\n    },\n    code(e) {\n      const {\n          gen: t,\n          data: n,\n          schemaCode: o,\n          it: i\n        } = e,\n        s = i.opts.multipleOfPrecision,\n        a = t.let(\"res\"),\n        c = s ? r._`Math.abs(Math.round(${a}) - ${a}) > 1e-${s}` : r._`${a} !== parseInt(${a})`;\n      e.fail$data(r._`(${o} === 0 || (${a} = ${n}/${o}, ${c}))`);\n    }\n  };\nexports.default = o;",
  "452": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib.BlockCipher,\n    n = e.algo,\n    o = [],\n    i = [],\n    s = [],\n    a = [],\n    c = [],\n    l = [],\n    u = [],\n    d = [],\n    p = [],\n    h = [];\n  !function () {\n    for (var e = [], t = 0; t < 256; t++) e[t] = t < 128 ? t << 1 : t << 1 ^ 283;\n    var n = 0,\n      r = 0;\n    for (t = 0; t < 256; t++) {\n      var f = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4;\n      f = f >>> 8 ^ 255 & f ^ 99;\n      o[n] = f;\n      i[f] = n;\n      var m = e[n],\n        g = e[m],\n        _ = e[g],\n        y = 257 * e[f] ^ 16843008 * f;\n      s[n] = y << 24 | y >>> 8;\n      a[n] = y << 16 | y >>> 16;\n      c[n] = y << 8 | y >>> 24;\n      l[n] = y;\n      y = 16843009 * _ ^ 65537 * g ^ 257 * m ^ 16843008 * n;\n      u[f] = y << 24 | y >>> 8;\n      d[f] = y << 16 | y >>> 16;\n      p[f] = y << 8 | y >>> 24;\n      h[f] = y;\n      n ? (n = m ^ e[e[e[_ ^ m]]], r ^= e[e[r]]) : n = r = 1;\n    }\n  }();\n  var f = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],\n    m = n.AES = t.extend({\n      _doReset: function () {\n        if (!this._nRounds || this._keyPriorReset !== this._key) {\n          for (var e = this._keyPriorReset = this._key, t = e.words, n = e.sigBytes / 4, r = 4 * ((this._nRounds = n + 6) + 1), i = this._keySchedule = [], s = 0; s < r; s++) s < n ? i[s] = t[s] : (l = i[s - 1], s % n ? n > 6 && s % n == 4 && (l = o[l >>> 24] << 24 | o[l >>> 16 & 255] << 16 | o[l >>> 8 & 255] << 8 | o[255 & l]) : (l = o[(l = l << 8 | l >>> 24) >>> 24] << 24 | o[l >>> 16 & 255] << 16 | o[l >>> 8 & 255] << 8 | o[255 & l], l ^= f[s / n | 0] << 24), i[s] = i[s - n] ^ l);\n          for (var a = this._invKeySchedule = [], c = 0; c < r; c++) {\n            s = r - c;\n            if (c % 4) var l = i[s];else l = i[s - 4];\n            a[c] = c < 4 || s <= 4 ? l : u[o[l >>> 24]] ^ d[o[l >>> 16 & 255]] ^ p[o[l >>> 8 & 255]] ^ h[o[255 & l]];\n          }\n        }\n      },\n      encryptBlock: function (e, t) {\n        this._doCryptBlock(e, t, this._keySchedule, s, a, c, l, o);\n      },\n      decryptBlock: function (e, t) {\n        var n = e[t + 1];\n        e[t + 1] = e[t + 3];\n        e[t + 3] = n;\n        this._doCryptBlock(e, t, this._invKeySchedule, u, d, p, h, i);\n        n = e[t + 1];\n        e[t + 1] = e[t + 3];\n        e[t + 3] = n;\n      },\n      _doCryptBlock: function (e, t, n, r, o, i, s, a) {\n        for (var c = this._nRounds, l = e[t] ^ n[0], u = e[t + 1] ^ n[1], d = e[t + 2] ^ n[2], p = e[t + 3] ^ n[3], h = 4, f = 1; f < c; f++) {\n          var m = r[l >>> 24] ^ o[u >>> 16 & 255] ^ i[d >>> 8 & 255] ^ s[255 & p] ^ n[h++],\n            g = r[u >>> 24] ^ o[d >>> 16 & 255] ^ i[p >>> 8 & 255] ^ s[255 & l] ^ n[h++],\n            _ = r[d >>> 24] ^ o[p >>> 16 & 255] ^ i[l >>> 8 & 255] ^ s[255 & u] ^ n[h++],\n            y = r[p >>> 24] ^ o[l >>> 16 & 255] ^ i[u >>> 8 & 255] ^ s[255 & d] ^ n[h++];\n          l = m;\n          u = g;\n          d = _;\n          p = y;\n        }\n        m = (a[l >>> 24] << 24 | a[u >>> 16 & 255] << 16 | a[d >>> 8 & 255] << 8 | a[255 & p]) ^ n[h++];\n        g = (a[u >>> 24] << 24 | a[d >>> 16 & 255] << 16 | a[p >>> 8 & 255] << 8 | a[255 & l]) ^ n[h++];\n        _ = (a[d >>> 24] << 24 | a[p >>> 16 & 255] << 16 | a[l >>> 8 & 255] << 8 | a[255 & u]) ^ n[h++];\n        y = (a[p >>> 24] << 24 | a[l >>> 16 & 255] << 16 | a[u >>> 8 & 255] << 8 | a[255 & d]) ^ n[h++];\n        e[t] = m;\n        e[t + 1] = g;\n        e[t + 2] = _;\n        e[t + 3] = y;\n      },\n      keySize: 8\n    });\n  e.AES = t._createHelper(m);\n})();\nmodule.exports = r.AES;",
  "453": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = undefined;\nconst r = require(3141),\n  o = require(8876),\n  i = require(4181),\n  s = require(3487),\n  a = require(6776);\nvar c;\nfunction getJSONTypes(e) {\n  const t = Array.isArray(e) ? e : e ? [e] : [];\n  if (t.every(r.isJSONType)) return t;\n  throw new Error(\"type must be JSONType or JSONType[]: \" + t.join(\",\"));\n}\n!function (e) {\n  e[e.Correct = 0] = \"Correct\";\n  e[e.Wrong = 1] = \"Wrong\";\n}(c = exports.DataType || (exports.DataType = {}));\nexports.getSchemaTypes = function (e) {\n  const t = getJSONTypes(e.type);\n  if (t.includes(\"null\")) {\n    if (!1 === e.nullable) throw new Error(\"type: null contradicts nullable: false\");\n  } else {\n    if (!t.length && undefined !== e.nullable) throw new Error('\"nullable\" cannot be used without \"type\"');\n    !0 === e.nullable && t.push(\"null\");\n  }\n  return t;\n};\nexports.getJSONTypes = getJSONTypes;\nexports.coerceAndCheckDataType = function (e, t) {\n  const {\n      gen: n,\n      data: r,\n      opts: i\n    } = e,\n    a = function (e, t) {\n      return t ? e.filter(e => u.has(e) || \"array\" === t && \"array\" === e) : [];\n    }(t, i.coerceTypes),\n    l = t.length > 0 && !(0 === a.length && 1 === t.length && o.schemaHasRulesForType(e, t[0]));\n  if (l) {\n    const o = checkDataTypes(t, r, i.strictNumbers, c.Wrong);\n    n.if(o, () => {\n      a.length ? function (e, t, n) {\n        const {\n            gen: r,\n            data: o,\n            opts: i\n          } = e,\n          a = r.let(\"dataType\", s._`typeof ${o}`),\n          c = r.let(\"coerced\", s._`undefined`);\n        \"array\" === i.coerceTypes && r.if(s._`${a} == 'object' && Array.isArray(${o}) && ${o}.length == 1`, () => r.assign(o, s._`${o}[0]`).assign(a, s._`typeof ${o}`).if(checkDataTypes(t, o, i.strictNumbers), () => r.assign(c, o)));\n        r.if(s._`${c} !== undefined`);\n        for (const e of n) (u.has(e) || \"array\" === e && \"array\" === i.coerceTypes) && l(e);\n        function l(e) {\n          switch (e) {\n            case \"string\":\n              return void r.elseIf(s._`${a} == \"number\" || ${a} == \"boolean\"`).assign(c, s._`\"\" + ${o}`).elseIf(s._`${o} === null`).assign(c, s._`\"\"`);\n            case \"number\":\n              return void r.elseIf(s._`${a} == \"boolean\" || ${o} === null\n              || (${a} == \"string\" && ${o} && ${o} == +${o})`).assign(c, s._`+${o}`);\n            case \"integer\":\n              return void r.elseIf(s._`${a} === \"boolean\" || ${o} === null\n              || (${a} === \"string\" && ${o} && ${o} == +${o} && !(${o} % 1))`).assign(c, s._`+${o}`);\n            case \"boolean\":\n              return void r.elseIf(s._`${o} === \"false\" || ${o} === 0 || ${o} === null`).assign(c, !1).elseIf(s._`${o} === \"true\" || ${o} === 1`).assign(c, !0);\n            case \"null\":\n              r.elseIf(s._`${o} === \"\" || ${o} === 0 || ${o} === false`);\n              return void r.assign(c, null);\n            case \"array\":\n              r.elseIf(s._`${a} === \"string\" || ${a} === \"number\"\n              || ${a} === \"boolean\" || ${o} === null`).assign(c, s._`[${o}]`);\n          }\n        }\n        r.else();\n        reportTypeError(e);\n        r.endIf();\n        r.if(s._`${c} !== undefined`, () => {\n          r.assign(o, c);\n          (function ({\n            gen: e,\n            parentData: t,\n            parentDataProperty: n\n          }, r) {\n            e.if(s._`${t} !== undefined`, () => e.assign(s._`${t}[${n}]`, r));\n          })(e, c);\n        });\n      }(e, t, a) : reportTypeError(e);\n    });\n  }\n  return l;\n};\nconst u = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\nfunction checkDataType(e, t, n, r = c.Correct) {\n  const o = r === c.Correct ? s.operators.EQ : s.operators.NEQ;\n  let i;\n  switch (e) {\n    case \"null\":\n      return s._`${t} ${o} null`;\n    case \"array\":\n      i = s._`Array.isArray(${t})`;\n      break;\n    case \"object\":\n      i = s._`${t} && typeof ${t} == \"object\" && !Array.isArray(${t})`;\n      break;\n    case \"integer\":\n      i = a(s._`!(${t} % 1) && !isNaN(${t})`);\n      break;\n    case \"number\":\n      i = a();\n      break;\n    default:\n      return s._`typeof ${t} ${o} ${e}`;\n  }\n  return r === c.Correct ? i : s.not(i);\n  function a(e = s.nil) {\n    return s.and(s._`typeof ${t} == \"number\"`, e, n ? s._`isFinite(${t})` : s.nil);\n  }\n}\nfunction checkDataTypes(e, t, n, r) {\n  if (1 === e.length) return checkDataType(e[0], t, n, r);\n  let o;\n  const i = a.toHash(e);\n  if (i.array && i.object) {\n    const e = s._`typeof ${t} != \"object\"`;\n    o = i.null ? e : s._`!${t} || ${e}`;\n    delete i.null;\n    delete i.array;\n    delete i.object;\n  } else o = s.nil;\n  i.number && delete i.integer;\n  for (const e in i) o = s.and(o, checkDataType(e, t, n, r));\n  return o;\n}\nexports.checkDataType = checkDataType;\nexports.checkDataTypes = checkDataTypes;\nconst h = {\n  message: ({\n    schema: e\n  }) => `must be ${e}`,\n  params: ({\n    schema: e,\n    schemaValue: t\n  }) => \"string\" == typeof e ? s._`{type: ${e}}` : s._`{type: ${t}}`\n};\nfunction reportTypeError(e) {\n  const t = function (e) {\n    const {\n        gen: t,\n        data: n,\n        schema: r\n      } = e,\n      o = a.schemaRefOrVal(e, r, \"type\");\n    return {\n      gen: t,\n      keyword: \"type\",\n      data: n,\n      schema: r.type,\n      schemaCode: o,\n      schemaValue: o,\n      parentSchema: r,\n      params: {},\n      it: e\n    };\n  }(e);\n  i.reportError(t, h);\n}\nexports.reportTypeError = reportTypeError;",
  "454": "var r = require(5290),\n  o = require(4953),\n  i = [],\n  s = {\n    syslog: function (e) {\n      var t = {\n        emerg: r.SeverityLevel.Critical,\n        alert: r.SeverityLevel.Critical,\n        crit: r.SeverityLevel.Critical,\n        error: r.SeverityLevel.Error,\n        warning: r.SeverityLevel.Warning,\n        notice: r.SeverityLevel.Information,\n        info: r.SeverityLevel.Information,\n        debug: r.SeverityLevel.Verbose\n      };\n      return undefined === t[e] ? r.SeverityLevel.Information : t[e];\n    },\n    npm: function (e) {\n      var t = {\n        error: r.SeverityLevel.Error,\n        warn: r.SeverityLevel.Warning,\n        info: r.SeverityLevel.Information,\n        verbose: r.SeverityLevel.Verbose,\n        debug: r.SeverityLevel.Verbose,\n        silly: r.SeverityLevel.Verbose\n      };\n      return undefined === t[e] ? r.SeverityLevel.Information : t[e];\n    },\n    unknown: function (e) {\n      return r.SeverityLevel.Information;\n    }\n  },\n  a = function (e) {\n    var t = e.data.message;\n    i.forEach(function (n) {\n      if (t instanceof Error) n.trackException({\n        exception: t,\n        properties: e.data.meta\n      });else {\n        var r = s[e.data.levelKind](e.data.level);\n        n.trackTrace({\n          message: t,\n          severity: r,\n          properties: e.data.meta\n        });\n      }\n    });\n  };\nexports.wp = function (e, t) {\n  e ? (0 === i.length && o.channel.subscribe(\"winston\", a), i.push(t)) : 0 === (i = i.filter(function (e) {\n    return e != t;\n  })).length && o.channel.unsubscribe(\"winston\", a);\n};",
  "464": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getFunctionPositions = exports.getFirstPrecedingComment = exports.isFunctionDefinition = exports.isFunction = exports.getAncestorWithSiblingFunctions = exports.queryPythonIsDocstring = exports.queryGlobalVars = exports.queryExports = exports.queryImports = exports.queryFunctions = exports.getBlockCloseToken = exports.parsesWithoutError = exports.parseTree = exports.getLanguage = exports.languageIdToWasmLanguage = exports.isSupportedLanguageId = exports.WASMLanguage = undefined;\nconst r = require(1017),\n  o = require(4087),\n  i = require(4087);\nvar s;\n!function (e) {\n  e.Python = \"python\";\n  e.JavaScript = \"javascript\";\n  e.TypeScript = \"typescript\";\n  e.Go = \"go\";\n  e.Ruby = \"ruby\";\n}(s = exports.WASMLanguage || (exports.WASMLanguage = {}));\nconst a = {\n  python: s.Python,\n  javascript: s.JavaScript,\n  javascriptreact: s.JavaScript,\n  jsx: s.JavaScript,\n  typescript: s.TypeScript,\n  typescriptreact: s.TypeScript,\n  go: s.Go,\n  ruby: s.Ruby\n};\nfunction languageIdToWasmLanguage(e) {\n  if (!(e in a)) throw new Error(`Unrecognized language: ${e}`);\n  return a[e];\n}\nexports.isSupportedLanguageId = function (e) {\n  return e in a;\n};\nexports.languageIdToWasmLanguage = languageIdToWasmLanguage;\nconst l = {\n    python: [[\"(function_definition body: (block\\n             (expression_statement (string))? @docstring) @body) @function\"], ['(ERROR (\"def\" (identifier) (parameters))) @function']],\n    javascript: [[\"[\\n            (function body: (statement_block) @body)\\n            (function_declaration body: (statement_block) @body)\\n            (generator_function body: (statement_block) @body)\\n            (generator_function_declaration body: (statement_block) @body)\\n            (method_definition body: (statement_block) @body)\\n          ] @function\"]],\n    typescript: [[\"[\\n            (function body: (statement_block) @body)\\n            (function_declaration body: (statement_block) @body)\\n            (generator_function body: (statement_block) @body)\\n            (generator_function_declaration body: (statement_block) @body)\\n            (method_definition body: (statement_block) @body)\\n          ] @function\"]],\n    go: [[\"[\\n            (function_declaration body: (block) @body)\\n            (method_declaration body: (block) @body)\\n          ] @function\"]],\n    ruby: [['[\\n            (method name: (_) parameters: (method_parameters)? @params [(_)+ \"end\"] @body)\\n            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ \"end\"] @body)\\n          ] @function']]\n  },\n  u = '(variable_declarator value: (call_expression function: ((identifier) @req (#eq? @req \"require\"))))',\n  d = `\\n    (lexical_declaration ${u}+)\\n    (variable_declaration ${u}+)\\n`,\n  p = {\n    python: [[\"(module (future_import_statement) @import)\"], [\"(module (import_statement) @import)\"], [\"(module (import_from_statement) @import)\"]],\n    javascript: [[`(program [ ${d} ] @import)`], [\"(program [ (import_statement) ] @import)\"]],\n    typescript: [[`(program [ ${d} ] @import)`], [\"(program [ (import_statement) (import_alias) ] @import)\"]],\n    go: [],\n    ruby: []\n  },\n  h = {\n    python: [],\n    javascript: [[\"(program (export_statement) @export)\"]],\n    typescript: [[\"(program (export_statement) @export)\"]],\n    go: [],\n    ruby: []\n  },\n  f = {\n    python: [[\"(module (global_statement) @globalVar)\"], [\"(module (expression_statement) @globalVar)\"]],\n    javascript: [],\n    typescript: [],\n    go: [],\n    ruby: []\n  },\n  m = {\n    python: new Set([\"function_definition\"]),\n    javascript: new Set([\"function\", \"function_declaration\", \"generator_function\", \"generator_function_declaration\", \"method_definition\", \"arrow_function\"]),\n    typescript: new Set([\"function\", \"function_declaration\", \"generator_function\", \"generator_function_declaration\", \"method_definition\", \"arrow_function\"]),\n    go: new Set([\"function_declaration\", \"method_declaration\"]),\n    ruby: new Set([\"method\", \"singleton_method\"])\n  },\n  g = {\n    python: e => {\n      var t;\n      return \"module\" === e.type || \"block\" === e.type && \"class_definition\" === (null === (t = e.parent) || undefined === t ? undefined : t.type);\n    },\n    javascript: e => \"program\" === e.type || \"class_body\" === e.type,\n    typescript: e => \"program\" === e.type || \"class_body\" === e.type,\n    go: e => \"source_file\" === e.type,\n    ruby: e => \"program\" === e.type || \"class\" === e.type\n  },\n  _ = new Map();\nasync function getLanguage(e) {\n  const t = languageIdToWasmLanguage(e);\n  if (!_.has(t)) {\n    const e = await async function (e) {\n      await o.init();\n      const t = r.resolve(__dirname, \"..\", \"dist\", `tree-sitter-${e}.wasm`);\n      return i.Language.load(t);\n    }(t);\n    _.set(t, e);\n  }\n  return _.get(t);\n}\nasync function parseTree(e, t) {\n  let n = await getLanguage(e);\n  const r = new o();\n  r.setLanguage(n);\n  const i = r.parse(t);\n  r.delete();\n  return i;\n}\nfunction b(e, t) {\n  const n = [];\n  for (const r of e) {\n    if (!r[1]) {\n      const e = t.tree.getLanguage();\n      r[1] = e.query(r[0]);\n    }\n    n.push(...r[1].matches(t));\n  }\n  return n;\n}\nfunction queryFunctions(e, t) {\n  return b(l[languageIdToWasmLanguage(e)], t);\n}\nexports.getLanguage = getLanguage;\nexports.parseTree = parseTree;\nexports.parsesWithoutError = async function (e, t) {\n  const n = await parseTree(e, t),\n    r = !n.rootNode.hasError();\n  n.delete();\n  return r;\n};\nexports.getBlockCloseToken = function (e) {\n  switch (languageIdToWasmLanguage(e)) {\n    case s.Python:\n      return null;\n    case s.JavaScript:\n    case s.TypeScript:\n    case s.Go:\n      return \"}\";\n    case s.Ruby:\n      return \"end\";\n  }\n};\nexports.queryFunctions = queryFunctions;\nexports.queryImports = function (e, t) {\n  return b(p[languageIdToWasmLanguage(e)], t);\n};\nexports.queryExports = function (e, t) {\n  return b(h[languageIdToWasmLanguage(e)], t);\n};\nexports.queryGlobalVars = function (e, t) {\n  return b(f[languageIdToWasmLanguage(e)], t);\n};\nconst x = [\"[\\n    (class_definition (block (expression_statement (string))))\\n    (function_definition (block (expression_statement (string))))\\n]\"];\nfunction isFunction(e, t) {\n  return m[languageIdToWasmLanguage(e)].has(t.type);\n}\nexports.queryPythonIsDocstring = function (e) {\n  return 1 == b([x], e).length;\n};\nexports.getAncestorWithSiblingFunctions = function (e, t) {\n  const n = g[languageIdToWasmLanguage(e)];\n  for (; t.parent;) {\n    if (n(t.parent)) return t;\n    t = t.parent;\n  }\n  return t.parent ? t : null;\n};\nexports.isFunction = isFunction;\nexports.isFunctionDefinition = function (e, t) {\n  switch (languageIdToWasmLanguage(e)) {\n    case s.Python:\n    case s.Go:\n    case s.Ruby:\n      return isFunction(e, t);\n    case s.JavaScript:\n    case s.TypeScript:\n      if (\"function_declaration\" === t.type || \"generator_function_declaration\" === t.type || \"method_definition\" === t.type) return !0;\n      if (\"lexical_declaration\" === t.type || \"variable_declaration\" === t.type) {\n        if (t.namedChildCount > 1) return !1;\n        let n = t.namedChild(0);\n        if (null == n) return !1;\n        let r = n.namedChild(1);\n        return null !== r && isFunction(e, r);\n      }\n      if (\"expression_statement\" === t.type) {\n        let n = t.namedChild(0);\n        if (\"assignment_expression\" === (null == n ? undefined : n.type)) {\n          let t = n.namedChild(1);\n          return null !== t && isFunction(e, t);\n        }\n      }\n      return !1;\n  }\n};\nexports.getFirstPrecedingComment = function (e) {\n  var t;\n  let n = e;\n  for (; \"comment\" === (null === (t = n.previousSibling) || undefined === t ? undefined : t.type);) {\n    let e = n.previousSibling;\n    if (e.endPosition.row < n.startPosition.row - 1) break;\n    n = e;\n  }\n  return \"comment\" === (null == n ? undefined : n.type) ? n : null;\n};\nexports.getFunctionPositions = async function (e, t) {\n  return queryFunctions(e, (await parseTree(e, t)).rootNode).map(e => {\n    const t = e.captures.find(e => \"function\" === e.name).node;\n    return {\n      startIndex: t.startIndex,\n      endIndex: t.endIndex\n    };\n  });\n};",
  "465": "module.exports = function (e, t) {\n  var n = [];\n  n.push(function (e) {\n    try {\n      return Error.prototype.toString.call(e);\n    } catch (e) {\n      try {\n        return \"<error: \" + e + \">\";\n      } catch (e) {\n        return \"<error>\";\n      }\n    }\n  }(e));\n  for (var r = 0; r < t.length; r++) {\n    var o,\n      i = t[r];\n    try {\n      o = i.toString();\n    } catch (e) {\n      try {\n        o = \"<error: \" + e + \">\";\n      } catch (e) {\n        o = \"<error>\";\n      }\n    }\n    n.push(\"    at \" + o);\n  }\n  return n.join(\"\\n\");\n};",
  "495": "var t;\n!function (e) {\n  e[e.Measurement = 0] = \"Measurement\";\n  e[e.Aggregation = 1] = \"Aggregation\";\n}(t || (t = {}));\nmodule.exports = t;",
  "498": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = {\n    keyword: [\"maxProperties\", \"minProperties\"],\n    type: \"object\",\n    schemaType: \"number\",\n    $data: !0,\n    error: {\n      message({\n        keyword: e,\n        schemaCode: t\n      }) {\n        const n = \"maxProperties\" === e ? \"more\" : \"fewer\";\n        return r.str`must NOT have ${n} than ${t} items`;\n      },\n      params: ({\n        schemaCode: e\n      }) => r._`{limit: ${e}}`\n    },\n    code(e) {\n      const {\n          keyword: t,\n          data: n,\n          schemaCode: o\n        } = e,\n        i = \"maxProperties\" === t ? r.operators.GT : r.operators.LT;\n      e.fail$data(r._`Object.keys(${n}).length ${i} ${o}`);\n    }\n  };\nexports.default = o;",
  "540": "!function (e) {\n  \"use strict\";\n\n  function t() {\n    for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];\n    if (t.length > 1) {\n      t[0] = t[0].slice(0, -1);\n      for (var r = t.length - 1, o = 1; o < r; ++o) t[o] = t[o].slice(1, -1);\n      t[r] = t[r].slice(1);\n      return t.join(\"\");\n    }\n    return t[0];\n  }\n  function n(e) {\n    return \"(?:\" + e + \")\";\n  }\n  function r(e) {\n    return undefined === e ? \"undefined\" : null === e ? \"null\" : Object.prototype.toString.call(e).split(\" \").pop().split(\"]\").shift().toLowerCase();\n  }\n  function o(e) {\n    return e.toUpperCase();\n  }\n  function i(e) {\n    var r = \"[A-Za-z]\",\n      o = \"[0-9]\",\n      i = t(o, \"[A-Fa-f]\"),\n      s = n(n(\"%[EFef]\" + i + \"%\" + i + i + \"%\" + i + i) + \"|\" + n(\"%[89A-Fa-f]\" + i + \"%\" + i + i) + \"|\" + n(\"%\" + i + i)),\n      a = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n      c = t(\"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", a),\n      l = e ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n      u = t(r, o, \"[\\\\-\\\\.\\\\_\\\\~]\", e ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\"),\n      d = n(r + t(r, o, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n      p = n(n(s + \"|\" + t(u, a, \"[\\\\:]\")) + \"*\"),\n      h = (n(n(\"25[0-5]\") + \"|\" + n(\"2[0-4][0-9]\") + \"|\" + n(\"1[0-9][0-9]\") + \"|\" + n(\"[1-9][0-9]\") + \"|\" + o), n(n(\"25[0-5]\") + \"|\" + n(\"2[0-4][0-9]\") + \"|\" + n(\"1[0-9][0-9]\") + \"|\" + n(\"0?[1-9][0-9]\") + \"|0?0?\" + o)),\n      f = n(h + \"\\\\.\" + h + \"\\\\.\" + h + \"\\\\.\" + h),\n      m = n(i + \"{1,4}\"),\n      g = n(n(m + \"\\\\:\" + m) + \"|\" + f),\n      _ = n(n(m + \"\\\\:\") + \"{6}\" + g),\n      y = n(\"\\\\:\\\\:\" + n(m + \"\\\\:\") + \"{5}\" + g),\n      v = n(n(m) + \"?\\\\:\\\\:\" + n(m + \"\\\\:\") + \"{4}\" + g),\n      b = n(n(n(m + \"\\\\:\") + \"{0,1}\" + m) + \"?\\\\:\\\\:\" + n(m + \"\\\\:\") + \"{3}\" + g),\n      w = n(n(n(m + \"\\\\:\") + \"{0,2}\" + m) + \"?\\\\:\\\\:\" + n(m + \"\\\\:\") + \"{2}\" + g),\n      x = n(n(n(m + \"\\\\:\") + \"{0,3}\" + m) + \"?\\\\:\\\\:\" + m + \"\\\\:\" + g),\n      E = n(n(n(m + \"\\\\:\") + \"{0,4}\" + m) + \"?\\\\:\\\\:\" + g),\n      C = n(n(n(m + \"\\\\:\") + \"{0,5}\" + m) + \"?\\\\:\\\\:\" + m),\n      S = n(n(n(m + \"\\\\:\") + \"{0,6}\" + m) + \"?\\\\:\\\\:\"),\n      T = n([_, y, v, b, w, x, E, C, S].join(\"|\")),\n      k = n(n(u + \"|\" + s) + \"+\"),\n      I = (n(T + \"\\\\%25\" + k), n(T + n(\"\\\\%25|\\\\%(?!\" + i + \"{2})\") + k)),\n      P = n(\"[vV]\" + i + \"+\\\\.\" + t(u, a, \"[\\\\:]\") + \"+\"),\n      A = n(\"\\\\[\" + n(I + \"|\" + T + \"|\" + P) + \"\\\\]\"),\n      O = n(n(s + \"|\" + t(u, a)) + \"*\"),\n      N = n(A + \"|\" + f + \"(?!\" + O + \")|\" + O),\n      R = n(\"[0-9]*\"),\n      M = n(n(p + \"@\") + \"?\" + N + n(\"\\\\:\" + R) + \"?\"),\n      L = n(s + \"|\" + t(u, a, \"[\\\\:\\\\@]\")),\n      $ = n(L + \"*\"),\n      D = n(L + \"+\"),\n      F = n(n(s + \"|\" + t(u, a, \"[\\\\@]\")) + \"+\"),\n      j = n(n(\"\\\\/\" + $) + \"*\"),\n      q = n(\"\\\\/\" + n(D + j) + \"?\"),\n      B = n(F + j),\n      U = n(D + j),\n      H = \"(?!\" + L + \")\",\n      z = (n(j + \"|\" + q + \"|\" + B + \"|\" + U + \"|\" + H), n(n(L + \"|\" + t(\"[\\\\/\\\\?]\", l)) + \"*\")),\n      G = n(n(L + \"|[\\\\/\\\\?]\") + \"*\"),\n      V = n(n(\"\\\\/\\\\/\" + M + j) + \"|\" + q + \"|\" + U + \"|\" + H),\n      W = n(d + \"\\\\:\" + V + n(\"\\\\?\" + z) + \"?\" + n(\"\\\\#\" + G) + \"?\"),\n      K = n(n(\"\\\\/\\\\/\" + M + j) + \"|\" + q + \"|\" + B + \"|\" + H),\n      J = n(K + n(\"\\\\?\" + z) + \"?\" + n(\"\\\\#\" + G) + \"?\");\n    n(W + \"|\" + J);\n    n(d + \"\\\\:\" + V + n(\"\\\\?\" + z) + \"?\");\n    n(n(\"\\\\/\\\\/(\" + n(\"(\" + p + \")@\") + \"?(\" + N + \")\" + n(\"\\\\:(\" + R + \")\") + \"?)\") + \"?(\" + j + \"|\" + q + \"|\" + U + \"|\" + H + \")\");\n    n(\"\\\\?(\" + z + \")\");\n    n(\"\\\\#(\" + G + \")\");\n    n(n(\"\\\\/\\\\/(\" + n(\"(\" + p + \")@\") + \"?(\" + N + \")\" + n(\"\\\\:(\" + R + \")\") + \"?)\") + \"?(\" + j + \"|\" + q + \"|\" + B + \"|\" + H + \")\");\n    n(\"\\\\?(\" + z + \")\");\n    n(\"\\\\#(\" + G + \")\");\n    n(n(\"\\\\/\\\\/(\" + n(\"(\" + p + \")@\") + \"?(\" + N + \")\" + n(\"\\\\:(\" + R + \")\") + \"?)\") + \"?(\" + j + \"|\" + q + \"|\" + U + \"|\" + H + \")\");\n    n(\"\\\\?(\" + z + \")\");\n    n(\"\\\\#(\" + G + \")\");\n    n(\"(\" + p + \")@\");\n    n(\"\\\\:(\" + R + \")\");\n    return {\n      NOT_SCHEME: new RegExp(t(\"[^]\", r, o, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n      NOT_USERINFO: new RegExp(t(\"[^\\\\%\\\\:]\", u, a), \"g\"),\n      NOT_HOST: new RegExp(t(\"[^\\\\%\\\\[\\\\]\\\\:]\", u, a), \"g\"),\n      NOT_PATH: new RegExp(t(\"[^\\\\%\\\\/\\\\:\\\\@]\", u, a), \"g\"),\n      NOT_PATH_NOSCHEME: new RegExp(t(\"[^\\\\%\\\\/\\\\@]\", u, a), \"g\"),\n      NOT_QUERY: new RegExp(t(\"[^\\\\%]\", u, a, \"[\\\\:\\\\@\\\\/\\\\?]\", l), \"g\"),\n      NOT_FRAGMENT: new RegExp(t(\"[^\\\\%]\", u, a, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n      ESCAPE: new RegExp(t(\"[^]\", u, a), \"g\"),\n      UNRESERVED: new RegExp(u, \"g\"),\n      OTHER_CHARS: new RegExp(t(\"[^\\\\%]\", u, c), \"g\"),\n      PCT_ENCODED: new RegExp(s, \"g\"),\n      IPV4ADDRESS: new RegExp(\"^(\" + f + \")$\"),\n      IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + T + \")\" + n(n(\"\\\\%25|\\\\%(?!\" + i + \"{2})\") + \"(\" + k + \")\") + \"?\\\\]?$\")\n    };\n  }\n  var s = i(!1),\n    a = i(!0),\n    c = function (e, t) {\n      if (Array.isArray(e)) return e;\n      if (Symbol.iterator in Object(e)) return function (e, t) {\n        var n = [],\n          r = !0,\n          o = !1,\n          i = undefined;\n        try {\n          for (var s, a = e[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); r = !0);\n        } catch (e) {\n          o = !0;\n          i = e;\n        } finally {\n          try {\n            !r && a.return && a.return();\n          } finally {\n            if (o) throw i;\n          }\n        }\n        return n;\n      }(e, t);\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    },\n    l = 2147483647,\n    u = 36,\n    d = /^xn--/,\n    p = /[^\\0-\\x7E]/,\n    h = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n    f = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    },\n    m = Math.floor,\n    g = String.fromCharCode;\n  function _(e) {\n    throw new RangeError(f[e]);\n  }\n  function y(e, t) {\n    var n = e.split(\"@\"),\n      r = \"\";\n    n.length > 1 && (r = n[0] + \"@\", e = n[1]);\n    return r + function (e, t) {\n      for (var n = [], r = e.length; r--;) n[r] = t(e[r]);\n      return n;\n    }((e = e.replace(h, \".\")).split(\".\"), t).join(\".\");\n  }\n  function v(e) {\n    for (var t = [], n = 0, r = e.length; n < r;) {\n      var o = e.charCodeAt(n++);\n      if (o >= 55296 && o <= 56319 && n < r) {\n        var i = e.charCodeAt(n++);\n        56320 == (64512 & i) ? t.push(((1023 & o) << 10) + (1023 & i) + 65536) : (t.push(o), n--);\n      } else t.push(o);\n    }\n    return t;\n  }\n  var b = function (e, t) {\n      return e + 22 + 75 * (e < 26) - ((0 != t) << 5);\n    },\n    w = function (e, t, n) {\n      var r = 0;\n      for (e = n ? m(e / 700) : e >> 1, e += m(e / t); e > 455; r += u) e = m(e / 35);\n      return m(r + 36 * e / (e + 38));\n    },\n    x = function (e) {\n      var t,\n        n = [],\n        r = e.length,\n        o = 0,\n        i = 128,\n        s = 72,\n        a = e.lastIndexOf(\"-\");\n      a < 0 && (a = 0);\n      for (var c = 0; c < a; ++c) {\n        e.charCodeAt(c) >= 128 && _(\"not-basic\");\n        n.push(e.charCodeAt(c));\n      }\n      for (var d = a > 0 ? a + 1 : 0; d < r;) {\n        for (var p = o, h = 1, f = u;; f += u) {\n          d >= r && _(\"invalid-input\");\n          var g = (t = e.charCodeAt(d++)) - 48 < 10 ? t - 22 : t - 65 < 26 ? t - 65 : t - 97 < 26 ? t - 97 : u;\n          (g >= u || g > m((l - o) / h)) && _(\"overflow\");\n          o += g * h;\n          var y = f <= s ? 1 : f >= s + 26 ? 26 : f - s;\n          if (g < y) break;\n          var v = u - y;\n          h > m(l / v) && _(\"overflow\");\n          h *= v;\n        }\n        var b = n.length + 1;\n        s = w(o - p, b, 0 == p);\n        m(o / b) > l - i && _(\"overflow\");\n        i += m(o / b);\n        o %= b;\n        n.splice(o++, 0, i);\n      }\n      return String.fromCodePoint.apply(String, n);\n    },\n    E = function (e) {\n      var t = [],\n        n = (e = v(e)).length,\n        r = 128,\n        o = 0,\n        i = 72,\n        s = !0,\n        a = !1,\n        c = undefined;\n      try {\n        for (var d, p = e[Symbol.iterator](); !(s = (d = p.next()).done); s = !0) {\n          var h = d.value;\n          h < 128 && t.push(g(h));\n        }\n      } catch (e) {\n        a = !0;\n        c = e;\n      } finally {\n        try {\n          !s && p.return && p.return();\n        } finally {\n          if (a) throw c;\n        }\n      }\n      var f = t.length,\n        y = f;\n      for (f && t.push(\"-\"); y < n;) {\n        var x = l,\n          E = !0,\n          C = !1,\n          S = undefined;\n        try {\n          for (var T, k = e[Symbol.iterator](); !(E = (T = k.next()).done); E = !0) {\n            var I = T.value;\n            I >= r && I < x && (x = I);\n          }\n        } catch (e) {\n          C = !0;\n          S = e;\n        } finally {\n          try {\n            !E && k.return && k.return();\n          } finally {\n            if (C) throw S;\n          }\n        }\n        var P = y + 1;\n        x - r > m((l - o) / P) && _(\"overflow\");\n        o += (x - r) * P;\n        r = x;\n        var A = !0,\n          O = !1,\n          N = undefined;\n        try {\n          for (var R, M = e[Symbol.iterator](); !(A = (R = M.next()).done); A = !0) {\n            var L = R.value;\n            L < r && ++o > l && _(\"overflow\");\n            if (L == r) {\n              for (var $ = o, D = u;; D += u) {\n                var F = D <= i ? 1 : D >= i + 26 ? 26 : D - i;\n                if ($ < F) break;\n                var j = $ - F,\n                  q = u - F;\n                t.push(g(b(F + j % q, 0))), $ = m(j / q);\n              }\n              t.push(g(b($, 0))), i = w(o, P, y == f), o = 0, ++y;\n            }\n          }\n        } catch (e) {\n          O = !0;\n          N = e;\n        } finally {\n          try {\n            !A && M.return && M.return();\n          } finally {\n            if (O) throw N;\n          }\n        }\n        ++o;\n        ++r;\n      }\n      return t.join(\"\");\n    },\n    C = function (e) {\n      return y(e, function (e) {\n        return p.test(e) ? \"xn--\" + E(e) : e;\n      });\n    },\n    S = function (e) {\n      return y(e, function (e) {\n        return d.test(e) ? x(e.slice(4).toLowerCase()) : e;\n      });\n    },\n    T = {};\n  function k(e) {\n    var t = e.charCodeAt(0);\n    return t < 16 ? \"%0\" + t.toString(16).toUpperCase() : t < 128 ? \"%\" + t.toString(16).toUpperCase() : t < 2048 ? \"%\" + (t >> 6 | 192).toString(16).toUpperCase() + \"%\" + (63 & t | 128).toString(16).toUpperCase() : \"%\" + (t >> 12 | 224).toString(16).toUpperCase() + \"%\" + (t >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (63 & t | 128).toString(16).toUpperCase();\n  }\n  function I(e) {\n    for (var t = \"\", n = 0, r = e.length; n < r;) {\n      var o = parseInt(e.substr(n + 1, 2), 16);\n      if (o < 128) {\n        t += String.fromCharCode(o);\n        n += 3;\n      } else if (o >= 194 && o < 224) {\n        if (r - n >= 6) {\n          var i = parseInt(e.substr(n + 4, 2), 16);\n          t += String.fromCharCode((31 & o) << 6 | 63 & i);\n        } else t += e.substr(n, 6);\n        n += 6;\n      } else if (o >= 224) {\n        if (r - n >= 9) {\n          var s = parseInt(e.substr(n + 4, 2), 16),\n            a = parseInt(e.substr(n + 7, 2), 16);\n          t += String.fromCharCode((15 & o) << 12 | (63 & s) << 6 | 63 & a);\n        } else t += e.substr(n, 9);\n        n += 9;\n      } else {\n        t += e.substr(n, 3);\n        n += 3;\n      }\n    }\n    return t;\n  }\n  function P(e, t) {\n    function n(e) {\n      var n = I(e);\n      return n.match(t.UNRESERVED) ? n : e;\n    }\n    e.scheme && (e.scheme = String(e.scheme).replace(t.PCT_ENCODED, n).toLowerCase().replace(t.NOT_SCHEME, \"\"));\n    undefined !== e.userinfo && (e.userinfo = String(e.userinfo).replace(t.PCT_ENCODED, n).replace(t.NOT_USERINFO, k).replace(t.PCT_ENCODED, o));\n    undefined !== e.host && (e.host = String(e.host).replace(t.PCT_ENCODED, n).toLowerCase().replace(t.NOT_HOST, k).replace(t.PCT_ENCODED, o));\n    undefined !== e.path && (e.path = String(e.path).replace(t.PCT_ENCODED, n).replace(e.scheme ? t.NOT_PATH : t.NOT_PATH_NOSCHEME, k).replace(t.PCT_ENCODED, o));\n    undefined !== e.query && (e.query = String(e.query).replace(t.PCT_ENCODED, n).replace(t.NOT_QUERY, k).replace(t.PCT_ENCODED, o));\n    undefined !== e.fragment && (e.fragment = String(e.fragment).replace(t.PCT_ENCODED, n).replace(t.NOT_FRAGMENT, k).replace(t.PCT_ENCODED, o));\n    return e;\n  }\n  function A(e) {\n    return e.replace(/^0*(.*)/, \"$1\") || \"0\";\n  }\n  function O(e, t) {\n    var n = e.match(t.IPV4ADDRESS) || [],\n      r = c(n, 2)[1];\n    return r ? r.split(\".\").map(A).join(\".\") : e;\n  }\n  function N(e, t) {\n    var n = e.match(t.IPV6ADDRESS) || [],\n      r = c(n, 3),\n      o = r[1],\n      i = r[2];\n    if (o) {\n      for (var s = o.toLowerCase().split(\"::\").reverse(), a = c(s, 2), l = a[0], u = a[1], d = u ? u.split(\":\").map(A) : [], p = l.split(\":\").map(A), h = t.IPV4ADDRESS.test(p[p.length - 1]), f = h ? 7 : 8, m = p.length - f, g = Array(f), _ = 0; _ < f; ++_) g[_] = d[_] || p[m + _] || \"\";\n      h && (g[f - 1] = O(g[f - 1], t));\n      var y = g.reduce(function (e, t, n) {\n          if (!t || \"0\" === t) {\n            var r = e[e.length - 1];\n            r && r.index + r.length === n ? r.length++ : e.push({\n              index: n,\n              length: 1\n            });\n          }\n          return e;\n        }, []).sort(function (e, t) {\n          return t.length - e.length;\n        })[0],\n        v = undefined;\n      if (y && y.length > 1) {\n        var b = g.slice(0, y.index),\n          w = g.slice(y.index + y.length);\n        v = b.join(\":\") + \"::\" + w.join(\":\");\n      } else v = g.join(\":\");\n      i && (v += \"%\" + i);\n      return v;\n    }\n    return e;\n  }\n  var R = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i,\n    M = undefined === \"\".match(/(){0}/)[1];\n  function L(e) {\n    var t = arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {},\n      n = {},\n      r = !1 !== t.iri ? a : s;\n    \"suffix\" === t.reference && (e = (t.scheme ? t.scheme + \":\" : \"\") + \"//\" + e);\n    var o = e.match(R);\n    if (o) {\n      M ? (n.scheme = o[1], n.userinfo = o[3], n.host = o[4], n.port = parseInt(o[5], 10), n.path = o[6] || \"\", n.query = o[7], n.fragment = o[8], isNaN(n.port) && (n.port = o[5])) : (n.scheme = o[1] || undefined, n.userinfo = -1 !== e.indexOf(\"@\") ? o[3] : undefined, n.host = -1 !== e.indexOf(\"//\") ? o[4] : undefined, n.port = parseInt(o[5], 10), n.path = o[6] || \"\", n.query = -1 !== e.indexOf(\"?\") ? o[7] : undefined, n.fragment = -1 !== e.indexOf(\"#\") ? o[8] : undefined, isNaN(n.port) && (n.port = e.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? o[4] : undefined));\n      n.host && (n.host = N(O(n.host, r), r));\n      undefined !== n.scheme || undefined !== n.userinfo || undefined !== n.host || undefined !== n.port || n.path || undefined !== n.query ? undefined === n.scheme ? n.reference = \"relative\" : undefined === n.fragment ? n.reference = \"absolute\" : n.reference = \"uri\" : n.reference = \"same-document\";\n      t.reference && \"suffix\" !== t.reference && t.reference !== n.reference && (n.error = n.error || \"URI is not a \" + t.reference + \" reference.\");\n      var i = T[(t.scheme || n.scheme || \"\").toLowerCase()];\n      if (t.unicodeSupport || i && i.unicodeSupport) P(n, r);else {\n        if (n.host && (t.domainHost || i && i.domainHost)) try {\n          n.host = C(n.host.replace(r.PCT_ENCODED, I).toLowerCase());\n        } catch (e) {\n          n.error = n.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n        }\n        P(n, s);\n      }\n      i && i.parse && i.parse(n, t);\n    } else n.error = n.error || \"URI can not be parsed.\";\n    return n;\n  }\n  function $(e, t) {\n    var n = !1 !== t.iri ? a : s,\n      r = [];\n    undefined !== e.userinfo && (r.push(e.userinfo), r.push(\"@\"));\n    undefined !== e.host && r.push(N(O(String(e.host), n), n).replace(n.IPV6ADDRESS, function (e, t, n) {\n      return \"[\" + t + (n ? \"%25\" + n : \"\") + \"]\";\n    }));\n    \"number\" != typeof e.port && \"string\" != typeof e.port || (r.push(\":\"), r.push(String(e.port)));\n    return r.length ? r.join(\"\") : undefined;\n  }\n  var D = /^\\.\\.?\\//,\n    F = /^\\/\\.(\\/|$)/,\n    j = /^\\/\\.\\.(\\/|$)/,\n    q = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n  function B(e) {\n    for (var t = []; e.length;) if (e.match(D)) e = e.replace(D, \"\");else if (e.match(F)) e = e.replace(F, \"/\");else if (e.match(j)) {\n      e = e.replace(j, \"/\");\n      t.pop();\n    } else if (\".\" === e || \"..\" === e) e = \"\";else {\n      var n = e.match(q);\n      if (!n) throw new Error(\"Unexpected dot segment condition\");\n      var r = n[0];\n      e = e.slice(r.length);\n      t.push(r);\n    }\n    return t.join(\"\");\n  }\n  function U(e) {\n    var t = arguments.length > 1 && undefined !== arguments[1] ? arguments[1] : {},\n      n = t.iri ? a : s,\n      r = [],\n      o = T[(t.scheme || e.scheme || \"\").toLowerCase()];\n    o && o.serialize && o.serialize(e, t);\n    if (e.host) if (n.IPV6ADDRESS.test(e.host)) ;else if (t.domainHost || o && o.domainHost) try {\n      e.host = t.iri ? S(e.host) : C(e.host.replace(n.PCT_ENCODED, I).toLowerCase());\n    } catch (n) {\n      e.error = e.error || \"Host's domain name can not be converted to \" + (t.iri ? \"Unicode\" : \"ASCII\") + \" via punycode: \" + n;\n    }\n    P(e, n);\n    \"suffix\" !== t.reference && e.scheme && (r.push(e.scheme), r.push(\":\"));\n    var i = $(e, t);\n    undefined !== i && (\"suffix\" !== t.reference && r.push(\"//\"), r.push(i), e.path && \"/\" !== e.path.charAt(0) && r.push(\"/\"));\n    if (void 0 !== e.path) {\n      var c = e.path;\n      t.absolutePath || o && o.absolutePath || (c = B(c)), void 0 === i && (c = c.replace(/^\\/\\//, \"/%2F\")), r.push(c);\n    }\n    undefined !== e.query && (r.push(\"?\"), r.push(e.query));\n    undefined !== e.fragment && (r.push(\"#\"), r.push(e.fragment));\n    return r.join(\"\");\n  }\n  function H(e, t) {\n    var n = arguments.length > 2 && undefined !== arguments[2] ? arguments[2] : {},\n      r = {};\n    arguments[3] || (e = L(U(e, n), n), t = L(U(t, n), n));\n    !(n = n || {}).tolerant && t.scheme ? (r.scheme = t.scheme, r.userinfo = t.userinfo, r.host = t.host, r.port = t.port, r.path = B(t.path || \"\"), r.query = t.query) : (undefined !== t.userinfo || undefined !== t.host || undefined !== t.port ? (r.userinfo = t.userinfo, r.host = t.host, r.port = t.port, r.path = B(t.path || \"\"), r.query = t.query) : (t.path ? (\"/\" === t.path.charAt(0) ? r.path = B(t.path) : (undefined === e.userinfo && undefined === e.host && undefined === e.port || e.path ? e.path ? r.path = e.path.slice(0, e.path.lastIndexOf(\"/\") + 1) + t.path : r.path = t.path : r.path = \"/\" + t.path, r.path = B(r.path)), r.query = t.query) : (r.path = e.path, undefined !== t.query ? r.query = t.query : r.query = e.query), r.userinfo = e.userinfo, r.host = e.host, r.port = e.port), r.scheme = e.scheme);\n    r.fragment = t.fragment;\n    return r;\n  }\n  function z(e, t) {\n    return e && e.toString().replace(t && t.iri ? a.PCT_ENCODED : s.PCT_ENCODED, I);\n  }\n  var G = {\n      scheme: \"http\",\n      domainHost: !0,\n      parse: function (e, t) {\n        e.host || (e.error = e.error || \"HTTP URIs must have a host.\");\n        return e;\n      },\n      serialize: function (e, t) {\n        var n = \"https\" === String(e.scheme).toLowerCase();\n        e.port !== (n ? 443 : 80) && \"\" !== e.port || (e.port = undefined);\n        e.path || (e.path = \"/\");\n        return e;\n      }\n    },\n    V = {\n      scheme: \"https\",\n      domainHost: G.domainHost,\n      parse: G.parse,\n      serialize: G.serialize\n    };\n  function W(e) {\n    return \"boolean\" == typeof e.secure ? e.secure : \"wss\" === String(e.scheme).toLowerCase();\n  }\n  var K = {\n      scheme: \"ws\",\n      domainHost: !0,\n      parse: function (e, t) {\n        var n = e;\n        n.secure = W(n);\n        n.resourceName = (n.path || \"/\") + (n.query ? \"?\" + n.query : \"\");\n        n.path = undefined;\n        n.query = undefined;\n        return n;\n      },\n      serialize: function (e, t) {\n        e.port !== (W(e) ? 443 : 80) && \"\" !== e.port || (e.port = undefined);\n        \"boolean\" == typeof e.secure && (e.scheme = e.secure ? \"wss\" : \"ws\", e.secure = undefined);\n        if (e.resourceName) {\n          var n = e.resourceName.split(\"?\"),\n            r = c(n, 2),\n            o = r[0],\n            i = r[1];\n          e.path = o && \"/\" !== o ? o : void 0, e.query = i, e.resourceName = void 0;\n        }\n        e.fragment = undefined;\n        return e;\n      }\n    },\n    J = {\n      scheme: \"wss\",\n      domainHost: K.domainHost,\n      parse: K.parse,\n      serialize: K.serialize\n    },\n    X = {},\n    Q = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\",\n    Y = \"[0-9A-Fa-f]\",\n    Z = n(n(\"%[EFef][0-9A-Fa-f]%\" + Y + Y + \"%\" + Y + Y) + \"|\" + n(\"%[89A-Fa-f][0-9A-Fa-f]%\" + Y + Y) + \"|\" + n(\"%\" + Y + Y)),\n    ee = t(\"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\", '[\\\\\"\\\\\\\\]'),\n    te = new RegExp(Q, \"g\"),\n    ne = new RegExp(Z, \"g\"),\n    re = new RegExp(t(\"[^]\", \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\", \"[\\\\.]\", '[\\\\\"]', ee), \"g\"),\n    oe = new RegExp(t(\"[^]\", Q, \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\"), \"g\"),\n    ie = oe;\n  function se(e) {\n    var t = I(e);\n    return t.match(te) ? t : e;\n  }\n  var ae = {\n      scheme: \"mailto\",\n      parse: function (e, t) {\n        var n = e,\n          r = n.to = n.path ? n.path.split(\",\") : [];\n        n.path = undefined;\n        if (n.query) {\n          for (var o = !1, i = {}, s = n.query.split(\"&\"), a = 0, c = s.length; a < c; ++a) {\n            var l = s[a].split(\"=\");\n            switch (l[0]) {\n              case \"to\":\n                for (var u = l[1].split(\",\"), d = 0, p = u.length; d < p; ++d) r.push(u[d]);\n                break;\n              case \"subject\":\n                n.subject = z(l[1], t);\n                break;\n              case \"body\":\n                n.body = z(l[1], t);\n                break;\n              default:\n                o = !0, i[z(l[0], t)] = z(l[1], t);\n            }\n          }\n          o && (n.headers = i);\n        }\n        n.query = undefined;\n        for (var h = 0, f = r.length; h < f; ++h) {\n          var m = r[h].split(\"@\");\n          m[0] = z(m[0]);\n          if (t.unicodeSupport) m[1] = z(m[1], t).toLowerCase();else try {\n            m[1] = C(z(m[1], t).toLowerCase());\n          } catch (e) {\n            n.error = n.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n          }\n          r[h] = m.join(\"@\");\n        }\n        return n;\n      },\n      serialize: function (e, t) {\n        var n,\n          r = e,\n          i = null != (n = e.to) ? n instanceof Array ? n : \"number\" != typeof n.length || n.split || n.setInterval || n.call ? [n] : Array.prototype.slice.call(n) : [];\n        if (i) {\n          for (var s = 0, a = i.length; s < a; ++s) {\n            var c = String(i[s]),\n              l = c.lastIndexOf(\"@\"),\n              u = c.slice(0, l).replace(ne, se).replace(ne, o).replace(re, k),\n              d = c.slice(l + 1);\n            try {\n              d = t.iri ? S(d) : C(z(d, t).toLowerCase());\n            } catch (e) {\n              r.error = r.error || \"Email address's domain name can not be converted to \" + (t.iri ? \"Unicode\" : \"ASCII\") + \" via punycode: \" + e;\n            }\n            i[s] = u + \"@\" + d;\n          }\n          r.path = i.join(\",\");\n        }\n        var p = e.headers = e.headers || {};\n        e.subject && (p.subject = e.subject);\n        e.body && (p.body = e.body);\n        var h = [];\n        for (var f in p) p[f] !== X[f] && h.push(f.replace(ne, se).replace(ne, o).replace(oe, k) + \"=\" + p[f].replace(ne, se).replace(ne, o).replace(ie, k));\n        h.length && (r.query = h.join(\"&\"));\n        return r;\n      }\n    },\n    ce = /^([^\\:]+)\\:(.*)/,\n    le = {\n      scheme: \"urn\",\n      parse: function (e, t) {\n        var n = e.path && e.path.match(ce),\n          r = e;\n        if (n) {\n          var o = t.scheme || r.scheme || \"urn\",\n            i = n[1].toLowerCase(),\n            s = n[2],\n            a = o + \":\" + (t.nid || i),\n            c = T[a];\n          r.nid = i;\n          r.nss = s;\n          r.path = undefined;\n          c && (r = c.parse(r, t));\n        } else r.error = r.error || \"URN can not be parsed.\";\n        return r;\n      },\n      serialize: function (e, t) {\n        var n = t.scheme || e.scheme || \"urn\",\n          r = e.nid,\n          o = n + \":\" + (t.nid || r),\n          i = T[o];\n        i && (e = i.serialize(e, t));\n        var s = e,\n          a = e.nss;\n        s.path = (r || t.nid) + \":\" + a;\n        return s;\n      }\n    },\n    ue = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/,\n    de = {\n      scheme: \"urn:uuid\",\n      parse: function (e, t) {\n        var n = e;\n        n.uuid = n.nss;\n        n.nss = undefined;\n        t.tolerant || n.uuid && n.uuid.match(ue) || (n.error = n.error || \"UUID is not valid.\");\n        return n;\n      },\n      serialize: function (e, t) {\n        var n = e;\n        n.nss = (e.uuid || \"\").toLowerCase();\n        return n;\n      }\n    };\n  T[G.scheme] = G;\n  T[V.scheme] = V;\n  T[K.scheme] = K;\n  T[J.scheme] = J;\n  T[ae.scheme] = ae;\n  T[le.scheme] = le;\n  T[de.scheme] = de;\n  e.SCHEMES = T;\n  e.pctEncChar = k;\n  e.pctDecChars = I;\n  e.parse = L;\n  e.removeDotSegments = B;\n  e.serialize = U;\n  e.resolveComponents = H;\n  e.resolve = function (e, t, n) {\n    var r = function (e, t) {\n      var n = e;\n      if (t) for (var r in t) n[r] = t[r];\n      return n;\n    }({\n      scheme: \"null\"\n    }, n);\n    return U(H(L(e, r), L(t, r), r, !0), r);\n  };\n  e.normalize = function (e, t) {\n    \"string\" == typeof e ? e = U(L(e, t), t) : \"object\" === r(e) && (e = L(U(e, t), t));\n    return e;\n  };\n  e.equal = function (e, t, n) {\n    \"string\" == typeof e ? e = U(L(e, n), n) : \"object\" === r(e) && (e = U(e, n));\n    \"string\" == typeof t ? t = U(L(t, n), n) : \"object\" === r(t) && (t = U(t, n));\n    return e === t;\n  };\n  e.escapeComponent = function (e, t) {\n    return e && e.toString().replace(t && t.iri ? a.ESCAPE : s.ESCAPE, k);\n  };\n  e.unescapeComponent = z;\n  Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n}(exports);",
  "569": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.computeScore = exports.IndentationBasedJaccardMatcher = exports.FixedWindowSizeJaccardMatcher = undefined;\nconst r = require(4855),\n  o = require(1016);\nclass FixedWindowSizeJaccardMatcher extends o.WindowedMatcher {\n  constructor(e, t) {\n    super(e);\n    this.windowLength = t;\n  }\n  id() {\n    return \"fixed:\" + this.windowLength;\n  }\n  getWindowsDelineations(e) {\n    const t = [],\n      n = e.length;\n    for (let e = 0; 0 == e || e < n - this.windowLength; e++) {\n      const r = Math.min(e + this.windowLength, n);\n      t.push([e, r]);\n    }\n    return t;\n  }\n  trimDocument(e) {\n    return e.source.slice(0, e.offset).split(\"\\n\").slice(-this.windowLength).join(\"\\n\");\n  }\n  similarityScore(e, t) {\n    return computeScore(e, t);\n  }\n}\nexports.FixedWindowSizeJaccardMatcher = FixedWindowSizeJaccardMatcher;\nFixedWindowSizeJaccardMatcher.FACTORY = e => ({\n  to: t => new FixedWindowSizeJaccardMatcher(t, e)\n});\nclass IndentationBasedJaccardMatcher extends o.WindowedMatcher {\n  constructor(e, t, n) {\n    super(e);\n    this.indentationMinLength = t;\n    this.indentationMaxLength = n;\n    this.languageId = e.languageId;\n  }\n  id() {\n    return `indent:${this.indentationMinLength}:${this.indentationMaxLength}:${this.languageId}`;\n  }\n  getWindowsDelineations(e) {\n    return r.getWindowsDelineations(e, this.languageId, this.indentationMinLength, this.indentationMaxLength);\n  }\n  trimDocument(e) {\n    return e.source.slice(0, e.offset).split(\"\\n\").slice(-this.indentationMaxLength).join(\"\\n\");\n  }\n  similarityScore(e, t) {\n    return computeScore(e, t);\n  }\n}\nfunction computeScore(e, t) {\n  const n = new Set();\n  e.forEach(e => {\n    t.has(e) && n.add(e);\n  });\n  return n.size / (e.size + t.size - n.size);\n}\nexports.IndentationBasedJaccardMatcher = IndentationBasedJaccardMatcher;\nIndentationBasedJaccardMatcher.FACTORY = (e, t) => ({\n  to: n => new IndentationBasedJaccardMatcher(n, e, t)\n});\nexports.computeScore = computeScore;",
  "608": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(5290);\nfunction getSamplingHashCode(e) {\n  var t = 2147483647,\n    n = 5381;\n  if (!e) return 0;\n  for (; e.length < 8;) e += e;\n  for (var r = 0; r < e.length; r++) n = ((n << 5) + n | 0) + e.charCodeAt(r) | 0;\n  return (n = n <= -2147483648 ? t : Math.abs(n)) / t * 100;\n}\nexports.samplingTelemetryProcessor = function (e, t) {\n  var n = e.sampleRate;\n  return null == n || n >= 100 || !(!e.data || r.TelemetryType.Metric !== r.baseTypeToTelemetryType(e.data.baseType)) || (t.correlationContext && t.correlationContext.operation ? getSamplingHashCode(t.correlationContext.operation.id) < n : 100 * Math.random() < n);\n};\nexports.getSamplingHashCode = getSamplingHashCode;",
  "706": "var r;\nr = require(8249);\n(function (e) {\n  var t = r,\n    n = t.lib,\n    o = n.WordArray,\n    i = n.Hasher,\n    s = t.algo,\n    a = o.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]),\n    c = o.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]),\n    l = o.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]),\n    u = o.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]),\n    d = o.create([0, 1518500249, 1859775393, 2400959708, 2840853838]),\n    p = o.create([1352829926, 1548603684, 1836072691, 2053994217, 0]),\n    h = s.RIPEMD160 = i.extend({\n      _doReset: function () {\n        this._hash = o.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);\n      },\n      _doProcessBlock: function (e, t) {\n        for (var n = 0; n < 16; n++) {\n          var r = t + n,\n            o = e[r];\n          e[r] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8);\n        }\n        var i,\n          s,\n          h,\n          b,\n          w,\n          x,\n          E,\n          C,\n          S,\n          T,\n          k,\n          I = this._hash.words,\n          P = d.words,\n          A = p.words,\n          O = a.words,\n          N = c.words,\n          R = l.words,\n          M = u.words;\n        for (x = i = I[0], E = s = I[1], C = h = I[2], S = b = I[3], T = w = I[4], n = 0; n < 80; n += 1) {\n          k = i + e[t + O[n]] | 0;\n          k += n < 16 ? f(s, h, b) + P[0] : n < 32 ? m(s, h, b) + P[1] : n < 48 ? g(s, h, b) + P[2] : n < 64 ? _(s, h, b) + P[3] : y(s, h, b) + P[4];\n          k = (k = v(k |= 0, R[n])) + w | 0;\n          i = w;\n          w = b;\n          b = v(h, 10);\n          h = s;\n          s = k;\n          k = x + e[t + N[n]] | 0;\n          k += n < 16 ? y(E, C, S) + A[0] : n < 32 ? _(E, C, S) + A[1] : n < 48 ? g(E, C, S) + A[2] : n < 64 ? m(E, C, S) + A[3] : f(E, C, S) + A[4];\n          k = (k = v(k |= 0, M[n])) + T | 0;\n          x = T;\n          T = S;\n          S = v(C, 10);\n          C = E;\n          E = k;\n        }\n        k = I[1] + h + S | 0;\n        I[1] = I[2] + b + T | 0;\n        I[2] = I[3] + w + x | 0;\n        I[3] = I[4] + i + E | 0;\n        I[4] = I[0] + s + C | 0;\n        I[0] = k;\n      },\n      _doFinalize: function () {\n        var e = this._data,\n          t = e.words,\n          n = 8 * this._nDataBytes,\n          r = 8 * e.sigBytes;\n        t[r >>> 5] |= 128 << 24 - r % 32;\n        t[14 + (r + 64 >>> 9 << 4)] = 16711935 & (n << 8 | n >>> 24) | 4278255360 & (n << 24 | n >>> 8);\n        e.sigBytes = 4 * (t.length + 1);\n        this._process();\n        for (var o = this._hash, i = o.words, s = 0; s < 5; s++) {\n          var a = i[s];\n          i[s] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8);\n        }\n        return o;\n      },\n      clone: function () {\n        var e = i.clone.call(this);\n        e._hash = this._hash.clone();\n        return e;\n      }\n    });\n  function f(e, t, n) {\n    return e ^ t ^ n;\n  }\n  function m(e, t, n) {\n    return e & t | ~e & n;\n  }\n  function g(e, t, n) {\n    return (e | ~t) ^ n;\n  }\n  function _(e, t, n) {\n    return e & n | t & ~n;\n  }\n  function y(e, t, n) {\n    return e ^ (t | ~n);\n  }\n  function v(e, t) {\n    return e << t | e >>> 32 - t;\n  }\n  t.RIPEMD160 = i._createHelper(h);\n  t.HmacRIPEMD160 = i._createHmacHelper(h);\n})(Math);\nmodule.exports = r.RIPEMD160;",
  "731": "var r = require(3685),\n  o = require(5687),\n  i = require(5282),\n  s = require(5740),\n  a = require(9036),\n  c = require(6694),\n  l = require(894),\n  u = require(4350),\n  d = function () {\n    function e(t) {\n      if (e.INSTANCE) throw new Error(\"Server request tracking should be configured from the applicationInsights object\");\n      e.INSTANCE = this;\n      this._client = t;\n    }\n    e.prototype.enable = function (e) {\n      this._isEnabled = e;\n      (this._isAutoCorrelating || this._isEnabled || u.isEnabled()) && !this._isInitialized && (this.useAutoCorrelation(this._isAutoCorrelating), this._initialize());\n    };\n    e.prototype.useAutoCorrelation = function (e, t) {\n      e && !this._isAutoCorrelating ? l.CorrelationContextManager.enable(t) : !e && this._isAutoCorrelating && l.CorrelationContextManager.disable();\n      this._isAutoCorrelating = e;\n    };\n    e.prototype.isInitialized = function () {\n      return this._isInitialized;\n    };\n    e.prototype.isAutoCorrelating = function () {\n      return this._isAutoCorrelating;\n    };\n    e.prototype._generateCorrelationContext = function (e) {\n      if (this._isAutoCorrelating) return l.CorrelationContextManager.generateContextObject(e.getOperationId(this._client.context.tags), e.getRequestId(), e.getOperationName(this._client.context.tags), e.getCorrelationContextHeader(), e.getTraceparent(), e.getTracestate());\n    };\n    e.prototype._initialize = function () {\n      var t = this;\n      this._isInitialized = !0;\n      var n = function (n) {\n          if (n) {\n            if (\"function\" != typeof n) throw new Error(\"onRequest handler must be a function\");\n            return function (r, o) {\n              l.CorrelationContextManager.wrapEmitter(r);\n              l.CorrelationContextManager.wrapEmitter(o);\n              var i = r && !r[e.alreadyAutoCollectedFlag];\n              if (r && i) {\n                var s = new c(r),\n                  a = t._generateCorrelationContext(s);\n                l.CorrelationContextManager.runWithContext(a, function () {\n                  t._isEnabled && (r[e.alreadyAutoCollectedFlag] = !0, e.trackRequest(t._client, {\n                    request: r,\n                    response: o\n                  }, s));\n                  \"function\" == typeof n && n(r, o);\n                });\n              } else \"function\" == typeof n && n(r, o);\n            };\n          }\n        },\n        i = function (e) {\n          var t = e.addListener.bind(e);\n          e.addListener = function (e, r) {\n            switch (e) {\n              case \"request\":\n              case \"checkContinue\":\n                return t(e, n(r));\n              default:\n                return t(e, r);\n            }\n          };\n          e.on = e.addListener;\n        },\n        s = r.createServer;\n      r.createServer = function (e) {\n        var t = s(n(e));\n        i(t);\n        return t;\n      };\n      var a = o.createServer;\n      o.createServer = function (e, t) {\n        var r = a(e, n(t));\n        i(r);\n        return r;\n      };\n    };\n    e.trackRequestSync = function (t, n) {\n      if (n.request && n.response && t) {\n        e.addResponseCorrelationIdHeader(t, n.response);\n        var r = l.CorrelationContextManager.getCurrentContext(),\n          o = new c(n.request, r && r.operation.parentId);\n        r && (r.operation.id = o.getOperationId(t.context.tags) || r.operation.id, r.operation.name = o.getOperationName(t.context.tags) || r.operation.name, r.operation.parentId = o.getRequestId() || r.operation.parentId, r.customProperties.addHeaderData(o.getCorrelationContextHeader()));\n        e.endRequest(t, o, n, n.duration, n.error);\n      } else i.info(\"AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: \", !n.request, !n.response, !t);\n    };\n    e.trackRequest = function (t, n, r) {\n      if (n.request && n.response && t) {\n        var o = l.CorrelationContextManager.getCurrentContext(),\n          a = r || new c(n.request, o && o.operation.parentId);\n        s.canIncludeCorrelationHeader(t, a.getUrl()) && e.addResponseCorrelationIdHeader(t, n.response);\n        o && !r && (o.operation.id = a.getOperationId(t.context.tags) || o.operation.id, o.operation.name = a.getOperationName(t.context.tags) || o.operation.name, o.operation.parentId = a.getOperationParentId(t.context.tags) || o.operation.parentId, o.customProperties.addHeaderData(a.getCorrelationContextHeader()));\n        n.response.once && n.response.once(\"finish\", function () {\n          e.endRequest(t, a, n, null, null);\n        });\n        n.request.on && n.request.on(\"error\", function (r) {\n          e.endRequest(t, a, n, null, r);\n        });\n      } else i.info(\"AutoCollectHttpRequests.trackRequest was called with invalid parameters: \", !n.request, !n.response, !t);\n    };\n    e.addResponseCorrelationIdHeader = function (e, t) {\n      if (e.config && e.config.correlationId && t.getHeader && t.setHeader && !t.headersSent) {\n        var n = t.getHeader(a.requestContextHeader);\n        s.safeIncludeCorrelationHeader(e, t, n);\n      }\n    };\n    e.endRequest = function (e, t, n, r, o) {\n      o ? t.onError(o, r) : t.onResponse(n.response, r);\n      var i = t.getRequestTelemetry(n);\n      i.tagOverrides = t.getRequestTags(e.context.tags);\n      if (n.tagOverrides) for (var s in n.tagOverrides) i.tagOverrides[s] = n.tagOverrides[s];\n      var a = t.getLegacyRootId();\n      a && (i.properties.ai_legacyRootId = a);\n      i.contextObjects = i.contextObjects || {};\n      i.contextObjects[\"http.ServerRequest\"] = n.request;\n      i.contextObjects[\"http.ServerResponse\"] = n.response;\n      e.trackRequest(i);\n    };\n    e.prototype.dispose = function () {\n      e.INSTANCE = null;\n      this.enable(!1);\n      this._isInitialized = !1;\n      l.CorrelationContextManager.disable();\n      this._isAutoCorrelating = !1;\n    };\n    e.alreadyAutoCollectedFlag = \"_appInsightsAutoCollected\";\n    return e;\n  }();\nmodule.exports = d;",
  "750": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.handleGhostTextResultTelemetry = exports.mkBasicResultTelemetry = exports.mkCanceledResultTelemetry = exports.telemetryRejected = exports.telemetryAccepted = exports.telemetryShown = undefined;\nconst r = require(6333),\n  o = require(8965);\nexports.telemetryShown = function (e, t, n, o) {\n  n.markAsDisplayed();\n  const i = o ? `${t}.shownFromCache` : `${t}.shown`;\n  r.telemetry(e, i, n);\n};\nexports.telemetryAccepted = function (e, t, n) {\n  const i = t + \".accepted\",\n    s = e.get(o.ContextualFilterManager);\n  s.previousLabel = 1;\n  s.previousLabelTimestamp = Date.now();\n  r.telemetry(e, i, n);\n};\nexports.telemetryRejected = function (e, t, n) {\n  const i = t + \".rejected\",\n    s = e.get(o.ContextualFilterManager);\n  s.previousLabel = 0;\n  s.previousLabelTimestamp = Date.now();\n  r.telemetry(e, i, n);\n};\nexports.mkCanceledResultTelemetry = function (e, t = {}) {\n  return {\n    ...t,\n    telemetryBlob: e\n  };\n};\nexports.mkBasicResultTelemetry = function (e) {\n  return {\n    headerRequestId: e.properties.headerRequestId,\n    copilot_trackingId: e.properties.copilot_trackingId\n  };\n};\nexports.handleGhostTextResultTelemetry = async function (e, t) {\n  if (\"success\" === t.type) {\n    r.telemetryRaw(e, \"ghostText.produced\", t.telemetryData, {});\n    return t.value;\n  }\n  \"abortedBeforeIssued\" !== t.type && (\"canceled\" !== t.type ? r.telemetryRaw(e, `ghostText.${t.type}`, {\n    ...t.telemetryData,\n    reason: t.reason\n  }, {}) : r.telemetry(e, \"ghostText.canceled\", t.telemetryData.telemetryBlob.extendedBy({\n    reason: t.reason,\n    cancelledNetworkRequest: t.telemetryData.cancelledNetworkRequest ? \"true\" : \"false\"\n  })));\n};",
  "766": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ComputationStatus = exports.getRepoUrlFromConfigText = exports.parseRepoUrl = exports.extractRepoInfoForTesting = exports.extractRepoInfoInBackground = exports.tryGetGitHubNWO = exports.getDogFood = exports.Dogfood = exports.getUserKind = exports.isNotRepo = exports.isRepoInfo = undefined;\nconst r = require(3055),\n  o = require(3458),\n  i = require(1017),\n  s = require(362),\n  a = require(3076);\nvar c;\nfunction tryGetGitHubNWO(e) {\n  if (undefined !== e && e !== f.PENDING) return \"github.com\" === e.hostname ? e.owner + \"/\" + e.repo : undefined;\n}\nexports.isRepoInfo = function (e) {\n  return undefined !== e && e !== f.PENDING;\n};\nexports.isNotRepo = function (e) {\n  return undefined === e;\n};\nexports.getUserKind = async function (e) {\n  var t, n;\n  const r = null !== (t = (await e.get(s.CopilotTokenManager).getCopilotToken(e, !1)).organization_list) && undefined !== t ? t : [];\n  return null !== (n = [\"a5db0bcaae94032fe715fb34a5e4bce2\", \"4535c7beffc844b46bb1ed4aa04d759a\"].find(e => r.includes(e))) && undefined !== n ? n : \"\";\n};\n(function (e) {\n  e.GITHUB = \"github\";\n  e.MICROSOFT = \"microsoft\";\n  e.UNKNOWN = \"\";\n})(c = exports.Dogfood || (exports.Dogfood = {}));\nexports.getDogFood = function (e) {\n  return undefined === e || e === f.PENDING ? c.UNKNOWN : \"github/github\" === tryGetGitHubNWO(e) ? c.GITHUB : \"ssh.dev.azure.com\" === e.hostname || \"vs-ssh.visualstudio.com\" === e.hostname || \"dev.azure.com\" === e.hostname || \"domoreexp.visualstudio.com\" === e.hostname || \"office.visualstudio.com\" === e.hostname ? c.MICROSOFT : c.UNKNOWN;\n};\nexports.tryGetGitHubNWO = tryGetGitHubNWO;\nexports.extractRepoInfoInBackground = function (e, t) {\n  if (!t) return;\n  const n = i.dirname(t);\n  return u(e, n);\n};\nconst u = function (e, t) {\n  const n = new a.LRUCache(1e4),\n    r = new Set();\n  return (t, ...o) => {\n    const i = JSON.stringify(o),\n      s = n.get(i);\n    if (s) return s.result;\n    if (r.has(i)) return f.PENDING;\n    const a = e(t, ...o);\n    r.add(i);\n    a.then(e => {\n      n.put(i, new m(e));\n      r.delete(i);\n    });\n    return f.PENDING;\n  };\n}(d);\nasync function d(e, t) {\n  var n;\n  const o = await async function (e, t) {\n    let n = t + \"_add_to_make_longer\";\n    const o = e.get(r.FileSystem);\n    for (; t.length > 1 && t.length < n.length;) {\n      const e = i.join(t, \".git\", \"config\");\n      let r = !1;\n      try {\n        await o.stat(e);\n        r = !0;\n      } catch (e) {\n        r = !1;\n      }\n      if (r) return t;\n      n = t;\n      t = i.dirname(t);\n    }\n  }(e, t);\n  if (!o) return;\n  const s = e.get(r.FileSystem),\n    a = i.join(o, \".git\", \"config\"),\n    c = null !== (n = getRepoUrlFromConfigText((await s.readFile(a)).toString())) && undefined !== n ? n : \"\",\n    l = parseRepoUrl(c);\n  return undefined === l ? {\n    baseFolder: o,\n    url: c,\n    hostname: \"\",\n    owner: \"\",\n    repo: \"\",\n    pathname: \"\"\n  } : {\n    baseFolder: o,\n    url: c,\n    ...l\n  };\n}\nfunction parseRepoUrl(e) {\n  let t = {};\n  try {\n    t = o(e);\n    if (\"\" == t.host || \"\" == t.owner || \"\" == t.name || \"\" == t.pathname) return;\n  } catch (e) {\n    return;\n  }\n  return {\n    hostname: t.host,\n    owner: t.owner,\n    repo: t.name,\n    pathname: t.pathname\n  };\n}\nfunction getRepoUrlFromConfigText(e) {\n  var t;\n  const n = /^\\s*\\[\\s*remote\\s+\"((\\\\\\\\|\\\\\"|[^\\\\\"])+)\"/,\n    r = /^\\s*\\[remote.([^\"\\s]+)/,\n    o = /^\\s*url\\s*=\\s*([^\\s#;]+)/,\n    i = /^\\s*\\[/;\n  let s,\n    a,\n    c = !1;\n  for (const l of e.split(\"\\n\")) if (c && undefined !== s) {\n    s += l;\n    if (l.endsWith(\"\\\\\")) s = s.substring(0, s.length - 1);else if (c = !1, \"origin\" === a) return s;\n  } else {\n    const e = null !== (t = l.match(n)) && undefined !== t ? t : l.match(r);\n    if (e) a = e[1];else if (l.match(i)) a = undefined;else {\n      if (s && \"origin\" !== a) continue;\n      {\n        const e = l.match(o);\n        if (e) {\n          s = e[1];\n          if (s.endsWith(\"\\\\\")) {\n            s = s.substring(0, s.length - 1);\n            c = !0;\n          } else if (\"origin\" === a) return s;\n        }\n      }\n    }\n  }\n  return s;\n}\nvar f;\nexports.extractRepoInfoForTesting = async function (e, t) {\n  return d(e, t);\n};\nexports.parseRepoUrl = parseRepoUrl;\nexports.getRepoUrlFromConfigText = getRepoUrlFromConfigText;\n(function (e) {\n  e[e.PENDING = 0] = \"PENDING\";\n})(f = exports.ComputationStatus || (exports.ComputationStatus = {}));\nclass m {\n  constructor(e) {\n    this.result = e;\n  }\n}",
  "820": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getSiblingFunctionStart = exports.getSiblingFunctions = undefined;\nconst r = require(1747),\n  o = require(464);\nexports.getSiblingFunctions = async function ({\n  source: e,\n  offset: t,\n  languageId: n\n}) {\n  var i, s;\n  const a = [];\n  let c = \"\",\n    l = e.substring(0, t);\n  if (o.isSupportedLanguageId(n)) {\n    const u = await o.parseTree(n, e);\n    try {\n      let d = t;\n      for (; d >= 0 && /\\s/.test(e[d]);) d--;\n      const p = u.rootNode.descendantForIndex(d),\n        h = o.getAncestorWithSiblingFunctions(n, p);\n      if (h) {\n        const u = o.getFirstPrecedingComment(h),\n          d = null !== (i = null == u ? undefined : u.startIndex) && undefined !== i ? i : h.startIndex;\n        let p,\n          f = 0;\n        for (; \" \" == (p = e[d - f - 1]) || \"\\t\" == p;) f++;\n        const m = e.substring(d - f, d);\n        for (let i = h.nextSibling; i; i = i.nextSibling) if (o.isFunctionDefinition(n, i)) {\n          const n = o.getFirstPrecedingComment(i),\n            c = null !== (s = null == n ? undefined : n.startIndex) && undefined !== s ? s : i.startIndex;\n          if (c < t) continue;\n          const l = e.substring(c, i.endIndex),\n            u = r.newLineEnded(l) + \"\\n\" + m;\n          a.push(u);\n        }\n        c = e.substring(0, d);\n        l = e.substring(d, t);\n      }\n    } finally {\n      u.delete();\n    }\n  }\n  return {\n    siblings: a,\n    beforeInsertion: c,\n    afterInsertion: l\n  };\n};\nexports.getSiblingFunctionStart = async function ({\n  source: e,\n  offset: t,\n  languageId: n\n}) {\n  var r;\n  if (o.isSupportedLanguageId(n)) {\n    const i = await o.parseTree(n, e);\n    try {\n      let s = t;\n      for (; s >= 0 && /\\s/.test(e[s]);) s--;\n      const a = i.rootNode.descendantForIndex(s),\n        c = o.getAncestorWithSiblingFunctions(n, a);\n      if (c) {\n        for (let e = c.nextSibling; e; e = e.nextSibling) if (o.isFunctionDefinition(n, e)) {\n          const n = o.getFirstPrecedingComment(e),\n            i = null !== (r = null == n ? undefined : n.startIndex) && undefined !== r ? r : e.startIndex;\n          if (i < t) continue;\n          return i;\n        }\n        if (c.endIndex >= t) return c.endIndex;\n      }\n    } finally {\n      i.delete();\n    }\n  }\n  return t;\n};",
  "852": "module.exports = require(\"async_hooks\");",
  "862": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.TimeBucketGranularity = exports.DEFAULT_GRANULARITY = exports.GranularityImplementation = undefined;\nclass GranularityImplementation {\n  constructor(e) {\n    this.prefix = e;\n  }\n  getCurrentAndUpComingValues(e) {\n    return [this.getValue(e), this.getUpcomingValues(e)];\n  }\n}\nexports.GranularityImplementation = GranularityImplementation;\nclass r extends GranularityImplementation {\n  getValue(e) {\n    return this.prefix;\n  }\n  getUpcomingValues(e) {\n    return [];\n  }\n}\nexports.DEFAULT_GRANULARITY = e => new r(e);\nexports.TimeBucketGranularity = class extends GranularityImplementation {\n  constructor(e, t = .5, n = new Date().setUTCHours(0, 0, 0, 0)) {\n    super(e);\n    this.prefix = e;\n    this.fetchBeforeFactor = t;\n    this.anchor = n;\n  }\n  setTimePeriod(e) {\n    isNaN(e) ? this.timePeriodLengthMs = undefined : this.timePeriodLengthMs = e;\n  }\n  setByCallBuckets(e) {\n    isNaN(e) ? this.numByCallBuckets = undefined : this.numByCallBuckets = e;\n  }\n  getValue(e) {\n    return this.prefix + this.getTimePeriodBucketString(e) + (this.numByCallBuckets ? this.timeHash(e) : \"\");\n  }\n  getTimePeriodBucketString(e) {\n    return this.timePeriodLengthMs ? this.dateToTimePartString(e) : \"\";\n  }\n  getUpcomingValues(e) {\n    const t = [],\n      n = this.getUpcomingTimePeriodBucketStrings(e),\n      r = this.getUpcomingByCallBucketStrings();\n    for (const e of n) for (const n of r) t.push(this.prefix + e + n);\n    return t;\n  }\n  getUpcomingTimePeriodBucketStrings(e) {\n    if (undefined === this.timePeriodLengthMs) return [\"\"];\n    if ((e.getTime() - this.anchor) % this.timePeriodLengthMs < this.fetchBeforeFactor * this.timePeriodLengthMs) return [this.getTimePeriodBucketString(e)];\n    {\n      const t = new Date(e.getTime() + this.timePeriodLengthMs);\n      return [this.getTimePeriodBucketString(e), this.getTimePeriodBucketString(t)];\n    }\n  }\n  getUpcomingByCallBucketStrings() {\n    return undefined === this.numByCallBuckets ? [\"\"] : Array.from(Array(this.numByCallBuckets).keys()).map(e => e.toString());\n  }\n  timeHash(e) {\n    return null == this.numByCallBuckets ? 0 : e.getTime() % this.numByCallBuckets * 7883 % this.numByCallBuckets;\n  }\n  dateToTimePartString(e) {\n    return null == this.timePeriodLengthMs ? \"\" : Math.floor((e.getTime() - this.anchor) / this.timePeriodLengthMs).toString();\n  }\n};",
  "888": "var r, o, i, s, a, c, l, u;\nu = require(8249);\nrequire(2783);\nrequire(9824);\ni = (o = (r = u).lib).Base;\ns = o.WordArray;\nc = (a = r.algo).MD5;\nl = a.EvpKDF = i.extend({\n  cfg: i.extend({\n    keySize: 4,\n    hasher: c,\n    iterations: 1\n  }),\n  init: function (e) {\n    this.cfg = this.cfg.extend(e);\n  },\n  compute: function (e, t) {\n    for (var n, r = this.cfg, o = r.hasher.create(), i = s.create(), a = i.words, c = r.keySize, l = r.iterations; a.length < c;) {\n      n && o.update(n);\n      n = o.update(e).finalize(t);\n      o.reset();\n      for (var u = 1; u < l; u++) {\n        n = o.finalize(n);\n        o.reset();\n      }\n      i.concat(n);\n    }\n    i.sigBytes = 4 * c;\n    return i;\n  }\n});\nr.EvpKDF = function (e, t, n) {\n  return l.create(n).compute(e, t);\n};\nmodule.exports = u.EvpKDF;",
  "893": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.CopilotListDocument = undefined;\nconst r = require(106),\n  o = require(1133),\n  i = require(6333),\n  s = require(2388);\nclass CopilotListDocument {\n  constructor(e, t, n, s, a, c) {\n    this.targetDocument = n;\n    this.completionContext = s;\n    this.token = c;\n    this._solutionCount = 0;\n    this.solutionCountTarget = 0;\n    this._solutions = [];\n    this._wasCancelled = !1;\n    this._updateHandlers = new Set();\n    this.savedTelemetryData = i.TelemetryData.createAndMarkAsIssued();\n    this.debouncedEventFire = r.debounce(10, () => this._updateHandlers.forEach(e => e(this._uri)));\n    this.onDidResultUpdated = e => (this._updateHandlers.add(e), {\n      dispose: () => {\n        this._updateHandlers.delete(e);\n      }\n    });\n    this.solutionCountTarget = a;\n    this._ctx = e;\n    this._uri = t;\n    this._showLogprobs = o.getConfig(e, o.ConfigKey.DebugShowScores);\n    this.startPosition = this.completionContext.insertPosition;\n    this.numberHeaderLines = Math.max(1, this.formatDisplayLines(\"\").length - 1);\n  }\n  async getDocument() {\n    return this.targetDocument;\n  }\n  get targetUri() {\n    return this.targetDocument.uri;\n  }\n  header() {\n    if (this._wasCancelled) return \"No synthesized solutions found.\";\n    {\n      const e = this._solutionCount - this._solutions.length > 0 ? \" (Duplicates hidden)\" : \"\";\n      return `Synthesizing ${this._solutionCount}/${this.solutionCountTarget} solutions${e}`;\n    }\n  }\n  areSolutionsDuplicates(e, t) {\n    return s.normalizeCompletionText(e.completionText) === s.normalizeCompletionText(t.completionText);\n  }\n  insertSorted(e, t, n) {\n    if (!/^\\s*$/.test(t.completionText)) {\n      for (let r = 0; r < e.length; r++) {\n        const o = e[r];\n        if (this.areSolutionsDuplicates(o, t)) {\n          if (n(o) < n(t)) {\n            e.splice(r, 1);\n            break;\n          }\n          return;\n        }\n      }\n      for (let r = 0; r < e.length; r++) if (n(e[r]) < n(t)) return void e.splice(r, 0, t);\n      e.push(t);\n    }\n  }\n  reportCancelled() {\n    this._wasCancelled = !0;\n    this.debouncedEventFire();\n  }\n  getCancellationToken() {\n    return this.token;\n  }\n  insertSolution(e) {\n    const t = {\n      displayLines: this.formatDisplayLines(e.displayText, e.meanProb, e.meanLogProb),\n      completionText: e.completionText,\n      meanLogProb: e.meanLogProb,\n      meanProb: e.meanProb,\n      prependToCompletion: e.prependToCompletion,\n      requestId: e.requestId,\n      choiceIndex: e.choiceIndex\n    };\n    this.insertSorted(this._solutions, t, e => e.meanProb);\n    this._solutionCount++;\n    this.debouncedEventFire();\n  }\n  formatDisplayLines(e, t, n) {\n    let r = \"\";\n    this._showLogprobs && (n = n || 0, r += `\\n\\t# mean prob: ${t}`);\n    return `${CopilotListDocument.separator}${r}\\n\\n${e}`.split(\"\\n\");\n  }\n  async runQuery() {\n    const e = await s.launchSolutions(this._ctx, this);\n    this.processNextSolution(e);\n  }\n  async processNextSolution(e) {\n    switch (e.status) {\n      case \"FinishedNormally\":\n      case \"FinishedWithError\":\n        return;\n      case \"Solution\":\n        this.insertSolution(e.solution);\n        this.processNextSolution(await e.next);\n    }\n  }\n  solutionsReceived() {\n    return this._solutionCount;\n  }\n  solutions() {\n    return this._solutions;\n  }\n  get value() {\n    return [this.header()].concat(this._solutions.flatMap(e => e.displayLines)).concat(\"\").join(\"\\n\");\n  }\n}\nexports.CopilotListDocument = CopilotListDocument;\nCopilotListDocument.separator = \"\\n=======\";",
  "894": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(5282),\n  o = require(7396),\n  CorrelationContextManager = function () {\n    function e() {}\n    e.getCurrentContext = function () {\n      if (!e.enabled) return null;\n      var t = e.session.get(e.CONTEXT_NAME);\n      return undefined === t ? null : t;\n    };\n    e.generateContextObject = function (e, t, n, r, o, i) {\n      t = t || e;\n      return this.enabled ? {\n        operation: {\n          name: n,\n          id: e,\n          parentId: t,\n          traceparent: o,\n          tracestate: i\n        },\n        customProperties: new s(r)\n      } : null;\n    };\n    e.runWithContext = function (t, n) {\n      return e.enabled ? e.session.bind(n, ((r = {})[e.CONTEXT_NAME] = t, r))() : n();\n      var r;\n    };\n    e.wrapEmitter = function (t) {\n      e.enabled && e.session.bindEmitter(t);\n    };\n    e.wrapCallback = function (t) {\n      return e.enabled ? e.session.bind(t) : t;\n    };\n    e.enable = function (t) {\n      this.enabled || (this.isNodeVersionCompatible() ? (e.hasEverEnabled || (this.forceClsHooked = t, this.hasEverEnabled = !0, undefined === this.cls && (!0 === e.forceClsHooked || undefined === e.forceClsHooked && e.shouldUseClsHooked() ? this.cls = require(9562) : this.cls = require(3057)), e.session = this.cls.createNamespace(\"AI-CLS-Session\"), o.registerContextPreservation(function (t) {\n        return e.session.bind(t);\n      })), this.enabled = !0) : this.enabled = !1);\n    };\n    e.disable = function () {\n      this.enabled = !1;\n    };\n    e.reset = function () {\n      e.hasEverEnabled && (e.session = null, e.session = this.cls.createNamespace(\"AI-CLS-Session\"));\n    };\n    e.isNodeVersionCompatible = function () {\n      var e = process.versions.node.split(\".\");\n      return parseInt(e[0]) > 3 || parseInt(e[0]) > 2 && parseInt(e[1]) > 2;\n    };\n    e.shouldUseClsHooked = function () {\n      var e = process.versions.node.split(\".\");\n      return parseInt(e[0]) > 8 || parseInt(e[0]) >= 8 && parseInt(e[1]) >= 2;\n    };\n    e.canUseClsHooked = function () {\n      var e = process.versions.node.split(\".\"),\n        t = parseInt(e[0]) > 8 || parseInt(e[0]) >= 8 && parseInt(e[1]) >= 0,\n        n = parseInt(e[0]) < 8 || parseInt(e[0]) <= 8 && parseInt(e[1]) < 2,\n        r = parseInt(e[0]) > 4 || parseInt(e[0]) >= 4 && parseInt(e[1]) >= 7;\n      return !(t && n) && r;\n    };\n    e.enabled = !1;\n    e.hasEverEnabled = !1;\n    e.forceClsHooked = undefined;\n    e.CONTEXT_NAME = \"ApplicationInsights-Context\";\n    return e;\n  }();\nexports.CorrelationContextManager = CorrelationContextManager;\nvar s = function () {\n  function e(e) {\n    this.props = [];\n    this.addHeaderData(e);\n  }\n  e.prototype.addHeaderData = function (e) {\n    var t = e ? e.split(\", \") : [];\n    this.props = t.map(function (e) {\n      var t = e.split(\"=\");\n      return {\n        key: t[0],\n        value: t[1]\n      };\n    }).concat(this.props);\n  };\n  e.prototype.serializeToHeader = function () {\n    return this.props.map(function (e) {\n      return e.key + \"=\" + e.value;\n    }).join(\", \");\n  };\n  e.prototype.getProperty = function (e) {\n    for (var t = 0; t < this.props.length; ++t) {\n      var n = this.props[t];\n      if (n.key === e) return n.value;\n    }\n  };\n  e.prototype.setProperty = function (t, n) {\n    if (e.bannedCharacters.test(t) || e.bannedCharacters.test(n)) r.warn(\"Correlation context property keys and values must not contain ',' or '='. setProperty was called with key: \" + t + \" and value: \" + n);else {\n      for (var o = 0; o < this.props.length; ++o) {\n        var i = this.props[o];\n        if (i.key === t) return void (i.value = n);\n      }\n      this.props.push({\n        key: t,\n        value: n\n      });\n    }\n  };\n  e.bannedCharacters = /[,=]/;\n  return e;\n}();",
  "901": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  }(require(8934));\nmodule.exports = i;",
  "935": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.exceptions = [];\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  }(require(8934));\nmodule.exports = i;",
  "937": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getTemperatureForSamples = exports.calculateMeanAlternativeLogProb = exports.calculateMeanLogProb = exports.cleanupIndentChoices = exports.convertToAPIChoice = exports.DEFAULT_CHARACTER_MULTIPLIER = exports.MAX_PROMPT_LENGTH = exports.OpenAIFetcher = exports.LiveOpenAIFetcher = exports.getRequestId = exports.CopilotUiKind = undefined;\nconst r = require(1133),\n  o = require(9899),\n  i = require(6333),\n  s = require(70);\nvar a = require(4419);\nfunction calculateMeanLogProb(e, t) {\n  var n;\n  if (null === (n = null == t ? undefined : t.logprobs) || undefined === n ? undefined : n.token_logprobs) try {\n    let e = 0,\n      n = 0,\n      r = 50;\n    for (let o = 0; o < t.logprobs.token_logprobs.length - 1 && r > 0; o++, r--) {\n      e += t.logprobs.token_logprobs[o];\n      n += 1;\n    }\n    return n > 0 ? e / n : undefined;\n  } catch (t) {\n    o.logger.error(e, `Error calculating mean prob: ${t}`);\n  }\n}\nfunction calculateMeanAlternativeLogProb(e, t) {\n  var n;\n  if (null === (n = null == t ? undefined : t.logprobs) || undefined === n ? undefined : n.top_logprobs) try {\n    let e = 0,\n      n = 0,\n      r = 50;\n    for (let o = 0; o < t.logprobs.token_logprobs.length - 1 && r > 0; o++, r--) {\n      const r = {\n        ...t.logprobs.top_logprobs[o]\n      };\n      delete r[t.logprobs.tokens[o]];\n      e += Math.max(...Object.values(r));\n      n += 1;\n    }\n    return n > 0 ? e / n : undefined;\n  } catch (t) {\n    o.logger.error(e, `Error calculating mean prob: ${t}`);\n  }\n}\nexports.CopilotUiKind = a.CopilotUiKind;\nexports.getRequestId = a.getRequestId;\nexports.LiveOpenAIFetcher = a.LiveOpenAIFetcher;\nexports.OpenAIFetcher = a.OpenAIFetcher;\nexports.MAX_PROMPT_LENGTH = 1500;\nexports.DEFAULT_CHARACTER_MULTIPLIER = 3;\nexports.convertToAPIChoice = function (e, t, n, r, o, s, a, u) {\n  i.logEngineCompletion(e, t, n, o, r);\n  return {\n    completionText: t,\n    meanLogProb: calculateMeanLogProb(e, n),\n    meanAlternativeLogProb: calculateMeanAlternativeLogProb(e, n),\n    choiceIndex: r,\n    requestId: o,\n    modelInfo: u,\n    blockFinished: s,\n    tokens: n.tokens,\n    numTokens: n.tokens.length,\n    telemetryData: a\n  };\n};\nexports.cleanupIndentChoices = async function* (e, t) {\n  for await (const n of e) {\n    const e = {\n        ...n\n      },\n      r = e.completionText.split(\"\\n\");\n    for (let e = 0; e < r.length; ++e) {\n      const n = r[e].trimLeft();\n      r[e] = \"\" === n ? n : t + n;\n    }\n    e.completionText = r.join(\"\\n\");\n    yield e;\n  }\n};\nexports.calculateMeanLogProb = calculateMeanLogProb;\nexports.calculateMeanAlternativeLogProb = calculateMeanAlternativeLogProb;\nexports.getTemperatureForSamples = function (e, t) {\n  if (s.isRunningInTest(e)) return 0;\n  const n = parseFloat(r.getConfig(e, r.ConfigKey.Temperature));\n  return n >= 0 && n <= 1 ? n : t <= 1 ? 0 : t < 10 ? .2 : t < 20 ? .4 : .8;\n};",
  "956": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.readTestingGitHubToken = exports.makeTestingCopilotTokenManager = undefined;\nconst r = require(7147),\n  o = require(362);\nfunction readTestingGitHubToken() {\n  const e = `${process.env.HOME}/.copilot-testing-gh-token`;\n  if (r.existsSync(e)) return r.readFileSync(e).toString();\n  throw new Error(`Tests: either GH_COPILOT_TOKEN, or GITHUB_TOKEN, must be set, or there must be a GitHub token from an app with access to Copilot in ${e}. Run \"npm run get_token\" to get one.`);\n}\nexports.makeTestingCopilotTokenManager = function () {\n  if (process.env.GH_COPILOT_TOKEN) return new o.FixedCopilotTokenManager({\n    token: process.env.GH_COPILOT_TOKEN,\n    telemetry: \"enabled\"\n  });\n  if (process.env.GITHUB_TOKEN) return new o.CopilotTokenManagerFromGitHubToken({\n    token: process.env.GITHUB_TOKEN\n  });\n  const e = readTestingGitHubToken();\n  process.env.GITHUB_TOKEN = e;\n  return new o.CopilotTokenManagerFromGitHubToken({\n    token: e\n  });\n};\nexports.readTestingGitHubToken = readTestingGitHubToken;",
  "966": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(6776),\n  i = require(3510),\n  s = {\n    keyword: \"enum\",\n    schemaType: \"array\",\n    $data: !0,\n    error: {\n      message: \"must be equal to one of the allowed values\",\n      params: ({\n        schemaCode: e\n      }) => r._`{allowedValues: ${e}}`\n    },\n    code(e) {\n      const {\n        gen: t,\n        data: n,\n        $data: s,\n        schema: a,\n        schemaCode: c,\n        it: l\n      } = e;\n      if (!s && 0 === a.length) throw new Error(\"enum must have non-empty array\");\n      const u = a.length >= l.opts.loopEnum,\n        d = o.useFunc(t, i.default);\n      let p;\n      if (u || s) {\n        p = t.let(\"valid\");\n        e.block$data(p, function () {\n          t.assign(p, !1);\n          t.forOf(\"v\", c, e => t.if(r._`${d}(${n}, ${e})`, () => t.assign(p, !0).break()));\n        });\n      } else {\n        if (!Array.isArray(a)) throw new Error(\"ajv implementation error\");\n        const e = t.const(\"vSchema\", c);\n        p = r.or(...a.map((t, o) => function (e, t) {\n          const o = a[t];\n          return \"object\" == typeof o && null !== o ? r._`${d}(${n}, ${e}[${t}])` : r._`${n} === ${o}`;\n        }(e, o)));\n      }\n      e.pass(p);\n    }\n  };\nexports.default = s;",
  "1006": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ghostTextScoreQuantile = exports.ghostTextScoreConfidence = undefined;\nconst r = require(9899),\n  o = require(7481),\n  i = (new r.Logger(r.LogLevel.INFO, \"restraint\"), {\n    link: e => Math.exp(e) / (1 + Math.exp(e)),\n    unlink: e => Math.log(e / (1 - e))\n  });\nclass s {\n  constructor(e, t, n) {\n    this.name = e;\n    this.coefficient = t;\n    this.transformation = n || (e => e);\n  }\n  contribution(e) {\n    return this.coefficient * this.transformation(e);\n  }\n}\nconst a = new class {\n  constructor(e, t, n) {\n    this.link = i;\n    this.intercept = e;\n    this.coefficients = t;\n    this.logitsToQuantiles = new Map();\n    this.logitsToQuantiles.set(0, 0);\n    this.logitsToQuantiles.set(1, 1);\n    if (n) for (const e in n) this.logitsToQuantiles.set(n[e], Number(e));\n  }\n  predict(e, t) {\n    let n = this.intercept;\n    for (const e of this.coefficients) {\n      const r = t[e.name];\n      if (undefined === r) return NaN;\n      n += e.contribution(r);\n    }\n    return this.link.link(n);\n  }\n  quantile(e, t) {\n    return function (e, t) {\n      const n = Math.min(...Array.from(t.keys()).filter(t => t >= e)),\n        r = Math.max(...Array.from(t.keys()).filter(t => t < e)),\n        o = t.get(n),\n        i = t.get(r);\n      return i + (o - i) * (e - r) / (n - r);\n    }(this.predict(e, t), this.logitsToQuantiles);\n  }\n}(o.ghostTextDisplayInterceptParameter, [new s(\"compCharLen\", o.ghostTextDisplayLog1pcompCharLenParameter, e => Math.log(1 + e)), new s(\"meanLogProb\", o.ghostTextDisplayMeanLogProbParameter), new s(\"meanAlternativeLogProb\", o.ghostTextDisplayMeanAlternativeLogProbParameter)].concat(Object.entries(o.ghostTextDisplayLanguageParameters).map(e => new s(e[0], e[1]))), o.ghostTextDisplayQuantiles);\nexports.ghostTextScoreConfidence = function (e, t) {\n  const n = {\n    ...t.measurements\n  };\n  Object.keys(o.ghostTextDisplayLanguageParameters).forEach(e => {\n    n[e] = t.properties[\"customDimensions.languageId\"] == e ? 1 : 0;\n  });\n  return a.predict(e, n);\n};\nexports.ghostTextScoreQuantile = function (e, t) {\n  const n = {\n    ...t.measurements\n  };\n  Object.keys(o.ghostTextDisplayLanguageParameters).forEach(e => {\n    n[e] = t.properties[\"customDimensions.languageId\"] == e ? 1 : 0;\n  });\n  return a.quantile(e, n);\n};",
  "1016": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.splitIntoWords = exports.WindowedMatcher = exports.SortOptions = undefined;\nconst r = require(1747);\nvar o;\n!function (e) {\n  e.Ascending = \"ascending\";\n  e.Descending = \"descending\";\n  e.None = \"none\";\n}(o = exports.SortOptions || (exports.SortOptions = {}));\nclass i {\n  constructor(e) {\n    var t;\n    this.stopsForLanguage = null !== (t = u.get(e.languageId)) && undefined !== t ? t : l;\n  }\n  tokenize(e) {\n    return new Set(splitIntoWords(e).filter(e => !this.stopsForLanguage.has(e)));\n  }\n}\nconst s = new class {\n  constructor(e) {\n    this.keys = [];\n    this.cache = {};\n    this.size = e;\n  }\n  put(e, t) {\n    var n;\n    this.cache[e] = t;\n    if (this.keys.length > this.size) {\n      this.keys.push(e);\n      const t = null !== (n = this.keys.shift()) && void 0 !== n ? n : \"\";\n      delete this.cache[t];\n    }\n  }\n  get(e) {\n    return this.cache[e];\n  }\n}(20);\nfunction splitIntoWords(e) {\n  return e.split(/[^a-zA-Z0-9]/).filter(e => e.length > 0);\n}\nexports.WindowedMatcher = class {\n  constructor(e) {\n    this.tokenizer = new i(e);\n    this.referenceTokens = this.tokenizer.tokenize(this.trimDocument(e));\n  }\n  sortScoredSnippets(e, t = o.Descending) {\n    return t == o.Ascending ? e.sort((e, t) => e.score > t.score ? 1 : -1) : t == o.Descending ? e.sort((e, t) => e.score > t.score ? -1 : 1) : e;\n  }\n  retrieveAllSnippets(e, t = o.Descending) {\n    var n;\n    const r = [];\n    if (0 === e.source.length || 0 === this.referenceTokens.size) return r;\n    const i = e.source.split(\"\\n\"),\n      a = this.id() + \":\" + e.source,\n      c = null !== (n = s.get(a)) && undefined !== n ? n : [],\n      l = 0 == c.length,\n      u = l ? i.map(this.tokenizer.tokenize, this.tokenizer) : [];\n    for (const [e, [t, n]] of this.getWindowsDelineations(i).entries()) {\n      if (l) {\n        const e = new Set();\n        u.slice(t, n).forEach(t => t.forEach(e.add, e));\n        c.push(e);\n      }\n      const o = c[e],\n        i = this.similarityScore(o, this.referenceTokens);\n      r.push({\n        score: i,\n        startLine: t,\n        endLine: n\n      });\n    }\n    l && s.put(a, c);\n    return this.sortScoredSnippets(r, t);\n  }\n  findMatches(e, t = r.SnippetSelectionOption.BestMatch, n) {\n    if (t == r.SnippetSelectionOption.BestMatch) {\n      const t = this.findBestMatch(e);\n      return t ? [t] : [];\n    }\n    return t == r.SnippetSelectionOption.TopK && this.findTopKMatches(e, n) || [];\n  }\n  findBestMatch(e) {\n    if (0 === e.source.length || 0 === this.referenceTokens.size) return;\n    const t = e.source.split(\"\\n\"),\n      n = this.retrieveAllSnippets(e, o.Descending);\n    return 0 !== n.length && 0 !== n[0].score ? {\n      snippet: t.slice(n[0].startLine, n[0].endLine).join(\"\\n\"),\n      ...n[0]\n    } : undefined;\n  }\n  findTopKMatches(e, t = 1) {\n    if (0 === e.source.length || 0 === this.referenceTokens.size || t < 1) return;\n    const n = e.source.split(\"\\n\"),\n      r = this.retrieveAllSnippets(e, o.Descending);\n    if (0 === r.length || 0 === r[0].score) return;\n    const i = [r[0]];\n    for (let e = 1; e < r.length && i.length < t; e++) -1 == i.findIndex(t => r[e].startLine < t.endLine && r[e].endLine > t.startLine) && i.push(r[e]);\n    return i.map(e => ({\n      snippet: n.slice(e.startLine, e.endLine).join(\"\\n\"),\n      ...e\n    }));\n  }\n};\nexports.splitIntoWords = splitIntoWords;\nconst c = new Set([\"we\", \"our\", \"you\", \"it\", \"its\", \"they\", \"them\", \"their\", \"this\", \"that\", \"these\", \"those\", \"is\", \"are\", \"was\", \"were\", \"be\", \"been\", \"being\", \"have\", \"has\", \"had\", \"having\", \"do\", \"does\", \"did\", \"doing\", \"can\", \"don\", \"t\", \"s\", \"will\", \"would\", \"should\", \"what\", \"which\", \"who\", \"when\", \"where\", \"why\", \"how\", \"a\", \"an\", \"the\", \"and\", \"or\", \"not\", \"no\", \"but\", \"because\", \"as\", \"until\", \"again\", \"further\", \"then\", \"once\", \"here\", \"there\", \"all\", \"any\", \"both\", \"each\", \"few\", \"more\", \"most\", \"other\", \"some\", \"such\", \"above\", \"below\", \"to\", \"during\", \"before\", \"after\", \"of\", \"at\", \"by\", \"about\", \"between\", \"into\", \"through\", \"from\", \"up\", \"down\", \"in\", \"out\", \"on\", \"off\", \"over\", \"under\", \"only\", \"own\", \"same\", \"so\", \"than\", \"too\", \"very\", \"just\", \"now\"]),\n  l = new Set([\"if\", \"then\", \"else\", \"for\", \"while\", \"with\", \"def\", \"function\", \"return\", \"TODO\", \"import\", \"try\", \"catch\", \"raise\", \"finally\", \"repeat\", \"switch\", \"case\", \"match\", \"assert\", \"continue\", \"break\", \"const\", \"class\", \"enum\", \"struct\", \"static\", \"new\", \"super\", \"this\", \"var\", ...c]),\n  u = new Map([]);",
  "1017": "module.exports = require(\"path\");",
  "1077": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.Iso97971 = {\n  pad: function (e, t) {\n    e.concat(r.lib.WordArray.create([2147483648], 1));\n    r.pad.ZeroPadding.pad(e, t);\n  },\n  unpad: function (e) {\n    r.pad.ZeroPadding.unpad(e);\n    e.sigBytes--;\n  }\n};\nmodule.exports = r.pad.Iso97971;",
  "1119": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(6776),\n  i = require(412),\n  s = require(4783),\n  a = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    error: {\n      message: ({\n        params: {\n          len: e\n        }\n      }) => r.str`must NOT have more than ${e} items`,\n      params: ({\n        params: {\n          len: e\n        }\n      }) => r._`{limit: ${e}}`\n    },\n    code(e) {\n      const {\n          schema: t,\n          parentSchema: n,\n          it: r\n        } = e,\n        {\n          prefixItems: a\n        } = n;\n      r.items = !0;\n      o.alwaysValidSchema(r, t) || (a ? s.validateAdditionalItems(e, a) : e.ok(i.validateArray(e)));\n    }\n  };\nexports.default = a;",
  "1124": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.checkSuffix = exports.postProcessChoice = undefined;\nconst r = require(9189),\n  o = require(2533),\n  i = require(6333),\n  s = require(70),\n  a = require(9657);\nexports.postProcessChoice = async function (e, t, n, c, l, u, d) {\n  if (a.isRepetitive(l.tokens, await e.get(r.Features).repetitionFilterMode())) {\n    const t = i.TelemetryData.createAndMarkAsIssued();\n    t.extendWithRequestId(l.requestId);\n    i.telemetry(e, \"repetition.detected\", t, !0);\n    return void d.info(e, \"Filtered out repetitive solution\");\n  }\n  const p = {\n    ...l\n  };\n  if (function (e, t, n) {\n    let r = \"\",\n      o = t.line + 1;\n    for (; \"\" === r && o < e.lineCount;) {\n      r = e.lineAt(o).text.trim();\n      if (r === n.trim()) return !0;\n      o++;\n    }\n    return !1;\n  }(n, c, p.completionText)) {\n    const t = i.TelemetryData.createAndMarkAsIssued();\n    t.extendWithRequestId(l.requestId);\n    i.telemetry(e, \"completion.alreadyInDocument\", t);\n    i.telemetry(e, \"completion.alreadyInDocument\", t.extendedBy({\n      completionTextJson: JSON.stringify(p.completionText)\n    }), !0);\n    return void d.info(e, \"Filtered out solution matching next line\");\n  }\n  p.completionText = await async function (e, t, n, r, i) {\n    var a;\n    if (\"\" === r) return r;\n    let c = \"}\";\n    try {\n      c = null !== (a = o.getBlockCloseToken(t.languageId)) && undefined !== a ? a : \"}\";\n    } catch (e) {}\n    let l = r.length;\n    do {\n      const o = r.lastIndexOf(\"\\n\", l - 2) + 1,\n        a = r.substring(o, l);\n      if (a.trim() === c) {\n        for (let e = n.line; e < t.lineCount; e++) {\n          let s = t.lineAt(e).text;\n          e === n.line && (s = s.substr(n.character));\n          if (s.startsWith(a.trimRight())) return r.substring(0, Math.max(0, i ? o : o - 1));\n          if (\"\" !== s.trim()) break;\n        }\n        break;\n      }\n      if (l === o) {\n        if (s.shouldFailForDebugPurposes(e)) throw Error(`Aborting: maybeSnipCompletion would have looped on completion: ${r}`);\n        break;\n      }\n      l = o;\n    } while (l > 1);\n    return r;\n  }(e, n, c, p.completionText, u);\n  return p.completionText ? p : undefined;\n};\nexports.checkSuffix = function (e, t, n) {\n  const r = e.lineAt(t.line).text.substring(t.character);\n  if (r.length > 0) {\n    if (-1 !== n.completionText.indexOf(r)) return !0;\n    {\n      let e = 0;\n      for (const t of r) {\n        const r = n.completionText.indexOf(t, e + 1);\n        if (!(r > e)) {\n          e = -1;\n          break;\n        }\n        e = r;\n      }\n      return -1 !== e;\n    }\n  }\n  return !1;\n};",
  "1125": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(6776),\n  o = {\n    keyword: \"allOf\",\n    schemaType: \"array\",\n    code(e) {\n      const {\n        gen: t,\n        schema: n,\n        it: o\n      } = e;\n      if (!Array.isArray(n)) throw new Error(\"ajv implementation error\");\n      const i = t.name(\"valid\");\n      n.forEach((t, n) => {\n        if (r.alwaysValidSchema(o, t)) return;\n        const s = e.subschema({\n          keyword: \"allOf\",\n          schemaProp: n\n        }, i);\n        e.ok(i);\n        e.mergeEvaluated(s);\n      });\n    }\n  };\nexports.default = o;",
  "1133": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.editorVersionHeaders = exports.EditorAndPluginInfo = exports.formatNameAndVersion = exports.getTestVscInfo = exports.VscInfo = exports.getVersion = exports.getBuild = exports.getBuildType = exports.isProduction = exports.BuildInfo = exports.fimSuffixLengthThreshold = exports.suffixMatchThreshold = exports.suffixPercent = exports.getEnabledConfig = exports.getLanguageConfig = exports.dumpConfig = exports.getHiddenConfig = exports.isDefaultSettingOverwritten = exports.getConfig = exports.getConfigDefaultForObjectKey = exports.getConfigDefaultForKey = exports.InMemoryConfigProvider = exports.DefaultsOnlyConfigProvider = exports.ConfigProvider = exports.ConfigBlockModeConfig = exports.BlockModeConfig = exports.BuildType = exports.shouldDoServerTrimming = exports.shouldDoParsingTrimming = exports.BlockMode = exports.ConfigKey = undefined;\nconst r = require(3055),\n  o = require(4197),\n  i = require(9189),\n  s = require(4147);\nvar a, c;\nexports.ConfigKey = {\n  Enable: \"enable\",\n  InlineSuggestEnable: \"inlineSuggest.enable\",\n  ShowEditorCompletions: [\"editor\", \"showEditorCompletions\"],\n  EnableAutoCompletions: [\"editor\", \"enableAutoCompletions\"],\n  DelayCompletions: [\"editor\", \"delayCompletions\"],\n  FilterCompletions: [\"editor\", \"filterCompletions\"],\n  DisplayStyle: [\"advanced\", \"displayStyle\"],\n  SecretKey: [\"advanced\", \"secret_key\"],\n  SolutionLength: [\"advanced\", \"length\"],\n  Stops: [\"advanced\", \"stops\"],\n  Temperature: [\"advanced\", \"temperature\"],\n  TopP: [\"advanced\", \"top_p\"],\n  IndentationMode: [\"advanced\", \"indentationMode\"],\n  InlineSuggestCount: [\"advanced\", \"inlineSuggestCount\"],\n  ListCount: [\"advanced\", \"listCount\"],\n  DebugOverrideProxyUrl: [\"advanced\", \"debug.overrideProxyUrl\"],\n  DebugTestOverrideProxyUrl: [\"advanced\", \"debug.testOverrideProxyUrl\"],\n  DebugOverrideEngine: [\"advanced\", \"debug.overrideEngine\"],\n  DebugShowScores: [\"advanced\", \"debug.showScores\"],\n  DebugOverrideLogLevels: [\"advanced\", \"debug.overrideLogLevels\"],\n  DebugFilterLogCategories: [\"advanced\", \"debug.filterLogCategories\"],\n  DebugUseSuffix: [\"advanced\", \"debug.useSuffix\"]\n};\n(function (e) {\n  e.Parsing = \"parsing\";\n  e.Server = \"server\";\n  e.ParsingAndServer = \"parsingandserver\";\n})(a = exports.BlockMode || (exports.BlockMode = {}));\nexports.shouldDoParsingTrimming = function (e) {\n  return [a.Parsing, a.ParsingAndServer].includes(e);\n};\nexports.shouldDoServerTrimming = function (e) {\n  return [a.Server, a.ParsingAndServer].includes(e);\n};\n(c = exports.BuildType || (exports.BuildType = {})).DEV = \"dev\";\nc.PROD = \"prod\";\nc.NIGHTLY = \"nightly\";\nclass BlockModeConfig {}\nfunction u(e, t) {\n  return e !== a.ParsingAndServer || r.isSupportedLanguageId(t) ? e : a.Server;\n}\nexports.BlockModeConfig = BlockModeConfig;\nexports.ConfigBlockModeConfig = class extends BlockModeConfig {\n  async forLanguage(e, n) {\n    if (e.get(ConfigProvider).isDefaultSettingOverwritten(exports.ConfigKey.IndentationMode)) switch (e.get(ConfigProvider).getLanguageConfig(exports.ConfigKey.IndentationMode, n)) {\n      case \"client\":\n      case !0:\n      case \"server\":\n        return a.Server;\n      case \"clientandserver\":\n        return u(a.ParsingAndServer, n);\n      default:\n        return a.Parsing;\n    }\n    const o = await e.get(i.Features).overrideBlockMode();\n    return o ? u(o, n) : r.isSupportedLanguageId(n) ? a.Parsing : a.Server;\n  }\n};\nclass ConfigProvider {}\nfunction getConfigDefaultForKey(e) {\n  try {\n    const t = s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`].default;\n    if (undefined === t) throw new Error(`Missing config default value: ${o.CopilotConfigPrefix}.${e}`);\n    return t;\n  } catch (t) {\n    throw new Error(`Error inspecting config default value ${o.CopilotConfigPrefix}.${e}: ${t}`);\n  }\n}\nfunction getConfigDefaultForObjectKey(e, t) {\n  try {\n    const n = s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`].properties[t].default;\n    if (undefined === n) throw new Error(`Missing config default value: ${o.CopilotConfigPrefix}.${e}`);\n    return n;\n  } catch (n) {\n    throw new Error(`Error inspecting config default value ${o.CopilotConfigPrefix}.${e}.${t}: ${n}`);\n  }\n}\nfunction getConfig(e, t) {\n  return e.get(ConfigProvider).getConfig(t);\n}\nfunction isDefaultSettingOverwritten(e, t) {\n  return e.get(ConfigProvider).isDefaultSettingOverwritten(t);\n}\nfunction getHiddenConfig(e, t, n) {\n  return isDefaultSettingOverwritten(e, t) ? getConfig(e, t) : n.default;\n}\nfunction getLanguageConfig(e, t, n) {\n  return e.get(ConfigProvider).getLanguageConfig(t, n);\n}\nexports.ConfigProvider = ConfigProvider;\nexports.DefaultsOnlyConfigProvider = class extends ConfigProvider {\n  getConfig(e) {\n    return Array.isArray(e) ? getConfigDefaultForObjectKey(e[0], e[1]) : getConfigDefaultForKey(e);\n  }\n  isDefaultSettingOverwritten(e) {\n    return !1;\n  }\n  dumpConfig() {\n    return {};\n  }\n  getLanguageConfig(e, t) {\n    const n = this.getConfig(e);\n    return t && t in n ? n[t] : n[\"*\"];\n  }\n};\nexports.InMemoryConfigProvider = class {\n  constructor(e, t) {\n    this.baseConfigProvider = e;\n    this.overrides = t;\n  }\n  getConfig(e) {\n    const t = this.overrides.get(e);\n    return undefined !== t ? t : this.baseConfigProvider.getConfig(e);\n  }\n  setConfig(e, t) {\n    undefined !== t ? this.overrides.set(e, t) : this.overrides.delete(e);\n  }\n  setLanguageEnablement(e, n) {\n    this.overrides.set(exports.ConfigKey.Enable, {\n      [e]: n\n    });\n  }\n  isDefaultSettingOverwritten(e) {\n    return !!this.overrides.has(e) || this.baseConfigProvider.isDefaultSettingOverwritten(e);\n  }\n  keyAsString(e) {\n    return Array.isArray(e) ? e.join(\".\") : e;\n  }\n  dumpConfig() {\n    const e = this.baseConfigProvider.dumpConfig();\n    this.overrides.forEach((t, n) => {\n      e[this.keyAsString(n)] = JSON.stringify(t);\n    });\n    return e;\n  }\n  getLanguageConfig(e, t) {\n    const n = this.overrides.get(e);\n    return undefined !== n ? undefined !== t ? n[t] : n[\"*\"] : this.baseConfigProvider.getLanguageConfig(e, t);\n  }\n};\nexports.getConfigDefaultForKey = getConfigDefaultForKey;\nexports.getConfigDefaultForObjectKey = getConfigDefaultForObjectKey;\nexports.getConfig = getConfig;\nexports.isDefaultSettingOverwritten = isDefaultSettingOverwritten;\nexports.getHiddenConfig = getHiddenConfig;\nexports.dumpConfig = function (e) {\n  return e.get(ConfigProvider).dumpConfig();\n};\nexports.getLanguageConfig = getLanguageConfig;\nexports.getEnabledConfig = function (e, n) {\n  return getLanguageConfig(e, exports.ConfigKey.Enable, n);\n};\nexports.suffixPercent = async function (e, n, r) {\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\n    default: !1\n  }) ? 15 : e.get(i.Features).suffixPercent(n, r);\n};\nexports.suffixMatchThreshold = async function (e, n, r) {\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\n    default: !1\n  }) ? 0 : e.get(i.Features).suffixMatchThreshold(n, r);\n};\nexports.fimSuffixLengthThreshold = async function (e, n, r) {\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\n    default: !1\n  }) ? -1 : e.get(i.Features).fimSuffixLengthThreshold(n, r);\n};\nclass BuildInfo {\n  constructor() {\n    this.packageJson = s;\n  }\n  isProduction() {\n    return \"dev\" != this.getBuildType();\n  }\n  getBuildType() {\n    return this.packageJson.buildType;\n  }\n  getVersion() {\n    return this.packageJson.version;\n  }\n  getBuild() {\n    return this.packageJson.build;\n  }\n  getName() {\n    return this.packageJson.name;\n  }\n}\nexports.BuildInfo = BuildInfo;\nexports.isProduction = function (e) {\n  return e.get(BuildInfo).isProduction();\n};\nexports.getBuildType = function (e) {\n  return e.get(BuildInfo).getBuildType();\n};\nexports.getBuild = function (e) {\n  return e.get(BuildInfo).getBuild();\n};\nexports.getVersion = function (e) {\n  return e.get(BuildInfo).getVersion();\n};\nclass VscInfo {\n  constructor(e, t, n) {\n    this.sessionId = e;\n    this.machineId = t;\n    this.vsCodeVersion = n;\n  }\n}\nfunction formatNameAndVersion({\n  name: e,\n  version: t\n}) {\n  return `${e}/${t}`;\n}\nexports.VscInfo = VscInfo;\nexports.getTestVscInfo = function () {\n  return new VscInfo(\"test-session-id\", \"test-machine-id\", \"test-vscode-version\");\n};\nexports.formatNameAndVersion = formatNameAndVersion;\nclass EditorAndPluginInfo {}\nexports.EditorAndPluginInfo = EditorAndPluginInfo;\nexports.editorVersionHeaders = function (e) {\n  const t = e.get(EditorAndPluginInfo);\n  return {\n    \"Editor-Version\": formatNameAndVersion(t.getEditorInfo(e)),\n    \"Editor-Plugin-Version\": formatNameAndVersion(t.getEditorPluginInfo(e))\n  };\n};",
  "1148": "var r, o;\no = require(8249);\nrequire(5109);\n(r = o.lib.BlockCipherMode.extend()).Encryptor = r.extend({\n  processBlock: function (e, t) {\n    this._cipher.encryptBlock(e, t);\n  }\n});\nr.Decryptor = r.extend({\n  processBlock: function (e, t) {\n    this._cipher.decryptBlock(e, t);\n  }\n});\no.mode.ECB = r;\nmodule.exports = o.mode.ECB;",
  "1188": "var r = require(2728);\nfunction H() {\n  this._array = [];\n  this._sorted = !0;\n  this._last = {\n    generatedLine: -1,\n    generatedColumn: 0\n  };\n}\nH.prototype.unsortedForEach = function (e, t) {\n  this._array.forEach(e, t);\n};\nH.prototype.add = function (e) {\n  var t, n, o, i, s, a;\n  n = e;\n  o = (t = this._last).generatedLine;\n  i = n.generatedLine;\n  s = t.generatedColumn;\n  a = n.generatedColumn;\n  i > o || i == o && a >= s || r.compareByGeneratedPositionsInflated(t, n) <= 0 ? (this._last = e, this._array.push(e)) : (this._sorted = !1, this._array.push(e));\n};\nH.prototype.toArray = function () {\n  this._sorted || (this._array.sort(r.compareByGeneratedPositionsInflated), this._sorted = !0);\n  return this._array;\n};\nexports.H = H;",
  "1227": "var r = require(4953),\n  o = [];\nexports.qP = function (e) {\n  o.forEach(function (t) {\n    var n = e.data.query,\n      r = n.preparable && n.preparable.text || n.plan || n.text || \"unknown query\",\n      o = !e.data.error,\n      i = e.data.database.host + \":\" + e.data.database.port;\n    t.trackDependency({\n      target: i,\n      data: r,\n      name: r,\n      duration: e.data.duration,\n      success: o,\n      resultCode: o ? \"0\" : \"1\",\n      dependencyTypeName: \"postgres\"\n    });\n  });\n};\nexports.wp = function (e, n) {\n  e ? (0 === o.length && r.channel.subscribe(\"postgres\", exports.qP), o.push(n)) : 0 === (o = o.filter(function (e) {\n    return e != n;\n  })).length && r.channel.unsubscribe(\"postgres\", exports.qP);\n};",
  "1240": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(9306),\n  i = {\n    keyword: \"discriminator\",\n    type: \"object\",\n    schemaType: \"object\",\n    error: {\n      message: ({\n        params: {\n          discrError: e,\n          tagName: t\n        }\n      }) => e === o.DiscrError.Tag ? `tag \"${t}\" must be string` : `value of tag \"${t}\" must be in oneOf`,\n      params: ({\n        params: {\n          discrError: e,\n          tag: t,\n          tagName: n\n        }\n      }) => r._`{error: ${e}, tag: ${n}, tagValue: ${t}}`\n    },\n    code(e) {\n      const {\n          gen: t,\n          data: n,\n          schema: i,\n          parentSchema: s,\n          it: a\n        } = e,\n        {\n          oneOf: c\n        } = s;\n      if (!a.opts.discriminator) throw new Error(\"discriminator: requires discriminator option\");\n      const l = i.propertyName;\n      if (\"string\" != typeof l) throw new Error(\"discriminator: requires propertyName\");\n      if (i.mapping) throw new Error(\"discriminator: mapping is not supported\");\n      if (!c) throw new Error(\"discriminator: requires oneOf keyword\");\n      const u = t.let(\"valid\", !1),\n        d = t.const(\"tag\", r._`${n}${r.getProperty(l)}`);\n      function p(n) {\n        const o = t.name(\"valid\"),\n          i = e.subschema({\n            keyword: \"oneOf\",\n            schemaProp: n\n          }, o);\n        e.mergeEvaluated(i, r.Name);\n        return o;\n      }\n      t.if(r._`typeof ${d} == \"string\"`, () => function () {\n        const n = function () {\n          var e;\n          const t = {},\n            n = o(s);\n          let r = !0;\n          for (let t = 0; t < c.length; t++) {\n            const s = c[t],\n              a = null === (e = s.properties) || undefined === e ? undefined : e[l];\n            if (\"object\" != typeof a) throw new Error(`discriminator: oneOf schemas must have \"properties/${l}\"`);\n            r = r && (n || o(s));\n            i(a, t);\n          }\n          if (!r) throw new Error(`discriminator: \"${l}\" must be required`);\n          return t;\n          function o({\n            required: e\n          }) {\n            return Array.isArray(e) && e.includes(l);\n          }\n          function i(e, t) {\n            if (e.const) a(e.const, t);else {\n              if (!e.enum) throw new Error(`discriminator: \"properties/${l}\" must have \"const\" or \"enum\"`);\n              for (const n of e.enum) a(n, t);\n            }\n          }\n          function a(e, n) {\n            if (\"string\" != typeof e || e in t) throw new Error(`discriminator: \"${l}\" values must be unique strings`);\n            t[e] = n;\n          }\n        }();\n        t.if(!1);\n        for (const e in n) {\n          t.elseIf(r._`${d} === ${e}`);\n          t.assign(u, p(n[e]));\n        }\n        t.else();\n        e.error(!1, {\n          discrError: o.DiscrError.Mapping,\n          tag: d,\n          tagName: l\n        });\n        t.endIf();\n      }(), () => e.error(!1, {\n        discrError: o.DiscrError.Tag,\n        tag: d,\n        tagName: l\n      }));\n      e.ok(u);\n    }\n  };\nexports.default = i;",
  "1259": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = require(7625),\n  s = require(731),\n  a = require(8723),\n  c = require(5282),\n  l = function (e) {\n    function t() {\n      return null !== e && e.apply(this, arguments) || this;\n    }\n    o(t, e);\n    t.prototype.trackNodeHttpRequestSync = function (e) {\n      e && e.request && e.response && e.duration ? s.trackRequestSync(this, e) : c.warn(\"trackNodeHttpRequestSync requires NodeHttpRequestTelemetry object with request, response and duration specified.\");\n    };\n    t.prototype.trackNodeHttpRequest = function (e) {\n      (e.duration || e.error) && c.warn(\"trackNodeHttpRequest will ignore supplied duration and error parameters. These values are collected from the request and response objects.\");\n      e && e.request && e.response ? s.trackRequest(this, e) : c.warn(\"trackNodeHttpRequest requires NodeHttpRequestTelemetry object with request and response specified.\");\n    };\n    t.prototype.trackNodeHttpDependency = function (e) {\n      e && e.request ? a.trackRequest(this, e) : c.warn(\"trackNodeHttpDependency requires NodeHttpDependencyTelemetry object with request specified.\");\n    };\n    return t;\n  }(i);\nmodule.exports = l;",
  "1267": "module.exports = require(\"worker_threads\");",
  "1354": "var r;\nr = require(8249);\nrequire(4938);\nrequire(2422);\nrequire(298);\nrequire(8269);\nrequire(8214);\nrequire(2783);\nrequire(2153);\nrequire(7792);\nrequire(34);\nrequire(7460);\nrequire(3327);\nrequire(706);\nrequire(9824);\nrequire(2112);\nrequire(888);\nrequire(5109);\nrequire(8568);\nrequire(4242);\nrequire(9968);\nrequire(7660);\nrequire(1148);\nrequire(3615);\nrequire(2807);\nrequire(1077);\nrequire(6475);\nrequire(6991);\nrequire(2209);\nrequire(452);\nrequire(4253);\nrequire(1857);\nrequire(4454);\nrequire(3974);\nmodule.exports = r;",
  "1547": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.NotificationSender = undefined;\nexports.NotificationSender = class {};",
  "1581": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;\nconst r = require(7159),\n  o = require(3924),\n  i = require(1240),\n  s = require(98),\n  a = [\"/properties\"],\n  c = \"http://json-schema.org/draft-07/schema\";\nclass l extends r.default {\n  _addVocabularies() {\n    super._addVocabularies();\n    o.default.forEach(e => this.addVocabulary(e));\n    this.opts.discriminator && this.addKeyword(i.default);\n  }\n  _addDefaultMetaSchema() {\n    super._addDefaultMetaSchema();\n    if (!this.opts.meta) return;\n    const e = this.opts.$data ? this.$dataMetaSchema(s, a) : s;\n    this.addMetaSchema(e, c, !1);\n    this.refs[\"http://json-schema.org/schema\"] = c;\n  }\n  defaultMeta() {\n    return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(c) ? c : undefined);\n  }\n}\nmodule.exports = exports = l;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.default = l;\nvar u = require(4815);\nexports.KeywordCxt = u.KeywordCxt;\nvar d = require(3487);\nexports._ = d._;\nexports.str = d.str;\nexports.stringify = d.stringify;\nexports.nil = d.nil;\nexports.Name = d.Name;\nexports.CodeGen = d.CodeGen;",
  "1595": "const r = require(7147);\nlet o;\nmodule.exports = () => (undefined === o && (o = function () {\n  try {\n    r.statSync(\"/.dockerenv\");\n    return !0;\n  } catch (e) {\n    return !1;\n  }\n}() || function () {\n  try {\n    return r.readFileSync(\"/proc/self/cgroup\", \"utf8\").includes(\"docker\");\n  } catch (e) {\n    return !1;\n  }\n}()), o);",
  "1629": "var r = this && this.__assign || Object.assign || function (e) {\n  for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n  return e;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar o = require(9253),\n  i = require(4470),\n  s = require(5282),\n  AutoCollectNativePerformance = function () {\n    function e(t) {\n      this._disabledMetrics = {};\n      e.INSTANCE && e.INSTANCE.dispose();\n      e.INSTANCE = this;\n      this._client = t;\n    }\n    e.isNodeVersionCompatible = function () {\n      var e = process.versions.node.split(\".\");\n      return parseInt(e[0]) >= 6;\n    };\n    e.prototype.enable = function (t, r, o) {\n      var i = this;\n      undefined === r && (r = {});\n      undefined === o && (o = 6e4);\n      if (e.isNodeVersionCompatible()) {\n        if (null == e._metricsAvailable && t && !this._isInitialized) try {\n          var a = require(9166);\n          e._emitter = new a(), e._metricsAvailable = !0, s.info(\"Native metrics module successfully loaded!\");\n        } catch (t) {\n          return void (e._metricsAvailable = !1);\n        }\n        this._isEnabled = t, this._disabledMetrics = r, this._isEnabled && !this._isInitialized && (this._isInitialized = !0), this._isEnabled && e._emitter ? (e._emitter.enable(!0, o), this._handle = setInterval(function () {\n          return i._trackNativeMetrics();\n        }, o), this._handle.unref()) : e._emitter && (e._emitter.enable(!1), this._handle && (clearInterval(this._handle), this._handle = void 0));\n      }\n    };\n    e.prototype.dispose = function () {\n      this.enable(!1);\n    };\n    e.parseEnabled = function (e) {\n      var t = process.env[o.ENV_nativeMetricsDisableAll],\n        n = process.env[o.ENV_nativeMetricsDisablers];\n      if (t) return {\n        isEnabled: !1,\n        disabledMetrics: {}\n      };\n      if (n) {\n        var i = n.split(\",\"),\n          s = {};\n        if (i.length > 0) for (var a = 0, c = i; a < c.length; a++) s[c[a]] = !0;\n        return \"object\" == typeof e ? {\n          isEnabled: !0,\n          disabledMetrics: r({}, e, s)\n        } : {\n          isEnabled: e,\n          disabledMetrics: s\n        };\n      }\n      return \"boolean\" == typeof e ? {\n        isEnabled: e,\n        disabledMetrics: {}\n      } : {\n        isEnabled: !0,\n        disabledMetrics: e\n      };\n    };\n    e.prototype._trackNativeMetrics = function () {\n      var e = !0;\n      \"object\" != typeof this._isEnabled && (e = this._isEnabled);\n      e && (this._trackGarbageCollection(), this._trackEventLoop(), this._trackHeapUsage());\n    };\n    e.prototype._trackGarbageCollection = function () {\n      if (!this._disabledMetrics.gc) {\n        var t,\n          n = e._emitter.getGCData();\n        for (var r in n) {\n          var o = n[r].metrics,\n            s = r + \" Garbage Collection Duration\",\n            a = Math.sqrt(o.sumSquares / o.count - Math.pow(o.total / o.count, 2)) || 0;\n          this._client.trackMetric({\n            name: s,\n            value: o.total,\n            count: o.count,\n            max: o.max,\n            min: o.min,\n            stdDev: a,\n            tagOverrides: (t = {}, t[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + i.sdkVersion, t)\n          });\n        }\n      }\n    };\n    e.prototype._trackEventLoop = function () {\n      if (!this._disabledMetrics.loop) {\n        var t = e._emitter.getLoopData().loopUsage;\n        if (0 != t.count) {\n          var n,\n            r = Math.sqrt(t.sumSquares / t.count - Math.pow(t.total / t.count, 2)) || 0;\n          this._client.trackMetric({\n            name: \"Event Loop CPU Time\",\n            value: t.total,\n            count: t.count,\n            min: t.min,\n            max: t.max,\n            stdDev: r,\n            tagOverrides: (n = {}, n[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + i.sdkVersion, n)\n          });\n        }\n      }\n    };\n    e.prototype._trackHeapUsage = function () {\n      if (!this._disabledMetrics.heap) {\n        var e,\n          t,\n          n,\n          r = process.memoryUsage(),\n          o = r.heapUsed,\n          s = r.heapTotal,\n          a = r.rss;\n        this._client.trackMetric({\n          name: \"Memory Usage (Heap)\",\n          value: o,\n          count: 1,\n          tagOverrides: (e = {}, e[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + i.sdkVersion, e)\n        });\n        this._client.trackMetric({\n          name: \"Memory Total (Heap)\",\n          value: s,\n          count: 1,\n          tagOverrides: (t = {}, t[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + i.sdkVersion, t)\n        });\n        this._client.trackMetric({\n          name: \"Memory Usage (Non-Heap)\",\n          value: a - s,\n          count: 1,\n          tagOverrides: (n = {}, n[this._client.context.keys.internalSdkVersion] = \"node-nativeperf:\" + i.sdkVersion, n)\n        });\n      }\n    };\n    return e;\n  }();\nexports.AutoCollectNativePerformance = AutoCollectNativePerformance;",
  "1687": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = {\n    keyword: [\"maxItems\", \"minItems\"],\n    type: \"array\",\n    schemaType: \"number\",\n    $data: !0,\n    error: {\n      message({\n        keyword: e,\n        schemaCode: t\n      }) {\n        const n = \"maxItems\" === e ? \"more\" : \"fewer\";\n        return r.str`must NOT have ${n} than ${t} items`;\n      },\n      params: ({\n        schemaCode: e\n      }) => r._`{limit: ${e}}`\n    },\n    code(e) {\n      const {\n          keyword: t,\n          data: n,\n          schemaCode: o\n        } = e,\n        i = \"maxItems\" === t ? r.operators.GT : r.operators.LT;\n      e.fail$data(r._`${n}.length ${i} ${o}`);\n    }\n  };\nexports.default = o;",
  "1747": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getPrompt = exports.newLineEnded = exports.normalizeLanguageId = exports.PromptOptions = exports.SuffixStartMode = exports.SuffixMatchOption = exports.SuffixOption = exports.LineEndingOptions = exports.LocalImportContextOption = exports.SnippetSelectionOption = exports.NeighboringTabsPositionOption = exports.NeighboringTabsOption = exports.SiblingOption = exports.PathMarkerOption = exports.LanguageMarkerOption = exports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = exports.MAX_EDIT_DISTANCE_LENGTH = exports.MAX_PROMPT_LENGTH = undefined;\nconst r = require(1788),\n  o = require(3507),\n  i = require(9931),\n  s = require(820),\n  a = require(9852),\n  c = require(7408),\n  l = require(4431);\nlet u = {\n  text: \"\",\n  tokens: []\n};\nvar d, p, h, f, m, g, _, y, v, b, w;\nexports.MAX_PROMPT_LENGTH = 1500;\nexports.MAX_EDIT_DISTANCE_LENGTH = 50;\nexports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5;\n(function (e) {\n  e.NoMarker = \"nomarker\";\n  e.Top = \"top\";\n  e.Always = \"always\";\n})(d = exports.LanguageMarkerOption || (exports.LanguageMarkerOption = {}));\n(function (e) {\n  e.NoMarker = \"nomarker\";\n  e.Top = \"top\";\n  e.Always = \"always\";\n})(p = exports.PathMarkerOption || (exports.PathMarkerOption = {}));\n(function (e) {\n  e.NoSiblings = \"nosiblings\";\n  e.SiblingsOverContext = \"siblingabove\";\n  e.ContextOverSiblings = \"contextabove\";\n})(h = exports.SiblingOption || (exports.SiblingOption = {}));\n(function (e) {\n  e.None = \"none\";\n  e.Conservative = \"conservative\";\n  e.Medium = \"medium\";\n  e.Eager = \"eager\";\n  e.EagerButLittle = \"eagerButLittle\";\n})(f = exports.NeighboringTabsOption || (exports.NeighboringTabsOption = {}));\n(function (e) {\n  e.TopOfText = \"top\";\n  e.DirectlyAboveCursor = \"aboveCursor\";\n  e.AfterSiblings = \"afterSiblings\";\n})(m = exports.NeighboringTabsPositionOption || (exports.NeighboringTabsPositionOption = {}));\n(function (e) {\n  e.BestMatch = \"bestMatch\";\n  e.TopK = \"topK\";\n})(g = exports.SnippetSelectionOption || (exports.SnippetSelectionOption = {}));\n(function (e) {\n  e.NoContext = \"nocontext\";\n  e.Declarations = \"declarations\";\n})(_ = exports.LocalImportContextOption || (exports.LocalImportContextOption = {}));\n(function (e) {\n  e.ConvertToUnix = \"unix\";\n  e.KeepOriginal = \"keep\";\n})(y = exports.LineEndingOptions || (exports.LineEndingOptions = {}));\n(w = exports.SuffixOption || (exports.SuffixOption = {})).None = \"none\";\nw.FifteenPercent = \"fifteenPercent\";\n(function (e) {\n  e.Equal = \"equal\";\n  e.Levenshtein = \"levenshteineditdistance\";\n})(v = exports.SuffixMatchOption || (exports.SuffixMatchOption = {}));\n(function (e) {\n  e.Cursor = \"cursor\";\n  e.CursorTrimStart = \"cursortrimstart\";\n  e.SiblingBlock = \"siblingblock\";\n  e.SiblingBlockTrimStart = \"siblingblocktrimstart\";\n})(b = exports.SuffixStartMode || (exports.SuffixStartMode = {}));\nclass PromptOptions {\n  constructor(e, n) {\n    this.fs = e;\n    this.maxPromptLength = exports.MAX_PROMPT_LENGTH;\n    this.languageMarker = d.Top;\n    this.pathMarker = p.Top;\n    this.includeSiblingFunctions = h.ContextOverSiblings;\n    this.localImportContext = _.Declarations;\n    this.neighboringTabs = f.Eager;\n    this.neighboringTabsPosition = m.TopOfText;\n    this.lineEnding = y.ConvertToUnix;\n    this.suffixPercent = 0;\n    this.suffixStartMode = b.Cursor;\n    this.suffixMatchThreshold = 0;\n    this.suffixMatchCriteria = v.Levenshtein;\n    this.fimSuffixLengthThreshold = 0;\n    if (n) for (const e in n) this[e] = n[e];\n    if (this.suffixPercent < 0 || this.suffixPercent > 100) throw new Error(`suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`);\n    if (this.suffixPercent > 0 && this.includeSiblingFunctions != h.NoSiblings) throw new Error(`Invalid option combination. Cannot set suffixPercent > 0 (${this.suffixPercent}) and includeSiblingFunctions ${this.includeSiblingFunctions}`);\n    if (this.suffixMatchThreshold < 0 || this.suffixMatchThreshold > 100) throw new Error(`suffixMatchThreshold must be at between 0 and 100, but was ${this.suffixMatchThreshold}`);\n    if (this.fimSuffixLengthThreshold < -1) throw new Error(`fimSuffixLengthThreshold must be at least -1, but was ${this.fimSuffixLengthThreshold}`);\n    if (null != this.indentationMinLength && null != this.indentationMaxLength && this.indentationMinLength > this.indentationMaxLength) throw new Error(`indentationMinLength must be less than or equal to indentationMaxLength, but was ${this.indentationMinLength} and ${this.indentationMaxLength}`);\n    if (this.snippetSelection === g.TopK && undefined === this.snippetSelectionK) throw new Error(\"snippetSelectionK must be defined.\");\n    if (this.snippetSelection === g.TopK && this.snippetSelectionK && this.snippetSelectionK <= 0) throw new Error(`snippetSelectionK must be greater than 0, but was ${this.snippetSelectionK}`);\n  }\n}\nexports.PromptOptions = PromptOptions;\nconst E = {\n  javascriptreact: \"javascript\",\n  jsx: \"javascript\",\n  typescriptreact: \"typescript\",\n  jade: \"pug\",\n  cshtml: \"razor\"\n};\nfunction normalizeLanguageId(e) {\n  var t;\n  e = e.toLowerCase();\n  return null !== (t = E[e]) && undefined !== t ? t : e;\n}\nfunction newLineEnded(e) {\n  return \"\" == e || e.endsWith(\"\\n\") ? e : e + \"\\n\";\n}\nexports.normalizeLanguageId = normalizeLanguageId;\nexports.newLineEnded = newLineEnded;\nexports.getPrompt = async function (e, n, g = {}, y = []) {\n  var w;\n  const E = new PromptOptions(e, g);\n  let T = !1;\n  const {\n    source: k,\n    offset: I\n  } = n;\n  if (I < 0 || I > k.length) throw new Error(`Offset ${I} is out of range.`);\n  n.languageId = normalizeLanguageId(n.languageId);\n  const P = new c.Priorities(),\n    A = P.justBelow(c.Priorities.TOP),\n    O = E.languageMarker == d.Always ? P.justBelow(c.Priorities.TOP) : P.justBelow(A),\n    N = E.pathMarker == p.Always ? P.justBelow(c.Priorities.TOP) : P.justBelow(A),\n    R = E.includeSiblingFunctions == h.ContextOverSiblings ? P.justBelow(A) : P.justAbove(A),\n    M = P.justBelow(A, R),\n    L = P.justBelow(M),\n    $ = new c.PromptWishlist(E.lineEnding);\n  let D, F;\n  if (E.languageMarker != d.NoMarker) {\n    const e = newLineEnded(r.getLanguageMarker(n));\n    D = $.append(e, c.PromptElementKind.LanguageMarker, O);\n  }\n  if (E.pathMarker != p.NoMarker) {\n    const e = newLineEnded(r.getPathMarker(n));\n    e.length > 0 && (F = $.append(e, c.PromptElementKind.PathMarker, N));\n  }\n  if (E.localImportContext != _.NoContext) for (const e of await o.extractLocalImportContext(n, E.fs)) $.append(newLineEnded(e), c.PromptElementKind.ImportedFile, M);\n  const j = E.neighboringTabs == f.None || 0 == y.length ? [] : await i.getNeighborSnippets(n, y, E.neighboringTabs, E.indentationMinLength, E.indentationMaxLength, E.snippetSelectionOption, E.snippetSelectionK);\n  function q() {\n    j.forEach(e => $.append(e.snippet, c.PromptElementKind.SimilarFile, L, a.tokenLength(e.snippet), e.score));\n  }\n  E.neighboringTabsPosition == m.TopOfText && q();\n  const B = [];\n  let U;\n  if (E.includeSiblingFunctions == h.NoSiblings) U = k.substring(0, I);else {\n    const {\n      siblings: e,\n      beforeInsertion: t,\n      afterInsertion: r\n    } = await s.getSiblingFunctions(n);\n    $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach(e => B.push(e));\n    let o = R;\n    e.forEach(e => {\n      $.append(e, c.PromptElementKind.AfterCursor, o);\n      o = P.justBelow(o);\n    });\n    E.neighboringTabsPosition == m.AfterSiblings && q();\n    U = r;\n  }\n  if (E.neighboringTabsPosition == m.DirectlyAboveCursor) {\n    const e = U.lastIndexOf(\"\\n\") + 1,\n      t = U.substring(0, e),\n      n = U.substring(e);\n    $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach(e => B.push(e));\n    q();\n    n.length > 0 && (B.push($.append(n, c.PromptElementKind.AfterCursor, A)), B.length > 1 && $.require(B[B.length - 2], B[B.length - 1]));\n  } else $.appendLineForLine(U, c.PromptElementKind.BeforeCursor, A).forEach(e => B.push(e));\n  d.Top == E.languageMarker && B.length > 0 && undefined !== D && $.require(D, B[0]);\n  p.Top == E.pathMarker && B.length > 0 && undefined !== F && (D ? $.require(F, D) : $.require(F, B[0]));\n  undefined !== D && undefined !== F && $.exclude(F, D);\n  let H = k.slice(I);\n  if (0 == E.suffixPercent || H.length <= E.fimSuffixLengthThreshold) return $.fulfill(E.maxPromptLength);\n  {\n    let e = n.offset;\n    E.suffixStartMode !== b.Cursor && E.suffixStartMode !== b.CursorTrimStart && (e = await s.getSiblingFunctionStart(n));\n    const r = E.maxPromptLength - exports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING;\n    let o = Math.floor(r * (100 - E.suffixPercent) / 100),\n      i = $.fulfill(o);\n    const c = r - i.prefixLength;\n    let d = k.slice(e);\n    E.suffixStartMode != b.SiblingBlockTrimStart && E.suffixStartMode != b.CursorTrimStart || (d = d.trimStart());\n    const p = a.takeFirstTokens(d, c);\n    p.tokens.length <= c - 3 && (o = r - p.tokens.length, i = $.fulfill(o));\n    E.suffixMatchCriteria == v.Equal ? p.tokens.length === u.tokens.length && p.tokens.every((e, t) => e === u.tokens[t]) && (T = !0) : E.suffixMatchCriteria == v.Levenshtein && p.tokens.length > 0 && E.suffixMatchThreshold > 0 && 100 * (null === (w = l.findEditDistanceScore(p.tokens.slice(0, exports.MAX_EDIT_DISTANCE_LENGTH), u.tokens.slice(0, exports.MAX_EDIT_DISTANCE_LENGTH))) || undefined === w ? undefined : w.score) < E.suffixMatchThreshold * Math.min(exports.MAX_EDIT_DISTANCE_LENGTH, p.tokens.length) && (T = !0);\n    !0 === T && u.tokens.length <= c ? (u.tokens.length <= c - 3 && (o = r - u.tokens.length, i = $.fulfill(o)), i.suffix = u.text, i.suffixLength = u.tokens.length) : (i.suffix = p.text, i.suffixLength = p.tokens.length, u = p);\n    return i;\n  }\n};",
  "1758": "exports.formatArgs = function (t) {\n  t[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + t[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + module.exports.humanize(this.diff);\n  if (!this.useColors) return;\n  const n = \"color: \" + this.color;\n  t.splice(1, 0, n, \"color: inherit\");\n  let r = 0,\n    o = 0;\n  t[0].replace(/%[a-zA-Z%]/g, e => {\n    \"%%\" !== e && (r++, \"%c\" === e && (o = r));\n  });\n  t.splice(o, 0, n);\n};\nexports.save = function (e) {\n  try {\n    e ? exports.storage.setItem(\"debug\", e) : exports.storage.removeItem(\"debug\");\n  } catch (e) {}\n};\nexports.load = function () {\n  let e;\n  try {\n    e = exports.storage.getItem(\"debug\");\n  } catch (e) {}\n  !e && \"undefined\" != typeof process && \"env\" in process && (e = process.env.DEBUG);\n  return e;\n};\nexports.useColors = function () {\n  return !(\"undefined\" == typeof window || !window.process || \"renderer\" !== window.process.type && !window.process.__nwjs) || (\"undefined\" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) && (\"undefined\" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || \"undefined\" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || \"undefined\" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || \"undefined\" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n};\nexports.storage = function () {\n  try {\n    return localStorage;\n  } catch (e) {}\n}();\nexports.destroy = (() => {\n  let e = !1;\n  return () => {\n    e || (e = !0, console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"));\n  };\n})();\nexports.colors = [\"#0000CC\", \"#0000FF\", \"#0033CC\", \"#0033FF\", \"#0066CC\", \"#0066FF\", \"#0099CC\", \"#0099FF\", \"#00CC00\", \"#00CC33\", \"#00CC66\", \"#00CC99\", \"#00CCCC\", \"#00CCFF\", \"#3300CC\", \"#3300FF\", \"#3333CC\", \"#3333FF\", \"#3366CC\", \"#3366FF\", \"#3399CC\", \"#3399FF\", \"#33CC00\", \"#33CC33\", \"#33CC66\", \"#33CC99\", \"#33CCCC\", \"#33CCFF\", \"#6600CC\", \"#6600FF\", \"#6633CC\", \"#6633FF\", \"#66CC00\", \"#66CC33\", \"#9900CC\", \"#9900FF\", \"#9933CC\", \"#9933FF\", \"#99CC00\", \"#99CC33\", \"#CC0000\", \"#CC0033\", \"#CC0066\", \"#CC0099\", \"#CC00CC\", \"#CC00FF\", \"#CC3300\", \"#CC3333\", \"#CC3366\", \"#CC3399\", \"#CC33CC\", \"#CC33FF\", \"#CC6600\", \"#CC6633\", \"#CC9900\", \"#CC9933\", \"#CCCC00\", \"#CCCC33\", \"#FF0000\", \"#FF0033\", \"#FF0066\", \"#FF0099\", \"#FF00CC\", \"#FF00FF\", \"#FF3300\", \"#FF3333\", \"#FF3366\", \"#FF3399\", \"#FF33CC\", \"#FF33FF\", \"#FF6600\", \"#FF6633\", \"#FF9900\", \"#FF9933\", \"#FFCC00\", \"#FFCC33\"];\nexports.log = console.debug || console.log || (() => {});\nmodule.exports = require(2447)(exports);\nconst {\n  formatters: r\n} = module.exports;\nr.j = function (e) {\n  try {\n    return JSON.stringify(e);\n  } catch (e) {\n    return \"[UnexpectedJSONParseError]: \" + e.message;\n  }\n};",
  "1787": "class t extends Error {\n  get name() {\n    return this.constructor.name;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nmodule.exports = {\n  RequestAbortedError: t\n};",
  "1788": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getPathMarker = exports.getLanguageMarker = exports.comment = exports.hasLanguageMarker = exports.languageCommentMarkers = undefined;\nexports.languageCommentMarkers = {\n  abap: {\n    start: '\"',\n    end: \"\"\n  },\n  bat: {\n    start: \"REM\",\n    end: \"\"\n  },\n  bibtex: {\n    start: \"%\",\n    end: \"\"\n  },\n  blade: {\n    start: \"#\",\n    end: \"\"\n  },\n  c: {\n    start: \"//\",\n    end: \"\"\n  },\n  clojure: {\n    start: \";\",\n    end: \"\"\n  },\n  coffeescript: {\n    start: \"//\",\n    end: \"\"\n  },\n  cpp: {\n    start: \"//\",\n    end: \"\"\n  },\n  csharp: {\n    start: \"//\",\n    end: \"\"\n  },\n  css: {\n    start: \"/*\",\n    end: \"*/\"\n  },\n  dart: {\n    start: \"//\",\n    end: \"\"\n  },\n  dockerfile: {\n    start: \"#\",\n    end: \"\"\n  },\n  elixir: {\n    start: \"#\",\n    end: \"\"\n  },\n  erb: {\n    start: \"<%#\",\n    end: \"%>\"\n  },\n  erlang: {\n    start: \"%\",\n    end: \"\"\n  },\n  fsharp: {\n    start: \"//\",\n    end: \"\"\n  },\n  go: {\n    start: \"//\",\n    end: \"\"\n  },\n  groovy: {\n    start: \"//\",\n    end: \"\"\n  },\n  haml: {\n    start: \"-#\",\n    end: \"\"\n  },\n  handlebars: {\n    start: \"{{!\",\n    end: \"}}\"\n  },\n  haskell: {\n    start: \"--\",\n    end: \"\"\n  },\n  html: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\"\n  },\n  ini: {\n    start: \";\",\n    end: \"\"\n  },\n  java: {\n    start: \"//\",\n    end: \"\"\n  },\n  javascript: {\n    start: \"//\",\n    end: \"\"\n  },\n  javascriptreact: {\n    start: \"//\",\n    end: \"\"\n  },\n  jsonc: {\n    start: \"//\",\n    end: \"\"\n  },\n  jsx: {\n    start: \"//\",\n    end: \"\"\n  },\n  julia: {\n    start: \"#\",\n    end: \"\"\n  },\n  kotlin: {\n    start: \"//\",\n    end: \"\"\n  },\n  latex: {\n    start: \"%\",\n    end: \"\"\n  },\n  less: {\n    start: \"//\",\n    end: \"\"\n  },\n  lua: {\n    start: \"--\",\n    end: \"\"\n  },\n  makefile: {\n    start: \"#\",\n    end: \"\"\n  },\n  markdown: {\n    start: \"[]: #\",\n    end: \"\"\n  },\n  \"objective-c\": {\n    start: \"//\",\n    end: \"\"\n  },\n  \"objective-cpp\": {\n    start: \"//\",\n    end: \"\"\n  },\n  perl: {\n    start: \"#\",\n    end: \"\"\n  },\n  php: {\n    start: \"//\",\n    end: \"\"\n  },\n  powershell: {\n    start: \"#\",\n    end: \"\"\n  },\n  pug: {\n    start: \"//\",\n    end: \"\"\n  },\n  python: {\n    start: \"#\",\n    end: \"\"\n  },\n  ql: {\n    start: \"//\",\n    end: \"\"\n  },\n  r: {\n    start: \"#\",\n    end: \"\"\n  },\n  razor: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\"\n  },\n  ruby: {\n    start: \"#\",\n    end: \"\"\n  },\n  rust: {\n    start: \"//\",\n    end: \"\"\n  },\n  sass: {\n    start: \"//\",\n    end: \"\"\n  },\n  scala: {\n    start: \"//\",\n    end: \"\"\n  },\n  scss: {\n    start: \"//\",\n    end: \"\"\n  },\n  shellscript: {\n    start: \"#\",\n    end: \"\"\n  },\n  slim: {\n    start: \"/\",\n    end: \"\"\n  },\n  solidity: {\n    start: \"//\",\n    end: \"\"\n  },\n  sql: {\n    start: \"--\",\n    end: \"\"\n  },\n  stylus: {\n    start: \"//\",\n    end: \"\"\n  },\n  svelte: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\"\n  },\n  swift: {\n    start: \"//\",\n    end: \"\"\n  },\n  terraform: {\n    start: \"#\",\n    end: \"\"\n  },\n  tex: {\n    start: \"%\",\n    end: \"\"\n  },\n  typescript: {\n    start: \"//\",\n    end: \"\"\n  },\n  typescriptreact: {\n    start: \"//\",\n    end: \"\"\n  },\n  vb: {\n    start: \"'\",\n    end: \"\"\n  },\n  verilog: {\n    start: \"//\",\n    end: \"\"\n  },\n  \"vue-html\": {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\"\n  },\n  vue: {\n    start: \"//\",\n    end: \"\"\n  },\n  xml: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\"\n  },\n  xsl: {\n    start: \"\\x3c!--\",\n    end: \"--\\x3e\"\n  },\n  yaml: {\n    start: \"#\",\n    end: \"\"\n  }\n};\nconst n = [\"php\", \"plaintext\"],\n  r = {\n    html: \"<!DOCTYPE html>\",\n    python: \"#!/usr/bin/env python3\",\n    ruby: \"#!/usr/bin/env ruby\",\n    shellscript: \"#!/bin/sh\",\n    yaml: \"# YAML data\"\n  };\nfunction hasLanguageMarker({\n  source: e\n}) {\n  return e.startsWith(\"#!\") || e.startsWith(\"<!DOCTYPE\");\n}\nfunction comment(e, n) {\n  const r = exports.languageCommentMarkers[n];\n  if (r) {\n    const t = \"\" == r.end ? \"\" : \" \" + r.end;\n    return `${r.start} ${e}${t}`;\n  }\n  return \"\";\n}\nexports.hasLanguageMarker = hasLanguageMarker;\nexports.comment = comment;\nexports.getLanguageMarker = function (e) {\n  const {\n    languageId: t\n  } = e;\n  return -1 !== n.indexOf(t) || hasLanguageMarker(e) ? \"\" : t in r ? r[t] : comment(`Language: ${t}`, t);\n};\nexports.getPathMarker = function (e) {\n  return e.relativePath ? comment(`Path: ${e.relativePath}`, e.languageId) : \"\";\n};",
  "1808": "module.exports = require(\"net\");",
  "1839": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.registerDocumentTracker = exports.sortByAccessTimes = undefined;\nconst r = require(3136),\n  o = new Map();\nexports.sortByAccessTimes = function (e) {\n  return [...e].sort((e, t) => {\n    var n, r;\n    const i = null !== (n = o.get(e.uri.toString())) && undefined !== n ? n : 0;\n    return (null !== (r = o.get(t.uri.toString())) && undefined !== r ? r : 0) - i;\n  });\n};\nexports.registerDocumentTracker = e => e.get(r.TextDocumentManager).onDidFocusTextDocument(e => {\n  e && o.set(e.document.uri.toString(), Date.now());\n});",
  "1857": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib.StreamCipher,\n    n = e.algo,\n    o = n.RC4 = t.extend({\n      _doReset: function () {\n        for (var e = this._key, t = e.words, n = e.sigBytes, r = this._S = [], o = 0; o < 256; o++) r[o] = o;\n        o = 0;\n        for (var i = 0; o < 256; o++) {\n          var s = o % n,\n            a = t[s >>> 2] >>> 24 - s % 4 * 8 & 255;\n          i = (i + r[o] + a) % 256;\n          var c = r[o];\n          r[o] = r[i];\n          r[i] = c;\n        }\n        this._i = this._j = 0;\n      },\n      _doProcessBlock: function (e, t) {\n        e[t] ^= i.call(this);\n      },\n      keySize: 8,\n      ivSize: 0\n    });\n  function i() {\n    for (var e = this._S, t = this._i, n = this._j, r = 0, o = 0; o < 4; o++) {\n      n = (n + e[t = (t + 1) % 256]) % 256;\n      var i = e[t];\n      e[t] = e[n];\n      e[n] = i;\n      r |= e[(e[t] + e[n]) % 256] << 24 - 8 * o;\n    }\n    this._i = t;\n    this._j = n;\n    return r;\n  }\n  e.RC4 = t._createHelper(o);\n  var s = n.RC4Drop = o.extend({\n    cfg: o.cfg.extend({\n      drop: 192\n    }),\n    _doReset: function () {\n      o._doReset.call(this);\n      for (var e = this.cfg.drop; e > 0; e--) i.call(this);\n    }\n  });\n  e.RC4Drop = t._createHelper(s);\n})();\nmodule.exports = r.RC4;",
  "1862": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.VSCodeCopilotTokenManager = exports.ExtensionNotificationSender = exports.setExtensionContext = exports.telemetryAcceptanceKey = undefined;\nconst r = require(9496),\n  o = require(362),\n  i = require(6794),\n  s = require(9899),\n  a = require(6333),\n  c = require(47);\nexports.telemetryAcceptanceKey = `github.copilot.telemetryAccepted.${i.LAST_TELEMETRY_TERMS_UPDATE}`;\nconst l = new s.Logger(s.LogLevel.INFO, \"auth\");\nlet u,\n  d = !1;\nexports.setExtensionContext = function (e) {\n  u = e;\n};\nexports.ExtensionNotificationSender = class {\n  async showWarningMessage(e, ...t) {\n    return {\n      title: await r.window.showWarningMessage(e, ...t.map(e => e.title))\n    };\n  }\n};\nclass VSCodeCopilotTokenManager extends o.CopilotTokenManager {\n  constructor() {\n    super();\n    this.copilotToken = undefined;\n  }\n  async getGitHubToken() {\n    const e = await c.getSession();\n    return null == e ? undefined : e.accessToken;\n  }\n  async getCopilotToken(e, n) {\n    (!this.copilotToken || this.copilotToken.expires_at < o.nowSeconds() || n) && (this.copilotToken = await async function (e) {\n      var n;\n      const s = await async function (e) {\n        const t = await c.getSession();\n        if (!t) {\n          l.info(e, \"GitHub login failed\");\n          a.telemetryError(e, \"auth.github_login_failed\");\n          return {\n            kind: \"failure\",\n            reason: \"GitHubLoginFailed\"\n          };\n        }\n        l.debug(e, `Logged in as ${t.account.label}, oauth token ${t.accessToken}`);\n        const n = await o.authFromGitHubToken(e, {\n          token: t.accessToken\n        });\n        if (\"success\" == n.kind) {\n          const r = n.token;\n          l.debug(e, `Copilot HMAC for ${t.account.label}: ${r}`);\n        }\n        return n;\n      }(e);\n      if (\"failure\" === s.kind && \"NotAuthorized\" === s.reason) throw Error(null !== (n = s.message) && undefined !== n ? n : \"User not authorized\");\n      if (\"failure\" === s.kind && \"HTTP401\" === s.reason) {\n        const e = \"Your GitHub token is invalid. Please sign out from your GitHub account using VSCode UI and try again.\";\n        throw d || (d = !0, r.window.showWarningMessage(e)), Error(e);\n      }\n      if (\"failure\" === s.kind) throw Error(\"Failed to get copilot token\");\n      if (\"unconfigured\" === s.telemetry && !(await async function (e) {\n        var n;\n        const o = null == u ? undefined : u.globalState;\n        if (!o) return !1;\n        const s = null === (n = c.getGithubAccount()) || undefined === n ? undefined : n.label;\n        if (!s) return !1;\n        const l = s,\n          d = o.get(exports.telemetryAcceptanceKey, undefined);\n        if (d && d === s) return !0;\n        const p = await r.window.showWarningMessage(`I agree to these [telemetry terms](${i.TELEMETRY_TERMS_URL}) as part of the GitHub Copilot technical preview.`, \"Cancel\", \"Agree\");\n        if (\"Agree\" !== p) {\n          const t = a.TelemetryData.createAndMarkAsIssued({\n            choice: null != p ? p : \"undefined\"\n          });\n          a.telemetry(e, \"auth.telemetry_terms_rejected\", t);\n          return !1;\n        }\n        o.update(exports.telemetryAcceptanceKey, l);\n        const h = a.TelemetryData.createAndMarkAsIssued({\n          terms_date: i.LAST_TELEMETRY_TERMS_UPDATE\n        });\n        a.telemetry(e, \"auth.telemetry_terms_accepted\", h);\n        return !0;\n      }(e))) throw Error(\"User did not agree to telemetry\");\n      return s;\n    }(e), o.refreshToken(e, this, this.copilotToken.refresh_in));\n    return this.copilotToken;\n  }\n  resetCopilotToken(e, t) {\n    undefined !== t && a.telemetry(e, \"auth.reset_token_\" + t);\n    l.debug(e, `Resetting copilot token on HTTP error ${t || \"unknown\"}`);\n    this.copilotToken = undefined;\n  }\n}\nexports.VSCodeCopilotTokenManager = VSCodeCopilotTokenManager;",
  "1906": "module.exports = (e, t, n) => {\n  const r = n => Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    writable: !0\n  });\n  Object.defineProperty(e, t, {\n    configurable: !0,\n    enumerable: !0,\n    get() {\n      const e = n();\n      r(e);\n      return e;\n    },\n    set(e) {\n      r(e);\n    }\n  });\n  return e;\n};",
  "1929": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.OpenCopilotActionProvider = undefined;\nconst r = require(9496),\n  o = require(256),\n  i = require(6333),\n  s = require(3060),\n  a = require(4540);\nexports.OpenCopilotActionProvider = class {\n  constructor(e) {\n    this.ctx = e;\n    this.lastVersion = 0;\n    this.lastRange = undefined;\n  }\n  indexOfGroup(e, t) {\n    let n = e.index;\n    for (let r = 1; r < t; r++) n += e[r].length;\n    return n;\n  }\n  telemetryCodeAction(e, t) {\n    const n = {\n      languageId: e.languageId,\n      codeActionType: o.completionTypeToString(t)\n    };\n    i.telemetry(this.ctx, \"codeAction.displayed\", i.TelemetryData.createAndMarkAsIssued(n));\n  }\n  async provideCodeActions(e, t, n, i) {\n    var c;\n    if (a.ignoreDocument(this.ctx, e)) return;\n    const l = e.lineAt(t.start);\n    if (e.version === this.lastVersion && this.lastRange && this.lastRange.isEqual(t)) return;\n    this.lastVersion = e.version;\n    this.lastRange = t;\n    const u = /^(\\W+)(todo)/i.exec(l.text);\n    if (u) {\n      const n = u[u.length - 1],\n        i = this.indexOfGroup(u, u.length - 1);\n      if (new r.Range(new r.Position(t.start.line, i), new r.Position(t.start.line, i + n.length)).contains(t.start)) {\n        const t = new r.CodeAction(\"Implement with GitHub Copilot\", r.CodeActionKind.QuickFix),\n          n = {\n            title: \"Implement with GitHub Copilot\",\n            command: s.CMDOpenPanelForRange,\n            arguments: [new o.CompletionContext(this.ctx, l.rangeIncludingLineBreak.end, o.CompletionType.TODO_QUICK_FIX)]\n          };\n        t.command = n;\n        this.telemetryCodeAction(e, o.CompletionType.TODO_QUICK_FIX);\n        return [t];\n      }\n    }\n    const d = n.diagnostics.find(e => \"ts\" === e.source && 2304 === e.code);\n    if (d) {\n      const t = await r.commands.executeCommand(\"vscode.executeCodeActionProvider\", e.uri, d.range),\n        n = null == t ? undefined : t.find(e => e.title.startsWith(\"Add missing function declaration\")),\n        i = null === (c = null == n ? undefined : n.edit) || undefined === c ? undefined : c.get(e.uri).pop();\n      if (i) {\n        const t = new r.CodeAction(\"Implement with GitHub Copilot\", r.CodeActionKind.QuickFix),\n          n = new o.CompletionContext(this.ctx, i.range.start, o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX),\n          a = i.newText.trim().split(\"\\n\")[0];\n        n.prependToCompletion = \"\\n\" + a;\n        const c = {\n          title: \"Implement with GitHub Copilot\",\n          command: s.CMDOpenPanelForRange,\n          arguments: [n]\n        };\n        t.command = c;\n        this.telemetryCodeAction(e, o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX);\n        return [t];\n      }\n    }\n  }\n};",
  "1974": "var t = function () {\n  function e(e) {\n    this.fieldmap = [];\n    e && (this.fieldmap = this.parseHeader(e));\n  }\n  e.prototype.toString = function () {\n    var e = this.fieldmap;\n    return e && 0 != e.length ? e.join(\", \") : null;\n  };\n  e.validateKeyChars = function (e) {\n    var t = e.split(\"@\");\n    if (2 == t.length) {\n      var n = t[0].trim(),\n        r = t[1].trim(),\n        o = Boolean(n.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,241}$/)),\n        i = Boolean(r.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,14}$/));\n      return o && i;\n    }\n    return 1 == t.length && Boolean(e.match(/^[\\ ]?[a-z0-9\\*\\-\\_/]{1,256}$/));\n  };\n  e.prototype.parseHeader = function (t) {\n    var n = [],\n      r = {},\n      o = t.split(\",\");\n    if (o.length > 32) return null;\n    for (var i = 0, s = o; i < s.length; i++) {\n      var a = s[i].trim();\n      if (0 !== a.length) {\n        var c = a.split(\"=\");\n        if (2 !== c.length) return null;\n        if (!e.validateKeyChars(c[0])) return null;\n        if (r[c[0]]) return null;\n        r[c[0]] = !0;\n        n.push(a);\n      }\n    }\n    return n;\n  };\n  e.strict = !0;\n  return e;\n}();\nmodule.exports = t;",
  "1995": "module.exports = require(\"http2\");",
  "2028": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(4953);\nexports.mongoCore = {\n  versionSpecifier: \">= 2.0.0 < 4.0.0\",\n  patch: function (e) {\n    var t = e.Server.prototype.connect;\n    e.Server.prototype.connect = function () {\n      var e = t.apply(this, arguments),\n        n = this.s.pool.write;\n      this.s.pool.write = function () {\n        var e = \"function\" == typeof arguments[1] ? 1 : 2;\n        \"function\" == typeof arguments[e] && (arguments[e] = r.channel.bindToContext(arguments[e]));\n        return n.apply(this, arguments);\n      };\n      var o = this.s.pool.logout;\n      this.s.pool.logout = function () {\n        \"function\" == typeof arguments[1] && (arguments[1] = r.channel.bindToContext(arguments[1]));\n        return o.apply(this, arguments);\n      };\n      return e;\n    };\n    return e;\n  }\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"mongodb-core\", exports.mongoCore);\n};",
  "2037": "module.exports = require(\"os\");",
  "2057": "module.exports = require(\"constants\");",
  "2081": "module.exports = require(\"child_process\");",
  "2112": "var r, o, i, s, a, c, l, u, d;\nd = require(8249);\nrequire(2783);\nrequire(9824);\ni = (o = (r = d).lib).Base;\ns = o.WordArray;\nc = (a = r.algo).SHA1;\nl = a.HMAC;\nu = a.PBKDF2 = i.extend({\n  cfg: i.extend({\n    keySize: 4,\n    hasher: c,\n    iterations: 1\n  }),\n  init: function (e) {\n    this.cfg = this.cfg.extend(e);\n  },\n  compute: function (e, t) {\n    for (var n = this.cfg, r = l.create(n.hasher, e), o = s.create(), i = s.create([1]), a = o.words, c = i.words, u = n.keySize, d = n.iterations; a.length < u;) {\n      var p = r.update(t).finalize(i);\n      r.reset();\n      for (var h = p.words, f = h.length, m = p, g = 1; g < d; g++) {\n        m = r.finalize(m);\n        r.reset();\n        for (var _ = m.words, y = 0; y < f; y++) h[y] ^= _[y];\n      }\n      o.concat(p);\n      c[0]++;\n    }\n    o.sigBytes = 4 * u;\n    return o;\n  }\n});\nr.PBKDF2 = function (e, t, n) {\n  return u.create(n).compute(e, t);\n};\nmodule.exports = d.PBKDF2;",
  "2130": "const r = require(2037),\n  o = require(6560),\n  i = process.env;\nlet s;\nfunction a(e) {\n  const t = function (e) {\n    if (!1 === s) return 0;\n    if (o(\"color=16m\") || o(\"color=full\") || o(\"color=truecolor\")) return 3;\n    if (o(\"color=256\")) return 2;\n    if (e && !e.isTTY && !0 !== s) return 0;\n    const t = s ? 1 : 0;\n    if (\"win32\" === process.platform) {\n      const e = r.release().split(\".\");\n      return Number(process.versions.node.split(\".\")[0]) >= 8 && Number(e[0]) >= 10 && Number(e[2]) >= 10586 ? Number(e[2]) >= 14931 ? 3 : 2 : 1;\n    }\n    if (\"CI\" in i) return [\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\"].some(e => e in i) || \"codeship\" === i.CI_NAME ? 1 : t;\n    if (\"TEAMCITY_VERSION\" in i) return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(i.TEAMCITY_VERSION) ? 1 : 0;\n    if (\"truecolor\" === i.COLORTERM) return 3;\n    if (\"TERM_PROGRAM\" in i) {\n      const e = parseInt((i.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);\n      switch (i.TERM_PROGRAM) {\n        case \"iTerm.app\":\n          return e >= 3 ? 3 : 2;\n        case \"Apple_Terminal\":\n          return 2;\n      }\n    }\n    return /-256(color)?$/i.test(i.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(i.TERM) || \"COLORTERM\" in i ? 1 : (i.TERM, t);\n  }(e);\n  return function (e) {\n    return 0 !== e && {\n      level: e,\n      hasBasic: !0,\n      has256: e >= 2,\n      has16m: e >= 3\n    };\n  }(t);\n}\no(\"no-color\") || o(\"no-colors\") || o(\"color=false\") ? s = !1 : (o(\"color\") || o(\"colors\") || o(\"color=true\") || o(\"color=always\")) && (s = !0);\n\"FORCE_COLOR\" in i && (s = 0 === i.FORCE_COLOR.length || 0 !== parseInt(i.FORCE_COLOR, 10));\nmodule.exports = {\n  supportsColor: a,\n  stdout: a(process.stdout),\n  stderr: a(process.stderr)\n};",
  "2141": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = {\n    data: new r.Name(\"data\"),\n    valCxt: new r.Name(\"valCxt\"),\n    instancePath: new r.Name(\"instancePath\"),\n    parentData: new r.Name(\"parentData\"),\n    parentDataProperty: new r.Name(\"parentDataProperty\"),\n    rootData: new r.Name(\"rootData\"),\n    dynamicAnchors: new r.Name(\"dynamicAnchors\"),\n    vErrors: new r.Name(\"vErrors\"),\n    errors: new r.Name(\"errors\"),\n    this: new r.Name(\"this\"),\n    self: new r.Name(\"self\"),\n    scope: new r.Name(\"scope\"),\n    json: new r.Name(\"json\"),\n    jsonPos: new r.Name(\"jsonPos\"),\n    jsonLen: new r.Name(\"jsonLen\"),\n    jsonPart: new r.Name(\"jsonPart\")\n  };\nexports.default = o;",
  "2153": "var r;\nr = require(8249);\n(function (e) {\n  var t = r,\n    n = t.lib,\n    o = n.WordArray,\n    i = n.Hasher,\n    s = t.algo,\n    a = [],\n    c = [];\n  !function () {\n    function t(t) {\n      for (var n = e.sqrt(t), r = 2; r <= n; r++) if (!(t % r)) return !1;\n      return !0;\n    }\n    function n(e) {\n      return 4294967296 * (e - (0 | e)) | 0;\n    }\n    for (var r = 2, o = 0; o < 64;) {\n      t(r) && (o < 8 && (a[o] = n(e.pow(r, .5))), c[o] = n(e.pow(r, 1 / 3)), o++);\n      r++;\n    }\n  }();\n  var l = [],\n    u = s.SHA256 = i.extend({\n      _doReset: function () {\n        this._hash = new o.init(a.slice(0));\n      },\n      _doProcessBlock: function (e, t) {\n        for (var n = this._hash.words, r = n[0], o = n[1], i = n[2], s = n[3], a = n[4], u = n[5], d = n[6], p = n[7], h = 0; h < 64; h++) {\n          if (h < 16) l[h] = 0 | e[t + h];else {\n            var f = l[h - 15],\n              m = (f << 25 | f >>> 7) ^ (f << 14 | f >>> 18) ^ f >>> 3,\n              g = l[h - 2],\n              _ = (g << 15 | g >>> 17) ^ (g << 13 | g >>> 19) ^ g >>> 10;\n            l[h] = m + l[h - 7] + _ + l[h - 16];\n          }\n          var y = r & o ^ r & i ^ o & i,\n            v = (r << 30 | r >>> 2) ^ (r << 19 | r >>> 13) ^ (r << 10 | r >>> 22),\n            b = p + ((a << 26 | a >>> 6) ^ (a << 21 | a >>> 11) ^ (a << 7 | a >>> 25)) + (a & u ^ ~a & d) + c[h] + l[h];\n          p = d;\n          d = u;\n          u = a;\n          a = s + b | 0;\n          s = i;\n          i = o;\n          o = r;\n          r = b + (v + y) | 0;\n        }\n        n[0] = n[0] + r | 0;\n        n[1] = n[1] + o | 0;\n        n[2] = n[2] + i | 0;\n        n[3] = n[3] + s | 0;\n        n[4] = n[4] + a | 0;\n        n[5] = n[5] + u | 0;\n        n[6] = n[6] + d | 0;\n        n[7] = n[7] + p | 0;\n      },\n      _doFinalize: function () {\n        var t = this._data,\n          n = t.words,\n          r = 8 * this._nDataBytes,\n          o = 8 * t.sigBytes;\n        n[o >>> 5] |= 128 << 24 - o % 32;\n        n[14 + (o + 64 >>> 9 << 4)] = e.floor(r / 4294967296);\n        n[15 + (o + 64 >>> 9 << 4)] = r;\n        t.sigBytes = 4 * n.length;\n        this._process();\n        return this._hash;\n      },\n      clone: function () {\n        var e = i.clone.call(this);\n        e._hash = this._hash.clone();\n        return e;\n      }\n    });\n  t.SHA256 = i._createHelper(u);\n  t.HmacSHA256 = i._createHmacHelper(u);\n})(Math);\nmodule.exports = r.SHA256;",
  "2209": "var r, o, i, s;\ns = require(8249);\nrequire(5109);\no = (r = s).lib.CipherParams;\ni = r.enc.Hex;\nr.format.Hex = {\n  stringify: function (e) {\n    return e.ciphertext.toString(i);\n  },\n  parse: function (e) {\n    var t = i.parse(e);\n    return o.create({\n      ciphertext: t\n    });\n  }\n};\nmodule.exports = s.format.Hex;",
  "2218": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.completionsFromGhostTextResults = undefined;\nconst r = require(2277),\n  o = require(6403),\n  i = require(9334),\n  s = require(3286);\nexports.completionsFromGhostTextResults = function (e, t, n, a, c, l, u) {\n  const d = e.get(o.LocationFactory),\n    p = a.lineAt(c);\n  let h = t.map(e => {\n    let t,\n      o = \"\";\n    l && (e.completion = s.normalizeIndentCharacter(l, e.completion, p.isEmptyOrWhitespace));\n    if (e.completion.displayNeedsWsOffset && p.isEmptyOrWhitespace) t = d.range(d.position(c.line, 0), c), o = e.completion.completionText;else if (p.isEmptyOrWhitespace && e.completion.completionText.startsWith(p.text)) t = d.range(d.position(c.line, 0), c), o = e.completion.completionText;else {\n      const n = a.getWordRangeAtPosition(c);\n      if (e.isMiddleOfTheLine) {\n        const n = a.lineAt(c),\n          r = d.range(d.position(c.line, 0), c),\n          i = a.getText(r);\n        t = e.coversSuffix ? n.range : r, o = i + e.completion.displayText;\n      } else if (n) {\n        const r = a.getText(n);\n        t = d.range(n.start, c), o = r + e.completion.completionText;\n      } else {\n        const n = d.range(d.position(c.line, 0), c);\n        t = n, o = a.getText(n) + e.completion.displayText;\n      }\n    }\n    return {\n      uuid: r.v4(),\n      text: o,\n      range: t,\n      file: a.uri,\n      index: e.completion.completionIndex,\n      telemetry: e.telemetry,\n      displayText: e.completion.displayText,\n      position: c,\n      offset: a.offsetAt(c),\n      resultType: n\n    };\n  });\n  if (n === i.ResultType.TypingAsSuggested && undefined !== u) {\n    const e = h.find(e => e.index === u);\n    if (e) {\n      const t = h.filter(e => e.index !== u);\n      h = [e, ...t];\n    }\n  }\n  return h;\n};",
  "2249": "var n;\nexports = module.exports = SemVer;\nn = \"object\" == typeof process && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? function () {\n  var e = Array.prototype.slice.call(arguments, 0);\n  e.unshift(\"SEMVER\");\n  console.log.apply(console, e);\n} : function () {};\nexports.SEMVER_SPEC_VERSION = \"2.0.0\";\nvar r = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  o = exports.re = [],\n  i = exports.src = [],\n  s = 0,\n  a = s++;\ni[a] = \"0|[1-9]\\\\d*\";\nvar c = s++;\ni[c] = \"[0-9]+\";\nvar l = s++;\ni[l] = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";\nvar u = s++;\ni[u] = \"(\" + i[a] + \")\\\\.(\" + i[a] + \")\\\\.(\" + i[a] + \")\";\nvar d = s++;\ni[d] = \"(\" + i[c] + \")\\\\.(\" + i[c] + \")\\\\.(\" + i[c] + \")\";\nvar p = s++;\ni[p] = \"(?:\" + i[a] + \"|\" + i[l] + \")\";\nvar h = s++;\ni[h] = \"(?:\" + i[c] + \"|\" + i[l] + \")\";\nvar f = s++;\ni[f] = \"(?:-(\" + i[p] + \"(?:\\\\.\" + i[p] + \")*))\";\nvar m = s++;\ni[m] = \"(?:-?(\" + i[h] + \"(?:\\\\.\" + i[h] + \")*))\";\nvar g = s++;\ni[g] = \"[0-9A-Za-z-]+\";\nvar _ = s++;\ni[_] = \"(?:\\\\+(\" + i[g] + \"(?:\\\\.\" + i[g] + \")*))\";\nvar y = s++,\n  v = \"v?\" + i[u] + i[f] + \"?\" + i[_] + \"?\";\ni[y] = \"^\" + v + \"$\";\nvar b = \"[v=\\\\s]*\" + i[d] + i[m] + \"?\" + i[_] + \"?\",\n  w = s++;\ni[w] = \"^\" + b + \"$\";\nvar x = s++;\ni[x] = \"((?:<|>)?=?)\";\nvar E = s++;\ni[E] = i[c] + \"|x|X|\\\\*\";\nvar C = s++;\ni[C] = i[a] + \"|x|X|\\\\*\";\nvar S = s++;\ni[S] = \"[v=\\\\s]*(\" + i[C] + \")(?:\\\\.(\" + i[C] + \")(?:\\\\.(\" + i[C] + \")(?:\" + i[f] + \")?\" + i[_] + \"?)?)?\";\nvar T = s++;\ni[T] = \"[v=\\\\s]*(\" + i[E] + \")(?:\\\\.(\" + i[E] + \")(?:\\\\.(\" + i[E] + \")(?:\" + i[m] + \")?\" + i[_] + \"?)?)?\";\nvar k = s++;\ni[k] = \"^\" + i[x] + \"\\\\s*\" + i[S] + \"$\";\nvar I = s++;\ni[I] = \"^\" + i[x] + \"\\\\s*\" + i[T] + \"$\";\nvar P = s++;\ni[P] = \"(?:^|[^\\\\d])(\\\\d{1,16})(?:\\\\.(\\\\d{1,16}))?(?:\\\\.(\\\\d{1,16}))?(?:$|[^\\\\d])\";\nvar A = s++;\ni[A] = \"(?:~>?)\";\nvar O = s++;\ni[O] = \"(\\\\s*)\" + i[A] + \"\\\\s+\";\no[O] = new RegExp(i[O], \"g\");\nvar N = s++;\ni[N] = \"^\" + i[A] + i[S] + \"$\";\nvar R = s++;\ni[R] = \"^\" + i[A] + i[T] + \"$\";\nvar M = s++;\ni[M] = \"(?:\\\\^)\";\nvar L = s++;\ni[L] = \"(\\\\s*)\" + i[M] + \"\\\\s+\";\no[L] = new RegExp(i[L], \"g\");\nvar $ = s++;\ni[$] = \"^\" + i[M] + i[S] + \"$\";\nvar D = s++;\ni[D] = \"^\" + i[M] + i[T] + \"$\";\nvar F = s++;\ni[F] = \"^\" + i[x] + \"\\\\s*(\" + b + \")$|^$\";\nvar j = s++;\ni[j] = \"^\" + i[x] + \"\\\\s*(\" + v + \")$|^$\";\nvar q = s++;\ni[q] = \"(\\\\s*)\" + i[x] + \"\\\\s*(\" + b + \"|\" + i[S] + \")\";\no[q] = new RegExp(i[q], \"g\");\nvar B = s++;\ni[B] = \"^\\\\s*(\" + i[S] + \")\\\\s+-\\\\s+(\" + i[S] + \")\\\\s*$\";\nvar U = s++;\ni[U] = \"^\\\\s*(\" + i[T] + \")\\\\s+-\\\\s+(\" + i[T] + \")\\\\s*$\";\nvar H = s++;\ni[H] = \"(<|>)?=?\\\\s*\\\\*\";\nfor (var z = 0; z < 35; z++) {\n  n(z, i[z]);\n  o[z] || (o[z] = new RegExp(i[z]));\n}\nfunction parse(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  if (e.length > 256) return null;\n  if (!(t.loose ? o[w] : o[y]).test(e)) return null;\n  try {\n    return new SemVer(e, t);\n  } catch (e) {\n    return null;\n  }\n}\nfunction SemVer(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof SemVer) {\n    if (e.loose === t.loose) return e;\n    e = e.version;\n  } else if (\"string\" != typeof e) throw new TypeError(\"Invalid Version: \" + e);\n  if (e.length > 256) throw new TypeError(\"version is longer than 256 characters\");\n  if (!(this instanceof SemVer)) return new SemVer(e, t);\n  n(\"SemVer\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  var i = e.trim().match(t.loose ? o[w] : o[y]);\n  if (!i) throw new TypeError(\"Invalid Version: \" + e);\n  this.raw = e;\n  this.major = +i[1];\n  this.minor = +i[2];\n  this.patch = +i[3];\n  if (this.major > r || this.major < 0) throw new TypeError(\"Invalid major version\");\n  if (this.minor > r || this.minor < 0) throw new TypeError(\"Invalid minor version\");\n  if (this.patch > r || this.patch < 0) throw new TypeError(\"Invalid patch version\");\n  i[4] ? this.prerelease = i[4].split(\".\").map(function (e) {\n    if (/^[0-9]+$/.test(e)) {\n      var t = +e;\n      if (t >= 0 && t < r) return t;\n    }\n    return e;\n  }) : this.prerelease = [];\n  this.build = i[5] ? i[5].split(\".\") : [];\n  this.format();\n}\nexports.parse = parse;\nexports.valid = function (e, t) {\n  var n = parse(e, t);\n  return n ? n.version : null;\n};\nexports.clean = function (e, t) {\n  var n = parse(e.trim().replace(/^[=v]+/, \"\"), t);\n  return n ? n.version : null;\n};\nexports.SemVer = SemVer;\nSemVer.prototype.format = function () {\n  this.version = this.major + \".\" + this.minor + \".\" + this.patch;\n  this.prerelease.length && (this.version += \"-\" + this.prerelease.join(\".\"));\n  return this.version;\n};\nSemVer.prototype.toString = function () {\n  return this.version;\n};\nSemVer.prototype.compare = function (e) {\n  n(\"SemVer.compare\", this.version, this.options, e);\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  return this.compareMain(e) || this.comparePre(e);\n};\nSemVer.prototype.compareMain = function (e) {\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  return compareIdentifiers(this.major, e.major) || compareIdentifiers(this.minor, e.minor) || compareIdentifiers(this.patch, e.patch);\n};\nSemVer.prototype.comparePre = function (e) {\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  if (this.prerelease.length && !e.prerelease.length) return -1;\n  if (!this.prerelease.length && e.prerelease.length) return 1;\n  if (!this.prerelease.length && !e.prerelease.length) return 0;\n  var t = 0;\n  do {\n    var r = this.prerelease[t],\n      o = e.prerelease[t];\n    n(\"prerelease compare\", t, r, o);\n    if (void 0 === r && void 0 === o) return 0;\n    if (undefined === o) return 1;\n    if (undefined === r) return -1;\n    if (r !== o) return compareIdentifiers(r, o);\n  } while (++t);\n};\nSemVer.prototype.inc = function (e, t) {\n  switch (e) {\n    case \"premajor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc(\"pre\", t);\n      break;\n    case \"preminor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc(\"pre\", t);\n      break;\n    case \"prepatch\":\n      this.prerelease.length = 0;\n      this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"prerelease\":\n      0 === this.prerelease.length && this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"major\":\n      0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"minor\":\n      0 === this.patch && 0 !== this.prerelease.length || this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"patch\":\n      0 === this.prerelease.length && this.patch++;\n      this.prerelease = [];\n      break;\n    case \"pre\":\n      if (0 === this.prerelease.length) this.prerelease = [0];else {\n        for (var n = this.prerelease.length; --n >= 0;) \"number\" == typeof this.prerelease[n] && (this.prerelease[n]++, n = -2);\n        -1 === n && this.prerelease.push(0);\n      }\n      t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);\n      break;\n    default:\n      throw new Error(\"invalid increment argument: \" + e);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\nexports.inc = function (e, t, n, r) {\n  \"string\" == typeof n && (r = n, n = undefined);\n  try {\n    return new SemVer(e, n).inc(t, r).version;\n  } catch (e) {\n    return null;\n  }\n};\nexports.diff = function (e, t) {\n  if (eq(e, t)) return null;\n  var n = parse(e),\n    r = parse(t),\n    o = \"\";\n  if (n.prerelease.length || r.prerelease.length) {\n    o = \"pre\";\n    var i = \"prerelease\";\n  }\n  for (var s in n) if ((\"major\" === s || \"minor\" === s || \"patch\" === s) && n[s] !== r[s]) return o + s;\n  return i;\n};\nexports.compareIdentifiers = compareIdentifiers;\nvar W = /^[0-9]+$/;\nfunction compareIdentifiers(e, t) {\n  var n = W.test(e),\n    r = W.test(t);\n  n && r && (e = +e, t = +t);\n  return e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;\n}\nfunction compare(e, t, n) {\n  return new SemVer(e, n).compare(new SemVer(t, n));\n}\nfunction gt(e, t, n) {\n  return compare(e, t, n) > 0;\n}\nfunction lt(e, t, n) {\n  return compare(e, t, n) < 0;\n}\nfunction eq(e, t, n) {\n  return 0 === compare(e, t, n);\n}\nfunction neq(e, t, n) {\n  return 0 !== compare(e, t, n);\n}\nfunction ee(e, t, n) {\n  return compare(e, t, n) >= 0;\n}\nfunction te(e, t, n) {\n  return compare(e, t, n) <= 0;\n}\nfunction ne(e, t, n, r) {\n  switch (t) {\n    case \"===\":\n      \"object\" == typeof e && (e = e.version);\n      \"object\" == typeof n && (n = n.version);\n      return e === n;\n    case \"!==\":\n      \"object\" == typeof e && (e = e.version);\n      \"object\" == typeof n && (n = n.version);\n      return e !== n;\n    case \"\":\n    case \"=\":\n    case \"==\":\n      return eq(e, n, r);\n    case \"!=\":\n      return neq(e, n, r);\n    case \">\":\n      return gt(e, n, r);\n    case \">=\":\n      return ee(e, n, r);\n    case \"<\":\n      return lt(e, n, r);\n    case \"<=\":\n      return te(e, n, r);\n    default:\n      throw new TypeError(\"Invalid operator: \" + t);\n  }\n}\nfunction re(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof re) {\n    if (e.loose === !!t.loose) return e;\n    e = e.value;\n  }\n  if (!(this instanceof re)) return new re(e, t);\n  n(\"comparator\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.parse(e);\n  this.semver === oe ? this.value = \"\" : this.value = this.operator + this.semver.version;\n  n(\"comp\", this);\n}\nexports.rcompareIdentifiers = function (e, t) {\n  return compareIdentifiers(t, e);\n};\nexports.major = function (e, t) {\n  return new SemVer(e, t).major;\n};\nexports.minor = function (e, t) {\n  return new SemVer(e, t).minor;\n};\nexports.patch = function (e, t) {\n  return new SemVer(e, t).patch;\n};\nexports.compare = compare;\nexports.compareLoose = function (e, t) {\n  return compare(e, t, !0);\n};\nexports.rcompare = function (e, t, n) {\n  return compare(t, e, n);\n};\nexports.sort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.compare(e, r, n);\n  });\n};\nexports.rsort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.rcompare(e, r, n);\n  });\n};\nexports.gt = gt;\nexports.lt = lt;\nexports.eq = eq;\nexports.neq = neq;\nexports.gte = ee;\nexports.lte = te;\nexports.cmp = ne;\nexports.Comparator = re;\nvar oe = {};\nfunction ie(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof ie) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new ie(e.raw, t);\n  if (e instanceof re) return new ie(e.value, t);\n  if (!(this instanceof ie)) return new ie(e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.includePrerelease = !!t.includePrerelease;\n  this.raw = e;\n  this.set = e.split(/\\s*\\|\\|\\s*/).map(function (e) {\n    return this.parseRange(e.trim());\n  }, this).filter(function (e) {\n    return e.length;\n  });\n  if (!this.set.length) throw new TypeError(\"Invalid SemVer Range: \" + e);\n  this.format();\n}\nfunction se(e) {\n  return !e || \"x\" === e.toLowerCase() || \"*\" === e;\n}\nfunction ae(e, t, n, r, o, i, s, a, c, l, u, d, p) {\n  return ((t = se(n) ? \"\" : se(r) ? \">=\" + n + \".0.0\" : se(o) ? \">=\" + n + \".\" + r + \".0\" : \">=\" + t) + \" \" + (a = se(c) ? \"\" : se(l) ? \"<\" + (+c + 1) + \".0.0\" : se(u) ? \"<\" + c + \".\" + (+l + 1) + \".0\" : d ? \"<=\" + c + \".\" + l + \".\" + u + \"-\" + d : \"<=\" + a)).trim();\n}\nfunction ce(e, t, r) {\n  for (var o = 0; o < e.length; o++) if (!e[o].test(t)) return !1;\n  if (t.prerelease.length && !r.includePrerelease) {\n    for (o = 0; o < e.length; o++) {\n      n(e[o].semver);\n      if (e[o].semver !== oe && e[o].semver.prerelease.length > 0) {\n        var i = e[o].semver;\n        if (i.major === t.major && i.minor === t.minor && i.patch === t.patch) return !0;\n      }\n    }\n    return !1;\n  }\n  return !0;\n}\nfunction le(e, t, n) {\n  try {\n    t = new ie(t, n);\n  } catch (e) {\n    return !1;\n  }\n  return t.test(e);\n}\nfunction ue(e, t, n, r) {\n  var o, i, s, a, c;\n  switch (e = new SemVer(e, r), t = new ie(t, r), n) {\n    case \">\":\n      o = gt;\n      i = te;\n      s = lt;\n      a = \">\";\n      c = \">=\";\n      break;\n    case \"<\":\n      o = lt;\n      i = ee;\n      s = gt;\n      a = \"<\";\n      c = \"<=\";\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n  if (le(e, t, r)) return !1;\n  for (var l = 0; l < t.set.length; ++l) {\n    var u = t.set[l],\n      d = null,\n      p = null;\n    u.forEach(function (e) {\n      e.semver === oe && (e = new re(\">=0.0.0\"));\n      d = d || e;\n      p = p || e;\n      o(e.semver, d.semver, r) ? d = e : s(e.semver, p.semver, r) && (p = e);\n    });\n    if (d.operator === a || d.operator === c) return !1;\n    if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;\n    if (p.operator === c && s(e, p.semver)) return !1;\n  }\n  return !0;\n}\nre.prototype.parse = function (e) {\n  var t = this.options.loose ? o[F] : o[j],\n    n = e.match(t);\n  if (!n) throw new TypeError(\"Invalid comparator: \" + e);\n  this.operator = n[1];\n  \"=\" === this.operator && (this.operator = \"\");\n  n[2] ? this.semver = new SemVer(n[2], this.options.loose) : this.semver = oe;\n};\nre.prototype.toString = function () {\n  return this.value;\n};\nre.prototype.test = function (e) {\n  n(\"Comparator.test\", e, this.options.loose);\n  return this.semver === oe || (\"string\" == typeof e && (e = new SemVer(e, this.options)), ne(e, this.operator, this.semver, this.options));\n};\nre.prototype.intersects = function (e, t) {\n  if (!(e instanceof re)) throw new TypeError(\"a Comparator is required\");\n  var n;\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (\"\" === this.operator) return n = new ie(e.value, t), le(this.value, n, t);\n  if (\"\" === e.operator) {\n    n = new ie(this.value, t);\n    return le(e.semver, n, t);\n  }\n  var r = !(\">=\" !== this.operator && \">\" !== this.operator || \">=\" !== e.operator && \">\" !== e.operator),\n    o = !(\"<=\" !== this.operator && \"<\" !== this.operator || \"<=\" !== e.operator && \"<\" !== e.operator),\n    i = this.semver.version === e.semver.version,\n    s = !(\">=\" !== this.operator && \"<=\" !== this.operator || \">=\" !== e.operator && \"<=\" !== e.operator),\n    a = ne(this.semver, \"<\", e.semver, t) && (\">=\" === this.operator || \">\" === this.operator) && (\"<=\" === e.operator || \"<\" === e.operator),\n    c = ne(this.semver, \">\", e.semver, t) && (\"<=\" === this.operator || \"<\" === this.operator) && (\">=\" === e.operator || \">\" === e.operator);\n  return r || o || i && s || a || c;\n};\nexports.Range = ie;\nie.prototype.format = function () {\n  this.range = this.set.map(function (e) {\n    return e.join(\" \").trim();\n  }).join(\"||\").trim();\n  return this.range;\n};\nie.prototype.toString = function () {\n  return this.range;\n};\nie.prototype.parseRange = function (e) {\n  var t = this.options.loose;\n  e = e.trim();\n  var r = t ? o[U] : o[B];\n  e = e.replace(r, ae);\n  n(\"hyphen replace\", e);\n  e = e.replace(o[q], \"$1$2$3\");\n  n(\"comparator trim\", e, o[q]);\n  e = (e = (e = e.replace(o[O], \"$1~\")).replace(o[L], \"$1^\")).split(/\\s+/).join(\" \");\n  var i = t ? o[F] : o[j],\n    s = e.split(\" \").map(function (e) {\n      return function (e, t) {\n        n(\"comp\", e, t);\n        e = function (e, t) {\n          return e.trim().split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              n(\"caret\", e, t);\n              var r = t.loose ? o[D] : o[$];\n              return e.replace(r, function (t, r, o, i, s) {\n                var a;\n                n(\"caret\", e, t, r, o, i, s);\n                se(r) ? a = \"\" : se(o) ? a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\" : se(i) ? a = \"0\" === r ? \">=\" + r + \".\" + o + \".0 <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".0 <\" + (+r + 1) + \".0.0\" : s ? (n(\"replaceCaret pr\", s), a = \"0\" === r ? \"0\" === o ? \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + o + \".\" + (+i + 1) : \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + (+r + 1) + \".0.0\") : (n(\"no pr\"), a = \"0\" === r ? \"0\" === o ? \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + o + \".\" + (+i + 1) : \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".\" + i + \" <\" + (+r + 1) + \".0.0\");\n                n(\"caret return\", a);\n                return a;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"caret\", e);\n        e = function (e, t) {\n          return e.trim().split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              var r = t.loose ? o[R] : o[N];\n              return e.replace(r, function (t, r, o, i, s) {\n                var a;\n                n(\"tilde\", e, t, r, o, i, s);\n                se(r) ? a = \"\" : se(o) ? a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\" : se(i) ? a = \">=\" + r + \".\" + o + \".0 <\" + r + \".\" + (+o + 1) + \".0\" : s ? (n(\"replaceTilde pr\", s), a = \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + (+o + 1) + \".0\") : a = \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + (+o + 1) + \".0\";\n                n(\"tilde return\", a);\n                return a;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"tildes\", e);\n        e = function (e, t) {\n          n(\"replaceXRanges\", e, t);\n          return e.split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              e = e.trim();\n              var r = t.loose ? o[I] : o[k];\n              return e.replace(r, function (t, r, o, i, s, a) {\n                n(\"xRange\", e, t, r, o, i, s, a);\n                var c = se(o),\n                  l = c || se(i),\n                  u = l || se(s);\n                \"=\" === r && u && (r = \"\");\n                c ? t = \">\" === r || \"<\" === r ? \"<0.0.0\" : \"*\" : r && u ? (l && (i = 0), s = 0, \">\" === r ? (r = \">=\", l ? (o = +o + 1, i = 0, s = 0) : (i = +i + 1, s = 0)) : \"<=\" === r && (r = \"<\", l ? o = +o + 1 : i = +i + 1), t = r + o + \".\" + i + \".\" + s) : l ? t = \">=\" + o + \".0.0 <\" + (+o + 1) + \".0.0\" : u && (t = \">=\" + o + \".\" + i + \".0 <\" + o + \".\" + (+i + 1) + \".0\");\n                n(\"xRange return\", t);\n                return t;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"xrange\", e);\n        e = function (e, t) {\n          n(\"replaceStars\", e, t);\n          return e.trim().replace(o[H], \"\");\n        }(e, t);\n        n(\"stars\", e);\n        return e;\n      }(e, this.options);\n    }, this).join(\" \").split(/\\s+/);\n  this.options.loose && (s = s.filter(function (e) {\n    return !!e.match(i);\n  }));\n  return s.map(function (e) {\n    return new re(e, this.options);\n  }, this);\n};\nie.prototype.intersects = function (e, t) {\n  if (!(e instanceof ie)) throw new TypeError(\"a Range is required\");\n  return this.set.some(function (n) {\n    return n.every(function (n) {\n      return e.set.some(function (e) {\n        return e.every(function (e) {\n          return n.intersects(e, t);\n        });\n      });\n    });\n  });\n};\nexports.toComparators = function (e, t) {\n  return new ie(e, t).set.map(function (e) {\n    return e.map(function (e) {\n      return e.value;\n    }).join(\" \").trim().split(\" \");\n  });\n};\nie.prototype.test = function (e) {\n  if (!e) return !1;\n  \"string\" == typeof e && (e = new SemVer(e, this.options));\n  for (var t = 0; t < this.set.length; t++) if (ce(this.set[t], e, this.options)) return !0;\n  return !1;\n};\nexports.satisfies = le;\nexports.maxSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    i.test(e) && (r && -1 !== o.compare(e) || (o = new SemVer(r = e, n)));\n  });\n  return r;\n};\nexports.minSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    i.test(e) && (r && 1 !== o.compare(e) || (o = new SemVer(r = e, n)));\n  });\n  return r;\n};\nexports.minVersion = function (e, t) {\n  e = new ie(e, t);\n  var n = new SemVer(\"0.0.0\");\n  if (e.test(n)) return n;\n  n = new SemVer(\"0.0.0-0\");\n  if (e.test(n)) return n;\n  n = null;\n  for (var r = 0; r < e.set.length; ++r) e.set[r].forEach(function (e) {\n    var t = new SemVer(e.semver.version);\n    switch (e.operator) {\n      case \">\":\n        0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0);\n        t.raw = t.format();\n      case \"\":\n      case \">=\":\n        n && !gt(n, t) || (n = t);\n        break;\n      case \"<\":\n      case \"<=\":\n        break;\n      default:\n        throw new Error(\"Unexpected operation: \" + e.operator);\n    }\n  });\n  return n && e.test(n) ? n : null;\n};\nexports.validRange = function (e, t) {\n  try {\n    return new ie(e, t).range || \"*\";\n  } catch (e) {\n    return null;\n  }\n};\nexports.ltr = function (e, t, n) {\n  return ue(e, t, \"<\", n);\n};\nexports.gtr = function (e, t, n) {\n  return ue(e, t, \">\", n);\n};\nexports.outside = ue;\nexports.prerelease = function (e, t) {\n  var n = parse(e, t);\n  return n && n.prerelease.length ? n.prerelease : null;\n};\nexports.intersects = function (e, t, n) {\n  e = new ie(e, n);\n  t = new ie(t, n);\n  return e.intersects(t);\n};\nexports.coerce = function (e) {\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  var t = e.match(o[P]);\n  return null == t ? null : parse(t[1] + \".\" + (t[2] || \"0\") + \".\" + (t[3] || \"0\"));\n};",
  "2277": "require.r(exports);\nrequire.d(exports, {\n  NIL: () => x,\n  parse: () => _,\n  stringify: () => d,\n  v1: () => g,\n  v3: () => v,\n  v4: () => b,\n  v5: () => w,\n  validate: () => l,\n  version: () => E\n});\nvar r = require(6113),\n  o = require.n(r);\nconst i = new Uint8Array(256);\nlet s = i.length;\nfunction a() {\n  s > i.length - 16 && (o().randomFillSync(i), s = 0);\n  return i.slice(s, s += 16);\n}\nconst c = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,\n  l = function (e) {\n    return \"string\" == typeof e && c.test(e);\n  },\n  u = [];\nfor (let e = 0; e < 256; ++e) u.push((e + 256).toString(16).substr(1));\nconst d = function (e, t = 0) {\n  const n = (u[e[t + 0]] + u[e[t + 1]] + u[e[t + 2]] + u[e[t + 3]] + \"-\" + u[e[t + 4]] + u[e[t + 5]] + \"-\" + u[e[t + 6]] + u[e[t + 7]] + \"-\" + u[e[t + 8]] + u[e[t + 9]] + \"-\" + u[e[t + 10]] + u[e[t + 11]] + u[e[t + 12]] + u[e[t + 13]] + u[e[t + 14]] + u[e[t + 15]]).toLowerCase();\n  if (!l(n)) throw TypeError(\"Stringified UUID is invalid\");\n  return n;\n};\nlet p,\n  h,\n  f = 0,\n  m = 0;\nconst g = function (e, t, n) {\n    let r = t && n || 0;\n    const o = t || new Array(16);\n    let i = (e = e || {}).node || p,\n      s = undefined !== e.clockseq ? e.clockseq : h;\n    if (null == i || null == s) {\n      const t = e.random || (e.rng || a)();\n      null == i && (i = p = [1 | t[0], t[1], t[2], t[3], t[4], t[5]]);\n      null == s && (s = h = 16383 & (t[6] << 8 | t[7]));\n    }\n    let c = undefined !== e.msecs ? e.msecs : Date.now(),\n      l = undefined !== e.nsecs ? e.nsecs : m + 1;\n    const u = c - f + (l - m) / 1e4;\n    u < 0 && undefined === e.clockseq && (s = s + 1 & 16383);\n    (u < 0 || c > f) && undefined === e.nsecs && (l = 0);\n    if (l >= 1e4) throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    f = c;\n    m = l;\n    h = s;\n    c += 122192928e5;\n    const g = (1e4 * (268435455 & c) + l) % 4294967296;\n    o[r++] = g >>> 24 & 255;\n    o[r++] = g >>> 16 & 255;\n    o[r++] = g >>> 8 & 255;\n    o[r++] = 255 & g;\n    const _ = c / 4294967296 * 1e4 & 268435455;\n    o[r++] = _ >>> 8 & 255;\n    o[r++] = 255 & _;\n    o[r++] = _ >>> 24 & 15 | 16;\n    o[r++] = _ >>> 16 & 255;\n    o[r++] = s >>> 8 | 128;\n    o[r++] = 255 & s;\n    for (let e = 0; e < 6; ++e) o[r + e] = i[e];\n    return t || d(o);\n  },\n  _ = function (e) {\n    if (!l(e)) throw TypeError(\"Invalid UUID\");\n    let t;\n    const n = new Uint8Array(16);\n    n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24;\n    n[1] = t >>> 16 & 255;\n    n[2] = t >>> 8 & 255;\n    n[3] = 255 & t;\n    n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8;\n    n[5] = 255 & t;\n    n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8;\n    n[7] = 255 & t;\n    n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8;\n    n[9] = 255 & t;\n    n[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255;\n    n[11] = t / 4294967296 & 255;\n    n[12] = t >>> 24 & 255;\n    n[13] = t >>> 16 & 255;\n    n[14] = t >>> 8 & 255;\n    n[15] = 255 & t;\n    return n;\n  };\nfunction y(e, t, n) {\n  function r(e, r, o, i) {\n    \"string\" == typeof e && (e = function (e) {\n      e = unescape(encodeURIComponent(e));\n      const t = [];\n      for (let n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));\n      return t;\n    }(e));\n    \"string\" == typeof r && (r = _(r));\n    if (16 !== r.length) throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n    let s = new Uint8Array(16 + e.length);\n    s.set(r);\n    s.set(e, r.length);\n    s = n(s);\n    s[6] = 15 & s[6] | t;\n    s[8] = 63 & s[8] | 128;\n    if (o) {\n      i = i || 0;\n      for (let e = 0; e < 16; ++e) o[i + e] = s[e];\n      return o;\n    }\n    return d(s);\n  }\n  try {\n    r.name = e;\n  } catch (e) {}\n  r.DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n  r.URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\n  return r;\n}\nconst v = y(\"v3\", 48, function (e) {\n    Array.isArray(e) ? e = Buffer.from(e) : \"string\" == typeof e && (e = Buffer.from(e, \"utf8\"));\n    return o().createHash(\"md5\").update(e).digest();\n  }),\n  b = function (e, t, n) {\n    const r = (e = e || {}).random || (e.rng || a)();\n    r[6] = 15 & r[6] | 64;\n    r[8] = 63 & r[8] | 128;\n    if (t) {\n      n = n || 0;\n      for (let e = 0; e < 16; ++e) t[n + e] = r[e];\n      return t;\n    }\n    return d(r);\n  },\n  w = y(\"v5\", 80, function (e) {\n    Array.isArray(e) ? e = Buffer.from(e) : \"string\" == typeof e && (e = Buffer.from(e, \"utf8\"));\n    return o().createHash(\"sha1\").update(e).digest();\n  }),\n  x = \"00000000-0000-0000-0000-000000000000\",\n  E = function (e) {\n    if (!l(e)) throw TypeError(\"Invalid UUID\");\n    return parseInt(e.substr(14, 1), 16);\n  };",
  "2279": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.postRequest = exports.Response = exports.HelixFetcher = exports.isAbortError = exports.Fetcher = exports.init = undefined;\nconst r = require(9825),\n  o = require(6149),\n  i = require(3837),\n  s = require(1133),\n  a = require(5413),\n  c = require(6333);\nlet l,\n  u = !1;\nexports.init = function (e) {\n  if (u) {\n    if (e !== l) throw new Error(`Networking re-initialized with mismatched version (old: ${l}, new: ${e})`);\n  } else {\n    l = e;\n    u = !0;\n  }\n};\nclass Fetcher {}\nexports.Fetcher = Fetcher;\nexports.isAbortError = function (e) {\n  return e instanceof r.AbortError;\n};\nexports.HelixFetcher = class extends Fetcher {\n  constructor(e) {\n    super();\n    this.ctx = e;\n    this.createSocketFactory = e => {\n      const t = o.httpOverHttp({\n        proxy: e\n      });\n      return e => new Promise(n => {\n        t.createSocket(e, e => {\n          n(e);\n        });\n      });\n    };\n    this.fetchApi = this.createFetchApi(e);\n  }\n  set proxySettings(e) {\n    this._proxySettings = e;\n    this.fetchApi = this.createFetchApi(this.ctx);\n  }\n  get proxySettings() {\n    return this._proxySettings;\n  }\n  createFetchApi(e) {\n    var t;\n    const n = e.get(s.BuildInfo);\n    !1 === (null === (t = this._proxySettings) || undefined === t ? undefined : t.rejectUnauthorized) && (process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\");\n    return r.context({\n      userAgent: `GithubCopilot/${n.getVersion()}`,\n      socketFactory: this._proxySettings ? this.createSocketFactory(this._proxySettings) : undefined\n    });\n  }\n  async fetch(e, t) {\n    const n = {\n        ...t,\n        body: t.body ? t.body : t.json,\n        signal: t.signal\n      },\n      r = await this.fetchApi.fetch(e, n);\n    return new Response(r.status, r.statusText, r.headers, () => r.text(), () => r.json(), async () => r.body);\n  }\n  disconnectAll() {\n    return this.fetchApi.reset();\n  }\n  makeAbortController() {\n    return new r.AbortController();\n  }\n};\nclass Response {\n  constructor(e, t, n, r, o, i) {\n    this.status = e;\n    this.statusText = t;\n    this.headers = n;\n    this.getText = r;\n    this.getJson = o;\n    this.getBody = i;\n    this.ok = this.status >= 200 && this.status < 300;\n  }\n  async text() {\n    return this.getText();\n  }\n  async json() {\n    return this.getJson();\n  }\n  async body() {\n    return this.getBody();\n  }\n}\nexports.Response = Response;\nexports.postRequest = function (e, t, n, r, o, l, p) {\n  if (!u) throw new Error(\"Networking must be initialized before being used\");\n  const h = {\n    Authorization: i.format(\"Bearer %s\", n),\n    \"X-Request-Id\": o,\n    \"Openai-Organization\": \"github-copilot\",\n    \"VScode-SessionId\": e.get(s.VscInfo).sessionId,\n    \"VScode-MachineId\": e.get(s.VscInfo).machineId,\n    ...s.editorVersionHeaders(e)\n  };\n  r && (h[\"OpenAI-Intent\"] = r);\n  const f = e.get(a.GhostTextDebounceManager).forceDelayMs;\n  f && (h[\"X-Copilot-Force-Delay\"] = f.toString());\n  const m = {\n      method: \"POST\",\n      headers: h,\n      json: l,\n      timeout: 3e4\n    },\n    g = e.get(Fetcher);\n  if (p) {\n    const t = g.makeAbortController();\n    p.onCancellationRequested(() => {\n      c.telemetry(e, \"networking.cancelRequest\", c.TelemetryData.createAndMarkAsIssued({\n        headerRequestId: o\n      }));\n      t.abort();\n    });\n    m.signal = t.signal;\n  }\n  return g.fetch(t, m).catch(n => {\n    if (\"ECONNRESET\" == n.code || \"ETIMEDOUT\" == n.code || \"ERR_HTTP2_INVALID_SESSION\" == n.code || \"ERR_HTTP2_GOAWAY_SESSION\" == n.message) {\n      c.telemetry(e, \"networking.disconnectAll\");\n      return g.disconnectAll().then(() => g.fetch(t, m));\n    }\n    throw n;\n  });\n};",
  "2296": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(412),\n  o = require(3487),\n  i = require(6776),\n  s = require(6776),\n  a = {\n    keyword: \"patternProperties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(e) {\n      const {\n          gen: t,\n          schema: n,\n          data: a,\n          parentSchema: c,\n          it: l\n        } = e,\n        {\n          opts: u\n        } = l,\n        d = r.allSchemaProperties(n),\n        p = d.filter(e => i.alwaysValidSchema(l, n[e]));\n      if (0 === d.length || p.length === d.length && (!l.opts.unevaluated || !0 === l.props)) return;\n      const h = u.strictSchema && !u.allowMatchingProperties && c.properties,\n        f = t.name(\"valid\");\n      !0 === l.props || l.props instanceof o.Name || (l.props = s.evaluatedPropsToName(t, l.props));\n      const {\n        props: m\n      } = l;\n      function g(e) {\n        for (const t in h) new RegExp(e).test(t) && i.checkStrictMode(l, `property ${t} matches pattern ${e} (use allowMatchingProperties)`);\n      }\n      function _(n) {\n        t.forIn(\"key\", a, i => {\n          t.if(o._`${r.usePattern(e, n)}.test(${i})`, () => {\n            const r = p.includes(n);\n            r || e.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: n,\n              dataProp: i,\n              dataPropType: s.Type.Str\n            }, f);\n            l.opts.unevaluated && !0 !== m ? t.assign(o._`${m}[${i}]`, !0) : r || l.allErrors || t.if(o.not(f), () => t.break());\n          });\n        });\n      }\n      !function () {\n        for (const e of d) {\n          h && g(e);\n          l.allErrors ? _(e) : (t.var(f, !0), _(e), t.if(f));\n        }\n      }();\n    }\n  };\nexports.default = a;",
  "2301": "module.exports = {\n  i8: \"1.3.7\"\n};",
  "2337": "module.exports = function (e, t) {\n  !0 === t && (t = 0);\n  var n = \"\";\n  if (\"string\" == typeof e) try {\n    n = new URL(e).protocol;\n  } catch (e) {} else e && e.constructor === URL && (n = e.protocol);\n  var r = n.split(/\\:|\\+/).filter(Boolean);\n  return \"number\" == typeof t ? r[t] : r;\n};",
  "2361": "module.exports = require(\"events\");",
  "2388": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.launchSolutions = exports.normalizeCompletionText = undefined;\nconst r = require(2277),\n  o = require(6932),\n  i = require(1133),\n  s = require(256),\n  a = require(9899),\n  c = require(3),\n  l = require(937),\n  u = require(6722),\n  d = require(7727),\n  p = require(4969),\n  h = require(2533),\n  f = require(766),\n  m = require(1124),\n  g = require(6333),\n  _ = require(6403),\n  y = new a.Logger(a.LogLevel.INFO, \"solutions\");\nfunction v(e, t, n, r) {\n  return async o => {\n    if (r instanceof Array) {\n      const [i, s] = r;\n      return d.isBlockBodyFinishedWithPrefix(e, t, n, o, s);\n    }\n    return d.isBlockBodyFinished(e, t, n, o);\n  };\n}\nasync function b(e, t, n) {\n  if (t.isCancellationRequested) {\n    e.removeProgress();\n    return {\n      status: \"FinishedWithError\",\n      error: \"Cancelled\"\n    };\n  }\n  const r = await n.next();\n  return !0 === r.done ? (e.removeProgress(), {\n    status: \"FinishedNormally\"\n  }) : {\n    status: \"Solution\",\n    solution: r.value,\n    next: b(e, t, n)\n  };\n}\nexports.normalizeCompletionText = function (e) {\n  return e.replace(/\\s+/g, \"\");\n};\nexports.launchSolutions = async function (e, t) {\n  var n, a, w;\n  const x = t.completionContext.insertPosition,\n    E = t.completionContext.prependToCompletion,\n    C = t.completionContext.indentation,\n    S = e.get(_.LocationFactory),\n    T = await t.getDocument(),\n    k = await p.extractPrompt(e, T, x);\n  if (\"contextTooShort\" === k.type) {\n    t.reportCancelled();\n    return {\n      status: \"FinishedWithError\",\n      error: \"Context too short\"\n    };\n  }\n  const I = k.prompt,\n    P = k.trailingWs;\n  P.length > 0 && (t.startPosition = S.position(t.startPosition.line, t.startPosition.character - P.length));\n  const A = t.getCancellationToken(),\n    O = r.v4();\n  t.savedTelemetryData = g.TelemetryData.createAndMarkAsIssued({\n    headerRequestId: O,\n    languageId: T.languageId,\n    source: s.completionTypeToString(t.completionContext.completionType)\n  }, {\n    ...g.telemetrizePromptLength(I),\n    solutionCount: t.solutionCountTarget,\n    promptEndPos: T.offsetAt(x)\n  });\n  if (t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX) {\n    const e = I.prefix.split(\"\\n\"),\n      t = e.pop(),\n      n = e.pop();\n    if (n) {\n      const r = /^\\W+(todo:?\\s+)/i.exec(n);\n      if (r) {\n        const o = r[1],\n          i = n.replace(o, \"\");\n        I.prefix = e.join(\"\\n\") + \"\\n\" + i + \"\\n\" + t;\n      }\n    }\n  }\n  t.completionContext.completionType === s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX && (I.prefix += t.completionContext.prependToCompletion);\n  y.info(e, `prompt: ${JSON.stringify(I)}`);\n  y.debug(e, `prependToCompletion: ${E}`);\n  g.telemetry(e, \"solution.requested\", t.savedTelemetryData);\n  const N = await e.get(i.BlockModeConfig).forLanguage(e, T.languageId),\n    R = h.isSupportedLanguageId(T.languageId),\n    M = d.contextIndentation(T, x),\n    L = {\n      stream: !0,\n      extra: {\n        language: T.languageId,\n        next_indent: null !== (n = M.next) && undefined !== n ? n : 0\n      }\n    };\n  \"parsing\" !== N || R || (L.stop = [\"\\n\\n\", \"\\r\\n\\r\\n\"]);\n  const $ = f.extractRepoInfoInBackground(e, T.fileName),\n    D = {\n      prompt: I,\n      languageId: T.languageId,\n      repoInfo: $,\n      ourRequestId: O,\n      engineUrl: await c.getEngineURL(e, f.tryGetGitHubNWO($), T.languageId, f.getDogFood($), await f.getUserKind(e), t.savedTelemetryData),\n      count: t.solutionCountTarget,\n      uiKind: l.CopilotUiKind.Panel,\n      postOptions: L,\n      requestLogProbs: !0\n    };\n  let F;\n  const j = t.completionContext.completionType === s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX ? [s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX, t.completionContext.prependToCompletion] : t.completionContext.completionType;\n  switch (N) {\n    case i.BlockMode.Server:\n      F = async e => {};\n      L.extra.force_indent = null !== (a = M.prev) && undefined !== a ? a : -1;\n      L.extra.trim_by_indentation = !0;\n      break;\n    case i.BlockMode.ParsingAndServer:\n      F = R ? v(e, T, t.startPosition, j) : async e => {};\n      L.extra.force_indent = null !== (w = M.prev) && undefined !== w ? w : -1;\n      L.extra.trim_by_indentation = !0;\n      break;\n    case i.BlockMode.Parsing:\n    default:\n      F = R ? v(e, T, t.startPosition, j) : async e => {};\n  }\n  e.get(u.StatusReporter).setProgress();\n  const q = await e.get(l.OpenAIFetcher).fetchAndStreamCompletions(e, D, g.TelemetryData.createAndMarkAsIssued(), F, A);\n  if (\"failed\" === q.type || \"canceled\" === q.type) {\n    t.reportCancelled();\n    e.get(u.StatusReporter).removeProgress();\n    return {\n      status: \"FinishedWithError\",\n      error: `${q.type}: ${q.reason}`\n    };\n  }\n  let B = q.choices;\n  B = async function* (e, t) {\n    for await (const n of e) {\n      const e = {\n        ...n\n      };\n      e.completionText = t + e.completionText.trimRight();\n      yield e;\n    }\n  }(B, E);\n  null !== C && (B = l.cleanupIndentChoices(B, C));\n  B = o.asyncIterableMapFilter(B, async t => m.postProcessChoice(e, \"solution\", T, x, t, !1, y));\n  const U = o.asyncIterableMapFilter(B, async n => {\n    let r = n.completionText;\n    y.info(e, `Open Copilot completion: [${n.completionText}]`);\n    if (t.completionContext.completionType === s.CompletionType.OPEN_COPILOT || t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX) {\n      let t = \"\";\n      const o = await (0, d.getNodeStart)(e, T, x, n.completionText);\n      if (o) [t] = (0, p.trimLastLine)(T.getText(S.range(S.position(o.line, o.character), x)));else {\n        const e = S.position(x.line, 0);\n        t = T.getText(S.range(e, x));\n      }\n      r = t + r;\n    }\n    let o = n.completionText;\n    t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX && (T.lineAt(x.line).isEmptyOrWhitespace || (o += \"\\n\"));\n    P.length > 0 && o.startsWith(P) && (o = o.substring(P.length));\n    const i = n.meanLogProb;\n    return {\n      displayText: r,\n      meanProb: undefined !== i ? Math.exp(i) : 0,\n      meanLogProb: i || 0,\n      completionText: o,\n      requestId: n.requestId,\n      choiceIndex: n.choiceIndex,\n      prependToCompletion: E\n    };\n  });\n  return b(e.get(u.StatusReporter), A, U[Symbol.asyncIterator]());\n};",
  "2422": "var r;\nr = require(8249);\n(function () {\n  if (\"function\" == typeof ArrayBuffer) {\n    var e = r.lib.WordArray,\n      t = e.init,\n      n = e.init = function (e) {\n        e instanceof ArrayBuffer && (e = new Uint8Array(e));\n        (e instanceof Int8Array || \"undefined\" != typeof Uint8ClampedArray && e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array || e instanceof Float64Array) && (e = new Uint8Array(e.buffer, e.byteOffset, e.byteLength));\n        if (e instanceof Uint8Array) {\n          for (var n = e.byteLength, r = [], o = 0; o < n; o++) r[o >>> 2] |= e[o] << 24 - o % 4 * 8;\n          t.call(this, r, n);\n        } else t.apply(this, arguments);\n      };\n    n.prototype = e;\n  }\n})();\nmodule.exports = r.lib.WordArray;",
  "2447": "module.exports = function (e) {\n  function t(e) {\n    let n,\n      o,\n      i,\n      s = null;\n    function a(...e) {\n      if (!a.enabled) return;\n      const r = a,\n        o = Number(new Date()),\n        i = o - (n || o);\n      r.diff = i;\n      r.prev = n;\n      r.curr = o;\n      n = o;\n      e[0] = t.coerce(e[0]);\n      \"string\" != typeof e[0] && e.unshift(\"%O\");\n      let s = 0;\n      e[0] = e[0].replace(/%([a-zA-Z%])/g, (n, o) => {\n        if (\"%%\" === n) return \"%\";\n        s++;\n        const i = t.formatters[o];\n        if (\"function\" == typeof i) {\n          const t = e[s];\n          n = i.call(r, t);\n          e.splice(s, 1);\n          s--;\n        }\n        return n;\n      });\n      t.formatArgs.call(r, e);\n      (r.log || t.log).apply(r, e);\n    }\n    a.namespace = e;\n    a.useColors = t.useColors();\n    a.color = t.selectColor(e);\n    a.extend = r;\n    a.destroy = t.destroy;\n    Object.defineProperty(a, \"enabled\", {\n      enumerable: !0,\n      configurable: !1,\n      get: () => null !== s ? s : (o !== t.namespaces && (o = t.namespaces, i = t.enabled(e)), i),\n      set: e => {\n        s = e;\n      }\n    });\n    \"function\" == typeof t.init && t.init(a);\n    return a;\n  }\n  function r(e, n) {\n    const r = t(this.namespace + (undefined === n ? \":\" : n) + e);\n    r.log = this.log;\n    return r;\n  }\n  function o(e) {\n    return e.toString().substring(2, e.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n  }\n  t.debug = t;\n  t.default = t;\n  t.coerce = function (e) {\n    return e instanceof Error ? e.stack || e.message : e;\n  };\n  t.disable = function () {\n    const e = [...t.names.map(o), ...t.skips.map(o).map(e => \"-\" + e)].join(\",\");\n    t.enable(\"\");\n    return e;\n  };\n  t.enable = function (e) {\n    let n;\n    t.save(e);\n    t.namespaces = e;\n    t.names = [];\n    t.skips = [];\n    const r = (\"string\" == typeof e ? e : \"\").split(/[\\s,]+/),\n      o = r.length;\n    for (n = 0; n < o; n++) r[n] && (\"-\" === (e = r[n].replace(/\\*/g, \".*?\"))[0] ? t.skips.push(new RegExp(\"^\" + e.slice(1) + \"$\")) : t.names.push(new RegExp(\"^\" + e + \"$\")));\n  };\n  t.enabled = function (e) {\n    if (\"*\" === e[e.length - 1]) return !0;\n    let n, r;\n    for (n = 0, r = t.skips.length; n < r; n++) if (t.skips[n].test(e)) return !1;\n    for (n = 0, r = t.names.length; n < r; n++) if (t.names[n].test(e)) return !0;\n    return !1;\n  };\n  t.humanize = require(7824);\n  t.destroy = function () {\n    console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n  };\n  Object.keys(e).forEach(n => {\n    t[n] = e[n];\n  });\n  t.names = [];\n  t.skips = [];\n  t.formatters = {};\n  t.selectColor = function (e) {\n    let n = 0;\n    for (let t = 0; t < e.length; t++) {\n      n = (n << 5) - n + e.charCodeAt(t);\n      n |= 0;\n    }\n    return t.colors[Math.abs(n) % t.colors.length];\n  };\n  t.enable(t.load());\n  return t;\n};",
  "2495": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(4953),\n  o = require(2781);\nexports.console = {\n  versionSpecifier: \">= 4.0.0\",\n  patch: function (e) {\n    var t = new o.Writable(),\n      n = new o.Writable();\n    t.write = function (e) {\n      if (!e) return !0;\n      var t = e.toString();\n      r.channel.publish(\"console\", {\n        message: t\n      });\n      return !0;\n    };\n    n.write = function (e) {\n      if (!e) return !0;\n      var t = e.toString();\n      r.channel.publish(\"console\", {\n        message: t,\n        stderr: !0\n      });\n      return !0;\n    };\n    for (var i = new e.Console(t, n), s = function (t) {\n        var n = e[t];\n        n && (e[t] = function () {\n          if (i[t]) try {\n            i[t].apply(i, arguments);\n          } catch (e) {}\n          return n.apply(e, arguments);\n        });\n      }, a = 0, c = [\"log\", \"info\", \"warn\", \"error\", \"dir\", \"time\", \"timeEnd\", \"trace\", \"assert\"]; a < c.length; a++) s(c[a]);\n    return e;\n  }\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"console\", exports.console);\n  require(6206);\n};",
  "2499": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.redactPaths = undefined;\nexports.redactPaths = function (e) {\n  return e.replace(/([\\s|(]|file:\\/\\/)(\\/[^\\s]+)/g, \"$1[redacted]\").replace(/([\\s|(]|file:\\/\\/)([a-zA-Z]:[(\\\\|/){1,2}][^\\s]+)/gi, \"$1[redacted]\").replace(/([\\s|(]|file:\\/\\/)(\\\\[^\\s]+)/gi, \"$1[redacted]\");\n};",
  "2500": "const {\n    Readable: r\n  } = require(2781),\n  {\n    Headers: o\n  } = require(9872),\n  {\n    Response: i\n  } = require(2981),\n  s = Symbol(\"CacheableResponse internals\");\nclass a extends i {\n  constructor(e, t) {\n    super(e, t);\n    const n = new o(t.headers);\n    this[s] = {\n      headers: n,\n      bufferedBody: e\n    };\n  }\n  get headers() {\n    return this[s].headers;\n  }\n  set headers(e) {\n    if (!(e instanceof o)) throw new TypeError(\"instance of Headers expected\");\n    this[s].headers = e;\n  }\n  get body() {\n    return r.from(this[s].bufferedBody);\n  }\n  get bodyUsed() {\n    return !1;\n  }\n  async buffer() {\n    return this[s].bufferedBody;\n  }\n  async arrayBuffer() {\n    return (e = this[s].bufferedBody).buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n    var e;\n  }\n  async text() {\n    return this[s].bufferedBody.toString();\n  }\n  async json() {\n    return JSON.parse(await this.text());\n  }\n  clone() {\n    const {\n      url: e,\n      status: t,\n      statusText: n,\n      headers: r,\n      httpVersion: o,\n      decoded: i,\n      counter: c\n    } = this;\n    return new a(this[s].bufferedBody, {\n      url: e,\n      status: t,\n      statusText: n,\n      headers: r,\n      httpVersion: o,\n      decoded: i,\n      counter: c\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nmodule.exports = {\n  cacheableResponse: async e => {\n    const t = await e.buffer(),\n      {\n        url: n,\n        status: r,\n        statusText: o,\n        headers: i,\n        httpVersion: s,\n        decoded: c,\n        counter: l\n      } = e;\n    return new a(t, {\n      url: n,\n      status: r,\n      statusText: o,\n      headers: i,\n      httpVersion: s,\n      decoded: c,\n      counter: l\n    });\n  }\n};",
  "2512": "if (global._stackChain) {\n  if (global._stackChain.version !== require(2301).i8) throw new Error(\"Conflicting version of stack-chain found\");\n  module.exports = global._stackChain;\n} else module.exports = global._stackChain = require(7898);",
  "2531": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = undefined;\nconst r = require(6776),\n  o = require(4063),\n  i = require(9461),\n  s = require(540),\n  a = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\nexports.inlineRef = function (e, t = !0) {\n  return \"boolean\" == typeof e || (!0 === t ? !l(e) : !!t && u(e) <= t);\n};\nconst c = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\nfunction l(e) {\n  for (const t in e) {\n    if (c.has(t)) return !0;\n    const n = e[t];\n    if (Array.isArray(n) && n.some(l)) return !0;\n    if (\"object\" == typeof n && l(n)) return !0;\n  }\n  return !1;\n}\nfunction u(e) {\n  let t = 0;\n  for (const n in e) {\n    if (\"$ref\" === n) return 1 / 0;\n    t++;\n    if (!a.has(n) && (\"object\" == typeof e[n] && (0, r.eachItem)(e[n], e => t += u(e)), t === 1 / 0)) return 1 / 0;\n  }\n  return t;\n}\nfunction getFullPath(e = \"\", t) {\n  !1 !== t && (e = normalizeId(e));\n  return _getFullPath(s.parse(e));\n}\nfunction _getFullPath(e) {\n  return s.serialize(e).split(\"#\")[0] + \"#\";\n}\nexports.getFullPath = getFullPath;\nexports._getFullPath = _getFullPath;\nconst h = /#\\/?$/;\nfunction normalizeId(e) {\n  return e ? e.replace(h, \"\") : \"\";\n}\nexports.normalizeId = normalizeId;\nexports.resolveUrl = function (e, t) {\n  t = normalizeId(t);\n  return s.resolve(e, t);\n};\nconst m = /^[a-z_][-a-z0-9._]*$/i;\nexports.getSchemaRefs = function (e, t) {\n  if (\"boolean\" == typeof e) return {};\n  const {\n      schemaId: n\n    } = this.opts,\n    r = normalizeId(e[n] || t),\n    a = {\n      \"\": r\n    },\n    c = getFullPath(r, !1),\n    l = {},\n    u = new Set();\n  i(e, {\n    allKeys: !0\n  }, (e, t, r, o) => {\n    if (undefined === o) return;\n    const i = c + t;\n    let d = a[o];\n    function g(t) {\n      t = normalizeId(d ? s.resolve(d, t) : t);\n      if (u.has(t)) throw h(t);\n      u.add(t);\n      let n = this.refs[t];\n      \"string\" == typeof n && (n = this.refs[n]);\n      \"object\" == typeof n ? p(e, n.schema, t) : t !== normalizeId(i) && (\"#\" === t[0] ? (p(e, l[t], t), l[t] = e) : this.refs[t] = i);\n      return t;\n    }\n    function _(e) {\n      if (\"string\" == typeof e) {\n        if (!m.test(e)) throw new Error(`invalid anchor \"${e}\"`);\n        g.call(this, `#${e}`);\n      }\n    }\n    \"string\" == typeof e[n] && (d = g.call(this, e[n]));\n    _.call(this, e.$anchor);\n    _.call(this, e.$dynamicAnchor);\n    a[t] = d;\n  });\n  return l;\n  function p(e, t, n) {\n    if (undefined !== t && !o(e, t)) throw h(n);\n  }\n  function h(e) {\n    return new Error(`reference \"${e}\" resolves to more than one schema`);\n  }\n};",
  "2533": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.parsesWithoutError = exports.getPrompt = exports.getNodeStart = exports.getFunctionPositions = exports.getBlockCloseToken = exports.isSupportedLanguageId = exports.isBlockBodyFinished = exports.isEmptyBlockStart = exports.terminate = exports.init = undefined;\nconst r = require(3055);\nlet o = null;\nconst i = new Map();\nlet s = 0;\nexports.init = function (t, u, d) {\n  if (!u) {\n    const t = require(4723);\n    for (const n of [...a, ...c]) module.exports[n] = t[n];\n    return;\n  }\n  for (const n of a) module.exports[n] = l(t, d, n);\n  module.exports.getPrompt = function (e, t) {\n    return function (n, ...r) {\n      const a = s++;\n      return new Promise((n, s) => {\n        i.set(a, {\n          resolve: n,\n          reject: s\n        });\n        t.debug(e, `Proxy getPrompt - ${a}`);\n        null == o || o.postMessage({\n          id: a,\n          fn: \"getPrompt\",\n          args: r\n        });\n      });\n    };\n  }(t, d);\n  o = r.createWorker();\n  i.clear();\n  s = 0;\n  const p = t.get(r.FileSystem);\n  function h(e) {\n    d.error(t, e);\n    for (const t of i.values()) t.reject(e);\n    i.clear();\n  }\n  o.on(\"message\", ({\n    id: e,\n    err: n,\n    res: r\n  }) => {\n    const o = i.get(e);\n    d.debug(t, `Response ${e} - ${r}, ${n}`);\n    o && (i.delete(e), n ? o.reject(n) : o.resolve(r));\n  });\n  o.on(\"error\", h);\n  o.on(\"exit\", e => {\n    0 !== e && h(new Error(`Worker thread exited with code ${e}.`));\n  });\n  o.on(\"readFileReq\", e => {\n    d.debug(t, `READ_FILE_REQ - ${e}`);\n    p.readFile(e).then(e => {\n      null == o || o.emit(\"readFileRes\", e);\n    }).catch(h);\n  });\n  o.on(\"mtimeRes\", e => {\n    d.debug(t, `mTime_REQ - ${e}`);\n    p.mtime(e).then(e => {\n      null == o || o.emit(\"mtimeRes\", e);\n    }).catch(h);\n  });\n};\nexports.terminate = function () {\n  o && (o.removeAllListeners(), o.terminate(), o = null, i.clear());\n};\nconst a = [\"getFunctionPositions\", \"isEmptyBlockStart\", \"isBlockBodyFinished\", \"getNodeStart\", \"parsesWithoutError\"],\n  c = [\"isSupportedLanguageId\", \"getBlockCloseToken\"];\nfunction l(e, t, n) {\n  return function (...r) {\n    const a = s++;\n    return new Promise((s, c) => {\n      i.set(a, {\n        resolve: s,\n        reject: c\n      });\n      t.debug(e, `Proxy ${n}`);\n      null == o || o.postMessage({\n        id: a,\n        fn: n,\n        args: r\n      });\n    });\n  };\n}\nexports.isEmptyBlockStart = r.isEmptyBlockStart;\nexports.isBlockBodyFinished = r.isBlockBodyFinished;\nexports.isSupportedLanguageId = r.isSupportedLanguageId;\nexports.getBlockCloseToken = r.getBlockCloseToken;\nexports.getFunctionPositions = r.getFunctionPositions;\nexports.getNodeStart = r.getNodeStart;\nexports.getPrompt = r.getPrompt;\nexports.parsesWithoutError = r.parsesWithoutError;",
  "2588": "var r = require(7147),\n  o = require(2037),\n  i = require(1017),\n  s = require(9796),\n  a = require(2081),\n  c = require(5282),\n  l = require(8723),\n  u = require(5740),\n  d = function () {\n    function e(t, n, o) {\n      this._config = t;\n      this._onSuccess = n;\n      this._onError = o;\n      this._enableDiskRetryMode = !1;\n      this._resendInterval = e.WAIT_BETWEEN_RESEND;\n      this._maxBytesOnDisk = e.MAX_BYTES_ON_DISK;\n      this._numConsecutiveFailures = 0;\n      if (!e.OS_PROVIDES_FILE_PROTECTION) if (e.USE_ICACLS) {\n        try {\n          e.OS_PROVIDES_FILE_PROTECTION = r.existsSync(e.ICACLS_PATH);\n        } catch (e) {}\n        e.OS_PROVIDES_FILE_PROTECTION || c.warn(e.TAG, \"Could not find ICACLS in expected location! This is necessary to use disk retry mode on Windows.\");\n      } else e.OS_PROVIDES_FILE_PROTECTION = !0;\n    }\n    e.prototype.setDiskRetryMode = function (t, n, r) {\n      this._enableDiskRetryMode = e.OS_PROVIDES_FILE_PROTECTION && t;\n      \"number\" == typeof n && n >= 0 && (this._resendInterval = Math.floor(n));\n      \"number\" == typeof r && r >= 0 && (this._maxBytesOnDisk = Math.floor(r));\n      t && !e.OS_PROVIDES_FILE_PROTECTION && (this._enableDiskRetryMode = !1, c.warn(e.TAG, \"Ignoring request to enable disk retry mode. Sufficient file protection capabilities were not detected.\"));\n    };\n    e.prototype.send = function (t, n) {\n      var r = this,\n        o = this._config.endpointUrl,\n        i = {\n          method: \"POST\",\n          withCredentials: !1,\n          headers: {\n            \"Content-Type\": \"application/x-json-stream\"\n          }\n        };\n      s.gzip(t, function (s, a) {\n        var d = a;\n        s ? (c.warn(s), d = t, i.headers[\"Content-Length\"] = t.length.toString()) : (i.headers[\"Content-Encoding\"] = \"gzip\", i.headers[\"Content-Length\"] = a.length);\n        c.info(e.TAG, i);\n        i[l.disableCollectionRequestOption] = !0;\n        var p = u.makeRequest(r._config, o, i, function (o) {\n          o.setEncoding(\"utf-8\");\n          var i = \"\";\n          o.on(\"data\", function (e) {\n            i += e;\n          });\n          o.on(\"end\", function () {\n            r._numConsecutiveFailures = 0;\n            c.info(e.TAG, i);\n            \"function\" == typeof r._onSuccess && r._onSuccess(i);\n            \"function\" == typeof n && n(i);\n            r._enableDiskRetryMode && (200 === o.statusCode ? setTimeout(function () {\n              return r._sendFirstFileOnDisk();\n            }, r._resendInterval).unref() : 408 !== o.statusCode && 429 !== o.statusCode && 439 !== o.statusCode && 500 !== o.statusCode && 503 !== o.statusCode || r._storeToDisk(t));\n          });\n        });\n        p.on(\"error\", function (o) {\n          r._numConsecutiveFailures++;\n          if (!r._enableDiskRetryMode || r._numConsecutiveFailures > 0 && r._numConsecutiveFailures % e.MAX_CONNECTION_FAILURES_BEFORE_WARN == 0) {\n            var i = \"Ingestion endpoint could not be reached. This batch of telemetry items has been lost. Use Disk Retry Caching to enable resending of failed telemetry. Error:\";\n            r._enableDiskRetryMode && (i = \"Ingestion endpoint could not be reached \" + r._numConsecutiveFailures + \" consecutive times. There may be resulting telemetry loss. Most recent error:\"), c.warn(e.TAG, i, o);\n          } else i = \"Transient failure to reach ingestion endpoint. This batch of telemetry items will be retried. Error:\", c.info(e.TAG, i, o);\n          r._onErrorHelper(o);\n          if (\"function\" == typeof n) {\n            var s = \"error sending telemetry\";\n            o && \"function\" == typeof o.toString && (s = o.toString()), n(s);\n          }\n          r._enableDiskRetryMode && r._storeToDisk(t);\n        });\n        p.write(d);\n        p.end();\n      });\n    };\n    e.prototype.saveOnCrash = function (e) {\n      this._enableDiskRetryMode && this._storeToDiskSync(e);\n    };\n    e.prototype._runICACLS = function (t, n) {\n      var r = a.spawn(e.ICACLS_PATH, t, {\n        windowsHide: !0\n      });\n      r.on(\"error\", function (e) {\n        return n(e);\n      });\n      r.on(\"close\", function (e, t) {\n        return n(0 === e ? null : new Error(\"Setting ACL restrictions did not succeed (ICACLS returned code \" + e + \")\"));\n      });\n    };\n    e.prototype._runICACLSSync = function (t) {\n      if (!a.spawnSync) throw new Error(\"Could not synchronously call ICACLS under current version of Node.js\");\n      var n = a.spawnSync(e.ICACLS_PATH, t, {\n        windowsHide: !0\n      });\n      if (n.error) throw n.error;\n      if (0 !== n.status) throw new Error(\"Setting ACL restrictions did not succeed (ICACLS returned code \" + n.status + \")\");\n    };\n    e.prototype._getACLIdentity = function (t) {\n      if (e.ACL_IDENTITY) return t(null, e.ACL_IDENTITY);\n      var n = a.spawn(e.POWERSHELL_PATH, [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"], {\n          windowsHide: !0,\n          stdio: [\"ignore\", \"pipe\", \"pipe\"]\n        }),\n        r = \"\";\n      n.stdout.on(\"data\", function (e) {\n        return r += e;\n      });\n      n.on(\"error\", function (e) {\n        return t(e, null);\n      });\n      n.on(\"close\", function (n, o) {\n        e.ACL_IDENTITY = r && r.trim();\n        return t(0 === n ? null : new Error(\"Getting ACL identity did not succeed (PS returned code \" + n + \")\"), e.ACL_IDENTITY);\n      });\n    };\n    e.prototype._getACLIdentitySync = function () {\n      if (e.ACL_IDENTITY) return e.ACL_IDENTITY;\n      if (a.spawnSync) {\n        var t = a.spawnSync(e.POWERSHELL_PATH, [\"-Command\", \"[System.Security.Principal.WindowsIdentity]::GetCurrent().Name\"], {\n          windowsHide: !0,\n          stdio: [\"ignore\", \"pipe\", \"pipe\"]\n        });\n        if (t.error) throw t.error;\n        if (0 !== t.status) throw new Error(\"Getting ACL identity did not succeed (PS returned code \" + t.status + \")\");\n        e.ACL_IDENTITY = t.stdout && t.stdout.toString().trim();\n        return e.ACL_IDENTITY;\n      }\n      throw new Error(\"Could not synchronously get ACL identity under current version of Node.js\");\n    };\n    e.prototype._getACLArguments = function (e, t) {\n      return [e, \"/grant\", \"*S-1-5-32-544:(OI)(CI)F\", \"/grant\", t + \":(OI)(CI)F\", \"/inheritance:r\"];\n    };\n    e.prototype._applyACLRules = function (t, n) {\n      var r = this;\n      return e.USE_ICACLS ? undefined !== e.ACLED_DIRECTORIES[t] ? n(e.ACLED_DIRECTORIES[t] ? null : new Error(\"Setting ACL restrictions did not succeed (cached result)\")) : (e.ACLED_DIRECTORIES[t] = !1, void this._getACLIdentity(function (o, i) {\n        if (o) {\n          e.ACLED_DIRECTORIES[t] = !1;\n          return n(o);\n        }\n        r._runICACLS(r._getACLArguments(t, i), function (r) {\n          e.ACLED_DIRECTORIES[t] = !r;\n          return n(r);\n        });\n      })) : n(null);\n    };\n    e.prototype._applyACLRulesSync = function (t) {\n      if (e.USE_ICACLS) {\n        if (undefined === e.ACLED_DIRECTORIES[t]) {\n          this._runICACLSSync(this._getACLArguments(t, this._getACLIdentitySync()));\n          return void (e.ACLED_DIRECTORIES[t] = !0);\n        }\n        if (!e.ACLED_DIRECTORIES[t]) throw new Error(\"Setting ACL restrictions did not succeed (cached result)\");\n      }\n    };\n    e.prototype._confirmDirExists = function (e, t) {\n      var n = this;\n      r.lstat(e, function (o, i) {\n        o && \"ENOENT\" === o.code ? r.mkdir(e, function (r) {\n          r && \"EEXIST\" !== r.code ? t(r) : n._applyACLRules(e, t);\n        }) : !o && i.isDirectory() ? n._applyACLRules(e, t) : t(o || new Error(\"Path existed but was not a directory\"));\n      });\n    };\n    e.prototype._getShallowDirectorySize = function (e, t) {\n      r.readdir(e, function (n, o) {\n        if (n) return t(n, -1);\n        var s = null,\n          a = 0,\n          c = 0;\n        if (0 !== o.length) for (var l = 0; l < o.length; l++) r.stat(i.join(e, o[l]), function (e, n) {\n          c++;\n          e ? s = e : n.isFile() && (a += n.size);\n          c === o.length && t(s, s ? -1 : a);\n        });else t(null, 0);\n      });\n    };\n    e.prototype._getShallowDirectorySizeSync = function (e) {\n      for (var t = r.readdirSync(e), n = 0, o = 0; o < t.length; o++) n += r.statSync(i.join(e, t[o])).size;\n      return n;\n    };\n    e.prototype._storeToDisk = function (t) {\n      var n = this,\n        s = i.join(o.tmpdir(), e.TEMPDIR_PREFIX + this._config.instrumentationKey);\n      c.info(e.TAG, \"Checking existance of data storage directory: \" + s);\n      this._confirmDirExists(s, function (o) {\n        if (o) {\n          c.warn(e.TAG, \"Error while checking/creating directory: \" + (o && o.message));\n          return void n._onErrorHelper(o);\n        }\n        n._getShallowDirectorySize(s, function (o, a) {\n          if (o || a < 0) {\n            c.warn(e.TAG, \"Error while checking directory size: \" + (o && o.message));\n            return void n._onErrorHelper(o);\n          }\n          if (a > n._maxBytesOnDisk) c.warn(e.TAG, \"Not saving data due to max size limit being met. Directory size in bytes is: \" + a);else {\n            var l = new Date().getTime() + \".ai.json\",\n              u = i.join(s, l);\n            c.info(e.TAG, \"saving data to disk at: \" + u);\n            r.writeFile(u, t, {\n              mode: 384\n            }, function (e) {\n              return n._onErrorHelper(e);\n            });\n          }\n        });\n      });\n    };\n    e.prototype._storeToDiskSync = function (t) {\n      var n = i.join(o.tmpdir(), e.TEMPDIR_PREFIX + this._config.instrumentationKey);\n      try {\n        c.info(e.TAG, \"Checking existance of data storage directory: \" + n);\n        r.existsSync(n) || r.mkdirSync(n);\n        this._applyACLRulesSync(n);\n        var s = this._getShallowDirectorySizeSync(n);\n        if (s > this._maxBytesOnDisk) return void c.info(e.TAG, \"Not saving data due to max size limit being met. Directory size in bytes is: \" + s);\n        var a = new Date().getTime() + \".ai.json\",\n          l = i.join(n, a);\n        c.info(e.TAG, \"saving data before crash to disk at: \" + l);\n        r.writeFileSync(l, t, {\n          mode: 384\n        });\n      } catch (t) {\n        c.warn(e.TAG, \"Error while saving data to disk: \" + (t && t.message));\n        this._onErrorHelper(t);\n      }\n    };\n    e.prototype._sendFirstFileOnDisk = function () {\n      var t = this,\n        n = i.join(o.tmpdir(), e.TEMPDIR_PREFIX + this._config.instrumentationKey);\n      r.exists(n, function (e) {\n        e && r.readdir(n, function (e, o) {\n          if (e) t._onErrorHelper(e);else if ((o = o.filter(function (e) {\n            return i.basename(e).indexOf(\".ai.json\") > -1;\n          })).length > 0) {\n            var s = o[0],\n              a = i.join(n, s);\n            r.readFile(a, function (e, n) {\n              e ? t._onErrorHelper(e) : r.unlink(a, function (e) {\n                e ? t._onErrorHelper(e) : t.send(n);\n              });\n            });\n          }\n        });\n      });\n    };\n    e.prototype._onErrorHelper = function (e) {\n      \"function\" == typeof this._onError && this._onError(e);\n    };\n    e.TAG = \"Sender\";\n    e.ICACLS_PATH = process.env.systemdrive + \"/windows/system32/icacls.exe\";\n    e.POWERSHELL_PATH = process.env.systemdrive + \"/windows/system32/windowspowershell/v1.0/powershell.exe\";\n    e.ACLED_DIRECTORIES = {};\n    e.ACL_IDENTITY = null;\n    e.WAIT_BETWEEN_RESEND = 6e4;\n    e.MAX_BYTES_ON_DISK = 5e7;\n    e.MAX_CONNECTION_FAILURES_BEFORE_WARN = 5;\n    e.TEMPDIR_PREFIX = \"appInsights-node\";\n    e.OS_PROVIDES_FILE_PROTECTION = !1;\n    e.USE_ICACLS = \"Windows_NT\" === o.type();\n    return e;\n  }();\nmodule.exports = d;",
  "2626": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\n(function (e) {\n  for (var n in e) exports.hasOwnProperty(n) || (exports[n] = e[n]);\n})(require(5481));",
  "2649": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3983),\n  o = require(430),\n  i = require(3229),\n  s = require(4336),\n  a = require(498),\n  c = require(3301),\n  l = require(1687),\n  u = require(2958),\n  d = require(4693),\n  p = require(966),\n  h = [r.default, o.default, i.default, s.default, a.default, c.default, l.default, u.default, {\n    keyword: \"type\",\n    schemaType: [\"string\", \"array\"]\n  }, {\n    keyword: \"nullable\",\n    schemaType: \"boolean\"\n  }, d.default, p.default];\nexports.default = h;",
  "2728": "exports.getArg = function (e, t, n) {\n  if (t in e) return e[t];\n  if (3 === arguments.length) return n;\n  throw new Error('\"' + t + '\" is a required argument.');\n};\nvar n = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/,\n  r = /^data:.+\\,.+$/;\nfunction urlParse(e) {\n  var t = e.match(n);\n  return t ? {\n    scheme: t[1],\n    auth: t[2],\n    host: t[3],\n    port: t[4],\n    path: t[5]\n  } : null;\n}\nfunction urlGenerate(e) {\n  var t = \"\";\n  e.scheme && (t += e.scheme + \":\");\n  t += \"//\";\n  e.auth && (t += e.auth + \"@\");\n  e.host && (t += e.host);\n  e.port && (t += \":\" + e.port);\n  e.path && (t += e.path);\n  return t;\n}\nfunction normalize(e) {\n  var n = e,\n    r = urlParse(e);\n  if (r) {\n    if (!r.path) return e;\n    n = r.path;\n  }\n  for (var s, a = exports.isAbsolute(n), c = n.split(/\\/+/), l = 0, u = c.length - 1; u >= 0; u--) \".\" === (s = c[u]) ? c.splice(u, 1) : \"..\" === s ? l++ : l > 0 && (\"\" === s ? (c.splice(u + 1, l), l = 0) : (c.splice(u, 2), l--));\n  \"\" === (n = c.join(\"/\")) && (n = a ? \"/\" : \".\");\n  return r ? (r.path = n, urlGenerate(r)) : n;\n}\nfunction join(e, t) {\n  \"\" === e && (e = \".\");\n  \"\" === t && (t = \".\");\n  var n = urlParse(t),\n    a = urlParse(e);\n  a && (e = a.path || \"/\");\n  if (n && !n.scheme) return a && (n.scheme = a.scheme), urlGenerate(n);\n  if (n || t.match(r)) return t;\n  if (a && !a.host && !a.path) {\n    a.host = t;\n    return urlGenerate(a);\n  }\n  var c = \"/\" === t.charAt(0) ? t : normalize(e.replace(/\\/+$/, \"\") + \"/\" + t);\n  return a ? (a.path = c, urlGenerate(a)) : c;\n}\nexports.urlParse = urlParse;\nexports.urlGenerate = urlGenerate;\nexports.normalize = normalize;\nexports.join = join;\nexports.isAbsolute = function (e) {\n  return \"/\" === e.charAt(0) || n.test(e);\n};\nexports.relative = function (e, t) {\n  \"\" === e && (e = \".\");\n  e = e.replace(/\\/$/, \"\");\n  for (var n = 0; 0 !== t.indexOf(e + \"/\");) {\n    var r = e.lastIndexOf(\"/\");\n    if (r < 0) return t;\n    if ((e = e.slice(0, r)).match(/^([^\\/]+:\\/)?\\/*$/)) return t;\n    ++n;\n  }\n  return Array(n + 1).join(\"../\") + t.substr(e.length + 1);\n};\nvar c = !(\"__proto__\" in Object.create(null));\nfunction l(e) {\n  return e;\n}\nfunction u(e) {\n  if (!e) return !1;\n  var t = e.length;\n  if (t < 9) return !1;\n  if (95 !== e.charCodeAt(t - 1) || 95 !== e.charCodeAt(t - 2) || 111 !== e.charCodeAt(t - 3) || 116 !== e.charCodeAt(t - 4) || 111 !== e.charCodeAt(t - 5) || 114 !== e.charCodeAt(t - 6) || 112 !== e.charCodeAt(t - 7) || 95 !== e.charCodeAt(t - 8) || 95 !== e.charCodeAt(t - 9)) return !1;\n  for (var n = t - 10; n >= 0; n--) if (36 !== e.charCodeAt(n)) return !1;\n  return !0;\n}\nfunction d(e, t) {\n  return e === t ? 0 : null === e ? 1 : null === t ? -1 : e > t ? 1 : -1;\n}\nexports.toSetString = c ? l : function (e) {\n  return u(e) ? \"$\" + e : e;\n};\nexports.fromSetString = c ? l : function (e) {\n  return u(e) ? e.slice(1) : e;\n};\nexports.compareByOriginalPositions = function (e, t, n) {\n  var r = d(e.source, t.source);\n  return 0 !== r || 0 != (r = e.originalLine - t.originalLine) || 0 != (r = e.originalColumn - t.originalColumn) || n || 0 != (r = e.generatedColumn - t.generatedColumn) || 0 != (r = e.generatedLine - t.generatedLine) ? r : d(e.name, t.name);\n};\nexports.compareByGeneratedPositionsDeflated = function (e, t, n) {\n  var r = e.generatedLine - t.generatedLine;\n  return 0 !== r || 0 != (r = e.generatedColumn - t.generatedColumn) || n || 0 !== (r = d(e.source, t.source)) || 0 != (r = e.originalLine - t.originalLine) || 0 != (r = e.originalColumn - t.originalColumn) ? r : d(e.name, t.name);\n};\nexports.compareByGeneratedPositionsInflated = function (e, t) {\n  var n = e.generatedLine - t.generatedLine;\n  return 0 !== n || 0 != (n = e.generatedColumn - t.generatedColumn) || 0 !== (n = d(e.source, t.source)) || 0 != (n = e.originalLine - t.originalLine) || 0 != (n = e.originalColumn - t.originalColumn) ? n : d(e.name, t.name);\n};\nexports.parseSourceMapInput = function (e) {\n  return JSON.parse(e.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n};\nexports.computeSourceURL = function (e, t, n) {\n  t = t || \"\";\n  e && (\"/\" !== e[e.length - 1] && \"/\" !== t[0] && (e += \"/\"), t = e + t);\n  if (n) {\n    var r = urlParse(n);\n    if (!r) throw new Error(\"sourceMapURL could not be parsed\");\n    if (r.path) {\n      var c = r.path.lastIndexOf(\"/\");\n      c >= 0 && (r.path = r.path.substring(0, c + 1));\n    }\n    t = join(urlGenerate(r), t);\n  }\n  return normalize(t);\n};",
  "2781": "module.exports = require(\"stream\");",
  "2783": "var r, o, i, s, a, c, l, u;\no = (r = u = require(8249)).lib;\ni = o.WordArray;\ns = o.Hasher;\na = r.algo;\nc = [];\nl = a.SHA1 = s.extend({\n  _doReset: function () {\n    this._hash = new i.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);\n  },\n  _doProcessBlock: function (e, t) {\n    for (var n = this._hash.words, r = n[0], o = n[1], i = n[2], s = n[3], a = n[4], l = 0; l < 80; l++) {\n      if (l < 16) c[l] = 0 | e[t + l];else {\n        var u = c[l - 3] ^ c[l - 8] ^ c[l - 14] ^ c[l - 16];\n        c[l] = u << 1 | u >>> 31;\n      }\n      var d = (r << 5 | r >>> 27) + a + c[l];\n      d += l < 20 ? 1518500249 + (o & i | ~o & s) : l < 40 ? 1859775393 + (o ^ i ^ s) : l < 60 ? (o & i | o & s | i & s) - 1894007588 : (o ^ i ^ s) - 899497514;\n      a = s;\n      s = i;\n      i = o << 30 | o >>> 2;\n      o = r;\n      r = d;\n    }\n    n[0] = n[0] + r | 0;\n    n[1] = n[1] + o | 0;\n    n[2] = n[2] + i | 0;\n    n[3] = n[3] + s | 0;\n    n[4] = n[4] + a | 0;\n  },\n  _doFinalize: function () {\n    var e = this._data,\n      t = e.words,\n      n = 8 * this._nDataBytes,\n      r = 8 * e.sigBytes;\n    t[r >>> 5] |= 128 << 24 - r % 32;\n    t[14 + (r + 64 >>> 9 << 4)] = Math.floor(n / 4294967296);\n    t[15 + (r + 64 >>> 9 << 4)] = n;\n    e.sigBytes = 4 * t.length;\n    this._process();\n    return this._hash;\n  },\n  clone: function () {\n    var e = s.clone.call(this);\n    e._hash = this._hash.clone();\n    return e;\n  }\n});\nr.SHA1 = s._createHelper(l);\nr.HmacSHA1 = s._createHmacHelper(l);\nmodule.exports = u.SHA1;",
  "2807": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.Iso10126 = {\n  pad: function (e, t) {\n    var n = 4 * t,\n      o = n - e.sigBytes % n;\n    e.concat(r.lib.WordArray.random(o - 1)).concat(r.lib.WordArray.create([o << 24], 1));\n  },\n  unpad: function (e) {\n    var t = 255 & e.words[e.sigBytes - 1 >>> 2];\n    e.sigBytes -= t;\n  }\n};\nmodule.exports = r.pad.Iso10126;",
  "2818": "const r = require(2037),\n  o = require(7147),\n  i = require(1595),\n  s = () => {\n    if (\"linux\" !== process.platform) return !1;\n    if (r.release().toLowerCase().includes(\"microsoft\")) return !i();\n    try {\n      return !!o.readFileSync(\"/proc/version\", \"utf8\").toLowerCase().includes(\"microsoft\") && !i();\n    } catch (e) {\n      return !1;\n    }\n  };\nprocess.env.__IS_WSL_TEST__ ? module.exports = s : module.exports = s();",
  "2826": "function n(e, t, n) {\n  var r = e[t];\n  e[t] = e[n];\n  e[n] = r;\n}\nfunction r(e, t, o, i) {\n  if (o < i) {\n    var s = o - 1;\n    n(e, (u = o, d = i, Math.round(u + Math.random() * (d - u))), i);\n    for (var a = e[i], c = o; c < i; c++) t(e[c], a) <= 0 && n(e, s += 1, c);\n    n(e, s + 1, c);\n    var l = s + 1;\n    r(e, t, o, l - 1);\n    r(e, t, l + 1, i);\n  }\n  var u, d;\n}\nexports.U = function (e, t) {\n  r(e, t, 0, e.length - 1);\n};",
  "2901": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.prepareSolutionForReturn = exports.processSSE = exports.splitChunk = undefined;\nconst r = require(9899),\n  o = require(6333),\n  i = require(937),\n  s = new r.Logger(r.LogLevel.INFO, \"streamChoices\");\nfunction splitChunk(e) {\n  const t = e.split(\"\\n\"),\n    n = t.pop();\n  return [t.filter(e => \"\" != e), n];\n}\nexports.splitChunk = splitChunk;\nexports.processSSE = async function* (e, t, n, r, c) {\n  var l, u, d, p, h, f, m, g, _;\n  const y = await t.body();\n  y.setEncoding(\"utf8\");\n  let v = i.getRequestId(t);\n  s.debug(e, `requestId: ${v.headerRequestId}`);\n  const b = {};\n  let w = \"\";\n  for await (const x of y) {\n    if (null == c ? undefined : c.isCancellationRequested) {\n      s.info(e, \"Cancelled after awaiting body chunk\");\n      return void y.destroy();\n    }\n    s.debug(e, \"chunk\", x.toString());\n    const [E, C] = splitChunk(w + x.toString());\n    w = C;\n    for (const a of E) {\n      const w = a.slice(\"data:\".length).trim();\n      if (\"[DONE]\" == w) {\n        for (const [t, n] of Object.entries(b)) {\n          const r = Number(t);\n          if (null != n && (yield {\n            solution: n,\n            finishOffset: undefined,\n            reason: \"DONE\",\n            requestId: v,\n            index: r\n          }, null == c ? undefined : c.isCancellationRequested)) {\n            s.debug(e, \"Cancelled after yielding on DONE\");\n            return void y.destroy();\n          }\n        }\n        return;\n      }\n      let x;\n      try {\n        x = JSON.parse(w);\n      } catch (t) {\n        s.error(e, \"Error parsing JSON stream data\", a);\n        continue;\n      }\n      if (undefined !== x.choices || undefined === x.error) {\n        0 == v.created && (v = i.getRequestId(t, x), 0 == v.created && s.error(e, `Request id invalid, should have \"completionId\" and \"created\": ${v}`, v));\n        for (let t = 0; t < x.choices.length; t++) {\n          const i = x.choices[t];\n          s.debug(e, \"choice\", i);\n          i.index in b || (b[i.index] = {\n            logprobs: [],\n            top_logprobs: [],\n            text: [],\n            text_offset: [],\n            tokens: []\n          });\n          const a = b[i.index];\n          if (null == a) continue;\n          let w;\n          a.text.push(i.text);\n          a.tokens.push(null !== (u = null === (l = i.logprobs) || undefined === l ? undefined : l.tokens) && undefined !== u ? u : []);\n          a.text_offset.push(null !== (p = null === (d = i.logprobs) || undefined === d ? undefined : d.text_offset) && undefined !== p ? p : []);\n          a.logprobs.push(null !== (f = null === (h = i.logprobs) || undefined === h ? undefined : h.token_logprobs) && undefined !== f ? f : []);\n          a.top_logprobs.push(null !== (g = null === (m = i.logprobs) || undefined === m ? undefined : m.top_logprobs) && undefined !== g ? g : []);\n          if ((i.finish_reason || i.text.indexOf(\"\\n\") > -1) && (w = await n(a.text.join(\"\")), null == c ? void 0 : c.isCancellationRequested)) return s.debug(e, \"Cancelled after awaiting finishedCb\"), void y.destroy();\n          if (i.finish_reason || undefined !== w) {\n            const t = null !== (_ = i.finish_reason) && undefined !== _ ? _ : \"client-trimmed\";\n            o.telemetry(e, \"completion.finishReason\", r.extendedBy({\n              completionChoiceFinishReason: t\n            }));\n            yield {\n              solution: a,\n              finishOffset: w,\n              reason: JSON.stringify(i.finish_reason),\n              requestId: v,\n              index: i.index\n            };\n            if (null == c ? void 0 : c.isCancellationRequested) return s.debug(e, \"Cancelled after yielding finished choice\"), void y.destroy();\n            b[i.index] = null;\n          }\n        }\n      } else s.error(e, \"Error in response:\", x.error.message);\n    }\n  }\n  for (const [t, n] of Object.entries(b)) {\n    const r = Number(t);\n    if (null != n && (yield {\n      solution: n,\n      finishOffset: undefined,\n      reason: \"Iteration Done\",\n      requestId: v,\n      index: r\n    }, null == c ? undefined : c.isCancellationRequested)) {\n      s.debug(e, \"Cancelled after yielding after iteration done\");\n      return void y.destroy();\n    }\n  }\n  if (w.length > 0) try {\n    const t = JSON.parse(w);\n    undefined !== t.error && s.error(e, `Error in response: ${t.error.message}`, t.error);\n  } catch (t) {\n    s.error(e, `Error parsing extraData: ${w}`);\n  }\n};\nexports.prepareSolutionForReturn = function (e, t, n) {\n  let r = t.solution.text.join(\"\"),\n    o = !1;\n  undefined !== t.finishOffset && (s.debug(e, `solution ${t.index}: early finish at offset ${t.finishOffset}`), r = r.substring(0, t.finishOffset), o = !0);\n  s.info(e, `solution ${t.index} returned. finish reason: [${t.reason}] finishOffset: [${t.finishOffset}] completionId: [{${t.requestId.completionId}}] created: [{${t.requestId.created}}]`);\n  const a = function (e, t) {\n    const n = {\n      text: t.text.join(\"\"),\n      tokens: t.text\n    };\n    if (0 === t.logprobs.length) return n;\n    const r = t.logprobs.reduce((e, t) => e.concat(t), []),\n      o = t.top_logprobs.reduce((e, t) => e.concat(t), []),\n      i = t.text_offset.reduce((e, t) => e.concat(t), []),\n      s = t.tokens.reduce((e, t) => e.concat(t), []);\n    return {\n      ...n,\n      logprobs: {\n        token_logprobs: r,\n        top_logprobs: o,\n        text_offset: i,\n        tokens: s\n      }\n    };\n  }(0, t.solution);\n  return i.convertToAPIChoice(e, r, a, t.index, t.requestId, o, n);\n};",
  "2924": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(4665),\n  o = {\n    keyword: \"prefixItems\",\n    type: \"array\",\n    schemaType: [\"array\"],\n    before: \"uniqueItems\",\n    code: e => r.validateTuple(e, \"items\")\n  };\nexports.default = o;",
  "2958": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(453),\n  o = require(3487),\n  i = require(6776),\n  s = require(3510),\n  a = {\n    keyword: \"uniqueItems\",\n    type: \"array\",\n    schemaType: \"boolean\",\n    $data: !0,\n    error: {\n      message: ({\n        params: {\n          i: e,\n          j: t\n        }\n      }) => o.str`must NOT have duplicate items (items ## ${t} and ${e} are identical)`,\n      params: ({\n        params: {\n          i: e,\n          j: t\n        }\n      }) => o._`{i: ${e}, j: ${t}}`\n    },\n    code(e) {\n      const {\n        gen: t,\n        data: n,\n        $data: a,\n        schema: c,\n        parentSchema: l,\n        schemaCode: u,\n        it: d\n      } = e;\n      if (!a && !c) return;\n      const p = t.let(\"valid\"),\n        h = l.items ? r.getSchemaTypes(l.items) : [];\n      function f(i, s) {\n        const a = t.name(\"item\"),\n          c = r.checkDataTypes(h, a, d.opts.strictNumbers, r.DataType.Wrong),\n          l = t.const(\"indices\", o._`{}`);\n        t.for(o._`;${i}--;`, () => {\n          t.let(a, o._`${n}[${i}]`);\n          t.if(c, o._`continue`);\n          h.length > 1 && t.if(o._`typeof ${a} == \"string\"`, o._`${a} += \"_\"`);\n          t.if(o._`typeof ${l}[${a}] == \"number\"`, () => {\n            t.assign(s, o._`${l}[${a}]`);\n            e.error();\n            t.assign(p, !1).break();\n          }).code(o._`${l}[${a}] = ${i}`);\n        });\n      }\n      function m(r, a) {\n        const c = i.useFunc(t, s.default),\n          l = t.name(\"outer\");\n        t.label(l).for(o._`;${r}--;`, () => t.for(o._`${a} = ${r}; ${a}--;`, () => t.if(o._`${c}(${n}[${r}], ${n}[${a}])`, () => {\n          e.error();\n          t.assign(p, !1).break(l);\n        })));\n      }\n      e.block$data(p, function () {\n        const r = t.let(\"i\", o._`${n}.length`),\n          i = t.let(\"j\");\n        e.setParams({\n          i: r,\n          j: i\n        });\n        t.assign(p, !0);\n        t.if(o._`${r} > 1`, () => (h.length > 0 && !h.some(e => \"object\" === e || \"array\" === e) ? f : m)(r, i));\n      }, o._`${u} === false`);\n      e.ok(p);\n    }\n  };\nexports.default = a;",
  "2981": "const {\n    Body: r,\n    cloneStream: o,\n    guessContentType: i\n  } = require(5600),\n  {\n    Headers: s\n  } = require(9872),\n  {\n    isPlainObject: a\n  } = require(4544),\n  {\n    isFormData: c,\n    FormDataSerializer: l\n  } = require(9407),\n  u = Symbol(\"Response internals\");\nclass d extends r {\n  constructor(e = null, t = {}) {\n    const n = new s(t.headers);\n    let r = e;\n    if (c(r) && !n.has(\"content-type\")) {\n      const e = new l(r);\n      r = e.stream();\n      n.set(\"content-type\", e.contentType());\n      n.has(\"transfer-encoding\") || n.has(\"content-length\") || n.set(\"content-length\", e.length());\n    }\n    if (null !== r && !n.has(\"content-type\")) if (a(r)) {\n      r = JSON.stringify(r);\n      n.set(\"content-type\", \"application/json\");\n    } else {\n      const e = i(r);\n      e && n.set(\"content-type\", e);\n    }\n    super(r);\n    this[u] = {\n      url: t.url,\n      status: t.status || 200,\n      statusText: t.statusText || \"\",\n      headers: n,\n      httpVersion: t.httpVersion,\n      decoded: t.decoded,\n      counter: t.counter\n    };\n  }\n  get url() {\n    return this[u].url || \"\";\n  }\n  get status() {\n    return this[u].status;\n  }\n  get statusText() {\n    return this[u].statusText;\n  }\n  get ok() {\n    return this[u].status >= 200 && this[u].status < 300;\n  }\n  get redirected() {\n    return this[u].counter > 0;\n  }\n  get headers() {\n    return this[u].headers;\n  }\n  get httpVersion() {\n    return this[u].httpVersion;\n  }\n  get decoded() {\n    return this[u].decoded;\n  }\n  static redirect(e, t = 302) {\n    if (![301, 302, 303, 307, 308].includes(t)) throw new RangeError(\"Invalid status code\");\n    return new d(null, {\n      headers: {\n        location: new URL(e).toString()\n      },\n      status: t\n    });\n  }\n  clone() {\n    if (this.bodyUsed) throw new TypeError(\"Cannot clone: already read\");\n    return new d(o(this), {\n      ...this[u]\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nObject.defineProperties(d.prototype, {\n  url: {\n    enumerable: !0\n  },\n  status: {\n    enumerable: !0\n  },\n  ok: {\n    enumerable: !0\n  },\n  redirected: {\n    enumerable: !0\n  },\n  statusText: {\n    enumerable: !0\n  },\n  headers: {\n    enumerable: !0\n  },\n  clone: {\n    enumerable: !0\n  }\n});\nmodule.exports = {\n  Response: d\n};",
  "2990": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.CopilotPanel = undefined;\nconst r = require(9496),\n  o = require(1133),\n  i = require(4197),\n  s = require(256),\n  a = require(893),\n  c = require(7017),\n  l = require(3060);\nexports.CopilotPanel = class {\n  constructor(e) {\n    this._onDidChange = new r.EventEmitter();\n    this._documents = new Map();\n    this._editorDecoration = r.window.createTextEditorDecorationType({\n      textDecoration: \"underline\"\n    });\n    this._ctx = e;\n    this._subscriptions = r.workspace.onDidCloseTextDocument(e => {\n      e.isClosed && e.uri.scheme == i.CopilotScheme && this._documents.delete(e.uri.toString());\n    });\n  }\n  dispose() {\n    this._subscriptions.dispose();\n    this._documents.clear();\n    this._editorDecoration.dispose();\n    this._onDidChange.dispose();\n  }\n  get onDidChange() {\n    return this._onDidChange.event;\n  }\n  async provideTextDocumentContent(e) {\n    var t;\n    let n = null === (t = this._documents.get(e.toString())) || undefined === t ? undefined : t.model;\n    if (n) return n.value;\n    const i = new r.CancellationTokenSource(),\n      [c, l] = s.decodeLocation(this._ctx, e),\n      u = await r.workspace.openTextDocument(c);\n    n = new a.CopilotListDocument(this._ctx, e, u, l, o.getConfig(this._ctx, o.ConfigKey.ListCount), i.token);\n    n.onDidResultUpdated(e => this._onDidChange.fire(e));\n    this._documents.set(e.toString(), {\n      model: n,\n      cts: i\n    });\n    n.runQuery();\n    return n.value;\n  }\n  getCodeLens(e) {\n    const t = e.model;\n    let n = t.numberHeaderLines;\n    const o = t.completionContext.insertPosition,\n      i = a.CopilotListDocument.separator.split(\"\\n\").length - 1;\n    return t.solutions().map((a, u) => {\n      const d = new r.Position(n + i, 0),\n        p = new r.Position(n + a.displayLines.length - 1, 0),\n        h = t.savedTelemetryData.extendedBy({\n          choiceIndex: a.choiceIndex.toString()\n        }, {\n          compCharLen: a.completionText.length,\n          meanProb: a.meanProb,\n          rank: u\n        });\n      h.extendWithRequestId(a.requestId);\n      h.markAsDisplayed();\n      const f = new r.CodeLens(new r.Range(d, p), {\n        title: \"Accept Solution\",\n        tooltip: \"Replace code with this solution\",\n        command: l.CMDAcceptPanelSolution,\n        arguments: [t.targetUri, o, a.completionText, t.completionContext.completionType === s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX, async () => {\n          const n = (await r.workspace.openTextDocument(t.targetUri)).offsetAt(o);\n          e.cts.cancel();\n          await c.postInsertionTasks(this._ctx, \"solution\", a.completionText, n, t.targetUri, h);\n        }]\n      });\n      n += a.displayLines.length;\n      return f;\n    });\n  }\n  provideCodeLenses(e, t) {\n    const n = this._documents.get(e.uri.toString());\n    if (n) return this.getCodeLens(n);\n  }\n};",
  "3054": "var t = function () {\n  function e() {}\n  e.prototype.getUrl = function () {\n    return this.url;\n  };\n  e.prototype.RequestParser = function () {\n    this.startTime = +new Date();\n  };\n  e.prototype._setStatus = function (e, t) {\n    var n = +new Date();\n    this.duration = n - this.startTime;\n    this.statusCode = e;\n    var r = this.properties || {};\n    if (t) if (\"string\" == typeof t) r.error = t;else if (t instanceof Error) r.error = t.message;else if (\"object\" == typeof t) for (var o in t) r[o] = t[o] && t[o].toString && t[o].toString();\n    this.properties = r;\n  };\n  e.prototype._isSuccess = function () {\n    return 0 < this.statusCode && this.statusCode < 400;\n  };\n  return e;\n}();\nmodule.exports = t;",
  "3055": "var r, o, i;\nr = {\n  271: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.defaultFileSystem = t.FileSystem = undefined;\n    const r = n(747);\n    t.FileSystem = class {};\n    t.defaultFileSystem = {\n      readFile: e => r.promises.readFile(e),\n      mtime: async e => (await r.promises.stat(e)).mtimeMs,\n      async stat(e) {\n        const t = await r.promises.stat(e);\n        return {\n          ctime: t.ctimeMs,\n          mtime: t.mtimeMs,\n          size: t.size\n        };\n      }\n    };\n  },\n  876: (e, t) => {\n    \"use strict\";\n\n    function n(e) {\n      return \"virtual\" === e.type;\n    }\n    function r(e) {\n      return \"top\" === e.type;\n    }\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.duplicateTree = t.cutTreeAfterLine = t.isTop = t.isVirtual = t.isLine = t.isBlank = t.topNode = t.blankNode = t.lineNode = t.virtualNode = undefined;\n    t.virtualNode = function (e, t, n) {\n      return {\n        type: \"virtual\",\n        indentation: e,\n        subs: t,\n        label: n\n      };\n    };\n    t.lineNode = function (e, t, n, r, o) {\n      if (\"\" === n) throw new Error(\"Cannot create a line node with an empty source line\");\n      return {\n        type: \"line\",\n        indentation: e,\n        lineNumber: t,\n        sourceLine: n,\n        subs: r,\n        label: o\n      };\n    };\n    t.blankNode = function (e) {\n      return {\n        type: \"blank\",\n        lineNumber: e,\n        subs: []\n      };\n    };\n    t.topNode = function (e) {\n      return {\n        type: \"top\",\n        indentation: -1,\n        subs: null != e ? e : []\n      };\n    };\n    t.isBlank = function (e) {\n      return \"blank\" === e.type;\n    };\n    t.isLine = function (e) {\n      return \"line\" === e.type;\n    };\n    t.isVirtual = n;\n    t.isTop = r;\n    t.cutTreeAfterLine = function (e, t) {\n      !function e(o) {\n        if (!n(o) && !r(o) && o.lineNumber === t) {\n          o.subs = [];\n          return !0;\n        }\n        for (let t = 0; t < o.subs.length; t++) if (e(o.subs[t])) {\n          o.subs = o.subs.slice(0, t + 1);\n          return !0;\n        }\n        return !1;\n      }(e);\n    };\n    t.duplicateTree = function (e) {\n      return JSON.parse(JSON.stringify(e));\n    };\n  },\n  617: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.rebuildTree = t.foldTree = t.visitTreeConditionally = t.visitTree = t.resetLineNumbers = t.mapLabels = t.clearLabelsIf = t.clearLabels = undefined;\n    const r = n(876);\n    function o(e, t, n) {\n      !function e(r) {\n        \"topDown\" === n && t(r);\n        r.subs.forEach(t => {\n          e(t);\n        });\n        \"bottomUp\" === n && t(r);\n      }(e);\n    }\n    t.clearLabels = function (e) {\n      o(e, e => {\n        e.label = undefined;\n      }, \"bottomUp\");\n      return e;\n    };\n    t.clearLabelsIf = function (e, t) {\n      o(e, e => {\n        e.label = e.label ? t(e.label) ? undefined : e.label : undefined;\n      }, \"bottomUp\");\n      return e;\n    };\n    t.mapLabels = function e(t, n) {\n      switch (t.type) {\n        case \"line\":\n        case \"virtual\":\n          const r = t.subs.map(t => e(t, n));\n          return {\n            ...t,\n            subs: r,\n            label: t.label ? n(t.label) : undefined\n          };\n        case \"blank\":\n          return {\n            ...t,\n            label: t.label ? n(t.label) : undefined\n          };\n        case \"top\":\n          return {\n            ...t,\n            subs: t.subs.map(t => e(t, n)),\n            label: t.label ? n(t.label) : undefined\n          };\n      }\n    };\n    t.resetLineNumbers = function (e) {\n      let t = 0;\n      o(e, function (e) {\n        r.isVirtual(e) || r.isTop(e) || (e.lineNumber = t, t++);\n      }, \"topDown\");\n    };\n    t.visitTree = o;\n    t.visitTreeConditionally = function (e, t, n) {\n      !function e(r) {\n        if (\"topDown\" === n && !t(r)) return !1;\n        let o = !0;\n        r.subs.forEach(t => {\n          o = o && e(t);\n        });\n        \"bottomUp\" === n && (o = o && t(r));\n        return o;\n      }(e);\n    };\n    t.foldTree = function (e, t, n, r) {\n      let i = t;\n      o(e, function (e) {\n        i = n(e, i);\n      }, r);\n      return i;\n    };\n    t.rebuildTree = function (e, t, n) {\n      const o = e => {\n          if (undefined !== n && n(e)) return e;\n          {\n            const n = e.subs.map(o).filter(e => undefined !== e);\n            e.subs = n;\n            return t(e);\n          }\n        },\n        i = o(e);\n      return undefined !== i ? i : r.topNode();\n    };\n  },\n  469: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.parseTree = t.registerLanguageSpecificParser = t.flattenVirtual = t.groupBlocks = t.combineClosersAndOpeners = t.buildLabelRules = t.labelVirtualInherited = t.labelLines = t.parseRaw = undefined;\n    const r = n(876),\n      o = n(617);\n    function i(e) {\n      const t = e.split(\"\\n\"),\n        n = t.map(e => e.match(/^\\s*/)[0].length),\n        o = t.map(e => e.trimLeft());\n      function i(e) {\n        const [t, i] = s(e + 1, n[e]);\n        return [r.lineNode(n[e], e, o[e], t), i];\n      }\n      function s(e, t) {\n        let s;\n        const a = [];\n        let c,\n          l = e;\n        for (; l < o.length && (\"\" === o[l] || n[l] > t);) if (\"\" === o[l]) {\n          undefined === c && (c = l);\n          l += 1;\n        } else {\n          if (undefined !== c) {\n            for (let e = c; e < l; e++) a.push(r.blankNode(e));\n            c = undefined;\n          }\n          [s, l] = i(l);\n          a.push(s);\n        }\n        undefined !== c && (l = c);\n        return [a, l];\n      }\n      const [a, c] = s(0, -1);\n      let l = c;\n      for (; l < o.length && \"\" === o[l];) {\n        a.push(r.blankNode(l));\n        l += 1;\n      }\n      if (l < o.length) throw new Error(`Parsing did not go to end of file. Ended at ${l} out of ${o.length}`);\n      return r.topNode(a);\n    }\n    function s(e, t) {\n      o.visitTree(e, function (e) {\n        if (r.isLine(e)) {\n          const n = t.find(t => t.matches(e.sourceLine));\n          n && (e.label = n.label);\n        }\n      }, \"bottomUp\");\n    }\n    function a(e) {\n      return Object.keys(e).map(t => {\n        let n;\n        n = e[t].test ? n => e[t].test(n) : e[t];\n        return {\n          matches: n,\n          label: t\n        };\n      });\n    }\n    function c(e) {\n      const t = o.rebuildTree(e, function (e) {\n        if (0 === e.subs.length || -1 === e.subs.findIndex(e => \"closer\" === e.label || \"opener\" === e.label)) return e;\n        const t = [];\n        let n;\n        for (let o = 0; o < e.subs.length; o++) {\n          const i = e.subs[o],\n            s = e.subs[o - 1];\n          if (\"opener\" === i.label && undefined !== s && r.isLine(s)) {\n            s.subs.push(i);\n            i.subs.forEach(e => s.subs.push(e));\n            i.subs = [];\n          } else if (\"closer\" === i.label && undefined !== n && (r.isLine(i) || r.isVirtual(i)) && i.indentation >= n.indentation) {\n            let e = t.length - 1;\n            for (; e > 0 && r.isBlank(t[e]);) e -= 1;\n            n.subs.push(...t.splice(e + 1));\n            if (i.subs.length > 0) {\n              const e = n.subs.findIndex(e => \"newVirtual\" !== e.label),\n                t = n.subs.slice(0, e),\n                o = n.subs.slice(e),\n                s = o.length > 0 ? [r.virtualNode(i.indentation, o, \"newVirtual\")] : [];\n              n.subs = [...t, ...s, i];\n            } else n.subs.push(i);\n          } else {\n            t.push(i);\n            r.isBlank(i) || (n = i);\n          }\n        }\n        e.subs = t;\n        return e;\n      });\n      o.clearLabelsIf(e, e => \"newVirtual\" === e);\n      return t;\n    }\n    t.parseRaw = i;\n    t.labelLines = s;\n    t.labelVirtualInherited = function (e) {\n      o.visitTree(e, function (e) {\n        if (r.isVirtual(e) && undefined === e.label) {\n          const t = e.subs.filter(e => !r.isBlank(e));\n          1 === t.length && (e.label = t[0].label);\n        }\n      }, \"bottomUp\");\n    };\n    t.buildLabelRules = a;\n    t.combineClosersAndOpeners = c;\n    t.groupBlocks = function (e, t = r.isBlank, n) {\n      return o.rebuildTree(e, function (e) {\n        if (e.subs.length <= 1) return e;\n        const o = [];\n        let i,\n          s = [],\n          a = !1;\n        function c(e = !1) {\n          if (undefined !== i && (o.length > 0 || !e)) {\n            const e = r.virtualNode(i, s, n);\n            o.push(e);\n          } else s.forEach(e => o.push(e));\n        }\n        for (let n = 0; n < e.subs.length; n++) {\n          const o = e.subs[n],\n            l = t(o);\n          !l && a && (c(), s = []);\n          a = l;\n          s.push(o);\n          r.isBlank(o) || (i = null != i ? i : o.indentation);\n        }\n        c(!0);\n        e.subs = o;\n        return e;\n      });\n    };\n    t.flattenVirtual = function (e) {\n      return o.rebuildTree(e, function (e) {\n        return r.isVirtual(e) && undefined === e.label && e.subs.length <= 1 ? 0 === e.subs.length ? undefined : e.subs[0] : (1 === e.subs.length && r.isVirtual(e.subs[0]) && undefined === e.subs[0].label && (e.subs = e.subs[0].subs), e);\n      });\n    };\n    const l = a({\n        opener: /^[\\[({]/,\n        closer: /^[\\])}]/\n      }),\n      u = {};\n    t.registerLanguageSpecificParser = function (e, t) {\n      u[e] = t;\n    };\n    t.parseTree = function (e, t) {\n      const n = i(e),\n        r = u[null != t ? t : \"\"];\n      return r ? r(n) : (s(n, l), c(n));\n    };\n  },\n  250: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.getWindowsDelineations = undefined;\n    const r = n(469),\n      o = n(617);\n    t.getWindowsDelineations = function (e, t, n, i) {\n      if (e.length < n || 0 == i) return [];\n      const s = [],\n        a = o.clearLabels(r.parseTree(e.join(\"\\n\"), t));\n      o.visitTree(a, e => {\n        if (\"blank\" === e.type) return void (e.label = {\n          totalLength: 1,\n          firstLineAfter: e.lineNumber + 1\n        });\n        let t = \"line\" === e.type ? 1 : 0,\n          r = \"line\" === e.type ? e.lineNumber + 1 : NaN;\n        function o(n) {\n          return -1 == n ? r - t : e.subs[n].label.firstLineAfter - e.subs[n].label.totalLength;\n        }\n        function a(t, n) {\n          return 0 == t ? n + 1 : e.subs[t - 1].label.firstLineAfter;\n        }\n        let c = \"line\" === e.type ? -1 : 0,\n          l = \"line\" === e.type ? 1 : 0,\n          u = 0;\n        for (let d = 0; d < e.subs.length; d++) {\n          for (; c >= 0 && c < e.subs.length && \"blank\" === e.subs[c].type;) {\n            l -= e.subs[c].label.totalLength;\n            c++;\n          }\n          \"blank\" !== e.subs[d].type && (u = d);\n          r = e.subs[d].label.firstLineAfter;\n          t += e.subs[d].label.totalLength;\n          l += e.subs[d].label.totalLength;\n          if (l > i) {\n            const t = o(c),\n              r = a(d, t),\n              p = u == d ? r : a(u, t);\n            for (n <= r - t && s.push([t, p]); l > i;) l -= -1 == c ? \"line\" == e.type ? 1 : 0 : e.subs[c].label.totalLength, c++;\n          }\n        }\n        if (c < e.subs.length) {\n          const t = o(c),\n            i = r,\n            a = -1 == c ? i : e.subs[u].label.firstLineAfter;\n          n <= i - t && s.push([t, a]);\n        }\n        e.label = {\n          totalLength: t,\n          firstLineAfter: r\n        };\n      }, \"bottomUp\");\n      return s.sort((e, t) => e[0] - t[0] || e[1] - t[1]).filter((e, t, n) => 0 == t || e[0] != n[t - 1][0] || e[1] != n[t - 1][1]);\n    };\n  },\n  417: (e, t) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.getPathMarker = t.getLanguageMarker = t.comment = t.hasLanguageMarker = t.languageCommentMarkers = undefined;\n    t.languageCommentMarkers = {\n      abap: {\n        start: '\"',\n        end: \"\"\n      },\n      bat: {\n        start: \"REM\",\n        end: \"\"\n      },\n      bibtex: {\n        start: \"%\",\n        end: \"\"\n      },\n      blade: {\n        start: \"#\",\n        end: \"\"\n      },\n      c: {\n        start: \"//\",\n        end: \"\"\n      },\n      clojure: {\n        start: \";\",\n        end: \"\"\n      },\n      coffeescript: {\n        start: \"//\",\n        end: \"\"\n      },\n      cpp: {\n        start: \"//\",\n        end: \"\"\n      },\n      csharp: {\n        start: \"//\",\n        end: \"\"\n      },\n      css: {\n        start: \"/*\",\n        end: \"*/\"\n      },\n      dart: {\n        start: \"//\",\n        end: \"\"\n      },\n      dockerfile: {\n        start: \"#\",\n        end: \"\"\n      },\n      elixir: {\n        start: \"#\",\n        end: \"\"\n      },\n      erb: {\n        start: \"<%#\",\n        end: \"%>\"\n      },\n      erlang: {\n        start: \"%\",\n        end: \"\"\n      },\n      fsharp: {\n        start: \"//\",\n        end: \"\"\n      },\n      go: {\n        start: \"//\",\n        end: \"\"\n      },\n      groovy: {\n        start: \"//\",\n        end: \"\"\n      },\n      haml: {\n        start: \"-#\",\n        end: \"\"\n      },\n      handlebars: {\n        start: \"{{!\",\n        end: \"}}\"\n      },\n      haskell: {\n        start: \"--\",\n        end: \"\"\n      },\n      html: {\n        start: \"\\x3c!--\",\n        end: \"--\\x3e\"\n      },\n      ini: {\n        start: \";\",\n        end: \"\"\n      },\n      java: {\n        start: \"//\",\n        end: \"\"\n      },\n      javascript: {\n        start: \"//\",\n        end: \"\"\n      },\n      javascriptreact: {\n        start: \"//\",\n        end: \"\"\n      },\n      jsonc: {\n        start: \"//\",\n        end: \"\"\n      },\n      jsx: {\n        start: \"//\",\n        end: \"\"\n      },\n      julia: {\n        start: \"#\",\n        end: \"\"\n      },\n      kotlin: {\n        start: \"//\",\n        end: \"\"\n      },\n      latex: {\n        start: \"%\",\n        end: \"\"\n      },\n      less: {\n        start: \"//\",\n        end: \"\"\n      },\n      lua: {\n        start: \"--\",\n        end: \"\"\n      },\n      makefile: {\n        start: \"#\",\n        end: \"\"\n      },\n      markdown: {\n        start: \"[]: #\",\n        end: \"\"\n      },\n      \"objective-c\": {\n        start: \"//\",\n        end: \"\"\n      },\n      \"objective-cpp\": {\n        start: \"//\",\n        end: \"\"\n      },\n      perl: {\n        start: \"#\",\n        end: \"\"\n      },\n      php: {\n        start: \"//\",\n        end: \"\"\n      },\n      powershell: {\n        start: \"#\",\n        end: \"\"\n      },\n      pug: {\n        start: \"//\",\n        end: \"\"\n      },\n      python: {\n        start: \"#\",\n        end: \"\"\n      },\n      ql: {\n        start: \"//\",\n        end: \"\"\n      },\n      r: {\n        start: \"#\",\n        end: \"\"\n      },\n      razor: {\n        start: \"\\x3c!--\",\n        end: \"--\\x3e\"\n      },\n      ruby: {\n        start: \"#\",\n        end: \"\"\n      },\n      rust: {\n        start: \"//\",\n        end: \"\"\n      },\n      sass: {\n        start: \"//\",\n        end: \"\"\n      },\n      scala: {\n        start: \"//\",\n        end: \"\"\n      },\n      scss: {\n        start: \"//\",\n        end: \"\"\n      },\n      shellscript: {\n        start: \"#\",\n        end: \"\"\n      },\n      slim: {\n        start: \"/\",\n        end: \"\"\n      },\n      solidity: {\n        start: \"//\",\n        end: \"\"\n      },\n      sql: {\n        start: \"--\",\n        end: \"\"\n      },\n      stylus: {\n        start: \"//\",\n        end: \"\"\n      },\n      svelte: {\n        start: \"\\x3c!--\",\n        end: \"--\\x3e\"\n      },\n      swift: {\n        start: \"//\",\n        end: \"\"\n      },\n      terraform: {\n        start: \"#\",\n        end: \"\"\n      },\n      tex: {\n        start: \"%\",\n        end: \"\"\n      },\n      typescript: {\n        start: \"//\",\n        end: \"\"\n      },\n      typescriptreact: {\n        start: \"//\",\n        end: \"\"\n      },\n      vb: {\n        start: \"'\",\n        end: \"\"\n      },\n      verilog: {\n        start: \"//\",\n        end: \"\"\n      },\n      \"vue-html\": {\n        start: \"\\x3c!--\",\n        end: \"--\\x3e\"\n      },\n      vue: {\n        start: \"//\",\n        end: \"\"\n      },\n      xml: {\n        start: \"\\x3c!--\",\n        end: \"--\\x3e\"\n      },\n      xsl: {\n        start: \"\\x3c!--\",\n        end: \"--\\x3e\"\n      },\n      yaml: {\n        start: \"#\",\n        end: \"\"\n      }\n    };\n    const n = [\"php\", \"plaintext\"],\n      r = {\n        html: \"<!DOCTYPE html>\",\n        python: \"#!/usr/bin/env python3\",\n        ruby: \"#!/usr/bin/env ruby\",\n        shellscript: \"#!/bin/sh\",\n        yaml: \"# YAML data\"\n      };\n    function o({\n      source: e\n    }) {\n      return e.startsWith(\"#!\") || e.startsWith(\"<!DOCTYPE\");\n    }\n    function i(e, n) {\n      const r = t.languageCommentMarkers[n];\n      if (r) {\n        const t = \"\" == r.end ? \"\" : \" \" + r.end;\n        return `${r.start} ${e}${t}`;\n      }\n      return \"\";\n    }\n    t.hasLanguageMarker = o;\n    t.comment = i;\n    t.getLanguageMarker = function (e) {\n      const {\n        languageId: t\n      } = e;\n      return -1 !== n.indexOf(t) || o(e) ? \"\" : t in r ? r[t] : i(`Language: ${t}`, t);\n    };\n    t.getPathMarker = function (e) {\n      return e.relativePath ? i(`Path: ${e.relativePath}`, e.languageId) : \"\";\n    };\n  },\n  563: function (e, t, n) {\n    \"use strict\";\n\n    var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n        undefined === r && (r = n);\n        Object.defineProperty(e, r, {\n          enumerable: !0,\n          get: function () {\n            return t[n];\n          }\n        });\n      } : function (e, t, n, r) {\n        undefined === r && (r = n);\n        e[r] = t[n];\n      }),\n      o = this && this.__exportStar || function (e, t) {\n        for (var n in e) \"default\" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);\n      };\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.createWorker = t.FileSystem = t.comment = t.languageCommentMarkers = undefined;\n    const i = n(622),\n      s = n(13);\n    o(n(306), t);\n    o(n(610), t);\n    o(n(312), t);\n    o(n(94), t);\n    var a = n(417);\n    Object.defineProperty(t, \"languageCommentMarkers\", {\n      enumerable: !0,\n      get: function () {\n        return a.languageCommentMarkers;\n      }\n    });\n    Object.defineProperty(t, \"comment\", {\n      enumerable: !0,\n      get: function () {\n        return a.comment;\n      }\n    });\n    var c = n(271);\n    Object.defineProperty(t, \"FileSystem\", {\n      enumerable: !0,\n      get: function () {\n        return c.FileSystem;\n      }\n    });\n    t.createWorker = function () {\n      return new s.Worker(i.resolve(__dirname, \"..\", \"dist\", \"worker.js\"));\n    };\n  },\n  179: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.extractLocalImportContext = t.getDocComment = undefined;\n    const r = n(622),\n      o = n(306);\n    function i(e, t) {\n      var n;\n      let o = null === (n = t.namedChild(1)) || undefined === n ? undefined : n.text.slice(1, -1);\n      if (!o || !o.startsWith(\".\")) return null;\n      if (\"\" === r.extname(o)) o += \".ts\";else if (\".ts\" !== r.extname(o)) return null;\n      return r.join(r.dirname(e), o);\n    }\n    function s(e) {\n      var t, n, r, o, i;\n      let s = [];\n      if (\"import_clause\" === (null === (t = e.namedChild(0)) || undefined === t ? undefined : t.type)) {\n        let t = e.namedChild(0);\n        if (\"named_imports\" === (null === (n = null == t ? undefined : t.namedChild(0)) || undefined === n ? undefined : n.type)) {\n          let e = t.namedChild(0);\n          for (let t of null !== (r = null == e ? undefined : e.namedChildren) && undefined !== r ? r : []) if (\"import_specifier\" === t.type) {\n            const e = null === (o = t.childForFieldName(\"name\")) || undefined === o ? undefined : o.text;\n            if (e) {\n              const n = null === (i = t.childForFieldName(\"alias\")) || undefined === i ? undefined : i.text;\n              s.push({\n                name: e,\n                alias: n\n              });\n            }\n          }\n        }\n      }\n      return s;\n    }\n    const a = new Map();\n    function c(e, t) {\n      var n, r;\n      let o = null !== (r = null === (n = null == t ? undefined : t.childForFieldName(\"name\")) || undefined === n ? undefined : n.text) && undefined !== r ? r : \"\";\n      switch (null == t ? undefined : t.type) {\n        case \"ambient_declaration\":\n          return c(e, t.namedChild(0));\n        case \"interface_declaration\":\n        case \"enum_declaration\":\n        case \"type_alias_declaration\":\n          return {\n            name: o,\n            decl: t.text\n          };\n        case \"function_declaration\":\n        case \"function_signature\":\n          return {\n            name: o,\n            decl: l(e, t)\n          };\n        case \"class_declaration\":\n          {\n            let n = function (e, t) {\n                let n = t.childForFieldName(\"body\");\n                if (n) return n.namedChildren.map(t => d(e, t)).filter(e => e);\n              }(e, t),\n              r = \"\";\n            if (n) {\n              let o = t.childForFieldName(\"body\");\n              r = `declare ${e.substring(t.startIndex, o.startIndex + 1)}`;\n              r += n.map(e => \"\\n\" + e).join(\"\");\n              r += \"\\n}\";\n            }\n            return {\n              name: o,\n              decl: r\n            };\n          }\n      }\n      return {\n        name: o,\n        decl: \"\"\n      };\n    }\n    function l(e, t) {\n      var n, r, o;\n      const i = null !== (r = null === (n = t.childForFieldName(\"return_type\")) || undefined === n ? undefined : n.endIndex) && undefined !== r ? r : null === (o = t.childForFieldName(\"parameters\")) || undefined === o ? undefined : o.endIndex;\n      if (undefined !== i) {\n        let n = e.substring(t.startIndex, i) + \";\";\n        return \"function_declaration\" === t.type || \"function_signature\" === t.type ? \"declare \" + n : n;\n      }\n      return \"\";\n    }\n    function u(e, t) {\n      const n = o.getFirstPrecedingComment(t);\n      return n ? e.substring(n.startIndex, t.startIndex) : \"\";\n    }\n    function d(e, t) {\n      var n, r, i, s, a;\n      if (\"accessibility_modifier\" === (null === (n = null == t ? undefined : t.firstChild) || undefined === n ? undefined : n.type) && \"private\" === t.firstChild.text) return \"\";\n      const c = o.getFirstPrecedingComment(t),\n        p = null !== (r = function (e, t) {\n          let n = t.startIndex - 1;\n          for (; n >= 0 && (\" \" === e[n] || \"\\t\" === e[n]);) n--;\n          if (n < 0 || \"\\n\" === e[n]) return e.substring(n + 1, t.startIndex);\n        }(e, null != c ? c : t)) && undefined !== r ? r : \"  \",\n        h = u(e, t);\n      switch (t.type) {\n        case \"ambient_declaration\":\n          const n = t.namedChild(0);\n          return n ? p + h + d(e, n) : \"\";\n        case \"method_definition\":\n        case \"method_signature\":\n          return p + h + l(e, t);\n        case \"public_field_definition\":\n          {\n            let n = null !== (s = null === (i = t.childForFieldName(\"type\")) || undefined === i ? undefined : i.endIndex) && undefined !== s ? s : null === (a = t.childForFieldName(\"name\")) || undefined === a ? undefined : a.endIndex;\n            if (undefined !== n) return p + h + e.substring(t.startIndex, n) + \";\";\n          }\n      }\n      return \"\";\n    }\n    async function p(e, t, n) {\n      let r = new Map(),\n        i = -1;\n      try {\n        i = await n.mtime(e);\n      } catch {\n        return r;\n      }\n      let s = a.get(e);\n      if (s && s.mtime === i) return s.exports;\n      if (\"typescript\" === t) {\n        let i = null;\n        try {\n          let s = (await n.readFile(e)).toString();\n          i = await o.parseTree(t, s);\n          for (let e of o.queryExports(t, i.rootNode)) for (let t of e.captures) {\n            let e = t.node;\n            if (\"export_statement\" === e.type) {\n              let t = e.childForFieldName(\"declaration\");\n              if (null == t ? undefined : t.hasError()) continue;\n              let {\n                name: n,\n                decl: o\n              } = c(s, t);\n              if (n) {\n                o = u(s, e) + o;\n                let t = r.get(n);\n                t || (t = [], r.set(n, t));\n                t.push(o);\n              }\n            }\n          }\n        } catch {} finally {\n          i && i.delete();\n        }\n      }\n      if (a.size > 2e3) for (let e of a.keys()) {\n        a.delete(e);\n        if (r.size <= 1e3) break;\n      }\n      a.set(e, {\n        mtime: i,\n        exports: r\n      });\n      return r;\n    }\n    t.getDocComment = u;\n    const h = /^\\s*import\\s*(type|)\\s*\\{[^}]*\\}\\s*from\\s*['\"]\\./gm;\n    t.extractLocalImportContext = async function (e, t) {\n      let {\n        source: n,\n        uri: r,\n        languageId: a\n      } = e;\n      return t && \"typescript\" === a ? async function (e, t, n) {\n        let r = \"typescript\",\n          a = [];\n        const c = function (e) {\n          let t,\n            n = -1;\n          h.lastIndex = -1;\n          do {\n            t = h.exec(e);\n            t && (n = h.lastIndex + t.length);\n          } while (t);\n          if (-1 === n) return -1;\n          const r = e.indexOf(\"\\n\", n);\n          return -1 !== r ? r : e.length;\n        }(e);\n        if (-1 === c) return a;\n        e = e.substring(0, c);\n        let l = await o.parseTree(r, e);\n        try {\n          for (let e of function (e) {\n            let t = [];\n            for (let n of e.namedChildren) \"import_statement\" === n.type && t.push(n);\n            return t;\n          }(l.rootNode)) {\n            let o = i(t, e);\n            if (!o) continue;\n            let c = s(e);\n            if (0 === c.length) continue;\n            let l = await p(o, r, n);\n            for (let e of c) l.has(e.name) && a.push(...l.get(e.name));\n          }\n        } finally {\n          l.delete();\n        }\n        return a;\n      }(n, r, t) : [];\n    };\n  },\n  306: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.getFunctionPositions = t.getFirstPrecedingComment = t.isFunctionDefinition = t.isFunction = t.getAncestorWithSiblingFunctions = t.queryPythonIsDocstring = t.queryGlobalVars = t.queryExports = t.queryImports = t.queryFunctions = t.getBlockCloseToken = t.parsesWithoutError = t.parseTree = t.getLanguage = t.languageIdToWasmLanguage = t.isSupportedLanguageId = t.WASMLanguage = undefined;\n    const r = n(622),\n      o = n(87),\n      i = n(87);\n    var s;\n    !function (e) {\n      e.Python = \"python\";\n      e.JavaScript = \"javascript\";\n      e.TypeScript = \"typescript\";\n      e.Go = \"go\";\n      e.Ruby = \"ruby\";\n    }(s = t.WASMLanguage || (t.WASMLanguage = {}));\n    const a = {\n      python: s.Python,\n      javascript: s.JavaScript,\n      javascriptreact: s.JavaScript,\n      jsx: s.JavaScript,\n      typescript: s.TypeScript,\n      typescriptreact: s.TypeScript,\n      go: s.Go,\n      ruby: s.Ruby\n    };\n    function c(e) {\n      if (!(e in a)) throw new Error(`Unrecognized language: ${e}`);\n      return a[e];\n    }\n    t.isSupportedLanguageId = function (e) {\n      return e in a;\n    };\n    t.languageIdToWasmLanguage = c;\n    const l = {\n        python: [[\"(function_definition body: (block\\n             (expression_statement (string))? @docstring) @body) @function\"], ['(ERROR (\"def\" (identifier) (parameters))) @function']],\n        javascript: [[\"[\\n            (function body: (statement_block) @body)\\n            (function_declaration body: (statement_block) @body)\\n            (generator_function body: (statement_block) @body)\\n            (generator_function_declaration body: (statement_block) @body)\\n            (method_definition body: (statement_block) @body)\\n          ] @function\"]],\n        typescript: [[\"[\\n            (function body: (statement_block) @body)\\n            (function_declaration body: (statement_block) @body)\\n            (generator_function body: (statement_block) @body)\\n            (generator_function_declaration body: (statement_block) @body)\\n            (method_definition body: (statement_block) @body)\\n          ] @function\"]],\n        go: [[\"[\\n            (function_declaration body: (block) @body)\\n            (method_declaration body: (block) @body)\\n          ] @function\"]],\n        ruby: [['[\\n            (method name: (_) parameters: (method_parameters)? @params [(_)+ \"end\"] @body)\\n            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ \"end\"] @body)\\n          ] @function']]\n      },\n      u = '(variable_declarator value: (call_expression function: ((identifier) @req (#eq? @req \"require\"))))',\n      d = `\\n    (lexical_declaration ${u}+)\\n    (variable_declaration ${u}+)\\n`,\n      p = {\n        python: [[\"(module (future_import_statement) @import)\"], [\"(module (import_statement) @import)\"], [\"(module (import_from_statement) @import)\"]],\n        javascript: [[`(program [ ${d} ] @import)`], [\"(program [ (import_statement) ] @import)\"]],\n        typescript: [[`(program [ ${d} ] @import)`], [\"(program [ (import_statement) (import_alias) ] @import)\"]],\n        go: [],\n        ruby: []\n      },\n      h = {\n        python: [],\n        javascript: [[\"(program (export_statement) @export)\"]],\n        typescript: [[\"(program (export_statement) @export)\"]],\n        go: [],\n        ruby: []\n      },\n      f = {\n        python: [[\"(module (global_statement) @globalVar)\"], [\"(module (expression_statement) @globalVar)\"]],\n        javascript: [],\n        typescript: [],\n        go: [],\n        ruby: []\n      },\n      m = {\n        python: new Set([\"function_definition\"]),\n        javascript: new Set([\"function\", \"function_declaration\", \"generator_function\", \"generator_function_declaration\", \"method_definition\", \"arrow_function\"]),\n        typescript: new Set([\"function\", \"function_declaration\", \"generator_function\", \"generator_function_declaration\", \"method_definition\", \"arrow_function\"]),\n        go: new Set([\"function_declaration\", \"method_declaration\"]),\n        ruby: new Set([\"method\", \"singleton_method\"])\n      },\n      g = {\n        python: e => {\n          var t;\n          return \"module\" === e.type || \"block\" === e.type && \"class_definition\" === (null === (t = e.parent) || undefined === t ? undefined : t.type);\n        },\n        javascript: e => \"program\" === e.type || \"class_body\" === e.type,\n        typescript: e => \"program\" === e.type || \"class_body\" === e.type,\n        go: e => \"source_file\" === e.type,\n        ruby: e => \"program\" === e.type || \"class\" === e.type\n      },\n      _ = new Map();\n    async function y(e) {\n      const t = c(e);\n      if (!_.has(t)) {\n        const e = await async function (e) {\n          await o.init();\n          const t = r.resolve(__dirname, \"..\", \"dist\", `tree-sitter-${e}.wasm`);\n          return i.Language.load(t);\n        }(t);\n        _.set(t, e);\n      }\n      return _.get(t);\n    }\n    async function v(e, t) {\n      let n = await y(e);\n      const r = new o();\n      r.setLanguage(n);\n      const i = r.parse(t);\n      r.delete();\n      return i;\n    }\n    function b(e, t) {\n      const n = [];\n      for (const r of e) {\n        if (!r[1]) {\n          const e = t.tree.getLanguage();\n          r[1] = e.query(r[0]);\n        }\n        n.push(...r[1].matches(t));\n      }\n      return n;\n    }\n    function w(e, t) {\n      return b(l[c(e)], t);\n    }\n    t.getLanguage = y;\n    t.parseTree = v;\n    t.parsesWithoutError = async function (e, t) {\n      const n = await v(e, t),\n        r = !n.rootNode.hasError();\n      n.delete();\n      return r;\n    };\n    t.getBlockCloseToken = function (e) {\n      switch (c(e)) {\n        case s.Python:\n          return null;\n        case s.JavaScript:\n        case s.TypeScript:\n        case s.Go:\n          return \"}\";\n        case s.Ruby:\n          return \"end\";\n      }\n    };\n    t.queryFunctions = w;\n    t.queryImports = function (e, t) {\n      return b(p[c(e)], t);\n    };\n    t.queryExports = function (e, t) {\n      return b(h[c(e)], t);\n    };\n    t.queryGlobalVars = function (e, t) {\n      return b(f[c(e)], t);\n    };\n    const x = [\"[\\n    (class_definition (block (expression_statement (string))))\\n    (function_definition (block (expression_statement (string))))\\n]\"];\n    function E(e, t) {\n      return m[c(e)].has(t.type);\n    }\n    t.queryPythonIsDocstring = function (e) {\n      return 1 == b([x], e).length;\n    };\n    t.getAncestorWithSiblingFunctions = function (e, t) {\n      const n = g[c(e)];\n      for (; t.parent;) {\n        if (n(t.parent)) return t;\n        t = t.parent;\n      }\n      return t.parent ? t : null;\n    };\n    t.isFunction = E;\n    t.isFunctionDefinition = function (e, t) {\n      switch (c(e)) {\n        case s.Python:\n        case s.Go:\n        case s.Ruby:\n          return E(e, t);\n        case s.JavaScript:\n        case s.TypeScript:\n          if (\"function_declaration\" === t.type || \"generator_function_declaration\" === t.type || \"method_definition\" === t.type) return !0;\n          if (\"lexical_declaration\" === t.type || \"variable_declaration\" === t.type) {\n            if (t.namedChildCount > 1) return !1;\n            let n = t.namedChild(0);\n            if (null == n) return !1;\n            let r = n.namedChild(1);\n            return null !== r && E(e, r);\n          }\n          if (\"expression_statement\" === t.type) {\n            let n = t.namedChild(0);\n            if (\"assignment_expression\" === (null == n ? undefined : n.type)) {\n              let t = n.namedChild(1);\n              return null !== t && E(e, t);\n            }\n          }\n          return !1;\n      }\n    };\n    t.getFirstPrecedingComment = function (e) {\n      var t;\n      let n = e;\n      for (; \"comment\" === (null === (t = n.previousSibling) || undefined === t ? undefined : t.type);) {\n        let e = n.previousSibling;\n        if (e.endPosition.row < n.startPosition.row - 1) break;\n        n = e;\n      }\n      return \"comment\" === (null == n ? undefined : n.type) ? n : null;\n    };\n    t.getFunctionPositions = async function (e, t) {\n      return w(e, (await v(e, t)).rootNode).map(e => {\n        const t = e.captures.find(e => \"function\" === e.name).node;\n        return {\n          startIndex: t.startIndex,\n          endIndex: t.endIndex\n        };\n      });\n    };\n  },\n  610: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.getNodeStart = t.isBlockBodyFinished = t.isEmptyBlockStart = t.getBlockParser = undefined;\n    const r = n(306);\n    class o {\n      constructor(e, t, n) {\n        this.languageId = e;\n        this.nodeMatch = t;\n        this.nodeTypesWithBlockOrStmtChild = n;\n      }\n      async getNodeMatchAtPosition(e, t, n) {\n        const o = await r.parseTree(this.languageId, e);\n        try {\n          let e = o.rootNode.descendantForIndex(t);\n          for (; e;) {\n            const t = this.nodeMatch[e.type];\n            if (t) {\n              if (!this.nodeTypesWithBlockOrStmtChild.has(e.type)) break;\n              const n = this.nodeTypesWithBlockOrStmtChild.get(e.type),\n                r = \"\" == n ? e.namedChildren[0] : e.childForFieldName(n);\n              if ((null == r ? undefined : r.type) == t) break;\n            }\n            e = e.parent;\n          }\n          if (!e) return;\n          return n(e);\n        } finally {\n          o.delete();\n        }\n      }\n      getNextBlockAtPosition(e, t, n) {\n        return this.getNodeMatchAtPosition(e, t, e => {\n          let t = e.children.reverse().find(t => t.type == this.nodeMatch[e.type]);\n          if (t) {\n            if (\"python\" == this.languageId && t.parent) {\n              const e = \":\" == t.parent.type ? t.parent.parent : t.parent;\n              let n = null == e ? undefined : e.nextSibling;\n              for (; n && \"comment\" == n.type;) {\n                const r = n.startPosition.row == t.endPosition.row && n.startPosition.column >= t.endPosition.column,\n                  o = n.startPosition.row > e.endPosition.row && n.startPosition.column > e.startPosition.column;\n                if (!r && !o) break;\n                t = n;\n                n = n.nextSibling;\n              }\n            }\n            if (!(t.endIndex >= t.tree.rootNode.endIndex - 1 && (t.hasError() || t.parent.hasError()))) return n(t);\n          }\n        });\n      }\n      async isBlockBodyFinished(e, t, n) {\n        const r = (e + t).trimEnd(),\n          o = await this.getNextBlockAtPosition(r, n, e => e.endIndex);\n        if (undefined !== o && o < r.length) {\n          const t = o - e.length;\n          return t > 0 ? t : undefined;\n        }\n      }\n      getNodeStart(e, t) {\n        const n = e.trimEnd();\n        return this.getNodeMatchAtPosition(n, t, e => e.startIndex);\n      }\n    }\n    class i extends o {\n      constructor(e, t, n, r, o) {\n        super(e, r, o);\n        this.blockEmptyMatch = t;\n        this.lineMatch = n;\n      }\n      isBlockStart(e) {\n        return this.lineMatch.test(e.trimStart());\n      }\n      async isBlockBodyEmpty(e, t) {\n        const n = await this.getNextBlockAtPosition(e, t, n => {\n          n.startIndex < t && (t = n.startIndex);\n          let r = e.substring(t, n.endIndex).trim();\n          return \"\" == r || r.replace(/\\s/g, \"\") == this.blockEmptyMatch;\n        });\n        return undefined === n || n;\n      }\n      async isEmptyBlockStart(e, t) {\n        t = s(e, t);\n        return this.isBlockStart(function (e, t) {\n          const n = e.lastIndexOf(\"\\n\", t - 1);\n          let r = e.indexOf(\"\\n\", t);\n          r < 0 && (r = e.length);\n          return e.slice(n + 1, r);\n        }(e, t)) && this.isBlockBodyEmpty(e, t);\n      }\n    }\n    function s(e, t) {\n      let n = t;\n      for (; n > 0 && /\\s/.test(e.charAt(n - 1));) n--;\n      return n;\n    }\n    function a(e, t) {\n      const n = e.startIndex,\n        r = e.startIndex - e.startPosition.column,\n        o = t.substring(r, n);\n      if (/^\\s*$/.test(o)) return o;\n    }\n    function c(e, t, n) {\n      if (t.startPosition.row <= e.startPosition.row) return !1;\n      const r = a(e, n),\n        o = a(t, n);\n      return undefined !== r && undefined !== o && r.startsWith(o);\n    }\n    class l extends o {\n      constructor(e, t, n, r, o, i, s) {\n        super(e, t, n);\n        this.startKeywords = r;\n        this.blockNodeType = o;\n        this.emptyStatementType = i;\n        this.curlyBraceLanguage = s;\n      }\n      isBlockEmpty(e, t) {\n        var n, o;\n        let i = e.text.trim();\n        this.curlyBraceLanguage && (i.startsWith(\"{\") && (i = i.slice(1)), i.endsWith(\"}\") && (i = i.slice(0, -1)), i = i.trim());\n        return 0 == i.length || !(\"python\" != this.languageId || \"class_definition\" != (null === (n = e.parent) || undefined === n ? undefined : n.type) && \"function_definition\" != (null === (o = e.parent) || undefined === o ? undefined : o.type) || 1 != e.children.length || !r.queryPythonIsDocstring(e.parent));\n      }\n      async isEmptyBlockStart(e, t) {\n        var n, o, i;\n        if (t > e.length) throw new RangeError(\"Invalid offset\");\n        for (let n = t; n < e.length && \"\\n\" != e.charAt(n); n++) if (/\\S/.test(e.charAt(n))) return !1;\n        t = s(e, t);\n        const a = await r.parseTree(this.languageId, e);\n        try {\n          const r = a.rootNode.descendantForIndex(t - 1);\n          if (null == r) return !1;\n          if (this.curlyBraceLanguage && \"}\" == r.type) return !1;\n          if ((\"javascript\" == this.languageId || \"typescript\" == this.languageId) && r.parent && \"object\" == r.parent.type && \"{\" == r.parent.text.trim()) return !0;\n          if (\"typescript\" == this.languageId) {\n            let n = r;\n            for (; n.parent;) {\n              if (\"function_signature\" == n.type || \"method_signature\" == n.type) {\n                const o = r.nextSibling;\n                return !!(o && n.hasError() && c(n, o, e)) || !n.children.find(e => \";\" == e.type) && n.endIndex <= t;\n              }\n              n = n.parent;\n            }\n          }\n          let s = null,\n            l = null,\n            u = null,\n            d = r;\n          for (; null != d;) {\n            if (d.type == this.blockNodeType) {\n              l = d;\n              break;\n            }\n            if (this.nodeMatch[d.type]) {\n              u = d;\n              break;\n            }\n            if (\"ERROR\" == d.type) {\n              s = d;\n              break;\n            }\n            d = d.parent;\n          }\n          if (null != l) {\n            if (!l.parent || !this.nodeMatch[l.parent.type]) return !1;\n            if (\"python\" == this.languageId) {\n              const e = l.previousSibling;\n              if (null != e && e.hasError() && (e.text.startsWith('\"\"\"') || e.text.startsWith(\"'''\"))) return !0;\n            }\n            return this.isBlockEmpty(l, t);\n          }\n          if (null != s) {\n            if (\"module\" == (null === (n = s.previousSibling) || undefined === n ? undefined : n.type) || \"internal_module\" == (null === (o = s.previousSibling) || undefined === o ? undefined : o.type)) return !0;\n            const e = [...s.children].reverse(),\n              a = e.find(e => this.startKeywords.includes(e.type));\n            let c = e.find(e => e.type == this.blockNodeType);\n            if (a) {\n              switch (this.languageId) {\n                case \"python\":\n                  {\n                    \"try\" == a.type && \"identifier\" == r.type && r.text.length > 4 && (c = null === (i = e.find(e => e.hasError())) || undefined === i ? undefined : i.children.find(e => \"block\" == e.type));\n                    const t = e.find(e => \":\" == e.type);\n                    if (t && a.endIndex <= t.startIndex && t.nextSibling) {\n                      if (\"def\" == a.type) {\n                        const e = t.nextSibling;\n                        if ('\"' == e.type || \"'\" == e.type) return !0;\n                        if (\"ERROR\" == e.type && ('\"\"\"' == e.text || \"'''\" == e.text)) return !0;\n                      }\n                      return !1;\n                    }\n                    break;\n                  }\n                case \"javascript\":\n                  {\n                    const t = e.find(e => \"formal_parameters\" == e.type);\n                    if (\"class\" == a.type && t) return !0;\n                    const n = e.find(e => \"{\" == e.type);\n                    if (n && n.startIndex > a.endIndex && null != n.nextSibling) return !1;\n                    if (e.find(e => \"do\" == e.type) && \"while\" == a.type) return !1;\n                    if (\"=>\" == a.type && a.nextSibling && \"{\" != a.nextSibling.type) return !1;\n                    break;\n                  }\n                case \"typescript\":\n                  {\n                    const t = e.find(e => \"{\" == e.type);\n                    if (t && t.startIndex > a.endIndex && null != t.nextSibling) return !1;\n                    if (e.find(e => \"do\" == e.type) && \"while\" == a.type) return !1;\n                    if (\"=>\" == a.type && a.nextSibling && \"{\" != a.nextSibling.type) return !1;\n                    break;\n                  }\n              }\n              return !(c && c.startIndex > a.endIndex) || this.isBlockEmpty(c, t);\n            }\n          }\n          if (null != u) {\n            const e = this.nodeMatch[u.type],\n              n = u.children.slice().reverse().find(t => t.type == e);\n            if (n) return this.isBlockEmpty(n, t);\n            if (this.nodeTypesWithBlockOrStmtChild.has(u.type)) {\n              const e = this.nodeTypesWithBlockOrStmtChild.get(u.type),\n                t = \"\" == e ? u.children[0] : u.childForFieldName(e);\n              if (t && t.type != this.blockNodeType && t.type != this.emptyStatementType) return !1;\n            }\n            return !0;\n          }\n          return !1;\n        } finally {\n          a.delete();\n        }\n      }\n    }\n    const u = {\n      python: new l(\"python\", {\n        class_definition: \"block\",\n        elif_clause: \"block\",\n        else_clause: \"block\",\n        except_clause: \"block\",\n        finally_clause: \"block\",\n        for_statement: \"block\",\n        function_definition: \"block\",\n        if_statement: \"block\",\n        try_statement: \"block\",\n        while_statement: \"block\",\n        with_statement: \"block\"\n      }, new Map(), [\"def\", \"class\", \"if\", \"elif\", \"else\", \"for\", \"while\", \"try\", \"except\", \"finally\", \"with\"], \"block\", null, !1),\n      javascript: new l(\"javascript\", {\n        arrow_function: \"statement_block\",\n        catch_clause: \"statement_block\",\n        do_statement: \"statement_block\",\n        else_clause: \"statement_block\",\n        finally_clause: \"statement_block\",\n        for_in_statement: \"statement_block\",\n        for_statement: \"statement_block\",\n        function: \"statement_block\",\n        function_declaration: \"statement_block\",\n        generator_function: \"statement_block\",\n        generator_function_declaration: \"statement_block\",\n        if_statement: \"statement_block\",\n        method_definition: \"statement_block\",\n        try_statement: \"statement_block\",\n        while_statement: \"statement_block\",\n        with_statement: \"statement_block\",\n        class: \"class_body\",\n        class_declaration: \"class_body\"\n      }, new Map([[\"arrow_function\", \"body\"], [\"do_statement\", \"body\"], [\"else_clause\", \"\"], [\"for_in_statement\", \"body\"], [\"for_statement\", \"body\"], [\"if_statement\", \"consequence\"], [\"while_statement\", \"body\"], [\"with_statement\", \"body\"]]), [\"=>\", \"try\", \"catch\", \"finally\", \"do\", \"for\", \"if\", \"else\", \"while\", \"with\", \"function\", \"function*\", \"class\"], \"statement_block\", \"empty_statement\", !0),\n      typescript: new l(\"typescript\", {\n        ambient_declaration: \"statement_block\",\n        arrow_function: \"statement_block\",\n        catch_clause: \"statement_block\",\n        do_statement: \"statement_block\",\n        else_clause: \"statement_block\",\n        finally_clause: \"statement_block\",\n        for_in_statement: \"statement_block\",\n        for_statement: \"statement_block\",\n        function: \"statement_block\",\n        function_declaration: \"statement_block\",\n        generator_function: \"statement_block\",\n        generator_function_declaration: \"statement_block\",\n        if_statement: \"statement_block\",\n        internal_module: \"statement_block\",\n        method_definition: \"statement_block\",\n        module: \"statement_block\",\n        try_statement: \"statement_block\",\n        while_statement: \"statement_block\",\n        abstract_class_declaration: \"class_body\",\n        class: \"class_body\",\n        class_declaration: \"class_body\"\n      }, new Map([[\"arrow_function\", \"body\"], [\"do_statement\", \"body\"], [\"else_clause\", \"\"], [\"for_in_statement\", \"body\"], [\"for_statement\", \"body\"], [\"if_statement\", \"consequence\"], [\"while_statement\", \"body\"], [\"with_statement\", \"body\"]]), [\"declare\", \"=>\", \"try\", \"catch\", \"finally\", \"do\", \"for\", \"if\", \"else\", \"while\", \"with\", \"function\", \"function*\", \"class\"], \"statement_block\", \"empty_statement\", !0),\n      go: new i(\"go\", \"{}\", /\\b(func|if|else|for)\\b/, {\n        communication_case: \"block\",\n        default_case: \"block\",\n        expression_case: \"block\",\n        for_statement: \"block\",\n        func_literal: \"block\",\n        function_declaration: \"block\",\n        if_statement: \"block\",\n        labeled_statement: \"block\",\n        method_declaration: \"block\",\n        type_case: \"block\"\n      }, new Map()),\n      ruby: new i(\"ruby\", \"end\", /\\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\\b|->/, {\n        begin_block: \"}\",\n        block: \"}\",\n        end_block: \"}\",\n        lambda: \"block\",\n        for: \"do\",\n        until: \"do\",\n        while: \"do\",\n        case: \"end\",\n        do: \"end\",\n        if: \"end\",\n        method: \"end\",\n        module: \"end\",\n        unless: \"end\",\n        do_block: \"end\"\n      }, new Map())\n    };\n    function d(e) {\n      return u[r.languageIdToWasmLanguage(e)];\n    }\n    t.getBlockParser = d;\n    t.isEmptyBlockStart = async function (e, t, n) {\n      return !!r.isSupportedLanguageId(e) && d(e).isEmptyBlockStart(t, n);\n    };\n    t.isBlockBodyFinished = async function (e, t, n, o) {\n      if (r.isSupportedLanguageId(e)) return d(e).isBlockBodyFinished(t, n, o);\n    };\n    t.getNodeStart = async function (e, t, n) {\n      if (r.isSupportedLanguageId(e)) return d(e).getNodeStart(t, n);\n    };\n  },\n  312: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.getPrompt = t.newLineEnded = t.normalizeLanguageId = t.PromptOptions = t.SuffixStartMode = t.SuffixMatchOption = t.SuffixOption = t.LineEndingOptions = t.LocalImportContextOption = t.SnippetSelectionOption = t.NeighboringTabsPositionOption = t.NeighboringTabsOption = t.SiblingOption = t.PathMarkerOption = t.LanguageMarkerOption = t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = t.MAX_EDIT_DISTANCE_LENGTH = t.MAX_PROMPT_LENGTH = undefined;\n    const r = n(417),\n      o = n(179),\n      i = n(125),\n      s = n(670),\n      a = n(94),\n      c = n(456),\n      l = n(395);\n    let u = {\n      text: \"\",\n      tokens: []\n    };\n    var d, p, h, f, m, g, _, y, v, b, w;\n    t.MAX_PROMPT_LENGTH = 1500;\n    t.MAX_EDIT_DISTANCE_LENGTH = 50;\n    t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5;\n    (function (e) {\n      e.NoMarker = \"nomarker\";\n      e.Top = \"top\";\n      e.Always = \"always\";\n    })(d = t.LanguageMarkerOption || (t.LanguageMarkerOption = {}));\n    (function (e) {\n      e.NoMarker = \"nomarker\";\n      e.Top = \"top\";\n      e.Always = \"always\";\n    })(p = t.PathMarkerOption || (t.PathMarkerOption = {}));\n    (function (e) {\n      e.NoSiblings = \"nosiblings\";\n      e.SiblingsOverContext = \"siblingabove\";\n      e.ContextOverSiblings = \"contextabove\";\n    })(h = t.SiblingOption || (t.SiblingOption = {}));\n    (function (e) {\n      e.None = \"none\";\n      e.Conservative = \"conservative\";\n      e.Medium = \"medium\";\n      e.Eager = \"eager\";\n      e.EagerButLittle = \"eagerButLittle\";\n    })(f = t.NeighboringTabsOption || (t.NeighboringTabsOption = {}));\n    (function (e) {\n      e.TopOfText = \"top\";\n      e.DirectlyAboveCursor = \"aboveCursor\";\n      e.AfterSiblings = \"afterSiblings\";\n    })(m = t.NeighboringTabsPositionOption || (t.NeighboringTabsPositionOption = {}));\n    (function (e) {\n      e.BestMatch = \"bestMatch\";\n      e.TopK = \"topK\";\n    })(g = t.SnippetSelectionOption || (t.SnippetSelectionOption = {}));\n    (function (e) {\n      e.NoContext = \"nocontext\";\n      e.Declarations = \"declarations\";\n    })(_ = t.LocalImportContextOption || (t.LocalImportContextOption = {}));\n    (function (e) {\n      e.ConvertToUnix = \"unix\";\n      e.KeepOriginal = \"keep\";\n    })(y = t.LineEndingOptions || (t.LineEndingOptions = {}));\n    (w = t.SuffixOption || (t.SuffixOption = {})).None = \"none\";\n    w.FifteenPercent = \"fifteenPercent\";\n    (function (e) {\n      e.Equal = \"equal\";\n      e.Levenshtein = \"levenshteineditdistance\";\n    })(v = t.SuffixMatchOption || (t.SuffixMatchOption = {}));\n    (function (e) {\n      e.Cursor = \"cursor\";\n      e.CursorTrimStart = \"cursortrimstart\";\n      e.SiblingBlock = \"siblingblock\";\n      e.SiblingBlockTrimStart = \"siblingblocktrimstart\";\n    })(b = t.SuffixStartMode || (t.SuffixStartMode = {}));\n    class x {\n      constructor(e, n) {\n        this.fs = e;\n        this.maxPromptLength = t.MAX_PROMPT_LENGTH;\n        this.languageMarker = d.Top;\n        this.pathMarker = p.Top;\n        this.includeSiblingFunctions = h.ContextOverSiblings;\n        this.localImportContext = _.Declarations;\n        this.neighboringTabs = f.Eager;\n        this.neighboringTabsPosition = m.TopOfText;\n        this.lineEnding = y.ConvertToUnix;\n        this.suffixPercent = 0;\n        this.suffixStartMode = b.Cursor;\n        this.suffixMatchThreshold = 0;\n        this.suffixMatchCriteria = v.Levenshtein;\n        this.fimSuffixLengthThreshold = 0;\n        if (n) for (const e in n) this[e] = n[e];\n        if (this.suffixPercent < 0 || this.suffixPercent > 100) throw new Error(`suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`);\n        if (this.suffixPercent > 0 && this.includeSiblingFunctions != h.NoSiblings) throw new Error(`Invalid option combination. Cannot set suffixPercent > 0 (${this.suffixPercent}) and includeSiblingFunctions ${this.includeSiblingFunctions}`);\n        if (this.suffixMatchThreshold < 0 || this.suffixMatchThreshold > 100) throw new Error(`suffixMatchThreshold must be at between 0 and 100, but was ${this.suffixMatchThreshold}`);\n        if (this.fimSuffixLengthThreshold < -1) throw new Error(`fimSuffixLengthThreshold must be at least -1, but was ${this.fimSuffixLengthThreshold}`);\n        if (null != this.indentationMinLength && null != this.indentationMaxLength && this.indentationMinLength > this.indentationMaxLength) throw new Error(`indentationMinLength must be less than or equal to indentationMaxLength, but was ${this.indentationMinLength} and ${this.indentationMaxLength}`);\n        if (this.snippetSelection === g.TopK && undefined === this.snippetSelectionK) throw new Error(\"snippetSelectionK must be defined.\");\n        if (this.snippetSelection === g.TopK && this.snippetSelectionK && this.snippetSelectionK <= 0) throw new Error(`snippetSelectionK must be greater than 0, but was ${this.snippetSelectionK}`);\n      }\n    }\n    t.PromptOptions = x;\n    const E = {\n      javascriptreact: \"javascript\",\n      jsx: \"javascript\",\n      typescriptreact: \"typescript\",\n      jade: \"pug\",\n      cshtml: \"razor\"\n    };\n    function C(e) {\n      var t;\n      e = e.toLowerCase();\n      return null !== (t = E[e]) && undefined !== t ? t : e;\n    }\n    function S(e) {\n      return \"\" == e || e.endsWith(\"\\n\") ? e : e + \"\\n\";\n    }\n    t.normalizeLanguageId = C;\n    t.newLineEnded = S;\n    t.getPrompt = async function (e, n, g = {}, y = []) {\n      var w;\n      const E = new x(e, g);\n      let T = !1;\n      const {\n        source: k,\n        offset: I\n      } = n;\n      if (I < 0 || I > k.length) throw new Error(`Offset ${I} is out of range.`);\n      n.languageId = C(n.languageId);\n      const P = new c.Priorities(),\n        A = P.justBelow(c.Priorities.TOP),\n        O = E.languageMarker == d.Always ? P.justBelow(c.Priorities.TOP) : P.justBelow(A),\n        N = E.pathMarker == p.Always ? P.justBelow(c.Priorities.TOP) : P.justBelow(A),\n        R = E.includeSiblingFunctions == h.ContextOverSiblings ? P.justBelow(A) : P.justAbove(A),\n        M = P.justBelow(A, R),\n        L = P.justBelow(M),\n        $ = new c.PromptWishlist(E.lineEnding);\n      let D, F;\n      if (E.languageMarker != d.NoMarker) {\n        const e = S(r.getLanguageMarker(n));\n        D = $.append(e, c.PromptElementKind.LanguageMarker, O);\n      }\n      if (E.pathMarker != p.NoMarker) {\n        const e = S(r.getPathMarker(n));\n        e.length > 0 && (F = $.append(e, c.PromptElementKind.PathMarker, N));\n      }\n      if (E.localImportContext != _.NoContext) for (const e of await o.extractLocalImportContext(n, E.fs)) $.append(S(e), c.PromptElementKind.ImportedFile, M);\n      const j = E.neighboringTabs == f.None || 0 == y.length ? [] : await i.getNeighborSnippets(n, y, E.neighboringTabs, E.indentationMinLength, E.indentationMaxLength, E.snippetSelectionOption, E.snippetSelectionK);\n      function q() {\n        j.forEach(e => $.append(e.snippet, c.PromptElementKind.SimilarFile, L, a.tokenLength(e.snippet), e.score));\n      }\n      E.neighboringTabsPosition == m.TopOfText && q();\n      const B = [];\n      let U;\n      if (E.includeSiblingFunctions == h.NoSiblings) U = k.substring(0, I);else {\n        const {\n          siblings: e,\n          beforeInsertion: t,\n          afterInsertion: r\n        } = await s.getSiblingFunctions(n);\n        $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach(e => B.push(e));\n        let o = R;\n        e.forEach(e => {\n          $.append(e, c.PromptElementKind.AfterCursor, o);\n          o = P.justBelow(o);\n        });\n        E.neighboringTabsPosition == m.AfterSiblings && q();\n        U = r;\n      }\n      if (E.neighboringTabsPosition == m.DirectlyAboveCursor) {\n        const e = U.lastIndexOf(\"\\n\") + 1,\n          t = U.substring(0, e),\n          n = U.substring(e);\n        $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach(e => B.push(e));\n        q();\n        n.length > 0 && (B.push($.append(n, c.PromptElementKind.AfterCursor, A)), B.length > 1 && $.require(B[B.length - 2], B[B.length - 1]));\n      } else $.appendLineForLine(U, c.PromptElementKind.BeforeCursor, A).forEach(e => B.push(e));\n      d.Top == E.languageMarker && B.length > 0 && undefined !== D && $.require(D, B[0]);\n      p.Top == E.pathMarker && B.length > 0 && undefined !== F && (D ? $.require(F, D) : $.require(F, B[0]));\n      undefined !== D && undefined !== F && $.exclude(F, D);\n      let H = k.slice(I);\n      if (0 == E.suffixPercent || H.length <= E.fimSuffixLengthThreshold) return $.fulfill(E.maxPromptLength);\n      {\n        let e = n.offset;\n        E.suffixStartMode !== b.Cursor && E.suffixStartMode !== b.CursorTrimStart && (e = await s.getSiblingFunctionStart(n));\n        const r = E.maxPromptLength - t.TOKENS_RESERVED_FOR_SUFFIX_ENCODING;\n        let o = Math.floor(r * (100 - E.suffixPercent) / 100),\n          i = $.fulfill(o);\n        const c = r - i.prefixLength;\n        let d = k.slice(e);\n        E.suffixStartMode != b.SiblingBlockTrimStart && E.suffixStartMode != b.CursorTrimStart || (d = d.trimStart());\n        const p = a.takeFirstTokens(d, c);\n        p.tokens.length <= c - 3 && (o = r - p.tokens.length, i = $.fulfill(o));\n        E.suffixMatchCriteria == v.Equal ? p.tokens.length === u.tokens.length && p.tokens.every((e, t) => e === u.tokens[t]) && (T = !0) : E.suffixMatchCriteria == v.Levenshtein && p.tokens.length > 0 && E.suffixMatchThreshold > 0 && 100 * (null === (w = l.findEditDistanceScore(p.tokens.slice(0, t.MAX_EDIT_DISTANCE_LENGTH), u.tokens.slice(0, t.MAX_EDIT_DISTANCE_LENGTH))) || undefined === w ? undefined : w.score) < E.suffixMatchThreshold * Math.min(t.MAX_EDIT_DISTANCE_LENGTH, p.tokens.length) && (T = !0);\n        !0 === T && u.tokens.length <= c ? (u.tokens.length <= c - 3 && (o = r - u.tokens.length, i = $.fulfill(o)), i.suffix = u.text, i.suffixLength = u.tokens.length) : (i.suffix = p.text, i.suffixLength = p.tokens.length, u = p);\n        return i;\n      }\n    };\n  },\n  670: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.getSiblingFunctionStart = t.getSiblingFunctions = undefined;\n    const r = n(312),\n      o = n(306);\n    t.getSiblingFunctions = async function ({\n      source: e,\n      offset: t,\n      languageId: n\n    }) {\n      var i, s;\n      const a = [];\n      let c = \"\",\n        l = e.substring(0, t);\n      if (o.isSupportedLanguageId(n)) {\n        const u = await o.parseTree(n, e);\n        try {\n          let d = t;\n          for (; d >= 0 && /\\s/.test(e[d]);) d--;\n          const p = u.rootNode.descendantForIndex(d),\n            h = o.getAncestorWithSiblingFunctions(n, p);\n          if (h) {\n            const u = o.getFirstPrecedingComment(h),\n              d = null !== (i = null == u ? undefined : u.startIndex) && undefined !== i ? i : h.startIndex;\n            let p,\n              f = 0;\n            for (; \" \" == (p = e[d - f - 1]) || \"\\t\" == p;) f++;\n            const m = e.substring(d - f, d);\n            for (let i = h.nextSibling; i; i = i.nextSibling) if (o.isFunctionDefinition(n, i)) {\n              const n = o.getFirstPrecedingComment(i),\n                c = null !== (s = null == n ? undefined : n.startIndex) && undefined !== s ? s : i.startIndex;\n              if (c < t) continue;\n              const l = e.substring(c, i.endIndex),\n                u = r.newLineEnded(l) + \"\\n\" + m;\n              a.push(u);\n            }\n            c = e.substring(0, d);\n            l = e.substring(d, t);\n          }\n        } finally {\n          u.delete();\n        }\n      }\n      return {\n        siblings: a,\n        beforeInsertion: c,\n        afterInsertion: l\n      };\n    };\n    t.getSiblingFunctionStart = async function ({\n      source: e,\n      offset: t,\n      languageId: n\n    }) {\n      var r;\n      if (o.isSupportedLanguageId(n)) {\n        const i = await o.parseTree(n, e);\n        try {\n          let s = t;\n          for (; s >= 0 && /\\s/.test(e[s]);) s--;\n          const a = i.rootNode.descendantForIndex(s),\n            c = o.getAncestorWithSiblingFunctions(n, a);\n          if (c) {\n            for (let e = c.nextSibling; e; e = e.nextSibling) if (o.isFunctionDefinition(n, e)) {\n              const n = o.getFirstPrecedingComment(e),\n                i = null !== (r = null == n ? undefined : n.startIndex) && undefined !== r ? r : e.startIndex;\n              if (i < t) continue;\n              return i;\n            }\n            if (c.endIndex >= t) return c.endIndex;\n          }\n        } finally {\n          i.delete();\n        }\n      }\n      return t;\n    };\n  },\n  404: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.computeScore = t.IndentationBasedJaccardMatcher = t.FixedWindowSizeJaccardMatcher = undefined;\n    const r = n(250),\n      o = n(467);\n    class i extends o.WindowedMatcher {\n      constructor(e, t) {\n        super(e);\n        this.windowLength = t;\n      }\n      id() {\n        return \"fixed:\" + this.windowLength;\n      }\n      getWindowsDelineations(e) {\n        const t = [],\n          n = e.length;\n        for (let e = 0; 0 == e || e < n - this.windowLength; e++) {\n          const r = Math.min(e + this.windowLength, n);\n          t.push([e, r]);\n        }\n        return t;\n      }\n      trimDocument(e) {\n        return e.source.slice(0, e.offset).split(\"\\n\").slice(-this.windowLength).join(\"\\n\");\n      }\n      similarityScore(e, t) {\n        return a(e, t);\n      }\n    }\n    t.FixedWindowSizeJaccardMatcher = i;\n    i.FACTORY = e => ({\n      to: t => new i(t, e)\n    });\n    class s extends o.WindowedMatcher {\n      constructor(e, t, n) {\n        super(e);\n        this.indentationMinLength = t;\n        this.indentationMaxLength = n;\n        this.languageId = e.languageId;\n      }\n      id() {\n        return `indent:${this.indentationMinLength}:${this.indentationMaxLength}:${this.languageId}`;\n      }\n      getWindowsDelineations(e) {\n        return r.getWindowsDelineations(e, this.languageId, this.indentationMinLength, this.indentationMaxLength);\n      }\n      trimDocument(e) {\n        return e.source.slice(0, e.offset).split(\"\\n\").slice(-this.indentationMaxLength).join(\"\\n\");\n      }\n      similarityScore(e, t) {\n        return a(e, t);\n      }\n    }\n    function a(e, t) {\n      const n = new Set();\n      e.forEach(e => {\n        t.has(e) && n.add(e);\n      });\n      return n.size / (e.size + t.size - n.size);\n    }\n    t.IndentationBasedJaccardMatcher = s;\n    s.FACTORY = (e, t) => ({\n      to: n => new s(n, e, t)\n    });\n    t.computeScore = a;\n  },\n  125: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.getNeighborSnippets = t.neighborOptionToSelection = undefined;\n    const r = n(417),\n      o = n(404);\n    function i(e) {\n      return [e.relativePath ? \"Compare this snippet from \" + e.relativePath + \":\" : \"Compare this snippet:\"].concat(e.snippet.split(\"\\n\"));\n    }\n    t.neighborOptionToSelection = {\n      none: {\n        matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(1),\n        threshold: -1,\n        numberOfSnippets: 0\n      },\n      conservative: {\n        matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\n        threshold: .3,\n        numberOfSnippets: 1\n      },\n      medium: {\n        matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(20),\n        threshold: .1,\n        numberOfSnippets: 2\n      },\n      eager: {\n        matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(60),\n        threshold: 0,\n        numberOfSnippets: 4\n      },\n      eagerButLittle: {\n        matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\n        threshold: 0,\n        numberOfSnippets: 1\n      }\n    };\n    t.getNeighborSnippets = async function (e, n, s, a, c, l, u) {\n      const d = t.neighborOptionToSelection[s],\n        p = function (e, n, r, i) {\n          const s = {\n            ...t.neighborOptionToSelection[n]\n          };\n          undefined !== r && undefined !== i && (s.matcherFactory = o.IndentationBasedJaccardMatcher.FACTORY(r, i));\n          return s.matcherFactory.to(e);\n        }(e, s, a, c);\n      return n.filter(e => e.source.length < 1e4 && e.source.length > 0).slice(0, 20).reduce((e, t) => e.concat(p.findMatches(t, l, u).map(e => ({\n        relativePath: t.relativePath,\n        ...e\n      }))), []).filter(e => e.score && e.snippet && e.score > d.threshold).sort((e, t) => e.score - t.score).slice(-d.numberOfSnippets).map(t => ({\n        score: t.score,\n        snippet: i(t).map(t => r.comment(t, e.languageId) + \"\\n\").join(\"\"),\n        startLine: t.startLine,\n        endLine: t.endLine\n      }));\n    };\n  },\n  467: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.splitIntoWords = t.WindowedMatcher = t.SortOptions = undefined;\n    const r = n(312);\n    var o;\n    !function (e) {\n      e.Ascending = \"ascending\";\n      e.Descending = \"descending\";\n      e.None = \"none\";\n    }(o = t.SortOptions || (t.SortOptions = {}));\n    class i {\n      constructor(e) {\n        var t;\n        this.stopsForLanguage = null !== (t = u.get(e.languageId)) && undefined !== t ? t : l;\n      }\n      tokenize(e) {\n        return new Set(a(e).filter(e => !this.stopsForLanguage.has(e)));\n      }\n    }\n    const s = new class {\n      constructor(e) {\n        this.keys = [];\n        this.cache = {};\n        this.size = e;\n      }\n      put(e, t) {\n        var n;\n        this.cache[e] = t;\n        if (this.keys.length > this.size) {\n          this.keys.push(e);\n          const t = null !== (n = this.keys.shift()) && void 0 !== n ? n : \"\";\n          delete this.cache[t];\n        }\n      }\n      get(e) {\n        return this.cache[e];\n      }\n    }(20);\n    function a(e) {\n      return e.split(/[^a-zA-Z0-9]/).filter(e => e.length > 0);\n    }\n    t.WindowedMatcher = class {\n      constructor(e) {\n        this.tokenizer = new i(e);\n        this.referenceTokens = this.tokenizer.tokenize(this.trimDocument(e));\n      }\n      sortScoredSnippets(e, t = o.Descending) {\n        return t == o.Ascending ? e.sort((e, t) => e.score > t.score ? 1 : -1) : t == o.Descending ? e.sort((e, t) => e.score > t.score ? -1 : 1) : e;\n      }\n      retrieveAllSnippets(e, t = o.Descending) {\n        var n;\n        const r = [];\n        if (0 === e.source.length || 0 === this.referenceTokens.size) return r;\n        const i = e.source.split(\"\\n\"),\n          a = this.id() + \":\" + e.source,\n          c = null !== (n = s.get(a)) && undefined !== n ? n : [],\n          l = 0 == c.length,\n          u = l ? i.map(this.tokenizer.tokenize, this.tokenizer) : [];\n        for (const [e, [t, n]] of this.getWindowsDelineations(i).entries()) {\n          if (l) {\n            const e = new Set();\n            u.slice(t, n).forEach(t => t.forEach(e.add, e));\n            c.push(e);\n          }\n          const o = c[e],\n            i = this.similarityScore(o, this.referenceTokens);\n          r.push({\n            score: i,\n            startLine: t,\n            endLine: n\n          });\n        }\n        l && s.put(a, c);\n        return this.sortScoredSnippets(r, t);\n      }\n      findMatches(e, t = r.SnippetSelectionOption.BestMatch, n) {\n        if (t == r.SnippetSelectionOption.BestMatch) {\n          const t = this.findBestMatch(e);\n          return t ? [t] : [];\n        }\n        return t == r.SnippetSelectionOption.TopK && this.findTopKMatches(e, n) || [];\n      }\n      findBestMatch(e) {\n        if (0 === e.source.length || 0 === this.referenceTokens.size) return;\n        const t = e.source.split(\"\\n\"),\n          n = this.retrieveAllSnippets(e, o.Descending);\n        return 0 !== n.length && 0 !== n[0].score ? {\n          snippet: t.slice(n[0].startLine, n[0].endLine).join(\"\\n\"),\n          ...n[0]\n        } : undefined;\n      }\n      findTopKMatches(e, t = 1) {\n        if (0 === e.source.length || 0 === this.referenceTokens.size || t < 1) return;\n        const n = e.source.split(\"\\n\"),\n          r = this.retrieveAllSnippets(e, o.Descending);\n        if (0 === r.length || 0 === r[0].score) return;\n        const i = [r[0]];\n        for (let e = 1; e < r.length && i.length < t; e++) -1 == i.findIndex(t => r[e].startLine < t.endLine && r[e].endLine > t.startLine) && i.push(r[e]);\n        return i.map(e => ({\n          snippet: n.slice(e.startLine, e.endLine).join(\"\\n\"),\n          ...e\n        }));\n      }\n    };\n    t.splitIntoWords = a;\n    const c = new Set([\"we\", \"our\", \"you\", \"it\", \"its\", \"they\", \"them\", \"their\", \"this\", \"that\", \"these\", \"those\", \"is\", \"are\", \"was\", \"were\", \"be\", \"been\", \"being\", \"have\", \"has\", \"had\", \"having\", \"do\", \"does\", \"did\", \"doing\", \"can\", \"don\", \"t\", \"s\", \"will\", \"would\", \"should\", \"what\", \"which\", \"who\", \"when\", \"where\", \"why\", \"how\", \"a\", \"an\", \"the\", \"and\", \"or\", \"not\", \"no\", \"but\", \"because\", \"as\", \"until\", \"again\", \"further\", \"then\", \"once\", \"here\", \"there\", \"all\", \"any\", \"both\", \"each\", \"few\", \"more\", \"most\", \"other\", \"some\", \"such\", \"above\", \"below\", \"to\", \"during\", \"before\", \"after\", \"of\", \"at\", \"by\", \"about\", \"between\", \"into\", \"through\", \"from\", \"up\", \"down\", \"in\", \"out\", \"on\", \"off\", \"over\", \"under\", \"only\", \"own\", \"same\", \"so\", \"than\", \"too\", \"very\", \"just\", \"now\"]),\n      l = new Set([\"if\", \"then\", \"else\", \"for\", \"while\", \"with\", \"def\", \"function\", \"return\", \"TODO\", \"import\", \"try\", \"catch\", \"raise\", \"finally\", \"repeat\", \"switch\", \"case\", \"match\", \"assert\", \"continue\", \"break\", \"const\", \"class\", \"enum\", \"struct\", \"static\", \"new\", \"super\", \"this\", \"var\", ...c]),\n      u = new Map([]);\n  },\n  395: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.findEditDistanceScore = undefined;\n    const r = n(94);\n    t.findEditDistanceScore = function (e, t) {\n      \"string\" == typeof e && (e = r.tokenize(e));\n      \"string\" == typeof t && (t = r.tokenize(t));\n      if (0 === e.length || 0 === t.length) return {\n        score: e.length + t.length\n      };\n      const n = Array.from({\n        length: e.length\n      }).map(() => Array.from({\n        length: t.length\n      }).map(() => 0));\n      for (let t = 0; t < e.length; t++) n[t][0] = t;\n      for (let e = 0; e < t.length; e++) n[0][e] = e;\n      for (let r = 0; r < t.length; r++) for (let o = 0; o < e.length; o++) n[o][r] = Math.min((0 == o ? r : n[o - 1][r]) + 1, (0 == r ? o : n[o][r - 1]) + 1, (0 == o || 0 == r ? Math.max(o, r) : n[o - 1][r - 1]) + (e[o] == t[r] ? 0 : 1));\n      return {\n        score: n[e.length - 1][t.length - 1]\n      };\n    };\n  },\n  456: (e, t, n) => {\n    \"use strict\";\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    t.Priorities = t.PromptWishlist = t.PromptElementRanges = t.PromptChoices = t.PromptBackground = t.PromptElementKind = undefined;\n    const r = n(312),\n      o = n(94);\n    var i;\n    !function (e) {\n      e.BeforeCursor = \"BeforeCursor\";\n      e.AfterCursor = \"AfterCursor\";\n      e.SimilarFile = \"SimilarFile\";\n      e.ImportedFile = \"ImportedFile\";\n      e.LanguageMarker = \"LanguageMarker\";\n      e.PathMarker = \"PathMarker\";\n    }(i = t.PromptElementKind || (t.PromptElementKind = {}));\n    class s {\n      constructor() {\n        this.used = new Map();\n        this.unused = new Map();\n      }\n      markUsed(e) {\n        this.IsNeighboringTab(e) && this.used.set(e.id, this.convert(e));\n      }\n      undoMarkUsed(e) {\n        this.IsNeighboringTab(e) && this.used.delete(e.id);\n      }\n      markUnused(e) {\n        this.IsNeighboringTab(e) && this.unused.set(e.id, this.convert(e));\n      }\n      convert(e) {\n        return {\n          score: e.score.toFixed(4),\n          length: e.text.length\n        };\n      }\n      IsNeighboringTab(e) {\n        return e.kind == i.SimilarFile;\n      }\n    }\n    t.PromptBackground = s;\n    class a {\n      constructor() {\n        this.used = new Map();\n        this.unused = new Map();\n      }\n      markUsed(e) {\n        this.used.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\n      }\n      undoMarkUsed(e) {\n        this.used.set(e.kind, (this.used.get(e.kind) || 0) - e.tokens);\n      }\n      markUnused(e) {\n        this.unused.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\n      }\n    }\n    t.PromptChoices = a;\n    class c {\n      constructor(e) {\n        this.ranges = new Array();\n        let t,\n          n = 0;\n        for (const {\n          element: r\n        } of e) 0 !== r.text.length && (t === i.BeforeCursor && r.kind === i.BeforeCursor ? this.ranges[this.ranges.length - 1].end += r.text.length : this.ranges.push({\n          kind: r.kind,\n          start: n,\n          end: n + r.text.length\n        }), t = r.kind, n += r.text.length);\n      }\n    }\n    t.PromptElementRanges = c;\n    t.PromptWishlist = class {\n      constructor(e) {\n        this.content = [];\n        this.lineEndingOption = e;\n      }\n      getContent() {\n        return [...this.content];\n      }\n      convertLineEndings(e) {\n        this.lineEndingOption === r.LineEndingOptions.ConvertToUnix && (e = e.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\"));\n        return e;\n      }\n      append(e, t, n, r = o.tokenLength(e), i = NaN) {\n        e = this.convertLineEndings(e);\n        const s = this.content.length;\n        this.content.push({\n          id: s,\n          text: e,\n          kind: t,\n          priority: n,\n          tokens: r,\n          requires: [],\n          excludes: [],\n          score: i\n        });\n        return s;\n      }\n      appendLineForLine(e, t, n) {\n        const r = (e = this.convertLineEndings(e)).split(\"\\n\");\n        for (let e = 0; e < r.length - 1; e++) r[e] += \"\\n\";\n        const o = [];\n        r.forEach((e, t) => {\n          \"\\n\" === e && o.length > 0 && !o[o.length - 1].endsWith(\"\\n\\n\") ? o[o.length - 1] += \"\\n\" : o.push(e);\n        });\n        const i = [];\n        o.forEach((e, r) => {\n          \"\" !== e && (i.push(this.append(e, t, n)), r > 0 && (this.content[this.content.length - 2].requires = [this.content[this.content.length - 1]]));\n        });\n        return i;\n      }\n      require(e, t) {\n        const n = this.content.find(t => t.id === e),\n          r = this.content.find(e => e.id === t);\n        n && r && n.requires.push(r);\n      }\n      exclude(e, t) {\n        const n = this.content.find(t => t.id === e),\n          r = this.content.find(e => e.id === t);\n        n && r && n.excludes.push(r);\n      }\n      fulfill(e) {\n        const t = new a(),\n          n = new s(),\n          r = this.content.map((e, t) => ({\n            element: e,\n            index: t\n          }));\n        r.sort((e, t) => e.element.priority === t.element.priority ? t.index - e.index : t.element.priority - e.element.priority);\n        const i = new Set(),\n          l = new Set();\n        let u;\n        const d = [];\n        let p = e;\n        r.forEach(e => {\n          var r;\n          const o = e.element,\n            s = e.index;\n          if (p >= 0 && (p > 0 || undefined === u) && o.requires.every(e => i.has(e.id)) && !l.has(o.id)) {\n            let a = o.tokens;\n            const c = null === (r = function (e, t) {\n              let n,\n                r = 1 / 0;\n              for (const o of e) o.index > t && o.index < r && (n = o, r = o.index);\n              return n;\n            }(d, s)) || undefined === r ? undefined : r.element;\n            o.text.endsWith(\"\\n\\n\") && c && !c.text.match(/^\\s/) && a++;\n            p >= a ? (p -= a, i.add(o.id), o.excludes.forEach(e => l.add(e.id)), t.markUsed(o), n.markUsed(o), d.push(e)) : u = null != u ? u : e;\n          } else {\n            t.markUnused(o);\n            n.markUnused(o);\n          }\n        });\n        d.sort((e, t) => e.index - t.index);\n        let h = d.reduce((e, t) => e + t.element.text, \"\"),\n          f = o.tokenLength(h);\n        for (; f > e;) {\n          d.sort((e, t) => t.element.priority === e.element.priority ? t.index - e.index : t.element.priority - e.element.priority);\n          const e = d.pop();\n          e && (t.undoMarkUsed(e.element), t.markUnused(e.element), n.undoMarkUsed(e.element), n.markUnused(e.element), u = undefined);\n          d.sort((e, t) => e.index - t.index);\n          h = d.reduce((e, t) => e + t.element.text, \"\");\n          f = o.tokenLength(h);\n        }\n        const m = [...d];\n        if (undefined !== u) {\n          m.push(u);\n          m.sort((e, t) => e.index - t.index);\n          const r = m.reduce((e, t) => e + t.element.text, \"\"),\n            i = o.tokenLength(r);\n          if (i <= e) {\n            t.markUsed(u.element);\n            n.markUsed(u.element);\n            const e = new c(m);\n            return {\n              prefix: r,\n              suffix: \"\",\n              prefixLength: i,\n              suffixLength: 0,\n              promptChoices: t,\n              promptBackground: n,\n              promptElementRanges: e\n            };\n          }\n          t.markUnused(u.element);\n          n.markUnused(u.element);\n        }\n        const g = new c(d);\n        return {\n          prefix: h,\n          suffix: \"\",\n          prefixLength: f,\n          suffixLength: 0,\n          promptChoices: t,\n          promptBackground: n,\n          promptElementRanges: g\n        };\n      }\n    };\n    class l {\n      constructor() {\n        this.registeredPriorities = [0, 1];\n      }\n      register(e) {\n        if (e > l.TOP || e < l.BOTTOM) throw new Error(\"Priority must be between 0 and 1\");\n        this.registeredPriorities.push(e);\n        return e;\n      }\n      justAbove(...e) {\n        const t = Math.max(...e),\n          n = Math.min(...this.registeredPriorities.filter(e => e > t));\n        return this.register((n + t) / 2);\n      }\n      justBelow(...e) {\n        const t = Math.min(...e),\n          n = Math.max(...this.registeredPriorities.filter(e => e < t));\n        return this.register((n + t) / 2);\n      }\n      between(e, t) {\n        if (this.registeredPriorities.some(n => n > e && n < t) || !this.registeredPriorities.includes(e) || !this.registeredPriorities.includes(t)) throw new Error(\"Priorities must be adjacent in the list of priorities\");\n        return this.register((e + t) / 2);\n      }\n    }\n    t.Priorities = l;\n    l.TOP = 1;\n    l.BOTTOM = 0;\n  },\n  87: (e, t, n) => {\n    var r,\n      o,\n      i = undefined !== i ? i : {};\n    undefined === (o = \"function\" == typeof (r = function () {\n      var t,\n        r = {};\n      for (t in i) i.hasOwnProperty(t) && (r[t] = i[t]);\n      var o,\n        s,\n        a = [],\n        c = \"./this.program\",\n        l = function (e, t) {\n          throw t;\n        },\n        u = !1,\n        d = !1;\n      u = \"object\" == typeof window;\n      d = \"function\" == typeof importScripts;\n      o = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node;\n      s = !u && !o && !d;\n      var p,\n        h,\n        f,\n        m,\n        g,\n        _ = \"\";\n      o ? (_ = d ? n(622).dirname(_) + \"/\" : __dirname + \"/\", p = function (e, t) {\n        m || (m = n(747));\n        g || (g = n(622));\n        e = g.normalize(e);\n        return m.readFileSync(e, t ? null : \"utf8\");\n      }, f = function (e) {\n        var t = p(e, !0);\n        t.buffer || (t = new Uint8Array(t));\n        O(t.buffer);\n        return t;\n      }, process.argv.length > 1 && (c = process.argv[1].replace(/\\\\/g, \"/\")), a = process.argv.slice(2), e.exports = i, l = function (e) {\n        process.exit(e);\n      }, i.inspect = function () {\n        return \"[Emscripten Module object]\";\n      }) : s ? (\"undefined\" != typeof read && (p = function (e) {\n        return read(e);\n      }), f = function (e) {\n        var t;\n        return \"function\" == typeof readbuffer ? new Uint8Array(readbuffer(e)) : (O(\"object\" == typeof (t = read(e, \"binary\"))), t);\n      }, \"undefined\" != typeof scriptArgs ? a = scriptArgs : undefined !== arguments && (a = arguments), \"function\" == typeof quit && (l = function (e) {\n        quit(e);\n      }), \"undefined\" != typeof print && (\"undefined\" == typeof console && (console = {}), console.log = print, console.warn = console.error = \"undefined\" != typeof printErr ? printErr : print)) : (u || d) && (d ? _ = self.location.href : \"undefined\" != typeof document && document.currentScript && (_ = document.currentScript.src), _ = 0 !== _.indexOf(\"blob:\") ? _.substr(0, _.lastIndexOf(\"/\") + 1) : \"\", p = function (e) {\n        var t = new XMLHttpRequest();\n        t.open(\"GET\", e, !1);\n        t.send(null);\n        return t.responseText;\n      }, d && (f = function (e) {\n        var t = new XMLHttpRequest();\n        t.open(\"GET\", e, !1);\n        t.responseType = \"arraybuffer\";\n        t.send(null);\n        return new Uint8Array(t.response);\n      }), h = function (e, t, n) {\n        var r = new XMLHttpRequest();\n        r.open(\"GET\", e, !0);\n        r.responseType = \"arraybuffer\";\n        r.onload = function () {\n          200 == r.status || 0 == r.status && r.response ? t(r.response) : n();\n        };\n        r.onerror = n;\n        r.send(null);\n      });\n      i.print || console.log.bind(console);\n      var y = i.printErr || console.warn.bind(console);\n      for (t in r) r.hasOwnProperty(t) && (i[t] = r[t]);\n      r = null;\n      i.arguments && (a = i.arguments);\n      i.thisProgram && (c = i.thisProgram);\n      i.quit && (l = i.quit);\n      var v,\n        b = 16,\n        w = [];\n      function x(e, t) {\n        if (!v) {\n          v = new WeakMap();\n          for (var n = 0; n < J.length; n++) {\n            var r = J.get(n);\n            r && v.set(r, n);\n          }\n        }\n        if (v.has(e)) return v.get(e);\n        var o = function () {\n          if (w.length) return w.pop();\n          try {\n            J.grow(1);\n          } catch (e) {\n            if (!(e instanceof RangeError)) throw e;\n            throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n          }\n          return J.length - 1;\n        }();\n        try {\n          J.set(o, e);\n        } catch (n) {\n          if (!(n instanceof TypeError)) throw n;\n          var i = function (e, t) {\n            if (\"function\" == typeof WebAssembly.Function) {\n              for (var n = {\n                  i: \"i32\",\n                  j: \"i64\",\n                  f: \"f32\",\n                  d: \"f64\"\n                }, r = {\n                  parameters: [],\n                  results: \"v\" == t[0] ? [] : [n[t[0]]]\n                }, o = 1; o < t.length; ++o) r.parameters.push(n[t[o]]);\n              return new WebAssembly.Function(r, e);\n            }\n            var i = [1, 0, 1, 96],\n              s = t.slice(0, 1),\n              a = t.slice(1),\n              c = {\n                i: 127,\n                j: 126,\n                f: 125,\n                d: 124\n              };\n            for (i.push(a.length), o = 0; o < a.length; ++o) i.push(c[a[o]]);\n            \"v\" == s ? i.push(0) : i = i.concat([1, c[s]]);\n            i[1] = i.length - 2;\n            var l = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(i, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0])),\n              u = new WebAssembly.Module(l);\n            return new WebAssembly.Instance(u, {\n              e: {\n                f: e\n              }\n            }).exports.f;\n          }(e, t);\n          J.set(o, i);\n        }\n        v.set(e, o);\n        return o;\n      }\n      var E,\n        C = function (e) {},\n        S = i.dynamicLibraries || [];\n      i.wasmBinary && (E = i.wasmBinary);\n      var T,\n        k = i.noExitRuntime || !0;\n      function I(e, t, n, r) {\n        switch (\"*\" === (n = n || \"i8\").charAt(n.length - 1) && (n = \"i32\"), n) {\n          case \"i1\":\n          case \"i8\":\n            R[e >> 0] = t;\n            break;\n          case \"i16\":\n            L[e >> 1] = t;\n            break;\n          case \"i32\":\n            $[e >> 2] = t;\n            break;\n          case \"i64\":\n            pe = [t >>> 0, (de = t, +Math.abs(de) >= 1 ? de > 0 ? (0 | Math.min(+Math.floor(de / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((de - +(~~de >>> 0)) / 4294967296) >>> 0 : 0)];\n            $[e >> 2] = pe[0];\n            $[e + 4 >> 2] = pe[1];\n            break;\n          case \"float\":\n            D[e >> 2] = t;\n            break;\n          case \"double\":\n            F[e >> 3] = t;\n            break;\n          default:\n            se(\"invalid type for setValue: \" + n);\n        }\n      }\n      function P(e, t, n) {\n        switch (\"*\" === (t = t || \"i8\").charAt(t.length - 1) && (t = \"i32\"), t) {\n          case \"i1\":\n          case \"i8\":\n            return R[e >> 0];\n          case \"i16\":\n            return L[e >> 1];\n          case \"i32\":\n          case \"i64\":\n            return $[e >> 2];\n          case \"float\":\n            return D[e >> 2];\n          case \"double\":\n            return F[e >> 3];\n          default:\n            se(\"invalid type for getValue: \" + t);\n        }\n        return null;\n      }\n      \"object\" != typeof WebAssembly && se(\"no native wasm support detected\");\n      var A = !1;\n      function O(e, t) {\n        e || se(\"Assertion failed: \" + t);\n      }\n      var N,\n        R,\n        M,\n        L,\n        $,\n        D,\n        F,\n        j = 1,\n        q = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : undefined;\n      function B(e, t, n) {\n        for (var r = t + n, o = t; e[o] && !(o >= r);) ++o;\n        if (o - t > 16 && e.subarray && q) return q.decode(e.subarray(t, o));\n        for (var i = \"\"; t < o;) {\n          var s = e[t++];\n          if (128 & s) {\n            var a = 63 & e[t++];\n            if (192 != (224 & s)) {\n              var c = 63 & e[t++];\n              if ((s = 224 == (240 & s) ? (15 & s) << 12 | a << 6 | c : (7 & s) << 18 | a << 12 | c << 6 | 63 & e[t++]) < 65536) i += String.fromCharCode(s);else {\n                var l = s - 65536;\n                i += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l);\n              }\n            } else i += String.fromCharCode((31 & s) << 6 | a);\n          } else i += String.fromCharCode(s);\n        }\n        return i;\n      }\n      function U(e, t) {\n        return e ? B(M, e, t) : \"\";\n      }\n      function H(e, t, n, r) {\n        if (!(r > 0)) return 0;\n        for (var o = n, i = n + r - 1, s = 0; s < e.length; ++s) {\n          var a = e.charCodeAt(s);\n          a >= 55296 && a <= 57343 && (a = 65536 + ((1023 & a) << 10) | 1023 & e.charCodeAt(++s));\n          if (a <= 127) {\n            if (n >= i) break;\n            t[n++] = a;\n          } else if (a <= 2047) {\n            if (n + 1 >= i) break;\n            t[n++] = 192 | a >> 6, t[n++] = 128 | 63 & a;\n          } else if (a <= 65535) {\n            if (n + 2 >= i) break;\n            t[n++] = 224 | a >> 12, t[n++] = 128 | a >> 6 & 63, t[n++] = 128 | 63 & a;\n          } else {\n            if (n + 3 >= i) break;\n            t[n++] = 240 | a >> 18, t[n++] = 128 | a >> 12 & 63, t[n++] = 128 | a >> 6 & 63, t[n++] = 128 | 63 & a;\n          }\n        }\n        t[n] = 0;\n        return n - o;\n      }\n      function z(e, t, n) {\n        return H(e, M, t, n);\n      }\n      function G(e) {\n        for (var t = 0, n = 0; n < e.length; ++n) {\n          var r = e.charCodeAt(n);\n          r >= 55296 && r <= 57343 && (r = 65536 + ((1023 & r) << 10) | 1023 & e.charCodeAt(++n));\n          r <= 127 ? ++t : t += r <= 2047 ? 2 : r <= 65535 ? 3 : 4;\n        }\n        return t;\n      }\n      function V(e) {\n        var t = G(e) + 1,\n          n = Ve(t);\n        H(e, R, n, t);\n        return n;\n      }\n      function W(e) {\n        N = e;\n        i.HEAP8 = R = new Int8Array(e);\n        i.HEAP16 = L = new Int16Array(e);\n        i.HEAP32 = $ = new Int32Array(e);\n        i.HEAPU8 = M = new Uint8Array(e);\n        i.HEAPU16 = new Uint16Array(e);\n        i.HEAPU32 = new Uint32Array(e);\n        i.HEAPF32 = D = new Float32Array(e);\n        i.HEAPF64 = F = new Float64Array(e);\n      }\n      var K = i.INITIAL_MEMORY || 33554432;\n      (T = i.wasmMemory ? i.wasmMemory : new WebAssembly.Memory({\n        initial: K / 65536,\n        maximum: 32768\n      })) && (N = T.buffer);\n      K = N.byteLength;\n      W(N);\n      var J = new WebAssembly.Table({\n          initial: 13,\n          element: \"anyfunc\"\n        }),\n        X = [],\n        Q = [],\n        Y = [],\n        Z = [],\n        ee = !1,\n        te = 0,\n        ne = null,\n        re = null;\n      function oe(e) {\n        te++;\n        i.monitorRunDependencies && i.monitorRunDependencies(te);\n      }\n      function ie(e) {\n        te--;\n        i.monitorRunDependencies && i.monitorRunDependencies(te);\n        if (0 == te && (null !== ne && (clearInterval(ne), ne = null), re)) {\n          var t = re;\n          re = null, t();\n        }\n      }\n      function se(e) {\n        throw i.onAbort && i.onAbort(e), y(e += \"\"), A = !0, e = \"abort(\" + e + \"). Build with -s ASSERTIONS=1 for more info.\", new WebAssembly.RuntimeError(e);\n      }\n      i.preloadedImages = {};\n      i.preloadedAudios = {};\n      i.preloadedWasm = {};\n      var ae = \"data:application/octet-stream;base64,\";\n      function ce(e) {\n        return e.startsWith(ae);\n      }\n      function le(e) {\n        return e.startsWith(\"file://\");\n      }\n      var ue,\n        de,\n        pe,\n        he = \"tree-sitter.wasm\";\n      function fe(e) {\n        try {\n          if (e == he && E) return new Uint8Array(E);\n          if (f) return f(e);\n          throw \"both async and sync fetching of the wasm failed\";\n        } catch (e) {\n          se(e);\n        }\n      }\n      ce(he) || (ue = he, he = i.locateFile ? i.locateFile(ue, _) : _ + ue);\n      var me = {},\n        ge = {\n          get: function (e, t) {\n            me[t] || (me[t] = new WebAssembly.Global({\n              value: \"i32\",\n              mutable: !0\n            }));\n            return me[t];\n          }\n        };\n      function _e(e) {\n        for (; e.length > 0;) {\n          var t = e.shift();\n          if (\"function\" != typeof t) {\n            var n = t.func;\n            \"number\" == typeof n ? undefined === t.arg ? J.get(n)() : J.get(n)(t.arg) : n(undefined === t.arg ? null : t.arg);\n          } else t(i);\n        }\n      }\n      function ye(e) {\n        var t = 0;\n        function n() {\n          for (var n = 0, r = 1;;) {\n            var o = e[t++];\n            n += (127 & o) * r;\n            r *= 128;\n            if (!(128 & o)) break;\n          }\n          return n;\n        }\n        if (e instanceof WebAssembly.Module) {\n          var r = WebAssembly.Module.customSections(e, \"dylink\");\n          O(0 != r.length, \"need dylink section\");\n          e = new Int8Array(r[0]);\n        } else {\n          O(1836278016 == new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0], \"need to see wasm magic number\");\n          O(0 === e[8], \"need the dylink section to be first\");\n          t = 9;\n          n();\n          O(6 === e[t]);\n          O(e[++t] === \"d\".charCodeAt(0));\n          O(e[++t] === \"y\".charCodeAt(0));\n          O(e[++t] === \"l\".charCodeAt(0));\n          O(e[++t] === \"i\".charCodeAt(0));\n          O(e[++t] === \"n\".charCodeAt(0));\n          O(e[++t] === \"k\".charCodeAt(0));\n          t++;\n        }\n        var o = {};\n        o.memorySize = n();\n        o.memoryAlign = n();\n        o.tableSize = n();\n        o.tableAlign = n();\n        var i = n();\n        o.neededDynlibs = [];\n        for (var s = 0; s < i; ++s) {\n          var a = n(),\n            c = e.subarray(t, t + a);\n          t += a;\n          var l = B(c, 0);\n          o.neededDynlibs.push(l);\n        }\n        return o;\n      }\n      var ve = 0;\n      function be() {\n        return k || ve > 0;\n      }\n      var we = {\n        nextHandle: 1,\n        loadedLibs: {},\n        loadedLibNames: {}\n      };\n      function xe(e, t, n) {\n        return e.includes(\"j\") ? function (e, t, n) {\n          var r = i[\"dynCall_\" + e];\n          return n && n.length ? r.apply(null, [t].concat(n)) : r.call(null, t);\n        }(e, t, n) : J.get(t).apply(null, n);\n      }\n      var Ee = 5250832;\n      function Ce(e) {\n        return [\"__cpp_exception\", \"__wasm_apply_data_relocs\", \"__dso_handle\", \"__set_stack_limits\"].includes(e);\n      }\n      function Se(e, t) {\n        var n = {};\n        for (var r in e) {\n          var o = e[r];\n          \"object\" == typeof o && (o = o.value);\n          \"number\" == typeof o && (o += t);\n          n[r] = o;\n        }\n        (function (e) {\n          for (var t in e) if (!Ce(t)) {\n            var n = !1,\n              r = e[t];\n            t.startsWith(\"orig$\") && (t = t.split(\"$\")[1], n = !0);\n            me[t] || (me[t] = new WebAssembly.Global({\n              value: \"i32\",\n              mutable: !0\n            }));\n            (n || 0 == me[t].value) && (\"function\" == typeof r ? me[t].value = x(r) : \"number\" == typeof r ? me[t].value = r : y(\"unhandled export type for `\" + t + \"`: \" + typeof r));\n          }\n        })(n);\n        return n;\n      }\n      function Te(e) {\n        return 0 == e.indexOf(\"dynCall_\") || [\"stackAlloc\", \"stackSave\", \"stackRestore\"].includes(e) ? e : \"_\" + e;\n      }\n      function ke(e, t) {\n        var n, r;\n        t && (n = i.asm[\"orig$\" + e]);\n        n || (n = i.asm[e]);\n        !n && t && (n = i[\"_orig$\" + e]);\n        n || (n = i[Te(e)]);\n        !n && e.startsWith(\"invoke_\") && (r = e.split(\"_\")[1], n = function () {\n          var e = ze();\n          try {\n            return xe(r, arguments[0], Array.prototype.slice.call(arguments, 1));\n          } catch (t) {\n            Ge(e);\n            if (t !== t + 0 && \"longjmp\" !== t) throw t;\n            We(1, 0);\n          }\n        });\n        return n;\n      }\n      function Ie(e, t) {\n        var n = ye(e);\n        function r() {\n          var r = Math.pow(2, n.memoryAlign);\n          r = Math.max(r, b);\n          var o,\n            i,\n            s,\n            a = (o = function (e) {\n              if (ee) return Ue(e);\n              var t = Ee,\n                n = t + e + 15 & -16;\n              Ee = n;\n              me.__heap_base.value = n;\n              return t;\n            }(n.memorySize + r), (i = r) || (i = b), Math.ceil(o / i) * i),\n            c = J.length;\n          J.grow(n.tableSize);\n          for (var l = a; l < a + n.memorySize; l++) R[l] = 0;\n          for (l = c; l < c + n.tableSize; l++) J.set(l, null);\n          var u = new Proxy(Be, {\n              get: function (e, t) {\n                switch (t) {\n                  case \"__memory_base\":\n                    return a;\n                  case \"__table_base\":\n                    return c;\n                }\n                return t in e ? e[t] : e[t] = function () {\n                  n || (n = function (e) {\n                    var t = ke(e, !1);\n                    t || (t = s[e]);\n                    return t;\n                  }(t));\n                  return n.apply(null, arguments);\n                };\n                var n;\n              }\n            }),\n            d = {\n              \"GOT.mem\": new Proxy(Be, ge),\n              \"GOT.func\": new Proxy(Be, ge),\n              env: u,\n              wasi_snapshot_preview1: u\n            };\n          function p(e) {\n            for (var r = 0; r < n.tableSize; r++) {\n              var o = J.get(c + r);\n              o && v.set(o, c + r);\n            }\n            s = Se(e.exports, a);\n            t.allowUndefined || Oe();\n            var i = s.__wasm_call_ctors;\n            i || (i = s.__post_instantiate);\n            i && (ee ? i() : Q.push(i));\n            return s;\n          }\n          if (t.loadAsync) {\n            if (e instanceof WebAssembly.Module) {\n              var h = new WebAssembly.Instance(e, d);\n              return Promise.resolve(p(h));\n            }\n            return WebAssembly.instantiate(e, d).then(function (e) {\n              return p(e.instance);\n            });\n          }\n          var f = e instanceof WebAssembly.Module ? e : new WebAssembly.Module(e);\n          return p(h = new WebAssembly.Instance(f, d));\n        }\n        return t.loadAsync ? n.neededDynlibs.reduce(function (e, n) {\n          return e.then(function () {\n            return Ae(n, t);\n          });\n        }, Promise.resolve()).then(function () {\n          return r();\n        }) : (n.neededDynlibs.forEach(function (e) {\n          Ae(e, t);\n        }), r());\n      }\n      function Pe(e, t) {\n        for (var n in e) if (e.hasOwnProperty(n)) {\n          Be.hasOwnProperty(n) || (Be[n] = e[n]);\n          var r = Te(n);\n          i.hasOwnProperty(r) || (i[r] = e[n]);\n        }\n      }\n      function Ae(e, t) {\n        \"__main__\" != e || we.loadedLibNames[e] || (we.loadedLibs[-1] = {\n          refcount: 1 / 0,\n          name: \"__main__\",\n          module: i.asm,\n          global: !0\n        }, we.loadedLibNames.__main__ = -1);\n        t = t || {\n          global: !0,\n          nodelete: !0\n        };\n        var n,\n          r = we.loadedLibNames[e];\n        if (r) {\n          n = we.loadedLibs[r];\n          t.global && !n.global && (n.global = !0, \"loading\" !== n.module && Pe(n.module));\n          t.nodelete && n.refcount !== 1 / 0 && (n.refcount = 1 / 0);\n          n.refcount++;\n          return t.loadAsync ? Promise.resolve(r) : r;\n        }\n        function o(e) {\n          if (t.fs) {\n            var n = t.fs.readFile(e, {\n              encoding: \"binary\"\n            });\n            n instanceof Uint8Array || (n = new Uint8Array(n));\n            return t.loadAsync ? Promise.resolve(n) : n;\n          }\n          return t.loadAsync ? (r = e, fetch(r, {\n            credentials: \"same-origin\"\n          }).then(function (e) {\n            if (!e.ok) throw \"failed to load binary file at '\" + r + \"'\";\n            return e.arrayBuffer();\n          }).then(function (e) {\n            return new Uint8Array(e);\n          })) : f(e);\n          var r;\n        }\n        function s() {\n          if (undefined !== i.preloadedWasm && undefined !== i.preloadedWasm[e]) {\n            var n = i.preloadedWasm[e];\n            return t.loadAsync ? Promise.resolve(n) : n;\n          }\n          return t.loadAsync ? o(e).then(function (e) {\n            return Ie(e, t);\n          }) : Ie(o(e), t);\n        }\n        function a(e) {\n          n.global && Pe(e);\n          n.module = e;\n        }\n        r = we.nextHandle++;\n        n = {\n          refcount: t.nodelete ? 1 / 0 : 1,\n          name: e,\n          module: \"loading\",\n          global: t.global\n        };\n        we.loadedLibNames[e] = r;\n        we.loadedLibs[r] = n;\n        return t.loadAsync ? s().then(function (e) {\n          a(e);\n          return r;\n        }) : (a(s()), r);\n      }\n      function Oe() {\n        for (var e in me) if (0 == me[e].value) {\n          var t = ke(e, !0);\n          \"function\" == typeof t ? me[e].value = x(t, t.sig) : \"number\" == typeof t ? me[e].value = t : O(!1, \"bad export type for `\" + e + \"`: \" + typeof t);\n        }\n      }\n      i.___heap_base = Ee;\n      var Ne,\n        Re = new WebAssembly.Global({\n          value: \"i32\",\n          mutable: !0\n        }, 5250832);\n      function Me() {\n        se();\n      }\n      i._abort = Me;\n      Me.sig = \"v\";\n      Ne = o ? function () {\n        var e = process.hrtime();\n        return 1e3 * e[0] + e[1] / 1e6;\n      } : \"undefined\" != typeof dateNow ? dateNow : function () {\n        return performance.now();\n      };\n      var Le = !0;\n      function $e(e, t) {\n        var n;\n        if (0 === e) n = Date.now();else {\n          if (1 !== e && 4 !== e || !Le) {\n            $[He() >> 2] = 28;\n            return -1;\n          }\n          n = Ne();\n        }\n        $[t >> 2] = n / 1e3 | 0;\n        $[t + 4 >> 2] = n % 1e3 * 1e3 * 1e3 | 0;\n        return 0;\n      }\n      function De(e) {\n        try {\n          T.grow(e - N.byteLength + 65535 >>> 16);\n          W(T.buffer);\n          return 1;\n        } catch (e) {}\n      }\n      function Fe(e) {\n        Qe(e);\n      }\n      function je(e) {\n        C(e);\n      }\n      $e.sig = \"iii\";\n      Fe.sig = \"vi\";\n      je.sig = \"vi\";\n      var qe,\n        Be = {\n          __heap_base: Ee,\n          __indirect_function_table: J,\n          __memory_base: 1024,\n          __stack_pointer: Re,\n          __table_base: 1,\n          abort: Me,\n          clock_gettime: $e,\n          emscripten_memcpy_big: function (e, t, n) {\n            M.copyWithin(e, t, t + n);\n          },\n          emscripten_resize_heap: function (e) {\n            var t,\n              n = M.length;\n            if ((e >>>= 0) > 2147483648) return !1;\n            for (var r = 1; r <= 4; r *= 2) {\n              var o = n * (1 + .2 / r);\n              o = Math.min(o, e + 100663296);\n              if (De(Math.min(2147483648, ((t = Math.max(e, o)) % 65536 > 0 && (t += 65536 - t % 65536), t)))) return !0;\n            }\n            return !1;\n          },\n          exit: Fe,\n          memory: T,\n          setTempRet0: je,\n          tree_sitter_log_callback: function (e, t) {\n            if (ft) {\n              const n = U(t);\n              ft(n, 0 !== e);\n            }\n          },\n          tree_sitter_parse_callback: function (e, t, n, r, o) {\n            var i = ht(t, {\n              row: n,\n              column: r\n            });\n            \"string\" == typeof i ? (I(o, i.length, \"i32\"), function (e, t, n) {\n              undefined === n && (n = 2147483647);\n              if (n < 2) return 0;\n              for (var r = (n -= 2) < 2 * e.length ? n / 2 : e.length, o = 0; o < r; ++o) {\n                var i = e.charCodeAt(o);\n                L[t >> 1] = i;\n                t += 2;\n              }\n              L[t >> 1] = 0;\n            }(i, e, 10240)) : I(o, 0, \"i32\");\n          }\n        },\n        Ue = (function () {\n          var e = {\n            env: Be,\n            wasi_snapshot_preview1: Be,\n            \"GOT.mem\": new Proxy(Be, ge),\n            \"GOT.func\": new Proxy(Be, ge)\n          };\n          function t(e, t) {\n            var n = e.exports;\n            n = Se(n, 1024);\n            i.asm = n;\n            var r,\n              o = ye(t);\n            o.neededDynlibs && (S = o.neededDynlibs.concat(S));\n            r = i.asm.__wasm_call_ctors;\n            Q.unshift(r);\n            ie();\n          }\n          function n(e) {\n            t(e.instance, e.module);\n          }\n          function r(t) {\n            return function () {\n              if (!E && (u || d)) {\n                if (\"function\" == typeof fetch && !le(he)) return fetch(he, {\n                  credentials: \"same-origin\"\n                }).then(function (e) {\n                  if (!e.ok) throw \"failed to load wasm binary file at '\" + he + \"'\";\n                  return e.arrayBuffer();\n                }).catch(function () {\n                  return fe(he);\n                });\n                if (h) return new Promise(function (e, t) {\n                  h(he, function (t) {\n                    e(new Uint8Array(t));\n                  }, t);\n                });\n              }\n              return Promise.resolve().then(function () {\n                return fe(he);\n              });\n            }().then(function (t) {\n              return WebAssembly.instantiate(t, e);\n            }).then(t, function (e) {\n              y(\"failed to asynchronously prepare wasm: \" + e);\n              se(e);\n            });\n          }\n          oe();\n          if (i.instantiateWasm) try {\n            return i.instantiateWasm(e, t);\n          } catch (e) {\n            return y(\"Module.instantiateWasm callback failed with error: \" + e), !1;\n          }\n          E || \"function\" != typeof WebAssembly.instantiateStreaming || ce(he) || le(he) || \"function\" != typeof fetch ? r(n) : fetch(he, {\n            credentials: \"same-origin\"\n          }).then(function (t) {\n            return WebAssembly.instantiateStreaming(t, e).then(n, function (e) {\n              y(\"wasm streaming compile failed: \" + e);\n              y(\"falling back to ArrayBuffer instantiation\");\n              return r(n);\n            });\n          });\n        }(), i.___wasm_call_ctors = function () {\n          return (i.___wasm_call_ctors = i.asm.__wasm_call_ctors).apply(null, arguments);\n        }, i._malloc = function () {\n          return (Ue = i._malloc = i.asm.malloc).apply(null, arguments);\n        }),\n        He = (i._ts_language_symbol_count = function () {\n          return (i._ts_language_symbol_count = i.asm.ts_language_symbol_count).apply(null, arguments);\n        }, i._ts_language_version = function () {\n          return (i._ts_language_version = i.asm.ts_language_version).apply(null, arguments);\n        }, i._ts_language_field_count = function () {\n          return (i._ts_language_field_count = i.asm.ts_language_field_count).apply(null, arguments);\n        }, i._ts_language_symbol_name = function () {\n          return (i._ts_language_symbol_name = i.asm.ts_language_symbol_name).apply(null, arguments);\n        }, i._ts_language_symbol_for_name = function () {\n          return (i._ts_language_symbol_for_name = i.asm.ts_language_symbol_for_name).apply(null, arguments);\n        }, i._ts_language_symbol_type = function () {\n          return (i._ts_language_symbol_type = i.asm.ts_language_symbol_type).apply(null, arguments);\n        }, i._ts_language_field_name_for_id = function () {\n          return (i._ts_language_field_name_for_id = i.asm.ts_language_field_name_for_id).apply(null, arguments);\n        }, i._memcpy = function () {\n          return (i._memcpy = i.asm.memcpy).apply(null, arguments);\n        }, i._free = function () {\n          return (i._free = i.asm.free).apply(null, arguments);\n        }, i._calloc = function () {\n          return (i._calloc = i.asm.calloc).apply(null, arguments);\n        }, i._ts_parser_delete = function () {\n          return (i._ts_parser_delete = i.asm.ts_parser_delete).apply(null, arguments);\n        }, i._ts_parser_reset = function () {\n          return (i._ts_parser_reset = i.asm.ts_parser_reset).apply(null, arguments);\n        }, i._ts_parser_set_language = function () {\n          return (i._ts_parser_set_language = i.asm.ts_parser_set_language).apply(null, arguments);\n        }, i._ts_parser_timeout_micros = function () {\n          return (i._ts_parser_timeout_micros = i.asm.ts_parser_timeout_micros).apply(null, arguments);\n        }, i._ts_parser_set_timeout_micros = function () {\n          return (i._ts_parser_set_timeout_micros = i.asm.ts_parser_set_timeout_micros).apply(null, arguments);\n        }, i._memcmp = function () {\n          return (i._memcmp = i.asm.memcmp).apply(null, arguments);\n        }, i._ts_query_new = function () {\n          return (i._ts_query_new = i.asm.ts_query_new).apply(null, arguments);\n        }, i._ts_query_delete = function () {\n          return (i._ts_query_delete = i.asm.ts_query_delete).apply(null, arguments);\n        }, i._iswspace = function () {\n          return (i._iswspace = i.asm.iswspace).apply(null, arguments);\n        }, i._iswalnum = function () {\n          return (i._iswalnum = i.asm.iswalnum).apply(null, arguments);\n        }, i._ts_query_pattern_count = function () {\n          return (i._ts_query_pattern_count = i.asm.ts_query_pattern_count).apply(null, arguments);\n        }, i._ts_query_capture_count = function () {\n          return (i._ts_query_capture_count = i.asm.ts_query_capture_count).apply(null, arguments);\n        }, i._ts_query_string_count = function () {\n          return (i._ts_query_string_count = i.asm.ts_query_string_count).apply(null, arguments);\n        }, i._ts_query_capture_name_for_id = function () {\n          return (i._ts_query_capture_name_for_id = i.asm.ts_query_capture_name_for_id).apply(null, arguments);\n        }, i._ts_query_string_value_for_id = function () {\n          return (i._ts_query_string_value_for_id = i.asm.ts_query_string_value_for_id).apply(null, arguments);\n        }, i._ts_query_predicates_for_pattern = function () {\n          return (i._ts_query_predicates_for_pattern = i.asm.ts_query_predicates_for_pattern).apply(null, arguments);\n        }, i._ts_tree_copy = function () {\n          return (i._ts_tree_copy = i.asm.ts_tree_copy).apply(null, arguments);\n        }, i._ts_tree_delete = function () {\n          return (i._ts_tree_delete = i.asm.ts_tree_delete).apply(null, arguments);\n        }, i._ts_init = function () {\n          return (i._ts_init = i.asm.ts_init).apply(null, arguments);\n        }, i._ts_parser_new_wasm = function () {\n          return (i._ts_parser_new_wasm = i.asm.ts_parser_new_wasm).apply(null, arguments);\n        }, i._ts_parser_enable_logger_wasm = function () {\n          return (i._ts_parser_enable_logger_wasm = i.asm.ts_parser_enable_logger_wasm).apply(null, arguments);\n        }, i._ts_parser_parse_wasm = function () {\n          return (i._ts_parser_parse_wasm = i.asm.ts_parser_parse_wasm).apply(null, arguments);\n        }, i._ts_language_type_is_named_wasm = function () {\n          return (i._ts_language_type_is_named_wasm = i.asm.ts_language_type_is_named_wasm).apply(null, arguments);\n        }, i._ts_language_type_is_visible_wasm = function () {\n          return (i._ts_language_type_is_visible_wasm = i.asm.ts_language_type_is_visible_wasm).apply(null, arguments);\n        }, i._ts_tree_root_node_wasm = function () {\n          return (i._ts_tree_root_node_wasm = i.asm.ts_tree_root_node_wasm).apply(null, arguments);\n        }, i._ts_tree_edit_wasm = function () {\n          return (i._ts_tree_edit_wasm = i.asm.ts_tree_edit_wasm).apply(null, arguments);\n        }, i._ts_tree_get_changed_ranges_wasm = function () {\n          return (i._ts_tree_get_changed_ranges_wasm = i.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_new_wasm = function () {\n          return (i._ts_tree_cursor_new_wasm = i.asm.ts_tree_cursor_new_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_delete_wasm = function () {\n          return (i._ts_tree_cursor_delete_wasm = i.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_reset_wasm = function () {\n          return (i._ts_tree_cursor_reset_wasm = i.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_goto_first_child_wasm = function () {\n          return (i._ts_tree_cursor_goto_first_child_wasm = i.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_goto_next_sibling_wasm = function () {\n          return (i._ts_tree_cursor_goto_next_sibling_wasm = i.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_goto_parent_wasm = function () {\n          return (i._ts_tree_cursor_goto_parent_wasm = i.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_current_node_type_id_wasm = function () {\n          return (i._ts_tree_cursor_current_node_type_id_wasm = i.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_current_node_is_named_wasm = function () {\n          return (i._ts_tree_cursor_current_node_is_named_wasm = i.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_current_node_is_missing_wasm = function () {\n          return (i._ts_tree_cursor_current_node_is_missing_wasm = i.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_current_node_id_wasm = function () {\n          return (i._ts_tree_cursor_current_node_id_wasm = i.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_start_position_wasm = function () {\n          return (i._ts_tree_cursor_start_position_wasm = i.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_end_position_wasm = function () {\n          return (i._ts_tree_cursor_end_position_wasm = i.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_start_index_wasm = function () {\n          return (i._ts_tree_cursor_start_index_wasm = i.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_end_index_wasm = function () {\n          return (i._ts_tree_cursor_end_index_wasm = i.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_current_field_id_wasm = function () {\n          return (i._ts_tree_cursor_current_field_id_wasm = i.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);\n        }, i._ts_tree_cursor_current_node_wasm = function () {\n          return (i._ts_tree_cursor_current_node_wasm = i.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);\n        }, i._ts_node_symbol_wasm = function () {\n          return (i._ts_node_symbol_wasm = i.asm.ts_node_symbol_wasm).apply(null, arguments);\n        }, i._ts_node_child_count_wasm = function () {\n          return (i._ts_node_child_count_wasm = i.asm.ts_node_child_count_wasm).apply(null, arguments);\n        }, i._ts_node_named_child_count_wasm = function () {\n          return (i._ts_node_named_child_count_wasm = i.asm.ts_node_named_child_count_wasm).apply(null, arguments);\n        }, i._ts_node_child_wasm = function () {\n          return (i._ts_node_child_wasm = i.asm.ts_node_child_wasm).apply(null, arguments);\n        }, i._ts_node_named_child_wasm = function () {\n          return (i._ts_node_named_child_wasm = i.asm.ts_node_named_child_wasm).apply(null, arguments);\n        }, i._ts_node_child_by_field_id_wasm = function () {\n          return (i._ts_node_child_by_field_id_wasm = i.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);\n        }, i._ts_node_next_sibling_wasm = function () {\n          return (i._ts_node_next_sibling_wasm = i.asm.ts_node_next_sibling_wasm).apply(null, arguments);\n        }, i._ts_node_prev_sibling_wasm = function () {\n          return (i._ts_node_prev_sibling_wasm = i.asm.ts_node_prev_sibling_wasm).apply(null, arguments);\n        }, i._ts_node_next_named_sibling_wasm = function () {\n          return (i._ts_node_next_named_sibling_wasm = i.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);\n        }, i._ts_node_prev_named_sibling_wasm = function () {\n          return (i._ts_node_prev_named_sibling_wasm = i.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);\n        }, i._ts_node_parent_wasm = function () {\n          return (i._ts_node_parent_wasm = i.asm.ts_node_parent_wasm).apply(null, arguments);\n        }, i._ts_node_descendant_for_index_wasm = function () {\n          return (i._ts_node_descendant_for_index_wasm = i.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);\n        }, i._ts_node_named_descendant_for_index_wasm = function () {\n          return (i._ts_node_named_descendant_for_index_wasm = i.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments);\n        }, i._ts_node_descendant_for_position_wasm = function () {\n          return (i._ts_node_descendant_for_position_wasm = i.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);\n        }, i._ts_node_named_descendant_for_position_wasm = function () {\n          return (i._ts_node_named_descendant_for_position_wasm = i.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments);\n        }, i._ts_node_start_point_wasm = function () {\n          return (i._ts_node_start_point_wasm = i.asm.ts_node_start_point_wasm).apply(null, arguments);\n        }, i._ts_node_end_point_wasm = function () {\n          return (i._ts_node_end_point_wasm = i.asm.ts_node_end_point_wasm).apply(null, arguments);\n        }, i._ts_node_start_index_wasm = function () {\n          return (i._ts_node_start_index_wasm = i.asm.ts_node_start_index_wasm).apply(null, arguments);\n        }, i._ts_node_end_index_wasm = function () {\n          return (i._ts_node_end_index_wasm = i.asm.ts_node_end_index_wasm).apply(null, arguments);\n        }, i._ts_node_to_string_wasm = function () {\n          return (i._ts_node_to_string_wasm = i.asm.ts_node_to_string_wasm).apply(null, arguments);\n        }, i._ts_node_children_wasm = function () {\n          return (i._ts_node_children_wasm = i.asm.ts_node_children_wasm).apply(null, arguments);\n        }, i._ts_node_named_children_wasm = function () {\n          return (i._ts_node_named_children_wasm = i.asm.ts_node_named_children_wasm).apply(null, arguments);\n        }, i._ts_node_descendants_of_type_wasm = function () {\n          return (i._ts_node_descendants_of_type_wasm = i.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);\n        }, i._ts_node_is_named_wasm = function () {\n          return (i._ts_node_is_named_wasm = i.asm.ts_node_is_named_wasm).apply(null, arguments);\n        }, i._ts_node_has_changes_wasm = function () {\n          return (i._ts_node_has_changes_wasm = i.asm.ts_node_has_changes_wasm).apply(null, arguments);\n        }, i._ts_node_has_error_wasm = function () {\n          return (i._ts_node_has_error_wasm = i.asm.ts_node_has_error_wasm).apply(null, arguments);\n        }, i._ts_node_is_missing_wasm = function () {\n          return (i._ts_node_is_missing_wasm = i.asm.ts_node_is_missing_wasm).apply(null, arguments);\n        }, i._ts_query_matches_wasm = function () {\n          return (i._ts_query_matches_wasm = i.asm.ts_query_matches_wasm).apply(null, arguments);\n        }, i._ts_query_captures_wasm = function () {\n          return (i._ts_query_captures_wasm = i.asm.ts_query_captures_wasm).apply(null, arguments);\n        }, i._iswalpha = function () {\n          return (i._iswalpha = i.asm.iswalpha).apply(null, arguments);\n        }, i._iswdigit = function () {\n          return (i._iswdigit = i.asm.iswdigit).apply(null, arguments);\n        }, i._iswlower = function () {\n          return (i._iswlower = i.asm.iswlower).apply(null, arguments);\n        }, i._towupper = function () {\n          return (i._towupper = i.asm.towupper).apply(null, arguments);\n        }, i._memchr = function () {\n          return (i._memchr = i.asm.memchr).apply(null, arguments);\n        }, i.___errno_location = function () {\n          return (He = i.___errno_location = i.asm.__errno_location).apply(null, arguments);\n        }),\n        ze = (i._strlen = function () {\n          return (i._strlen = i.asm.strlen).apply(null, arguments);\n        }, i.stackSave = function () {\n          return (ze = i.stackSave = i.asm.stackSave).apply(null, arguments);\n        }),\n        Ge = i.stackRestore = function () {\n          return (Ge = i.stackRestore = i.asm.stackRestore).apply(null, arguments);\n        },\n        Ve = i.stackAlloc = function () {\n          return (Ve = i.stackAlloc = i.asm.stackAlloc).apply(null, arguments);\n        },\n        We = i._setThrew = function () {\n          return (We = i._setThrew = i.asm.setThrew).apply(null, arguments);\n        };\n      function Ke(e) {\n        this.name = \"ExitStatus\";\n        this.message = \"Program terminated with exit(\" + e + \")\";\n        this.status = e;\n      }\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function () {\n        return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments);\n      };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function () {\n        return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments);\n      };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function () {\n        return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments);\n      };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function () {\n        return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments);\n      };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function () {\n        return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments);\n      };\n      i.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function () {\n        return (i.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = i.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments);\n      };\n      i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function () {\n        return (i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = i.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments);\n      };\n      i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function () {\n        return (i.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = i.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments);\n      };\n      i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ = function () {\n        return (i.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ = i.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_).apply(null, arguments);\n      };\n      i.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = function () {\n        return (i.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = i.asm._ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv).apply(null, arguments);\n      };\n      i.__Znwm = function () {\n        return (i.__Znwm = i.asm._Znwm).apply(null, arguments);\n      };\n      i.__ZdlPv = function () {\n        return (i.__ZdlPv = i.asm._ZdlPv).apply(null, arguments);\n      };\n      i._orig$ts_parser_timeout_micros = function () {\n        return (i._orig$ts_parser_timeout_micros = i.asm.orig$ts_parser_timeout_micros).apply(null, arguments);\n      };\n      i._orig$ts_parser_set_timeout_micros = function () {\n        return (i._orig$ts_parser_set_timeout_micros = i.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);\n      };\n      i._TRANSFER_BUFFER = 7296;\n      i.___THREW__ = 7932;\n      i.___threwValue = 7936;\n      i.___cxa_new_handler = 7928;\n      i.allocate = function (e, t) {\n        var n;\n        n = t == j ? Ve(e.length) : Ue(e.length);\n        e.subarray || e.slice ? M.set(e, n) : M.set(new Uint8Array(e), n);\n        return n;\n      };\n      re = function e() {\n        qe || Xe();\n        qe || (re = e);\n      };\n      var Je = !1;\n      function Xe(e) {\n        function t() {\n          qe || (qe = !0, i.calledRun = !0, A || (ee = !0, _e(Q), _e(Y), i.onRuntimeInitialized && i.onRuntimeInitialized(), Ye && function (e) {\n            var t = i._main;\n            if (t) {\n              var n = (e = e || []).length + 1,\n                r = Ve(4 * (n + 1));\n              $[r >> 2] = V(c);\n              for (var o = 1; o < n; o++) $[(r >> 2) + o] = V(e[o - 1]);\n              $[(r >> 2) + n] = 0;\n              try {\n                Qe(t(n, r), !0);\n              } catch (e) {\n                if (e instanceof Ke) return;\n                if (\"unwind\" == e) return;\n                var s = e;\n                e && \"object\" == typeof e && e.stack && (s = [e, e.stack]);\n                y(\"exception thrown: \" + s);\n                l(1, e);\n              }\n            }\n          }(e), function () {\n            if (i.postRun) for (\"function\" == typeof i.postRun && (i.postRun = [i.postRun]); i.postRun.length;) {\n              e = i.postRun.shift();\n              Z.unshift(e);\n            }\n            var e;\n            _e(Z);\n          }()));\n        }\n        e = e || a;\n        te > 0 || !Je && (function () {\n          if (S.length) {\n            if (!f) {\n              oe();\n              return void S.reduce(function (e, t) {\n                return e.then(function () {\n                  return Ae(t, {\n                    loadAsync: !0,\n                    global: !0,\n                    nodelete: !0,\n                    allowUndefined: !0\n                  });\n                });\n              }, Promise.resolve()).then(function () {\n                ie();\n                Oe();\n              });\n            }\n            S.forEach(function (e) {\n              Ae(e, {\n                global: !0,\n                nodelete: !0,\n                allowUndefined: !0\n              });\n            });\n            Oe();\n          } else Oe();\n        }(), Je = !0, te > 0) || (function () {\n          if (i.preRun) for (\"function\" == typeof i.preRun && (i.preRun = [i.preRun]); i.preRun.length;) {\n            e = i.preRun.shift();\n            X.unshift(e);\n          }\n          var e;\n          _e(X);\n        }(), te > 0 || (i.setStatus ? (i.setStatus(\"Running...\"), setTimeout(function () {\n          setTimeout(function () {\n            i.setStatus(\"\");\n          }, 1);\n          t();\n        }, 1)) : t()));\n      }\n      function Qe(e, t) {\n        t && be() && 0 === e || (be() || (i.onExit && i.onExit(e), A = !0), l(e, new Ke(e)));\n      }\n      i.run = Xe;\n      if (i.preInit) for (\"function\" == typeof i.preInit && (i.preInit = [i.preInit]); i.preInit.length > 0;) i.preInit.pop()();\n      var Ye = !0;\n      i.noInitialRun && (Ye = !1);\n      Xe();\n      const Ze = i,\n        et = {},\n        tt = 4,\n        nt = 5 * tt,\n        rt = 2 * tt,\n        ot = 2 * tt + 2 * rt,\n        it = {\n          row: 0,\n          column: 0\n        },\n        st = /[\\w-.]*/g,\n        at = 1,\n        ct = 2,\n        lt = /^_?tree_sitter_\\w+/;\n      var ut,\n        dt,\n        pt,\n        ht,\n        ft,\n        mt = new Promise(e => {\n          i.onRuntimeInitialized = e;\n        }).then(() => {\n          pt = Ze._ts_init();\n          ut = P(pt, \"i32\");\n          dt = P(pt + tt, \"i32\");\n        });\n      class gt {\n        static init() {\n          return mt;\n        }\n        constructor() {\n          if (null == pt) throw new Error(\"You must first call Parser.init() and wait for it to resolve.\");\n          Ze._ts_parser_new_wasm();\n          this[0] = P(pt, \"i32\");\n          this[1] = P(pt + tt, \"i32\");\n        }\n        delete() {\n          Ze._ts_parser_delete(this[0]);\n          Ze._free(this[1]);\n          this[0] = 0;\n          this[1] = 0;\n        }\n        setLanguage(e) {\n          let t;\n          if (e) {\n            if (e.constructor !== bt) throw new Error(\"Argument must be a Language\");\n            {\n              t = e[0];\n              const n = Ze._ts_language_version(t);\n              if (n < dt || ut < n) throw new Error(`Incompatible language version ${n}. Compatibility range ${dt} through ${ut}.`);\n            }\n          } else {\n            t = 0;\n            e = null;\n          }\n          this.language = e;\n          Ze._ts_parser_set_language(this[0], t);\n          return this;\n        }\n        getLanguage() {\n          return this.language;\n        }\n        parse(e, t, n) {\n          if (\"string\" == typeof e) ht = (t, n, r) => e.slice(t, r);else {\n            if (\"function\" != typeof e) throw new Error(\"Argument must be a string or a function\");\n            ht = e;\n          }\n          this.logCallback ? (ft = this.logCallback, Ze._ts_parser_enable_logger_wasm(this[0], 1)) : (ft = null, Ze._ts_parser_enable_logger_wasm(this[0], 0));\n          let r = 0,\n            o = 0;\n          if (n && n.includedRanges) {\n            r = n.includedRanges.length;\n            let e = o = Ze._calloc(r, ot);\n            for (let t = 0; t < r; t++) {\n              Nt(e, n.includedRanges[t]);\n              e += ot;\n            }\n          }\n          const i = Ze._ts_parser_parse_wasm(this[0], this[1], t ? t[0] : 0, o, r);\n          if (!i) throw ht = null, ft = null, new Error(\"Parsing failed\");\n          const s = new _t(et, i, this.language, ht);\n          ht = null;\n          ft = null;\n          return s;\n        }\n        reset() {\n          Ze._ts_parser_reset(this[0]);\n        }\n        setTimeoutMicros(e) {\n          Ze._ts_parser_set_timeout_micros(this[0], e);\n        }\n        getTimeoutMicros() {\n          return Ze._ts_parser_timeout_micros(this[0]);\n        }\n        setLogger(e) {\n          if (e) {\n            if (\"function\" != typeof e) throw new Error(\"Logger callback must be a function\");\n          } else e = null;\n          this.logCallback = e;\n          return this;\n        }\n        getLogger() {\n          return this.logCallback;\n        }\n      }\n      class _t {\n        constructor(e, t, n, r) {\n          Ct(e);\n          this[0] = t;\n          this.language = n;\n          this.textCallback = r;\n        }\n        copy() {\n          const e = Ze._ts_tree_copy(this[0]);\n          return new _t(et, e, this.language, this.textCallback);\n        }\n        delete() {\n          Ze._ts_tree_delete(this[0]);\n          this[0] = 0;\n        }\n        edit(e) {\n          !function (e) {\n            let t = pt;\n            At(t, e.startPosition);\n            At(t += rt, e.oldEndPosition);\n            At(t += rt, e.newEndPosition);\n            I(t += rt, e.startIndex, \"i32\");\n            I(t += tt, e.oldEndIndex, \"i32\");\n            I(t += tt, e.newEndIndex, \"i32\");\n            t += tt;\n          }(e);\n          Ze._ts_tree_edit_wasm(this[0]);\n        }\n        get rootNode() {\n          Ze._ts_tree_root_node_wasm(this[0]);\n          return kt(this);\n        }\n        getLanguage() {\n          return this.language;\n        }\n        walk() {\n          return this.rootNode.walk();\n        }\n        getChangedRanges(e) {\n          if (e.constructor !== _t) throw new TypeError(\"Argument must be a Tree\");\n          Ze._ts_tree_get_changed_ranges_wasm(this[0], e[0]);\n          const t = P(pt, \"i32\"),\n            n = P(pt + tt, \"i32\"),\n            r = new Array(t);\n          if (t > 0) {\n            let e = n;\n            for (let n = 0; n < t; n++) {\n              r[n] = Rt(e);\n              e += ot;\n            }\n            Ze._free(n);\n          }\n          return r;\n        }\n      }\n      class yt {\n        constructor(e, t) {\n          Ct(e);\n          this.tree = t;\n        }\n        get typeId() {\n          Tt(this);\n          return Ze._ts_node_symbol_wasm(this.tree[0]);\n        }\n        get type() {\n          return this.tree.language.types[this.typeId] || \"ERROR\";\n        }\n        get endPosition() {\n          Tt(this);\n          Ze._ts_node_end_point_wasm(this.tree[0]);\n          return Ot(pt);\n        }\n        get endIndex() {\n          Tt(this);\n          return Ze._ts_node_end_index_wasm(this.tree[0]);\n        }\n        get text() {\n          return xt(this.tree, this.startIndex, this.endIndex);\n        }\n        isNamed() {\n          Tt(this);\n          return 1 === Ze._ts_node_is_named_wasm(this.tree[0]);\n        }\n        hasError() {\n          Tt(this);\n          return 1 === Ze._ts_node_has_error_wasm(this.tree[0]);\n        }\n        hasChanges() {\n          Tt(this);\n          return 1 === Ze._ts_node_has_changes_wasm(this.tree[0]);\n        }\n        isMissing() {\n          Tt(this);\n          return 1 === Ze._ts_node_is_missing_wasm(this.tree[0]);\n        }\n        equals(e) {\n          return this.id === e.id;\n        }\n        child(e) {\n          Tt(this);\n          Ze._ts_node_child_wasm(this.tree[0], e);\n          return kt(this.tree);\n        }\n        namedChild(e) {\n          Tt(this);\n          Ze._ts_node_named_child_wasm(this.tree[0], e);\n          return kt(this.tree);\n        }\n        childForFieldId(e) {\n          Tt(this);\n          Ze._ts_node_child_by_field_id_wasm(this.tree[0], e);\n          return kt(this.tree);\n        }\n        childForFieldName(e) {\n          const t = this.tree.language.fields.indexOf(e);\n          if (-1 !== t) return this.childForFieldId(t);\n        }\n        get childCount() {\n          Tt(this);\n          return Ze._ts_node_child_count_wasm(this.tree[0]);\n        }\n        get namedChildCount() {\n          Tt(this);\n          return Ze._ts_node_named_child_count_wasm(this.tree[0]);\n        }\n        get firstChild() {\n          return this.child(0);\n        }\n        get firstNamedChild() {\n          return this.namedChild(0);\n        }\n        get lastChild() {\n          return this.child(this.childCount - 1);\n        }\n        get lastNamedChild() {\n          return this.namedChild(this.namedChildCount - 1);\n        }\n        get children() {\n          if (!this._children) {\n            Tt(this);\n            Ze._ts_node_children_wasm(this.tree[0]);\n            const e = P(pt, \"i32\"),\n              t = P(pt + tt, \"i32\");\n            this._children = new Array(e);\n            if (e > 0) {\n              let n = t;\n              for (let t = 0; t < e; t++) this._children[t] = kt(this.tree, n), n += nt;\n              Ze._free(t);\n            }\n          }\n          return this._children;\n        }\n        get namedChildren() {\n          if (!this._namedChildren) {\n            Tt(this);\n            Ze._ts_node_named_children_wasm(this.tree[0]);\n            const e = P(pt, \"i32\"),\n              t = P(pt + tt, \"i32\");\n            this._namedChildren = new Array(e);\n            if (e > 0) {\n              let n = t;\n              for (let t = 0; t < e; t++) this._namedChildren[t] = kt(this.tree, n), n += nt;\n              Ze._free(t);\n            }\n          }\n          return this._namedChildren;\n        }\n        descendantsOfType(e, t, n) {\n          Array.isArray(e) || (e = [e]);\n          t || (t = it);\n          n || (n = it);\n          const r = [],\n            o = this.tree.language.types;\n          for (let t = 0, n = o.length; t < n; t++) e.includes(o[t]) && r.push(t);\n          const i = Ze._malloc(tt * r.length);\n          for (let e = 0, t = r.length; e < t; e++) I(i + e * tt, r[e], \"i32\");\n          Tt(this);\n          Ze._ts_node_descendants_of_type_wasm(this.tree[0], i, r.length, t.row, t.column, n.row, n.column);\n          const s = P(pt, \"i32\"),\n            a = P(pt + tt, \"i32\"),\n            c = new Array(s);\n          if (s > 0) {\n            let e = a;\n            for (let t = 0; t < s; t++) {\n              c[t] = kt(this.tree, e);\n              e += nt;\n            }\n          }\n          Ze._free(a);\n          Ze._free(i);\n          return c;\n        }\n        get nextSibling() {\n          Tt(this);\n          Ze._ts_node_next_sibling_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        get previousSibling() {\n          Tt(this);\n          Ze._ts_node_prev_sibling_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        get nextNamedSibling() {\n          Tt(this);\n          Ze._ts_node_next_named_sibling_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        get previousNamedSibling() {\n          Tt(this);\n          Ze._ts_node_prev_named_sibling_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        get parent() {\n          Tt(this);\n          Ze._ts_node_parent_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        descendantForIndex(e, t = e) {\n          if (\"number\" != typeof e || \"number\" != typeof t) throw new Error(\"Arguments must be numbers\");\n          Tt(this);\n          let n = pt + nt;\n          I(n, e, \"i32\");\n          I(n + tt, t, \"i32\");\n          Ze._ts_node_descendant_for_index_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        namedDescendantForIndex(e, t = e) {\n          if (\"number\" != typeof e || \"number\" != typeof t) throw new Error(\"Arguments must be numbers\");\n          Tt(this);\n          let n = pt + nt;\n          I(n, e, \"i32\");\n          I(n + tt, t, \"i32\");\n          Ze._ts_node_named_descendant_for_index_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        descendantForPosition(e, t = e) {\n          if (!St(e) || !St(t)) throw new Error(\"Arguments must be {row, column} objects\");\n          Tt(this);\n          let n = pt + nt;\n          At(n, e);\n          At(n + rt, t);\n          Ze._ts_node_descendant_for_position_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        namedDescendantForPosition(e, t = e) {\n          if (!St(e) || !St(t)) throw new Error(\"Arguments must be {row, column} objects\");\n          Tt(this);\n          let n = pt + nt;\n          At(n, e);\n          At(n + rt, t);\n          Ze._ts_node_named_descendant_for_position_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        walk() {\n          Tt(this);\n          Ze._ts_tree_cursor_new_wasm(this.tree[0]);\n          return new vt(et, this.tree);\n        }\n        toString() {\n          Tt(this);\n          const e = Ze._ts_node_to_string_wasm(this.tree[0]),\n            t = function (e) {\n              for (var t = \"\";;) {\n                var n = M[e++ >> 0];\n                if (!n) return t;\n                t += String.fromCharCode(n);\n              }\n            }(e);\n          Ze._free(e);\n          return t;\n        }\n      }\n      class vt {\n        constructor(e, t) {\n          Ct(e);\n          this.tree = t;\n          Pt(this);\n        }\n        delete() {\n          It(this);\n          Ze._ts_tree_cursor_delete_wasm(this.tree[0]);\n          this[0] = this[1] = this[2] = 0;\n        }\n        reset(e) {\n          Tt(e);\n          It(this, pt + nt);\n          Ze._ts_tree_cursor_reset_wasm(this.tree[0]);\n          Pt(this);\n        }\n        get nodeType() {\n          return this.tree.language.types[this.nodeTypeId] || \"ERROR\";\n        }\n        get nodeTypeId() {\n          It(this);\n          return Ze._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);\n        }\n        get nodeId() {\n          It(this);\n          return Ze._ts_tree_cursor_current_node_id_wasm(this.tree[0]);\n        }\n        get nodeIsNamed() {\n          It(this);\n          return 1 === Ze._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]);\n        }\n        get nodeIsMissing() {\n          It(this);\n          return 1 === Ze._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]);\n        }\n        get nodeText() {\n          It(this);\n          const e = Ze._ts_tree_cursor_start_index_wasm(this.tree[0]),\n            t = Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);\n          return xt(this.tree, e, t);\n        }\n        get startPosition() {\n          It(this);\n          Ze._ts_tree_cursor_start_position_wasm(this.tree[0]);\n          return Ot(pt);\n        }\n        get endPosition() {\n          It(this);\n          Ze._ts_tree_cursor_end_position_wasm(this.tree[0]);\n          return Ot(pt);\n        }\n        get startIndex() {\n          It(this);\n          return Ze._ts_tree_cursor_start_index_wasm(this.tree[0]);\n        }\n        get endIndex() {\n          It(this);\n          return Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);\n        }\n        currentNode() {\n          It(this);\n          Ze._ts_tree_cursor_current_node_wasm(this.tree[0]);\n          return kt(this.tree);\n        }\n        currentFieldId() {\n          It(this);\n          return Ze._ts_tree_cursor_current_field_id_wasm(this.tree[0]);\n        }\n        currentFieldName() {\n          return this.tree.language.fields[this.currentFieldId()];\n        }\n        gotoFirstChild() {\n          It(this);\n          const e = Ze._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);\n          Pt(this);\n          return 1 === e;\n        }\n        gotoNextSibling() {\n          It(this);\n          const e = Ze._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);\n          Pt(this);\n          return 1 === e;\n        }\n        gotoParent() {\n          It(this);\n          const e = Ze._ts_tree_cursor_goto_parent_wasm(this.tree[0]);\n          Pt(this);\n          return 1 === e;\n        }\n      }\n      class bt {\n        constructor(e, t) {\n          Ct(e);\n          this[0] = t;\n          this.types = new Array(Ze._ts_language_symbol_count(this[0]));\n          for (let e = 0, t = this.types.length; e < t; e++) Ze._ts_language_symbol_type(this[0], e) < 2 && (this.types[e] = U(Ze._ts_language_symbol_name(this[0], e)));\n          this.fields = new Array(Ze._ts_language_field_count(this[0]) + 1);\n          for (let e = 0, t = this.fields.length; e < t; e++) {\n            const t = Ze._ts_language_field_name_for_id(this[0], e);\n            this.fields[e] = 0 !== t ? U(t) : null;\n          }\n        }\n        get version() {\n          return Ze._ts_language_version(this[0]);\n        }\n        get fieldCount() {\n          return this.fields.length - 1;\n        }\n        fieldIdForName(e) {\n          const t = this.fields.indexOf(e);\n          return -1 !== t ? t : null;\n        }\n        fieldNameForId(e) {\n          return this.fields[e] || null;\n        }\n        idForNodeType(e, t) {\n          const n = G(e),\n            r = Ze._malloc(n + 1);\n          z(e, r, n + 1);\n          const o = Ze._ts_language_symbol_for_name(this[0], r, n, t);\n          Ze._free(r);\n          return o || null;\n        }\n        get nodeTypeCount() {\n          return Ze._ts_language_symbol_count(this[0]);\n        }\n        nodeTypeForId(e) {\n          const t = Ze._ts_language_symbol_name(this[0], e);\n          return t ? U(t) : null;\n        }\n        nodeTypeIsNamed(e) {\n          return !!Ze._ts_language_type_is_named_wasm(this[0], e);\n        }\n        nodeTypeIsVisible(e) {\n          return !!Ze._ts_language_type_is_visible_wasm(this[0], e);\n        }\n        query(e) {\n          const t = G(e),\n            n = Ze._malloc(t + 1);\n          z(e, n, t + 1);\n          const r = Ze._ts_query_new(this[0], n, t, pt, pt + tt);\n          if (!r) {\n            const t = P(pt + tt, \"i32\"),\n              r = U(n, P(pt, \"i32\")).length,\n              o = e.substr(r, 100).split(\"\\n\")[0];\n            let i,\n              s = o.match(st)[0];\n            switch (t) {\n              case 2:\n                i = new RangeError(`Bad node name '${s}'`);\n                break;\n              case 3:\n                i = new RangeError(`Bad field name '${s}'`);\n                break;\n              case 4:\n                i = new RangeError(`Bad capture name @${s}`);\n                break;\n              case 5:\n                i = new TypeError(`Bad pattern structure at offset ${r}: '${o}'...`);\n                s = \"\";\n                break;\n              default:\n                i = new SyntaxError(`Bad syntax at offset ${r}: '${o}'...`);\n                s = \"\";\n            }\n            throw i.index = r, i.length = s.length, Ze._free(n), i;\n          }\n          const o = Ze._ts_query_string_count(r),\n            i = Ze._ts_query_capture_count(r),\n            s = Ze._ts_query_pattern_count(r),\n            a = new Array(i),\n            c = new Array(o);\n          for (let e = 0; e < i; e++) {\n            const t = Ze._ts_query_capture_name_for_id(r, e, pt),\n              n = P(pt, \"i32\");\n            a[e] = U(t, n);\n          }\n          for (let e = 0; e < o; e++) {\n            const t = Ze._ts_query_string_value_for_id(r, e, pt),\n              n = P(pt, \"i32\");\n            c[e] = U(t, n);\n          }\n          const l = new Array(s),\n            u = new Array(s),\n            d = new Array(s),\n            p = new Array(s),\n            h = new Array(s);\n          for (let e = 0; e < s; e++) {\n            const t = Ze._ts_query_predicates_for_pattern(r, e, pt),\n              n = P(pt, \"i32\");\n            p[e] = [];\n            h[e] = [];\n            const o = [];\n            let i = t;\n            for (let t = 0; t < n; t++) {\n              const t = P(i, \"i32\"),\n                n = P(i += tt, \"i32\");\n              i += tt;\n              if (t === at) o.push({\n                type: \"capture\",\n                name: a[n]\n              });else if (t === ct) o.push({\n                type: \"string\",\n                value: c[n]\n              });else if (o.length > 0) {\n                if (\"string\" !== o[0].type) throw new Error(\"Predicates must begin with a literal value\");\n                const t = o[0].value;\n                let n = !0;\n                switch (t) {\n                  case \"not-eq?\":\n                    n = !1;\n                  case \"eq?\":\n                    if (3 !== o.length) throw new Error(\"Wrong number of arguments to `#eq?` predicate. Expected 2, got \" + (o.length - 1));\n                    if (\"capture\" !== o[1].type) throw new Error(`First argument of \\`#eq?\\` predicate must be a capture. Got \"${o[1].value}\"`);\n                    if (\"capture\" === o[2].type) {\n                      const t = o[1].name,\n                        r = o[2].name;\n                      h[e].push(function (e) {\n                        let o, i;\n                        for (const n of e) n.name === t && (o = n.node), n.name === r && (i = n.node);\n                        return o.text === i.text === n;\n                      });\n                    } else {\n                      const t = o[1].name,\n                        r = o[2].value;\n                      h[e].push(function (e) {\n                        for (const o of e) if (o.name === t) return o.node.text === r === n;\n                        return !1;\n                      });\n                    }\n                    break;\n                  case \"not-match?\":\n                    n = !1;\n                  case \"match?\":\n                    if (3 !== o.length) throw new Error(`Wrong number of arguments to \\`#match?\\` predicate. Expected 2, got ${o.length - 1}.`);\n                    if (\"capture\" !== o[1].type) throw new Error(`First argument of \\`#match?\\` predicate must be a capture. Got \"${o[1].value}\".`);\n                    if (\"string\" !== o[2].type) throw new Error(`Second argument of \\`#match?\\` predicate must be a string. Got @${o[2].value}.`);\n                    const r = o[1].name,\n                      i = new RegExp(o[2].value);\n                    h[e].push(function (e) {\n                      for (const t of e) if (t.name === r) return i.test(t.node.text) === n;\n                      return !1;\n                    });\n                    break;\n                  case \"set!\":\n                    if (o.length < 2 || o.length > 3) throw new Error(`Wrong number of arguments to \\`#set!\\` predicate. Expected 1 or 2. Got ${o.length - 1}.`);\n                    if (o.some(e => \"string\" !== e.type)) throw new Error('Arguments to `#set!` predicate must be a strings.\".');\n                    l[e] || (l[e] = {}), l[e][o[1].value] = o[2] ? o[2].value : null;\n                    break;\n                  case \"is?\":\n                  case \"is-not?\":\n                    if (o.length < 2 || o.length > 3) throw new Error(`Wrong number of arguments to \\`#${t}\\` predicate. Expected 1 or 2. Got ${o.length - 1}.`);\n                    if (o.some(e => \"string\" !== e.type)) throw new Error(`Arguments to \\`#${t}\\` predicate must be a strings.\".`);\n                    const s = \"is?\" === t ? u : d;\n                    s[e] || (s[e] = {}), s[e][o[1].value] = o[2] ? o[2].value : null;\n                    break;\n                  default:\n                    p[e].push({\n                      operator: t,\n                      operands: o.slice(1)\n                    });\n                }\n                o.length = 0;\n              }\n            }\n            Object.freeze(l[e]);\n            Object.freeze(u[e]);\n            Object.freeze(d[e]);\n          }\n          Ze._free(n);\n          return new wt(et, r, a, h, p, Object.freeze(l), Object.freeze(u), Object.freeze(d));\n        }\n        static load(e) {\n          let t;\n          if (e instanceof Uint8Array) t = Promise.resolve(e);else {\n            const r = e;\n            if (\"undefined\" != typeof process && process.versions && process.versions.node) {\n              const e = n(747);\n              t = Promise.resolve(e.readFileSync(r));\n            } else t = fetch(r).then(e => e.arrayBuffer().then(t => {\n              if (e.ok) return new Uint8Array(t);\n              {\n                const n = new TextDecoder(\"utf-8\").decode(t);\n                throw new Error(`Language.load failed with status ${e.status}.\\n\\n${n}`);\n              }\n            }));\n          }\n          const r = \"function\" == typeof loadSideModule ? loadSideModule : Ie;\n          return t.then(e => r(e, {\n            loadAsync: !0\n          })).then(e => {\n            const t = Object.keys(e),\n              n = t.find(e => lt.test(e) && !e.includes(\"external_scanner_\"));\n            n || console.log(`Couldn't find language function in WASM file. Symbols:\\n${JSON.stringify(t, null, 2)}`);\n            const r = e[n]();\n            return new bt(et, r);\n          });\n        }\n      }\n      class wt {\n        constructor(e, t, n, r, o, i, s, a) {\n          Ct(e);\n          this[0] = t;\n          this.captureNames = n;\n          this.textPredicates = r;\n          this.predicates = o;\n          this.setProperties = i;\n          this.assertedProperties = s;\n          this.refutedProperties = a;\n          this.exceededMatchLimit = !1;\n        }\n        delete() {\n          Ze._ts_query_delete(this[0]);\n          this[0] = 0;\n        }\n        matches(e, t, n) {\n          t || (t = it);\n          n || (n = it);\n          Tt(e);\n          Ze._ts_query_matches_wasm(this[0], e.tree[0], t.row, t.column, n.row, n.column);\n          const r = P(pt, \"i32\"),\n            o = P(pt + tt, \"i32\"),\n            i = P(pt + 2 * tt, \"i32\"),\n            s = new Array(r);\n          this.exceededMatchLimit = !!i;\n          let a = 0,\n            c = o;\n          for (let t = 0; t < r; t++) {\n            const n = P(c, \"i32\"),\n              r = P(c += tt, \"i32\");\n            c += tt;\n            const o = new Array(r);\n            c = Et(this, e.tree, c, o);\n            if (this.textPredicates[n].every(e => e(o))) {\n              s[a++] = {\n                pattern: n,\n                captures: o\n              };\n              const e = this.setProperties[n];\n              e && (s[t].setProperties = e);\n              const r = this.assertedProperties[n];\n              r && (s[t].assertedProperties = r);\n              const i = this.refutedProperties[n];\n              i && (s[t].refutedProperties = i);\n            }\n          }\n          s.length = a;\n          Ze._free(o);\n          return s;\n        }\n        captures(e, t, n) {\n          t || (t = it);\n          n || (n = it);\n          Tt(e);\n          Ze._ts_query_captures_wasm(this[0], e.tree[0], t.row, t.column, n.row, n.column);\n          const r = P(pt, \"i32\"),\n            o = P(pt + tt, \"i32\"),\n            i = P(pt + 2 * tt, \"i32\"),\n            s = [];\n          this.exceededMatchLimit = !!i;\n          const a = [];\n          let c = o;\n          for (let t = 0; t < r; t++) {\n            const t = P(c, \"i32\"),\n              n = P(c += tt, \"i32\"),\n              r = P(c += tt, \"i32\");\n            c += tt;\n            a.length = n;\n            c = Et(this, e.tree, c, a);\n            if (this.textPredicates[t].every(e => e(a))) {\n              const e = a[r],\n                n = this.setProperties[t];\n              n && (e.setProperties = n);\n              const o = this.assertedProperties[t];\n              o && (e.assertedProperties = o);\n              const i = this.refutedProperties[t];\n              i && (e.refutedProperties = i), s.push(e);\n            }\n          }\n          Ze._free(o);\n          return s;\n        }\n        predicatesForPattern(e) {\n          return this.predicates[e];\n        }\n        didExceedMatchLimit() {\n          return this.exceededMatchLimit;\n        }\n      }\n      function xt(e, t, n) {\n        const r = n - t;\n        let o = e.textCallback(t, null, n);\n        for (t += o.length; t < n;) {\n          const r = e.textCallback(t, null, n);\n          if (!(r && r.length > 0)) break;\n          t += r.length;\n          o += r;\n        }\n        t > n && (o = o.slice(0, r));\n        return o;\n      }\n      function Et(e, t, n, r) {\n        for (let o = 0, i = r.length; o < i; o++) {\n          const i = P(n, \"i32\"),\n            s = kt(t, n += tt);\n          n += nt;\n          r[o] = {\n            name: e.captureNames[i],\n            node: s\n          };\n        }\n        return n;\n      }\n      function Ct(e) {\n        if (e !== et) throw new Error(\"Illegal constructor\");\n      }\n      function St(e) {\n        return e && \"number\" == typeof e.row && \"number\" == typeof e.column;\n      }\n      function Tt(e) {\n        let t = pt;\n        I(t, e.id, \"i32\");\n        I(t += tt, e.startIndex, \"i32\");\n        I(t += tt, e.startPosition.row, \"i32\");\n        I(t += tt, e.startPosition.column, \"i32\");\n        I(t += tt, e[0], \"i32\");\n      }\n      function kt(e, t = pt) {\n        const n = P(t, \"i32\");\n        if (0 === n) return null;\n        const r = P(t += tt, \"i32\"),\n          o = P(t += tt, \"i32\"),\n          i = P(t += tt, \"i32\"),\n          s = P(t += tt, \"i32\"),\n          a = new yt(et, e);\n        a.id = n;\n        a.startIndex = r;\n        a.startPosition = {\n          row: o,\n          column: i\n        };\n        a[0] = s;\n        return a;\n      }\n      function It(e, t = pt) {\n        I(t + 0 * tt, e[0], \"i32\");\n        I(t + 1 * tt, e[1], \"i32\");\n        I(t + 2 * tt, e[2], \"i32\");\n      }\n      function Pt(e) {\n        e[0] = P(pt + 0 * tt, \"i32\");\n        e[1] = P(pt + 1 * tt, \"i32\");\n        e[2] = P(pt + 2 * tt, \"i32\");\n      }\n      function At(e, t) {\n        I(e, t.row, \"i32\");\n        I(e + tt, t.column, \"i32\");\n      }\n      function Ot(e) {\n        return {\n          row: P(e, \"i32\"),\n          column: P(e + tt, \"i32\")\n        };\n      }\n      function Nt(e, t) {\n        At(e, t.startPosition);\n        At(e += rt, t.endPosition);\n        I(e += rt, t.startIndex, \"i32\");\n        I(e += tt, t.endIndex, \"i32\");\n        e += tt;\n      }\n      function Rt(e) {\n        const t = {};\n        t.startPosition = Ot(e);\n        e += rt;\n        t.endPosition = Ot(e);\n        e += rt;\n        t.startIndex = P(e, \"i32\");\n        e += tt;\n        t.endIndex = P(e, \"i32\");\n        return t;\n      }\n      gt.Language = bt;\n      gt.Parser = gt;\n      return gt;\n    }) ? r.apply(t, []) : r) || (e.exports = o);\n  },\n  94: (e, t, n) => {\n    const r = n(747),\n      o = n(622),\n      i = (e, t) => Array.from(Array(t).keys()).slice(e),\n      s = e => e.charCodeAt(0),\n      a = new TextDecoder(\"utf-8\"),\n      c = e => a.decode(new Uint8Array(e));\n    function l(e) {\n      const t = new Set();\n      let n = e[0];\n      for (let r = 1; r < e.length; r++) {\n        const o = e[r];\n        t.add([n, o]);\n        n = o;\n      }\n      return t;\n    }\n    const u = new TextEncoder(\"utf-8\"),\n      d = /'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu;\n    let p = !1;\n    const h = {};\n    let f,\n      m = {},\n      g = new Map(),\n      _ = new Map();\n    const y = new Map();\n    function v() {\n      if (p) return;\n      m = JSON.parse(r.readFileSync(o.resolve(__dirname, \"..\", \"dist\", \"tokenizer.json\")));\n      Object.keys(m).map(e => {\n        h[m[e]] = e;\n      });\n      const e = r.readFileSync(o.resolve(__dirname, \"..\", \"dist\", \"vocab.bpe\"), \"utf-8\").split(\"\\n\"),\n        t = e.slice(1, e.length - 1).map(e => e.split(/(\\s+)/).filter(function (e) {\n          return e.trim().length > 0;\n        }));\n      f = ((e, t) => {\n        const n = {};\n        e.map((r, o) => {\n          n[e[o]] = t[o];\n        });\n        return n;\n      })(t, i(0, t.length));\n      (function (e) {\n        const t = i(s(\"!\"), s(\"~\") + 1).concat(i(s(\"¡\"), s(\"¬\") + 1), i(s(\"®\"), s(\"ÿ\") + 1));\n        let n = t.slice(),\n          r = 0;\n        for (let e = 0; e < 256; e++) t.includes(e) || (t.push(e), n.push(256 + r), r += 1);\n        n = n.map(e => (e => String.fromCharCode(e))(e));\n        for (let r = 0; r < t.length; r++) e.set(t[r], n[r]);\n      })(g);\n      g.forEach(function (e, t, n) {\n        _.set(e, t);\n      });\n      p = !0;\n    }\n    function b(e) {\n      if (y.has(e)) return y.get(e);\n      let t = (r = e, Array.from(u.encode(r))).map(e => g.get(e)),\n        n = l(t);\n      var r;\n      if (!n) return t.map(e => m[e]);\n      for (;;) {\n        const e = {};\n        Array.from(n).map(t => {\n          const n = f[t];\n          e[isNaN(n) ? 1e11 : n] = t;\n        });\n        const r = e[Math.min(...Object.keys(e).map(e => parseInt(e)))];\n        if (!(r in f)) break;\n        const o = r[0],\n          i = r[1];\n        let s = [],\n          a = 0;\n        for (; a < t.length;) {\n          const e = t.indexOf(o, a);\n          if (-1 === e) {\n            Array.prototype.push.apply(s, t.slice(a));\n            break;\n          }\n          Array.prototype.push.apply(s, t.slice(a, e));\n          a = e;\n          t[a] === o && a < t.length - 1 && t[a + 1] === i ? (s.push(o + i), a += 2) : (s.push(t[a]), a += 1);\n        }\n        t = s;\n        if (1 === t.length) break;\n        n = l(t);\n      }\n      tokens = t.map(e => m[e]);\n      y.set(e, tokens);\n      return tokens;\n    }\n    function w(e) {\n      v();\n      let t = [];\n      const n = Array.from(e.matchAll(d)).map(e => e[0]);\n      for (let e of n) {\n        const n = b(e);\n        Array.prototype.push.apply(t, n);\n      }\n      return t;\n    }\n    function x(e, t) {\n      if (t <= 0) return \"\";\n      let n = Math.min(e.length, 4 * t),\n        r = e.slice(-n),\n        o = w(r);\n      for (; o.length < t + 2 && n < e.length;) {\n        n = Math.min(e.length, n + 1 * t);\n        r = e.slice(-n);\n        o = w(r);\n      }\n      return o.length < t ? e : (o = o.slice(-t), E(o));\n    }\n    function E(e) {\n      v();\n      let t = e.map(e => h[e]).join(\"\");\n      t = c(t.split(\"\").map(e => _.get(e)));\n      return t;\n    }\n    e.exports = {\n      prepareTokenizer: v,\n      tokenize: w,\n      tokenize_strings: function (e) {\n        return w(e).map(e => c(h[e].split(\"\").map(e => _.get(e))));\n      },\n      tokenLength: function (e) {\n        return w(e).length;\n      },\n      takeLastTokens: x,\n      takeLastLinesTokens: function (e, t) {\n        const n = x(e, t);\n        if (n.length === e.length || \"\\n\" === e[e.length - n.length - 1]) return n;\n        let r = n.indexOf(\"\\n\");\n        return n.substring(r + 1);\n      },\n      takeFirstTokens: function (e, t) {\n        if (t <= 0) return {\n          text: \"\",\n          tokens: []\n        };\n        let n = Math.min(e.length, 4 * t),\n          r = e.slice(0, n),\n          o = w(r);\n        for (; o.length < t + 2 && n < e.length;) {\n          n = Math.min(e.length, n + 1 * t);\n          r = e.slice(0, n);\n          o = w(r);\n        }\n        return o.length < t ? {\n          text: e,\n          tokens: o\n        } : (o = o.slice(0, t), {\n          text: E(o),\n          tokens: o\n        });\n      },\n      detokenize: E\n    };\n  },\n  747: e => {\n    \"use strict\";\n\n    e.exports = require(7147);\n  },\n  622: e => {\n    \"use strict\";\n\n    e.exports = require(1017);\n  },\n  13: e => {\n    \"use strict\";\n\n    e.exports = require(1267);\n  }\n};\no = {};\ni = function e(t) {\n  var n = o[t];\n  if (undefined !== n) return n.exports;\n  var i = o[t] = {\n    exports: {}\n  };\n  r[t].call(i.exports, i, i.exports, e);\n  return i.exports;\n}(563);\nmodule.exports = i;",
  "3057": "var r = require(9491),\n  o = require(9867),\n  i = \"error@context\";\nfunction s(e) {\n  this.name = e;\n  this.active = null;\n  this._set = [];\n  this.id = null;\n}\nfunction a(e) {\n  return process.namespaces[e];\n}\nfunction c(e) {\n  var t = a(e);\n  r.ok(t, \"can't delete nonexistent namespace!\");\n  r.ok(t.id, \"don't assign to process.namespaces directly!\");\n  process.removeAsyncListener(t.id);\n  process.namespaces[e] = null;\n}\nfunction l() {\n  process.namespaces && Object.keys(process.namespaces).forEach(function (e) {\n    c(e);\n  });\n  process.namespaces = Object.create(null);\n}\nprocess.addAsyncListener || require(7645);\ns.prototype.set = function (e, t) {\n  if (!this.active) throw new Error(\"No context available. ns.run() or ns.bind() must be called first.\");\n  this.active[e] = t;\n  return t;\n};\ns.prototype.get = function (e) {\n  if (this.active) return this.active[e];\n};\ns.prototype.createContext = function () {\n  return Object.create(this.active);\n};\ns.prototype.run = function (e) {\n  var t = this.createContext();\n  this.enter(t);\n  try {\n    e(t);\n    return t;\n  } catch (e) {\n    throw e && (e[i] = t), e;\n  } finally {\n    this.exit(t);\n  }\n};\ns.prototype.runAndReturn = function (e) {\n  var t;\n  this.run(function (n) {\n    t = e(n);\n  });\n  return t;\n};\ns.prototype.bind = function (e, t) {\n  t || (t = this.active ? this.active : this.createContext());\n  var n = this;\n  return function () {\n    n.enter(t);\n    try {\n      return e.apply(this, arguments);\n    } catch (e) {\n      throw e && (e[i] = t), e;\n    } finally {\n      n.exit(t);\n    }\n  };\n};\ns.prototype.enter = function (e) {\n  r.ok(e, \"context must be provided for entering\");\n  this._set.push(this.active);\n  this.active = e;\n};\ns.prototype.exit = function (e) {\n  r.ok(e, \"context must be provided for exiting\");\n  if (this.active === e) return r.ok(this._set.length, \"can't remove top context\"), void (this.active = this._set.pop());\n  var t = this._set.lastIndexOf(e);\n  r.ok(t >= 0, \"context not currently entered; can't exit\");\n  r.ok(t, \"can't remove top context\");\n  this._set.splice(t, 1);\n};\ns.prototype.bindEmitter = function (e) {\n  r.ok(e.on && e.addListener && e.emit, \"can only bind real EEs\");\n  var t = this,\n    n = \"context@\" + this.name;\n  o(e, function (e) {\n    e && (e[\"cls@contexts\"] || (e[\"cls@contexts\"] = Object.create(null)), e[\"cls@contexts\"][n] = {\n      namespace: t,\n      context: t.active\n    });\n  }, function (e) {\n    if (!e || !e[\"cls@contexts\"]) return e;\n    var t = e,\n      n = e[\"cls@contexts\"];\n    Object.keys(n).forEach(function (e) {\n      var r = n[e];\n      t = r.namespace.bind(t, r.context);\n    });\n    return t;\n  });\n};\ns.prototype.fromException = function (e) {\n  return e[i];\n};\nprocess.namespaces || l();\nmodule.exports = {\n  getNamespace: a,\n  createNamespace: function (e) {\n    r.ok(e, \"namespace must be given a name!\");\n    var t = new s(e);\n    t.id = process.addAsyncListener({\n      create: function () {\n        return t.active;\n      },\n      before: function (e, n) {\n        n && t.enter(n);\n      },\n      after: function (e, n) {\n        n && t.exit(n);\n      },\n      error: function (e) {\n        e && t.exit(e);\n      }\n    });\n    process.namespaces[e] = t;\n    return t;\n  },\n  destroyNamespace: c,\n  reset: l\n};",
  "3060": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.CopilotLabelPrefix = exports.CMDSendFeedback = exports.CMDShowActivationErrors = exports.CMDToggleCopilot = exports.CMDAcceptPanelSolution = exports.CMDOpenPanelForRange = exports.CMDOpenPanel = undefined;\nexports.CMDOpenPanel = \"github.copilot.generate\";\nexports.CMDOpenPanelForRange = \"github.copilot.openPanelForRange\";\nexports.CMDAcceptPanelSolution = \"github.copilot.acceptPanelSolution\";\nexports.CMDToggleCopilot = \"github.copilot.toggleCopilot\";\nexports.CMDShowActivationErrors = \"github.copilot.showActivationErrors\";\nexports.CMDSendFeedback = \"github.copilot.sendFeedback\";\nexports.CopilotLabelPrefix = \"$(copilot-logo) \";",
  "3076": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.LRUCache = exports.keyForPrompt = undefined;\nconst r = require(1354);\nexports.keyForPrompt = function (e) {\n  return r.SHA256(e.prefix + e.suffix).toString();\n};\nexports.LRUCache = class {\n  constructor(e = 10) {\n    this.values = new Map();\n    this.lruKeys = [];\n    this.size = e;\n  }\n  removeKeyFromLRU(e) {\n    const t = this.lruKeys.indexOf(e);\n    -1 !== t && this.lruKeys.splice(t, 1);\n  }\n  touchKeyInLRU(e) {\n    this.removeKeyFromLRU(e);\n    this.lruKeys.push(e);\n  }\n  clear() {\n    this.values.clear();\n    this.lruKeys = [];\n  }\n  deleteKey(e) {\n    this.removeKeyFromLRU(e);\n    undefined !== this.values.get(e) && this.values.delete(e);\n  }\n  get(e) {\n    if (this.values.has(e)) {\n      const t = this.values.get(e);\n      this.touchKeyInLRU(e);\n      return t;\n    }\n  }\n  put(e, t) {\n    let n = [];\n    this.values.has(e) ? n = [e] : this.lruKeys.length >= this.size && (n = this.lruKeys.splice(0, 1));\n    for (const e of n) this.deleteKey(e);\n    this.values.set(e, t);\n    this.touchKeyInLRU(e);\n  }\n};",
  "3092": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.metrics = [];\n      t.properties = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  }(require(8934));\nmodule.exports = i;",
  "3099": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = undefined;\nconst r = require(3487),\n  o = require(6776);\nexports.getSubschema = function (e, {\n  keyword: t,\n  schemaProp: n,\n  schema: i,\n  schemaPath: s,\n  errSchemaPath: a,\n  topSchemaRef: c\n}) {\n  if (undefined !== t && undefined !== i) throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n  if (undefined !== t) {\n    const i = e.schema[t];\n    return undefined === n ? {\n      schema: i,\n      schemaPath: r._`${e.schemaPath}${r.getProperty(t)}`,\n      errSchemaPath: `${e.errSchemaPath}/${t}`\n    } : {\n      schema: i[n],\n      schemaPath: r._`${e.schemaPath}${r.getProperty(t)}${r.getProperty(n)}`,\n      errSchemaPath: `${e.errSchemaPath}/${t}/${o.escapeFragment(n)}`\n    };\n  }\n  if (undefined !== i) {\n    if (undefined === s || undefined === a || undefined === c) throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n    return {\n      schema: i,\n      schemaPath: s,\n      topSchemaRef: c,\n      errSchemaPath: a\n    };\n  }\n  throw new Error('either \"keyword\" or \"schema\" must be passed');\n};\nexports.extendSubschemaData = function (e, t, {\n  dataProp: n,\n  dataPropType: i,\n  data: s,\n  dataTypes: a,\n  propertyName: c\n}) {\n  if (undefined !== s && undefined !== n) throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n  const {\n    gen: l\n  } = t;\n  if (undefined !== n) {\n    const {\n      errorPath: s,\n      dataPathArr: a,\n      opts: c\n    } = t;\n    u(l.let(\"data\", r._`${t.data}${r.getProperty(n)}`, !0));\n    e.errorPath = r.str`${s}${o.getErrorPath(n, i, c.jsPropertySyntax)}`;\n    e.parentDataProperty = r._`${n}`;\n    e.dataPathArr = [...a, e.parentDataProperty];\n  }\n  function u(n) {\n    e.data = n;\n    e.dataLevel = t.dataLevel + 1;\n    e.dataTypes = [];\n    t.definedProperties = new Set();\n    e.parentData = t.data;\n    e.dataNames = [...t.dataNames, n];\n  }\n  undefined !== s && (u(s instanceof r.Name ? s : l.let(\"data\", s, !0)), undefined !== c && (e.propertyName = c));\n  a && (e.dataTypes = a);\n};\nexports.extendSubschemaMode = function (e, {\n  jtdDiscriminator: t,\n  jtdMetadata: n,\n  compositeRule: r,\n  createErrors: o,\n  allErrors: i\n}) {\n  undefined !== r && (e.compositeRule = r);\n  undefined !== o && (e.createErrors = o);\n  undefined !== i && (e.allErrors = i);\n  e.jtdDiscriminator = t;\n  e.jtdMetadata = n;\n};",
  "3100": "const r = require(8104)(\"helix-fetch:core\"),\n  {\n    request: o,\n    setupContext: i,\n    resetContext: s,\n    RequestAbortedError: a,\n    ALPN_HTTP2: c,\n    ALPN_HTTP2C: l,\n    ALPN_HTTP1_1: u,\n    ALPN_HTTP1_0: d\n  } = require(9575);\nclass p {\n  constructor(e) {\n    this.options = {\n      ...(e || {})\n    };\n    i(this);\n  }\n  api() {\n    return {\n      request: async (e, t) => this.request(e, t),\n      context: (e = {}) => new p(e).api(),\n      reset: async () => this.reset(),\n      RequestAbortedError: a,\n      ALPN_HTTP2: c,\n      ALPN_HTTP2C: l,\n      ALPN_HTTP1_1: u,\n      ALPN_HTTP1_0: d\n    };\n  }\n  async request(e, t) {\n    return o(this, e, t);\n  }\n  async reset() {\n    r(\"resetting context\");\n    return s(this);\n  }\n}\nmodule.exports = new p().api();",
  "3136": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.TextDocumentManager = exports.getRelativePath = undefined;\nconst r = require(1017);\nexports.getRelativePath = function (e, t) {\n  for (const n of e) {\n    const e = n.fsPath;\n    if (t.startsWith(e + r.sep)) return r.relative(e, t);\n  }\n};\nexports.TextDocumentManager = class {};",
  "3141": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getRules = exports.isJSONType = undefined;\nconst n = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"]);\nexports.isJSONType = function (e) {\n  return \"string\" == typeof e && n.has(e);\n};\nexports.getRules = function () {\n  const e = {\n    number: {\n      type: \"number\",\n      rules: []\n    },\n    string: {\n      type: \"string\",\n      rules: []\n    },\n    array: {\n      type: \"array\",\n      rules: []\n    },\n    object: {\n      type: \"object\",\n      rules: []\n    }\n  };\n  return {\n    types: {\n      ...e,\n      integer: !0,\n      boolean: !0,\n      null: !0\n    },\n    rules: [{\n      rules: []\n    }, e.number, e.string, e.array, e.object],\n    post: {\n      rules: []\n    },\n    all: {},\n    keywords: {}\n  };\n};",
  "3197": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.registerGhostText = exports.handleGhostTextPostInsert = exports.handleGhostTextShown = exports.provideInlineCompletions = exports.ghostTextLogger = exports.getInsertionTextFromCompletion = undefined;\nconst r = require(9496),\n  o = require(1133),\n  i = require(2218),\n  s = require(9334),\n  a = require(750),\n  c = require(9899),\n  l = require(7017),\n  u = require(6333),\n  d = require(4540),\n  p = \"_ghostTextPostInsert\";\nfunction getInsertionTextFromCompletion(e) {\n  return e.insertText;\n}\nlet f, m;\nexports.getInsertionTextFromCompletion = getInsertionTextFromCompletion;\nexports.ghostTextLogger = new c.Logger(c.LogLevel.INFO, \"ghostText\");\nlet g,\n  _ = [];\nasync function provideInlineCompletions(e, n, c, h, y) {\n  const v = await async function (e, n, a, c, h) {\n    const y = u.TelemetryData.createAndMarkAsIssued();\n    if (!function (e) {\n      return o.getConfig(e, o.ConfigKey.InlineSuggestEnable);\n    }(e)) return {\n      type: \"abortedBeforeIssued\",\n      reason: \"ghost text is disabled\"\n    };\n    if (d.ignoreDocument(e, n)) return {\n      type: \"abortedBeforeIssued\",\n      reason: \"document is ignored\"\n    };\n    exports.ghostTextLogger.debug(e, `Ghost text called at [${a.line}, ${a.character}], with triggerKind ${c.triggerKind}`);\n    if (h.isCancellationRequested) return exports.ghostTextLogger.info(e, \"Cancelled before extractPrompt\"), {\n      type: \"abortedBeforeIssued\",\n      reason: \"cancelled before extractPrompt\"\n    };\n    if (c.selectedCompletionInfo) {\n      exports.ghostTextLogger.debug(e, \"Not showing ghost text because autocomplete widget is displayed\");\n      return {\n        type: \"abortedBeforeIssued\",\n        reason: \"autocomplete widget is displayed\"\n      };\n    }\n    const v = await s.getGhostText(e, n, a, c.triggerKind === r.InlineCompletionTriggerKind.Invoke, y, h);\n    if (\"success\" !== v.type) {\n      exports.ghostTextLogger.debug(e, \"Breaking, no results from getGhostText -- \" + v.type + \": \" + v.reason);\n      return v;\n    }\n    const [b, w] = v.value;\n    if (f && m && (!f.isEqual(a) || m !== n.uri) && w !== s.ResultType.TypingAsSuggested) {\n      const t = _.flatMap(e => e.displayText && e.telemetry ? [{\n        completionText: e.displayText,\n        completionTelemetryData: e.telemetry\n      }] : []);\n      t.length > 0 && l.postRejectionTasks(e, \"ghostText\", n.offsetAt(f), m, t);\n    }\n    f = a;\n    m = n.uri;\n    _ = [];\n    if (h.isCancellationRequested) return exports.ghostTextLogger.info(e, \"Cancelled after getGhostText\"), {\n      type: \"canceled\",\n      reason: \"after getGhostText\",\n      telemetryData: {\n        telemetryBlob: v.telemetryBlob\n      }\n    };\n    const x = i.completionsFromGhostTextResults(e, b, w, n, a, function (e) {\n      const t = r.window.visibleTextEditors.find(t => t.document === e);\n      return null == t ? undefined : t.options;\n    }(n), g);\n    exports.ghostTextLogger.debug(e, \"Completions\", x);\n    const E = x.map(e => {\n      const {\n          text: t,\n          range: o\n        } = e,\n        i = new r.Range(new r.Position(o.start.line, o.start.character), new r.Position(o.end.line, o.end.character)),\n        s = new r.InlineCompletionItem(t, i);\n      s.index = e.index;\n      s.telemetry = e.telemetry;\n      s.displayText = e.displayText;\n      s.resultType = e.resultType;\n      s.uri = n.uri;\n      s.insertOffset = n.offsetAt(new r.Position(e.position.line, e.position.character));\n      s.command = {\n        title: \"PostInsertTask\",\n        command: p,\n        arguments: [s]\n      };\n      return s;\n    });\n    return 0 === E.length ? {\n      type: \"empty\",\n      reason: \"no completions in final result\",\n      telemetryData: v.telemetryData\n    } : {\n      ...v,\n      value: E\n    };\n  }(e, n, c, h, y);\n  return await a.handleGhostTextResultTelemetry(e, v);\n}\nexports.provideInlineCompletions = provideInlineCompletions;\nclass v {\n  constructor(e) {\n    this.ctx = e;\n  }\n  async provideInlineCompletionItems(e, t, n, r) {\n    return provideInlineCompletions(this.ctx, e, t, n, r);\n  }\n  handleDidShowCompletionItem(e) {\n    handleGhostTextShown(this.ctx, e);\n  }\n}\nfunction handleGhostTextShown(e, n) {\n  g = n.index;\n  if (!_.find(e => e.index === n.index) && (_.push(n), n.telemetry)) {\n    const r = !(n.resultType === s.ResultType.Network);\n    exports.ghostTextLogger.debug(e, `[${n.telemetry.properties.headerRequestId}] shown choiceIndex: ${n.telemetry.properties.choiceIndex}, fromCache ${r}`), (0, a.telemetryShown)(e, \"ghostText\", n.telemetry, r);\n  }\n}\nasync function handleGhostTextPostInsert(e, n) {\n  _ = [];\n  m = undefined;\n  f = undefined;\n  exports.ghostTextLogger.debug(e, \"Ghost text post insert\");\n  n.telemetry && n.uri && n.displayText && undefined !== n.insertOffset && n.range && (n.telemetry.measurements.compCharLen = getInsertionTextFromCompletion(n).length, await l.postInsertionTasks(e, \"ghostText\", n.displayText, n.insertOffset, n.uri, n.telemetry));\n}\nexports.handleGhostTextShown = handleGhostTextShown;\nexports.handleGhostTextPostInsert = handleGhostTextPostInsert;\nexports.registerGhostText = function (e) {\n  const t = new v(e);\n  return [r.languages.registerInlineCompletionItemProvider({\n    pattern: \"**\"\n  }, t), r.commands.registerCommand(p, async t => handleGhostTextPostInsert(e, t))];\n};",
  "3223": "const r = require(9822);\nif (global._asyncHook) {\n  if (global._asyncHook.version !== require(6157).i8) throw new Error(\"Conflicting version of async-hook-jl found\");\n  module.exports = global._asyncHook;\n} else {\n  require(2512).filter.attach(function (e, t) {\n    return t.filter(function (e) {\n      const t = e.getFileName();\n      return !(t && t.slice(0, __dirname.length) === __dirname);\n    });\n  });\n  module.exports = global._asyncHook = new r();\n}",
  "3229": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(6776),\n  i = require(4499),\n  s = {\n    keyword: [\"maxLength\", \"minLength\"],\n    type: \"string\",\n    schemaType: \"number\",\n    $data: !0,\n    error: {\n      message({\n        keyword: e,\n        schemaCode: t\n      }) {\n        const n = \"maxLength\" === e ? \"more\" : \"fewer\";\n        return r.str`must NOT have ${n} than ${t} characters`;\n      },\n      params: ({\n        schemaCode: e\n      }) => r._`{limit: ${e}}`\n    },\n    code(e) {\n      const {\n          keyword: t,\n          data: n,\n          schemaCode: s,\n          it: a\n        } = e,\n        c = \"maxLength\" === t ? r.operators.GT : r.operators.LT,\n        l = !1 === a.opts.unicode ? r._`${n}.length` : r._`${o.useFunc(e.gen, i.default)}(${n})`;\n      e.fail$data(r._`${l} ${c} ${s}`);\n    }\n  };\nexports.default = s;",
  "3269": "function t() {}\nmodule.exports = function () {\n  const e = this._hooks,\n    n = this._state,\n    r = process.nextTick;\n  process.nextTick = function () {\n    if (!n.enabled) return r.apply(process, arguments);\n    const o = new Array(arguments.length);\n    for (let e = 0; e < arguments.length; e++) o[e] = arguments[e];\n    const i = o[0];\n    if (\"function\" != typeof i) throw new TypeError(\"callback is not a function\");\n    const s = new t(),\n      a = --n.counter;\n    e.init.call(s, a, 0, null, null);\n    o[0] = function () {\n      e.pre.call(s, a);\n      let t = !0;\n      try {\n        i.apply(this, arguments);\n        t = !1;\n      } finally {\n        t && process.listenerCount(\"uncaughtException\") > 0 && process.once(\"uncaughtException\", function () {\n          e.post.call(s, a, !0);\n          e.destroy.call(null, a);\n        });\n      }\n      e.post.call(s, a, !1);\n      e.destroy.call(null, a);\n    };\n    return r.apply(process, o);\n  };\n};",
  "3286": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.normalizeIndentCharacter = undefined;\nexports.normalizeIndentCharacter = function (e, t, n) {\n  function r(e, t, n) {\n    const r = new RegExp(`^(${t})+`, \"g\");\n    return e.split(\"\\n\").map(e => {\n      const t = e.replace(r, \"\"),\n        o = e.length - t.length;\n      return n(o) + t;\n    }).join(\"\\n\");\n  }\n  let o;\n  o = undefined === e.tabSize || \"string\" == typeof e.tabSize ? 4 : e.tabSize;\n  if (!1 === e.insertSpaces) {\n    const e = e => r(e, \" \", e => \"\\t\".repeat(Math.floor(e / o)) + \" \".repeat(e % o));\n    t.displayText = e(t.displayText), t.completionText = e(t.completionText);\n  } else if (!0 === e.insertSpaces) {\n    const e = e => r(e, \"\\t\", e => \" \".repeat(e * o));\n    if (t.displayText = e(t.displayText), t.completionText = e(t.completionText), n) {\n      const e = e => {\n        const t = e.length - e.trimLeft().length,\n          n = t % o;\n        return 0 !== n && t > 0 ? r(e, \" \".repeat(n), e => \" \".repeat((Math.floor(e / o) + 1) * o)) : e;\n      };\n      t.displayText = e(t.displayText), t.completionText = e(t.completionText);\n    }\n  }\n  return t;\n};",
  "3301": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(412),\n  o = require(3487),\n  i = require(6776),\n  s = {\n    keyword: \"required\",\n    type: \"object\",\n    schemaType: \"array\",\n    $data: !0,\n    error: {\n      message: ({\n        params: {\n          missingProperty: e\n        }\n      }) => o.str`must have required property '${e}'`,\n      params: ({\n        params: {\n          missingProperty: e\n        }\n      }) => o._`{missingProperty: ${e}}`\n    },\n    code(e) {\n      const {\n          gen: t,\n          schema: n,\n          schemaCode: s,\n          data: a,\n          $data: c,\n          it: l\n        } = e,\n        {\n          opts: u\n        } = l;\n      if (!c && 0 === n.length) return;\n      const d = n.length >= u.loopRequired;\n      l.allErrors ? function () {\n        if (d || c) e.block$data(o.nil, p);else for (const t of n) r.checkReportMissingProp(e, t);\n      }() : function () {\n        const i = t.let(\"missing\");\n        if (d || c) {\n          const n = t.let(\"valid\", !0);\n          e.block$data(n, () => function (n, i) {\n            e.setParams({\n              missingProperty: n\n            });\n            t.forOf(n, s, () => {\n              t.assign(i, r.propertyInData(t, a, n, u.ownProperties));\n              t.if(o.not(i), () => {\n                e.error();\n                t.break();\n              });\n            }, o.nil);\n          }(i, n));\n          e.ok(n);\n        } else {\n          t.if(r.checkMissingProp(e, n, i));\n          r.reportMissingProp(e, i);\n          t.else();\n        }\n      }();\n      if (u.strictRequired) {\n        const t = e.parentSchema.properties,\n          {\n            definedProperties: r\n          } = e.it;\n        for (const e of n) if (void 0 === (null == t ? void 0 : t[e]) && !r.has(e)) {\n          const t = `required property \"${e}\" is not defined at \"${l.schemaEnv.baseId + l.errSchemaPath}\" (strictRequired)`;\n          (0, i.checkStrictMode)(l, t, l.opts.strictRequired);\n        }\n      }\n      function p() {\n        t.forOf(\"prop\", s, n => {\n          e.setParams({\n            missingProperty: n\n          });\n          t.if(r.noPropertyInData(t, a, n, u.ownProperties), () => e.error());\n        });\n      }\n    }\n  };\nexports.default = s;",
  "3327": "var r;\nr = require(8249);\nrequire(4938);\n(function (e) {\n  var t = r,\n    n = t.lib,\n    o = n.WordArray,\n    i = n.Hasher,\n    s = t.x64.Word,\n    a = t.algo,\n    c = [],\n    l = [],\n    u = [];\n  !function () {\n    for (var e = 1, t = 0, n = 0; n < 24; n++) {\n      c[e + 5 * t] = (n + 1) * (n + 2) / 2 % 64;\n      var r = (2 * e + 3 * t) % 5;\n      e = t % 5;\n      t = r;\n    }\n    for (e = 0; e < 5; e++) for (t = 0; t < 5; t++) l[e + 5 * t] = t + (2 * e + 3 * t) % 5 * 5;\n    for (var o = 1, i = 0; i < 24; i++) {\n      for (var a = 0, d = 0, p = 0; p < 7; p++) {\n        if (1 & o) {\n          var h = (1 << p) - 1;\n          h < 32 ? d ^= 1 << h : a ^= 1 << h - 32;\n        }\n        128 & o ? o = o << 1 ^ 113 : o <<= 1;\n      }\n      u[i] = s.create(a, d);\n    }\n  }();\n  var d = [];\n  !function () {\n    for (var e = 0; e < 25; e++) d[e] = s.create();\n  }();\n  var p = a.SHA3 = i.extend({\n    cfg: i.cfg.extend({\n      outputLength: 512\n    }),\n    _doReset: function () {\n      for (var e = this._state = [], t = 0; t < 25; t++) e[t] = new s.init();\n      this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n    },\n    _doProcessBlock: function (e, t) {\n      for (var n = this._state, r = this.blockSize / 2, o = 0; o < r; o++) {\n        var i = e[t + 2 * o],\n          s = e[t + 2 * o + 1];\n        i = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8);\n        s = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8);\n        (I = n[o]).high ^= s;\n        I.low ^= i;\n      }\n      for (var a = 0; a < 24; a++) {\n        for (var p = 0; p < 5; p++) {\n          for (var h = 0, f = 0, m = 0; m < 5; m++) {\n            h ^= (I = n[p + 5 * m]).high;\n            f ^= I.low;\n          }\n          var g = d[p];\n          g.high = h;\n          g.low = f;\n        }\n        for (p = 0; p < 5; p++) {\n          var _ = d[(p + 4) % 5],\n            y = d[(p + 1) % 5],\n            v = y.high,\n            b = y.low;\n          for (h = _.high ^ (v << 1 | b >>> 31), f = _.low ^ (b << 1 | v >>> 31), m = 0; m < 5; m++) {\n            (I = n[p + 5 * m]).high ^= h;\n            I.low ^= f;\n          }\n        }\n        for (var w = 1; w < 25; w++) {\n          var x = (I = n[w]).high,\n            E = I.low,\n            C = c[w];\n          C < 32 ? (h = x << C | E >>> 32 - C, f = E << C | x >>> 32 - C) : (h = E << C - 32 | x >>> 64 - C, f = x << C - 32 | E >>> 64 - C);\n          var S = d[l[w]];\n          S.high = h;\n          S.low = f;\n        }\n        var T = d[0],\n          k = n[0];\n        for (T.high = k.high, T.low = k.low, p = 0; p < 5; p++) for (m = 0; m < 5; m++) {\n          var I = n[w = p + 5 * m],\n            P = d[w],\n            A = d[(p + 1) % 5 + 5 * m],\n            O = d[(p + 2) % 5 + 5 * m];\n          I.high = P.high ^ ~A.high & O.high;\n          I.low = P.low ^ ~A.low & O.low;\n        }\n        I = n[0];\n        var N = u[a];\n        I.high ^= N.high;\n        I.low ^= N.low;\n      }\n    },\n    _doFinalize: function () {\n      var t = this._data,\n        n = t.words,\n        r = (this._nDataBytes, 8 * t.sigBytes),\n        i = 32 * this.blockSize;\n      n[r >>> 5] |= 1 << 24 - r % 32;\n      n[(e.ceil((r + 1) / i) * i >>> 5) - 1] |= 128;\n      t.sigBytes = 4 * n.length;\n      this._process();\n      for (var s = this._state, a = this.cfg.outputLength / 8, c = a / 8, l = [], u = 0; u < c; u++) {\n        var d = s[u],\n          p = d.high,\n          h = d.low;\n        p = 16711935 & (p << 8 | p >>> 24) | 4278255360 & (p << 24 | p >>> 8);\n        h = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8);\n        l.push(h);\n        l.push(p);\n      }\n      return new o.init(l, a);\n    },\n    clone: function () {\n      for (var e = i.clone.call(this), t = e._state = this._state.slice(0), n = 0; n < 25; n++) t[n] = t[n].clone();\n      return e;\n    }\n  });\n  t.SHA3 = i._createHelper(p);\n  t.HmacSHA3 = i._createHmacHelper(p);\n})(Math);\nmodule.exports = r.SHA3;",
  "3458": "var r = require(9266);\nfunction o(e) {\n  if (\"string\" != typeof e) throw new Error(\"The url must be a string.\");\n  /^([a-z\\d-]{1,39})\\/([-\\.\\w]{1,100})$/i.test(e) && (e = \"https://github.com/\" + e);\n  var t = r(e),\n    n = t.resource.split(\".\"),\n    i = null;\n  switch (t.toString = function (e) {\n    return o.stringify(this, e);\n  }, t.source = n.length > 2 ? n.slice(1 - n.length).join(\".\") : t.source = t.resource, t.git_suffix = /\\.git$/.test(t.pathname), t.name = decodeURIComponent((t.pathname || t.href).replace(/(^\\/)|(\\/$)/g, \"\").replace(/\\.git$/, \"\")), t.owner = decodeURIComponent(t.user), t.source) {\n    case \"git.cloudforge.com\":\n      t.owner = t.user;\n      t.organization = n[0];\n      t.source = \"cloudforge.com\";\n      break;\n    case \"visualstudio.com\":\n      if (\"vs-ssh.visualstudio.com\" === t.resource) {\n        4 === (i = t.name.split(\"/\")).length && (t.organization = i[1], t.owner = i[2], t.name = i[3], t.full_name = i[2] + \"/\" + i[3]);\n        break;\n      }\n      2 === (i = t.name.split(\"/\")).length ? (t.owner = i[1], t.name = i[1], t.full_name = \"_git/\" + t.name) : 3 === i.length ? (t.name = i[2], \"DefaultCollection\" === i[0] ? (t.owner = i[2], t.organization = i[0], t.full_name = t.organization + \"/_git/\" + t.name) : (t.owner = i[0], t.full_name = t.owner + \"/_git/\" + t.name)) : 4 === i.length && (t.organization = i[0], t.owner = i[1], t.name = i[3], t.full_name = t.organization + \"/\" + t.owner + \"/_git/\" + t.name);\n      break;\n    case \"dev.azure.com\":\n    case \"azure.com\":\n      if (\"ssh.dev.azure.com\" === t.resource) {\n        4 === (i = t.name.split(\"/\")).length && (t.organization = i[1], t.owner = i[2], t.name = i[3]);\n        break;\n      }\n      5 === (i = t.name.split(\"/\")).length ? (t.organization = i[0], t.owner = i[1], t.name = i[4], t.full_name = \"_git/\" + t.name) : 3 === i.length ? (t.name = i[2], \"DefaultCollection\" === i[0] ? (t.owner = i[2], t.organization = i[0], t.full_name = t.organization + \"/_git/\" + t.name) : (t.owner = i[0], t.full_name = t.owner + \"/_git/\" + t.name)) : 4 === i.length && (t.organization = i[0], t.owner = i[1], t.name = i[3], t.full_name = t.organization + \"/\" + t.owner + \"/_git/\" + t.name);\n      t.query && t.query.path && (t.filepath = t.query.path.replace(/^\\/+/g, \"\"));\n      t.query && t.query.version && (t.ref = t.query.version.replace(/^GB/, \"\"));\n      break;\n    default:\n      var s = (i = t.name.split(\"/\")).length - 1;\n      if (i.length >= 2) {\n        var a = i.indexOf(\"-\", 2),\n          c = i.indexOf(\"blob\", 2),\n          l = i.indexOf(\"tree\", 2),\n          u = i.indexOf(\"commit\", 2),\n          d = i.indexOf(\"src\", 2),\n          p = i.indexOf(\"raw\", 2),\n          h = i.indexOf(\"edit\", 2);\n        s = a > 0 ? a - 1 : c > 0 ? c - 1 : l > 0 ? l - 1 : u > 0 ? u - 1 : d > 0 ? d - 1 : p > 0 ? p - 1 : h > 0 ? h - 1 : s;\n        t.owner = i.slice(0, s).join(\"/\");\n        t.name = i[s];\n        u && (t.commit = i[s + 2]);\n      }\n      t.ref = \"\";\n      t.filepathtype = \"\";\n      t.filepath = \"\";\n      var f = i.length > s && \"-\" === i[s + 1] ? s + 1 : s;\n      i.length > f + 2 && [\"raw\", \"src\", \"blob\", \"tree\", \"edit\"].indexOf(i[f + 1]) >= 0 && (t.filepathtype = i[f + 1], t.ref = i[f + 2], i.length > f + 3 && (t.filepath = i.slice(f + 3).join(\"/\")));\n      t.organization = t.owner;\n  }\n  t.full_name || (t.full_name = t.owner, t.name && (t.full_name && (t.full_name += \"/\"), t.full_name += t.name));\n  t.owner.startsWith(\"scm/\") && (t.source = \"bitbucket-server\", t.owner = t.owner.replace(\"scm/\", \"\"), t.organization = t.owner, t.full_name = t.owner + \"/\" + t.name);\n  var m = /(projects|users)\\/(.*?)\\/repos\\/(.*?)((\\/.*$)|$)/.exec(t.pathname);\n  null != m && (t.source = \"bitbucket-server\", \"users\" === m[1] ? t.owner = \"~\" + m[2] : t.owner = m[2], t.organization = t.owner, t.name = m[3], (i = m[4].split(\"/\")).length > 1 && ([\"raw\", \"browse\"].indexOf(i[1]) >= 0 ? (t.filepathtype = i[1], i.length > 2 && (t.filepath = i.slice(2).join(\"/\"))) : \"commits\" === i[1] && i.length > 2 && (t.commit = i[2])), t.full_name = t.owner + \"/\" + t.name, t.query.at ? t.ref = t.query.at : t.ref = \"\");\n  return t;\n}\no.stringify = function (e, t) {\n  t = t || (e.protocols && e.protocols.length ? e.protocols.join(\"+\") : e.protocol);\n  var n = e.port ? \":\" + e.port : \"\",\n    r = e.user || \"git\",\n    o = e.git_suffix ? \".git\" : \"\";\n  switch (t) {\n    case \"ssh\":\n      return n ? \"ssh://\" + r + \"@\" + e.resource + n + \"/\" + e.full_name + o : r + \"@\" + e.resource + \":\" + e.full_name + o;\n    case \"git+ssh\":\n    case \"ssh+git\":\n    case \"ftp\":\n    case \"ftps\":\n      return t + \"://\" + r + \"@\" + e.resource + n + \"/\" + e.full_name + o;\n    case \"http\":\n    case \"https\":\n      return t + \"://\" + (e.token ? function (e) {\n        return \"bitbucket.org\" === e.source ? \"x-token-auth:\" + e.token + \"@\" : e.token + \"@\";\n      }(e) : e.user && (e.protocols.includes(\"http\") || e.protocols.includes(\"https\")) ? e.user + \"@\" : \"\") + e.resource + n + \"/\" + function (e) {\n        return \"bitbucket-server\" === e.source ? \"scm/\" + e.full_name : \"\" + e.full_name;\n      }(e) + o;\n    default:\n      return e.href;\n  }\n};\nmodule.exports = o;",
  "3487": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = undefined;\nconst r = require(7023),\n  o = require(8490);\nvar i = require(7023);\nexports._ = i._;\nexports.str = i.str;\nexports.strConcat = i.strConcat;\nexports.nil = i.nil;\nexports.getProperty = i.getProperty;\nexports.stringify = i.stringify;\nexports.regexpCode = i.regexpCode;\nexports.Name = i.Name;\nvar s = require(8490);\nexports.Scope = s.Scope;\nexports.ValueScope = s.ValueScope;\nexports.ValueScopeName = s.ValueScopeName;\nexports.varKinds = s.varKinds;\nexports.operators = {\n  GT: new r._Code(\">\"),\n  GTE: new r._Code(\">=\"),\n  LT: new r._Code(\"<\"),\n  LTE: new r._Code(\"<=\"),\n  EQ: new r._Code(\"===\"),\n  NEQ: new r._Code(\"!==\"),\n  NOT: new r._Code(\"!\"),\n  OR: new r._Code(\"||\"),\n  AND: new r._Code(\"&&\"),\n  ADD: new r._Code(\"+\")\n};\nclass a {\n  optimizeNodes() {\n    return this;\n  }\n  optimizeNames(e, t) {\n    return this;\n  }\n}\nclass c extends a {\n  constructor(e, t, n) {\n    super();\n    this.varKind = e;\n    this.name = t;\n    this.rhs = n;\n  }\n  render({\n    es5: e,\n    _n: t\n  }) {\n    const n = e ? o.varKinds.var : this.varKind,\n      r = undefined === this.rhs ? \"\" : ` = ${this.rhs}`;\n    return `${n} ${this.name}${r};` + t;\n  }\n  optimizeNames(e, t) {\n    if (e[this.name.str]) {\n      this.rhs && (this.rhs = O(this.rhs, e, t));\n      return this;\n    }\n  }\n  get names() {\n    return this.rhs instanceof r._CodeOrName ? this.rhs.names : {};\n  }\n}\nclass l extends a {\n  constructor(e, t, n) {\n    super();\n    this.lhs = e;\n    this.rhs = t;\n    this.sideEffects = n;\n  }\n  render({\n    _n: e\n  }) {\n    return `${this.lhs} = ${this.rhs};` + e;\n  }\n  optimizeNames(e, t) {\n    if (!(this.lhs instanceof r.Name) || e[this.lhs.str] || this.sideEffects) {\n      this.rhs = O(this.rhs, e, t);\n      return this;\n    }\n  }\n  get names() {\n    return A(this.lhs instanceof r.Name ? {} : {\n      ...this.lhs.names\n    }, this.rhs);\n  }\n}\nclass u extends l {\n  constructor(e, t, n, r) {\n    super(e, n, r);\n    this.op = t;\n  }\n  render({\n    _n: e\n  }) {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + e;\n  }\n}\nclass d extends a {\n  constructor(e) {\n    super();\n    this.label = e;\n    this.names = {};\n  }\n  render({\n    _n: e\n  }) {\n    return `${this.label}:` + e;\n  }\n}\nclass p extends a {\n  constructor(e) {\n    super();\n    this.label = e;\n    this.names = {};\n  }\n  render({\n    _n: e\n  }) {\n    return `break${this.label ? ` ${this.label}` : \"\"};` + e;\n  }\n}\nclass h extends a {\n  constructor(e) {\n    super();\n    this.error = e;\n  }\n  render({\n    _n: e\n  }) {\n    return `throw ${this.error};` + e;\n  }\n  get names() {\n    return this.error.names;\n  }\n}\nclass f extends a {\n  constructor(e) {\n    super();\n    this.code = e;\n  }\n  render({\n    _n: e\n  }) {\n    return `${this.code};` + e;\n  }\n  optimizeNodes() {\n    return `${this.code}` ? this : undefined;\n  }\n  optimizeNames(e, t) {\n    this.code = O(this.code, e, t);\n    return this;\n  }\n  get names() {\n    return this.code instanceof r._CodeOrName ? this.code.names : {};\n  }\n}\nclass m extends a {\n  constructor(e = []) {\n    super();\n    this.nodes = e;\n  }\n  render(e) {\n    return this.nodes.reduce((t, n) => t + n.render(e), \"\");\n  }\n  optimizeNodes() {\n    const {\n      nodes: e\n    } = this;\n    let t = e.length;\n    for (; t--;) {\n      const n = e[t].optimizeNodes();\n      Array.isArray(n) ? e.splice(t, 1, ...n) : n ? e[t] = n : e.splice(t, 1);\n    }\n    return e.length > 0 ? this : undefined;\n  }\n  optimizeNames(e, t) {\n    const {\n      nodes: n\n    } = this;\n    let r = n.length;\n    for (; r--;) {\n      const o = n[r];\n      o.optimizeNames(e, t) || (N(e, o.names), n.splice(r, 1));\n    }\n    return n.length > 0 ? this : undefined;\n  }\n  get names() {\n    return this.nodes.reduce((e, t) => P(e, t.names), {});\n  }\n}\nclass g extends m {\n  render(e) {\n    return \"{\" + e._n + super.render(e) + \"}\" + e._n;\n  }\n}\nclass _ extends m {}\nclass y extends g {}\ny.kind = \"else\";\nclass v extends g {\n  constructor(e, t) {\n    super(t);\n    this.condition = e;\n  }\n  render(e) {\n    let t = `if(${this.condition})` + super.render(e);\n    this.else && (t += \"else \" + this.else.render(e));\n    return t;\n  }\n  optimizeNodes() {\n    super.optimizeNodes();\n    const e = this.condition;\n    if (!0 === e) return this.nodes;\n    let t = this.else;\n    if (t) {\n      const e = t.optimizeNodes();\n      t = this.else = Array.isArray(e) ? new y(e) : e;\n    }\n    return t ? !1 === e ? t instanceof v ? t : t.nodes : this.nodes.length ? this : new v(not(e), t instanceof v ? [t] : t.nodes) : !1 !== e && this.nodes.length ? this : undefined;\n  }\n  optimizeNames(e, t) {\n    var n;\n    this.else = null === (n = this.else) || undefined === n ? undefined : n.optimizeNames(e, t);\n    if (super.optimizeNames(e, t) || this.else) return this.condition = O(this.condition, e, t), this;\n  }\n  get names() {\n    const e = super.names;\n    A(e, this.condition);\n    this.else && P(e, this.else.names);\n    return e;\n  }\n}\nv.kind = \"if\";\nclass b extends g {}\nb.kind = \"for\";\nclass w extends b {\n  constructor(e) {\n    super();\n    this.iteration = e;\n  }\n  render(e) {\n    return `for(${this.iteration})` + super.render(e);\n  }\n  optimizeNames(e, t) {\n    if (super.optimizeNames(e, t)) {\n      this.iteration = O(this.iteration, e, t);\n      return this;\n    }\n  }\n  get names() {\n    return P(super.names, this.iteration.names);\n  }\n}\nclass x extends b {\n  constructor(e, t, n, r) {\n    super();\n    this.varKind = e;\n    this.name = t;\n    this.from = n;\n    this.to = r;\n  }\n  render(e) {\n    const t = e.es5 ? o.varKinds.var : this.varKind,\n      {\n        name: n,\n        from: r,\n        to: i\n      } = this;\n    return `for(${t} ${n}=${r}; ${n}<${i}; ${n}++)` + super.render(e);\n  }\n  get names() {\n    const e = A(super.names, this.from);\n    return A(e, this.to);\n  }\n}\nclass E extends b {\n  constructor(e, t, n, r) {\n    super();\n    this.loop = e;\n    this.varKind = t;\n    this.name = n;\n    this.iterable = r;\n  }\n  render(e) {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(e);\n  }\n  optimizeNames(e, t) {\n    if (super.optimizeNames(e, t)) {\n      this.iterable = O(this.iterable, e, t);\n      return this;\n    }\n  }\n  get names() {\n    return P(super.names, this.iterable.names);\n  }\n}\nclass C extends g {\n  constructor(e, t, n) {\n    super();\n    this.name = e;\n    this.args = t;\n    this.async = n;\n  }\n  render(e) {\n    return `${this.async ? \"async \" : \"\"}function ${this.name}(${this.args})` + super.render(e);\n  }\n}\nC.kind = \"func\";\nclass S extends m {\n  render(e) {\n    return \"return \" + super.render(e);\n  }\n}\nS.kind = \"return\";\nclass T extends g {\n  render(e) {\n    let t = \"try\" + super.render(e);\n    this.catch && (t += this.catch.render(e));\n    this.finally && (t += this.finally.render(e));\n    return t;\n  }\n  optimizeNodes() {\n    var e, t;\n    super.optimizeNodes();\n    null === (e = this.catch) || undefined === e || e.optimizeNodes();\n    null === (t = this.finally) || undefined === t || t.optimizeNodes();\n    return this;\n  }\n  optimizeNames(e, t) {\n    var n, r;\n    super.optimizeNames(e, t);\n    null === (n = this.catch) || undefined === n || n.optimizeNames(e, t);\n    null === (r = this.finally) || undefined === r || r.optimizeNames(e, t);\n    return this;\n  }\n  get names() {\n    const e = super.names;\n    this.catch && P(e, this.catch.names);\n    this.finally && P(e, this.finally.names);\n    return e;\n  }\n}\nclass k extends g {\n  constructor(e) {\n    super();\n    this.error = e;\n  }\n  render(e) {\n    return `catch(${this.error})` + super.render(e);\n  }\n}\nk.kind = \"catch\";\nclass I extends g {\n  render(e) {\n    return \"finally\" + super.render(e);\n  }\n}\nfunction P(e, t) {\n  for (const n in t) e[n] = (e[n] || 0) + (t[n] || 0);\n  return e;\n}\nfunction A(e, t) {\n  return t instanceof r._CodeOrName ? P(e, t.names) : e;\n}\nfunction O(e, t, n) {\n  return e instanceof r.Name ? i(e) : (o = e) instanceof r._Code && o._items.some(e => e instanceof r.Name && 1 === t[e.str] && undefined !== n[e.str]) ? new r._Code(e._items.reduce((e, t) => (t instanceof r.Name && (t = i(t)), t instanceof r._Code ? e.push(...t._items) : e.push(t), e), [])) : e;\n  var o;\n  function i(e) {\n    const r = n[e.str];\n    return undefined === r || 1 !== t[e.str] ? e : (delete t[e.str], r);\n  }\n}\nfunction N(e, t) {\n  for (const n in t) e[n] = (e[n] || 0) - (t[n] || 0);\n}\nfunction not(e) {\n  return \"boolean\" == typeof e || \"number\" == typeof e || null === e ? !e : r._`!${D(e)}`;\n}\nI.kind = \"finally\";\nexports.CodeGen = class {\n  constructor(e, t = {}) {\n    this._values = {};\n    this._blockStarts = [];\n    this._constants = {};\n    this.opts = {\n      ...t,\n      _n: t.lines ? \"\\n\" : \"\"\n    };\n    this._extScope = e;\n    this._scope = new o.Scope({\n      parent: e\n    });\n    this._nodes = [new _()];\n  }\n  toString() {\n    return this._root.render(this.opts);\n  }\n  name(e) {\n    return this._scope.name(e);\n  }\n  scopeName(e) {\n    return this._extScope.name(e);\n  }\n  scopeValue(e, t) {\n    const n = this._extScope.value(e, t);\n    (this._values[n.prefix] || (this._values[n.prefix] = new Set())).add(n);\n    return n;\n  }\n  getScopeValue(e, t) {\n    return this._extScope.getValue(e, t);\n  }\n  scopeRefs(e) {\n    return this._extScope.scopeRefs(e, this._values);\n  }\n  scopeCode() {\n    return this._extScope.scopeCode(this._values);\n  }\n  _def(e, t, n, r) {\n    const o = this._scope.toName(t);\n    undefined !== n && r && (this._constants[o.str] = n);\n    this._leafNode(new c(e, o, n));\n    return o;\n  }\n  const(e, t, n) {\n    return this._def(o.varKinds.const, e, t, n);\n  }\n  let(e, t, n) {\n    return this._def(o.varKinds.let, e, t, n);\n  }\n  var(e, t, n) {\n    return this._def(o.varKinds.var, e, t, n);\n  }\n  assign(e, t, n) {\n    return this._leafNode(new l(e, t, n));\n  }\n  add(e, n) {\n    return this._leafNode(new u(e, exports.operators.ADD, n));\n  }\n  code(e) {\n    \"function\" == typeof e ? e() : e !== r.nil && this._leafNode(new f(e));\n    return this;\n  }\n  object(...e) {\n    const t = [\"{\"];\n    for (const [n, o] of e) {\n      t.length > 1 && t.push(\",\");\n      t.push(n);\n      (n !== o || this.opts.es5) && (t.push(\":\"), r.addCodeArg(t, o));\n    }\n    t.push(\"}\");\n    return new r._Code(t);\n  }\n  if(e, t, n) {\n    this._blockNode(new v(e));\n    if (t && n) this.code(t).else().code(n).endIf();else if (t) this.code(t).endIf();else if (n) throw new Error('CodeGen: \"else\" body without \"then\" body');\n    return this;\n  }\n  elseIf(e) {\n    return this._elseNode(new v(e));\n  }\n  else() {\n    return this._elseNode(new y());\n  }\n  endIf() {\n    return this._endBlockNode(v, y);\n  }\n  _for(e, t) {\n    this._blockNode(e);\n    t && this.code(t).endFor();\n    return this;\n  }\n  for(e, t) {\n    return this._for(new w(e), t);\n  }\n  forRange(e, t, n, r, i = this.opts.es5 ? o.varKinds.var : o.varKinds.let) {\n    const s = this._scope.toName(e);\n    return this._for(new x(i, s, t, n), () => r(s));\n  }\n  forOf(e, t, n, i = o.varKinds.const) {\n    const s = this._scope.toName(e);\n    if (this.opts.es5) {\n      const e = t instanceof r.Name ? t : this.var(\"_arr\", t);\n      return this.forRange(\"_i\", 0, r._`${e}.length`, t => {\n        this.var(s, r._`${e}[${t}]`);\n        n(s);\n      });\n    }\n    return this._for(new E(\"of\", i, s, t), () => n(s));\n  }\n  forIn(e, t, n, i = this.opts.es5 ? o.varKinds.var : o.varKinds.const) {\n    if (this.opts.ownProperties) return this.forOf(e, r._`Object.keys(${t})`, n);\n    const s = this._scope.toName(e);\n    return this._for(new E(\"in\", i, s, t), () => n(s));\n  }\n  endFor() {\n    return this._endBlockNode(b);\n  }\n  label(e) {\n    return this._leafNode(new d(e));\n  }\n  break(e) {\n    return this._leafNode(new p(e));\n  }\n  return(e) {\n    const t = new S();\n    this._blockNode(t);\n    this.code(e);\n    if (1 !== t.nodes.length) throw new Error('CodeGen: \"return\" should have one node');\n    return this._endBlockNode(S);\n  }\n  try(e, t, n) {\n    if (!t && !n) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n    const r = new T();\n    this._blockNode(r);\n    this.code(e);\n    if (t) {\n      const e = this.name(\"e\");\n      this._currNode = r.catch = new k(e), t(e);\n    }\n    n && (this._currNode = r.finally = new I(), this.code(n));\n    return this._endBlockNode(k, I);\n  }\n  throw(e) {\n    return this._leafNode(new h(e));\n  }\n  block(e, t) {\n    this._blockStarts.push(this._nodes.length);\n    e && this.code(e).endBlock(t);\n    return this;\n  }\n  endBlock(e) {\n    const t = this._blockStarts.pop();\n    if (undefined === t) throw new Error(\"CodeGen: not in self-balancing block\");\n    const n = this._nodes.length - t;\n    if (n < 0 || undefined !== e && n !== e) throw new Error(`CodeGen: wrong number of nodes: ${n} vs ${e} expected`);\n    this._nodes.length = t;\n    return this;\n  }\n  func(e, t = r.nil, n, o) {\n    this._blockNode(new C(e, t, n));\n    o && this.code(o).endFunc();\n    return this;\n  }\n  endFunc() {\n    return this._endBlockNode(C);\n  }\n  optimize(e = 1) {\n    for (; e-- > 0;) {\n      this._root.optimizeNodes();\n      this._root.optimizeNames(this._root.names, this._constants);\n    }\n  }\n  _leafNode(e) {\n    this._currNode.nodes.push(e);\n    return this;\n  }\n  _blockNode(e) {\n    this._currNode.nodes.push(e);\n    this._nodes.push(e);\n  }\n  _endBlockNode(e, t) {\n    const n = this._currNode;\n    if (n instanceof e || t && n instanceof t) {\n      this._nodes.pop();\n      return this;\n    }\n    throw new Error(`CodeGen: not in block \"${t ? `${e.kind}/${t.kind}` : e.kind}\"`);\n  }\n  _elseNode(e) {\n    const t = this._currNode;\n    if (!(t instanceof v)) throw new Error('CodeGen: \"else\" without \"if\"');\n    this._currNode = t.else = e;\n    return this;\n  }\n  get _root() {\n    return this._nodes[0];\n  }\n  get _currNode() {\n    const e = this._nodes;\n    return e[e.length - 1];\n  }\n  set _currNode(e) {\n    const t = this._nodes;\n    t[t.length - 1] = e;\n  }\n};\nexports.not = not;\nconst M = $(exports.operators.AND);\nexports.and = function (...e) {\n  return e.reduce(M);\n};\nconst L = $(exports.operators.OR);\nfunction $(e) {\n  return (t, n) => t === r.nil ? n : n === r.nil ? t : r._`${D(t)} ${e} ${D(n)}`;\n}\nfunction D(e) {\n  return e instanceof r.Name ? e : r._`(${e})`;\n}\nexports.or = function (...e) {\n  return e.reduce(L);\n};",
  "3504": "var r = require(5282),\n  o = function () {\n    function e(e, t, n, r) {\n      this._buffer = [];\n      this._lastSend = 0;\n      this._isDisabled = e;\n      this._getBatchSize = t;\n      this._getBatchIntervalMs = n;\n      this._sender = r;\n    }\n    e.prototype.setUseDiskRetryCaching = function (e, t, n) {\n      this._sender.setDiskRetryMode(e, t, n);\n    };\n    e.prototype.send = function (e) {\n      var t = this;\n      if (!this._isDisabled()) if (e) {\n        var n = this._stringify(e);\n        \"string\" == typeof n && (this._buffer.push(n), this._buffer.length >= this._getBatchSize() ? this.triggerSend(!1) : !this._timeoutHandle && this._buffer.length > 0 && (this._timeoutHandle = setTimeout(function () {\n          t._timeoutHandle = null;\n          t.triggerSend(!1);\n        }, this._getBatchIntervalMs())));\n      } else r.warn(\"Cannot send null/undefined telemetry\");\n    };\n    e.prototype.triggerSend = function (e, t) {\n      var n = this._buffer.length < 1;\n      if (!n) {\n        var r = this._buffer.join(\"\\n\");\n        e ? (this._sender.saveOnCrash(r), \"function\" == typeof t && t(\"data saved on crash\")) : this._sender.send(Buffer.from ? Buffer.from(r) : new Buffer(r), t);\n      }\n      this._lastSend = +new Date();\n      this._buffer.length = 0;\n      clearTimeout(this._timeoutHandle);\n      this._timeoutHandle = null;\n      n && \"function\" == typeof t && t(\"no data to send\");\n    };\n    e.prototype._stringify = function (e) {\n      try {\n        return JSON.stringify(e);\n      } catch (t) {\n        r.warn(\"Failed to serialize payload\", t, e);\n      }\n    };\n    return e;\n  }();\nmodule.exports = o;",
  "3507": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.extractLocalImportContext = exports.getDocComment = undefined;\nconst r = require(1017),\n  o = require(464);\nfunction i(e, t) {\n  var n;\n  let o = null === (n = t.namedChild(1)) || undefined === n ? undefined : n.text.slice(1, -1);\n  if (!o || !o.startsWith(\".\")) return null;\n  if (\"\" === r.extname(o)) o += \".ts\";else if (\".ts\" !== r.extname(o)) return null;\n  return r.join(r.dirname(e), o);\n}\nfunction s(e) {\n  var t, n, r, o, i;\n  let s = [];\n  if (\"import_clause\" === (null === (t = e.namedChild(0)) || undefined === t ? undefined : t.type)) {\n    let t = e.namedChild(0);\n    if (\"named_imports\" === (null === (n = null == t ? undefined : t.namedChild(0)) || undefined === n ? undefined : n.type)) {\n      let e = t.namedChild(0);\n      for (let t of null !== (r = null == e ? undefined : e.namedChildren) && undefined !== r ? r : []) if (\"import_specifier\" === t.type) {\n        const e = null === (o = t.childForFieldName(\"name\")) || undefined === o ? undefined : o.text;\n        if (e) {\n          const n = null === (i = t.childForFieldName(\"alias\")) || undefined === i ? undefined : i.text;\n          s.push({\n            name: e,\n            alias: n\n          });\n        }\n      }\n    }\n  }\n  return s;\n}\nconst a = new Map();\nfunction c(e, t) {\n  var n, r;\n  let o = null !== (r = null === (n = null == t ? undefined : t.childForFieldName(\"name\")) || undefined === n ? undefined : n.text) && undefined !== r ? r : \"\";\n  switch (null == t ? undefined : t.type) {\n    case \"ambient_declaration\":\n      return c(e, t.namedChild(0));\n    case \"interface_declaration\":\n    case \"enum_declaration\":\n    case \"type_alias_declaration\":\n      return {\n        name: o,\n        decl: t.text\n      };\n    case \"function_declaration\":\n    case \"function_signature\":\n      return {\n        name: o,\n        decl: l(e, t)\n      };\n    case \"class_declaration\":\n      {\n        let n = function (e, t) {\n            let n = t.childForFieldName(\"body\");\n            if (n) return n.namedChildren.map(t => d(e, t)).filter(e => e);\n          }(e, t),\n          r = \"\";\n        if (n) {\n          let o = t.childForFieldName(\"body\");\n          r = `declare ${e.substring(t.startIndex, o.startIndex + 1)}`;\n          r += n.map(e => \"\\n\" + e).join(\"\");\n          r += \"\\n}\";\n        }\n        return {\n          name: o,\n          decl: r\n        };\n      }\n  }\n  return {\n    name: o,\n    decl: \"\"\n  };\n}\nfunction l(e, t) {\n  var n, r, o;\n  const i = null !== (r = null === (n = t.childForFieldName(\"return_type\")) || undefined === n ? undefined : n.endIndex) && undefined !== r ? r : null === (o = t.childForFieldName(\"parameters\")) || undefined === o ? undefined : o.endIndex;\n  if (undefined !== i) {\n    let n = e.substring(t.startIndex, i) + \";\";\n    return \"function_declaration\" === t.type || \"function_signature\" === t.type ? \"declare \" + n : n;\n  }\n  return \"\";\n}\nfunction getDocComment(e, t) {\n  const n = o.getFirstPrecedingComment(t);\n  return n ? e.substring(n.startIndex, t.startIndex) : \"\";\n}\nfunction d(e, t) {\n  var n, r, i, s, a;\n  if (\"accessibility_modifier\" === (null === (n = null == t ? undefined : t.firstChild) || undefined === n ? undefined : n.type) && \"private\" === t.firstChild.text) return \"\";\n  const c = o.getFirstPrecedingComment(t),\n    p = null !== (r = function (e, t) {\n      let n = t.startIndex - 1;\n      for (; n >= 0 && (\" \" === e[n] || \"\\t\" === e[n]);) n--;\n      if (n < 0 || \"\\n\" === e[n]) return e.substring(n + 1, t.startIndex);\n    }(e, null != c ? c : t)) && undefined !== r ? r : \"  \",\n    h = getDocComment(e, t);\n  switch (t.type) {\n    case \"ambient_declaration\":\n      const n = t.namedChild(0);\n      return n ? p + h + d(e, n) : \"\";\n    case \"method_definition\":\n    case \"method_signature\":\n      return p + h + l(e, t);\n    case \"public_field_definition\":\n      {\n        let n = null !== (s = null === (i = t.childForFieldName(\"type\")) || undefined === i ? undefined : i.endIndex) && undefined !== s ? s : null === (a = t.childForFieldName(\"name\")) || undefined === a ? undefined : a.endIndex;\n        if (undefined !== n) return p + h + e.substring(t.startIndex, n) + \";\";\n      }\n  }\n  return \"\";\n}\nasync function p(e, t, n) {\n  let r = new Map(),\n    i = -1;\n  try {\n    i = await n.mtime(e);\n  } catch {\n    return r;\n  }\n  let s = a.get(e);\n  if (s && s.mtime === i) return s.exports;\n  if (\"typescript\" === t) {\n    let i = null;\n    try {\n      let s = (await n.readFile(e)).toString();\n      i = await o.parseTree(t, s);\n      for (let e of o.queryExports(t, i.rootNode)) for (let t of e.captures) {\n        let e = t.node;\n        if (\"export_statement\" === e.type) {\n          let t = e.childForFieldName(\"declaration\");\n          if (null == t ? undefined : t.hasError()) continue;\n          let {\n            name: n,\n            decl: o\n          } = c(s, t);\n          if (n) {\n            o = getDocComment(s, e) + o;\n            let t = r.get(n);\n            t || (t = [], r.set(n, t));\n            t.push(o);\n          }\n        }\n      }\n    } catch {} finally {\n      i && i.delete();\n    }\n  }\n  if (a.size > 2e3) for (let e of a.keys()) {\n    a.delete(e);\n    if (r.size <= 1e3) break;\n  }\n  a.set(e, {\n    mtime: i,\n    exports: r\n  });\n  return r;\n}\nexports.getDocComment = getDocComment;\nconst h = /^\\s*import\\s*(type|)\\s*\\{[^}]*\\}\\s*from\\s*['\"]\\./gm;\nexports.extractLocalImportContext = async function (e, t) {\n  let {\n    source: n,\n    uri: r,\n    languageId: a\n  } = e;\n  return t && \"typescript\" === a ? async function (e, t, n) {\n    let r = \"typescript\",\n      a = [];\n    const c = function (e) {\n      let t,\n        n = -1;\n      h.lastIndex = -1;\n      do {\n        t = h.exec(e);\n        t && (n = h.lastIndex + t.length);\n      } while (t);\n      if (-1 === n) return -1;\n      const r = e.indexOf(\"\\n\", n);\n      return -1 !== r ? r : e.length;\n    }(e);\n    if (-1 === c) return a;\n    e = e.substring(0, c);\n    let l = await o.parseTree(r, e);\n    try {\n      for (let e of function (e) {\n        let t = [];\n        for (let n of e.namedChildren) \"import_statement\" === n.type && t.push(n);\n        return t;\n      }(l.rootNode)) {\n        let o = i(t, e);\n        if (!o) continue;\n        let c = s(e);\n        if (0 === c.length) continue;\n        let l = await p(o, r, n);\n        for (let e of c) l.has(e.name) && a.push(...l.get(e.name));\n      }\n    } finally {\n      l.delete();\n    }\n    return a;\n  }(n, r, t) : [];\n};",
  "3510": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(4063);\nr.code = 'require(\"ajv/dist/runtime/equal\").default';\nexports.default = r;",
  "3580": "var n, r, o;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.DEFAULT_BREEZE_ENDPOINT = \"https://dc.services.visualstudio.com\";\nexports.DEFAULT_LIVEMETRICS_ENDPOINT = \"https://rt.services.visualstudio.com\";\nexports.DEFAULT_LIVEMETRICS_HOST = \"rt.services.visualstudio.com\";\n(function (e) {\n  e.COMMITTED_BYTES = \"\\\\Memory\\\\Committed Bytes\";\n  e.PROCESSOR_TIME = \"\\\\Processor(_Total)\\\\% Processor Time\";\n  e.REQUEST_RATE = \"\\\\ApplicationInsights\\\\Requests/Sec\";\n  e.REQUEST_FAILURE_RATE = \"\\\\ApplicationInsights\\\\Requests Failed/Sec\";\n  e.REQUEST_DURATION = \"\\\\ApplicationInsights\\\\Request Duration\";\n  e.DEPENDENCY_RATE = \"\\\\ApplicationInsights\\\\Dependency Calls/Sec\";\n  e.DEPENDENCY_FAILURE_RATE = \"\\\\ApplicationInsights\\\\Dependency Calls Failed/Sec\";\n  e.DEPENDENCY_DURATION = \"\\\\ApplicationInsights\\\\Dependency Call Duration\";\n  e.EXCEPTION_RATE = \"\\\\ApplicationInsights\\\\Exceptions/Sec\";\n})(n = exports.QuickPulseCounter || (exports.QuickPulseCounter = {}));\n(function (e) {\n  e.PRIVATE_BYTES = \"\\\\Process(??APP_WIN32_PROC??)\\\\Private Bytes\";\n  e.AVAILABLE_BYTES = \"\\\\Memory\\\\Available Bytes\";\n  e.PROCESSOR_TIME = \"\\\\Processor(_Total)\\\\% Processor Time\";\n  e.PROCESS_TIME = \"\\\\Process(??APP_WIN32_PROC??)\\\\% Processor Time\";\n  e.REQUEST_RATE = \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Requests/Sec\";\n  e.REQUEST_DURATION = \"\\\\ASP.NET Applications(??APP_W3SVC_PROC??)\\\\Request Execution Time\";\n})(r = exports.PerformanceCounter || (exports.PerformanceCounter = {}));\n(o = {})[r.PROCESSOR_TIME] = n.PROCESSOR_TIME;\no[r.REQUEST_RATE] = n.REQUEST_RATE;\no[r.REQUEST_DURATION] = n.REQUEST_DURATION;\no[n.COMMITTED_BYTES] = n.COMMITTED_BYTES;\no[n.REQUEST_FAILURE_RATE] = n.REQUEST_FAILURE_RATE;\no[n.DEPENDENCY_RATE] = n.DEPENDENCY_RATE;\no[n.DEPENDENCY_FAILURE_RATE] = n.DEPENDENCY_FAILURE_RATE;\no[n.DEPENDENCY_DURATION] = n.DEPENDENCY_DURATION;\no[n.EXCEPTION_RATE] = n.EXCEPTION_RATE;\nexports.PerformanceToQuickPulseCounter = o;\nexports.QuickPulseDocumentType = {\n  Event: \"Event\",\n  Exception: \"Exception\",\n  Trace: \"Trace\",\n  Metric: \"Metric\",\n  Request: \"Request\",\n  Dependency: \"RemoteDependency\",\n  Availability: \"Availability\"\n};\nexports.QuickPulseType = {\n  Event: \"EventTelemetryDocument\",\n  Exception: \"ExceptionTelemetryDocument\",\n  Trace: \"TraceTelemetryDocument\",\n  Metric: \"MetricTelemetryDocument\",\n  Request: \"RequestTelemetryDocument\",\n  Dependency: \"DependencyTelemetryDocument\",\n  Availability: \"AvailabilityTelemetryDocument\"\n};\nexports.TelemetryTypeStringToQuickPulseType = {\n  EventData: exports.QuickPulseType.Event,\n  ExceptionData: exports.QuickPulseType.Exception,\n  MessageData: exports.QuickPulseType.Trace,\n  MetricData: exports.QuickPulseType.Metric,\n  RequestData: exports.QuickPulseType.Request,\n  RemoteDependencyData: exports.QuickPulseType.Dependency,\n  AvailabilityData: exports.QuickPulseType.Availability\n};\nexports.TelemetryTypeStringToQuickPulseDocumentType = {\n  EventData: exports.QuickPulseDocumentType.Event,\n  ExceptionData: exports.QuickPulseDocumentType.Exception,\n  MessageData: exports.QuickPulseDocumentType.Trace,\n  MetricData: exports.QuickPulseDocumentType.Metric,\n  RequestData: exports.QuickPulseDocumentType.Request,\n  RemoteDependencyData: exports.QuickPulseDocumentType.Dependency,\n  AvailabilityData: exports.QuickPulseDocumentType.Availability\n};",
  "3615": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.AnsiX923 = {\n  pad: function (e, t) {\n    var n = e.sigBytes,\n      r = 4 * t,\n      o = r - n % r,\n      i = n + o - 1;\n    e.clamp();\n    e.words[i >>> 2] |= o << 24 - i % 4 * 8;\n    e.sigBytes += o;\n  },\n  unpad: function (e) {\n    var t = 255 & e.words[e.sigBytes - 1 >>> 2];\n    e.sigBytes -= t;\n  }\n};\nmodule.exports = r.pad.Ansix923;",
  "3668": "var r = require(5282),\n  o = require(9253),\n  i = require(7148),\n  s = require(9184),\n  a = require(3580),\n  c = require(4470),\n  l = function () {\n    function e(e, t) {\n      this._isCollectingData = !1;\n      this._lastSuccessTime = Date.now();\n      this._lastSendSucceeded = !0;\n      this._metrics = {};\n      this._documents = [];\n      this._collectors = [];\n      this.config = new o(e);\n      this.context = t || new c();\n      this._sender = new s(this.config);\n      this._isEnabled = !1;\n    }\n    e.prototype.addCollector = function (e) {\n      this._collectors.push(e);\n    };\n    e.prototype.trackMetric = function (e) {\n      this._addMetric(e);\n    };\n    e.prototype.addDocument = function (e) {\n      var t = i.telemetryEnvelopeToQuickPulseDocument(e);\n      t && this._documents.push(t);\n    };\n    e.prototype.enable = function (e) {\n      e && !this._isEnabled ? (this._isEnabled = !0, this._goQuickPulse()) : !e && this._isEnabled && (this._isEnabled = !1, clearTimeout(this._handle), this._handle = undefined);\n    };\n    e.prototype.enableCollectors = function (e) {\n      this._collectors.forEach(function (t) {\n        t.enable(e);\n      });\n    };\n    e.prototype._addMetric = function (e) {\n      var t = e.value,\n        n = e.count || 1,\n        r = a.PerformanceToQuickPulseCounter[e.name];\n      r && (this._metrics[r] ? (this._metrics[r].Value = (this._metrics[r].Value * this._metrics[r].Weight + t * n) / (this._metrics[r].Weight + n), this._metrics[r].Weight += n) : (this._metrics[r] = i.createQuickPulseMetric(e), this._metrics[r].Name = r, this._metrics[r].Weight = 1));\n    };\n    e.prototype._resetQuickPulseBuffer = function () {\n      delete this._metrics;\n      this._metrics = {};\n      this._documents.length = 0;\n    };\n    e.prototype._goQuickPulse = function () {\n      var t = this,\n        n = Object.keys(this._metrics).map(function (e) {\n          return t._metrics[e];\n        }),\n        r = i.createQuickPulseEnvelope(n, this._documents.slice(), this.config, this.context);\n      this._resetQuickPulseBuffer();\n      this._isCollectingData ? this._post(r) : this._ping(r);\n      var o = this._isCollectingData ? e.POST_INTERVAL : e.PING_INTERVAL;\n      this._isCollectingData && Date.now() - this._lastSuccessTime >= e.MAX_POST_WAIT_TIME && !this._lastSendSucceeded ? (this._isCollectingData = !1, o = e.FALLBACK_INTERVAL) : !this._isCollectingData && Date.now() - this._lastSuccessTime >= e.MAX_PING_WAIT_TIME && !this._lastSendSucceeded && (o = e.FALLBACK_INTERVAL);\n      this._lastSendSucceeded = null;\n      this._handle = setTimeout(this._goQuickPulse.bind(this), o);\n      this._handle.unref();\n    };\n    e.prototype._ping = function (e) {\n      this._sender.ping(e, this._quickPulseDone.bind(this));\n    };\n    e.prototype._post = function (e) {\n      this._sender.post(e, this._quickPulseDone.bind(this));\n    };\n    e.prototype._quickPulseDone = function (e, t) {\n      null != e ? (this._isCollectingData !== e && (r.info(\"Live Metrics sending data\", e), this.enableCollectors(e)), this._isCollectingData = e, t && t.statusCode < 300 && t.statusCode >= 200 ? (this._lastSuccessTime = Date.now(), this._lastSendSucceeded = !0) : this._lastSendSucceeded = !1) : this._lastSendSucceeded = !1;\n    };\n    e.MAX_POST_WAIT_TIME = 2e4;\n    e.MAX_PING_WAIT_TIME = 6e4;\n    e.FALLBACK_INTERVAL = 6e4;\n    e.PING_INTERVAL = 5e3;\n    e.POST_INTERVAL = 1e3;\n    return e;\n  }();\nmodule.exports = l;",
  "3683": "class t extends Error {\n  constructor(e, t) {\n    super(e);\n    this.type = t;\n  }\n  get name() {\n    return this.constructor.name;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nmodule.exports = {\n  FetchBaseError: t,\n  FetchError: class extends t {\n    constructor(e, t, n) {\n      super(e, t);\n      n && (this.code = this.errno = n.code, this.erroredSysCall = n.syscall);\n    }\n  },\n  AbortError: class extends t {\n    constructor(e, t = \"aborted\") {\n      super(e, t);\n    }\n  }\n};",
  "3685": "module.exports = require(\"http\");",
  "3708": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"propertyNames\",\n    type: \"object\",\n    schemaType: [\"object\", \"boolean\"],\n    error: {\n      message: \"property name must be valid\",\n      params: ({\n        params: e\n      }) => r._`{propertyName: ${e.propertyName}}`\n    },\n    code(e) {\n      const {\n        gen: t,\n        schema: n,\n        data: i,\n        it: s\n      } = e;\n      if (o.alwaysValidSchema(s, n)) return;\n      const a = t.name(\"valid\");\n      t.forIn(\"key\", i, n => {\n        e.setParams({\n          propertyName: n\n        });\n        e.subschema({\n          keyword: \"propertyNames\",\n          data: n,\n          dataTypes: [\"string\"],\n          propertyName: n,\n          compositeRule: !0\n        }, a);\n        t.if(r.not(a), () => {\n          e.error(!0);\n          s.allErrors || t.break();\n        });\n      });\n      e.ok(a);\n    }\n  };\nexports.default = i;",
  "3769": "const {\n  EventEmitter: r\n} = require(2361);\nmodule.exports = () => {\n  const e = {},\n    t = new r();\n  t.setMaxListeners(0);\n  return {\n    acquire: n => new Promise(r => {\n      if (!e[n]) {\n        e[n] = !0;\n        return void r();\n      }\n      const o = i => {\n        e[n] || (e[n] = !0, t.removeListener(n, o), r(i));\n      };\n      t.on(n, o);\n    }),\n    release: (n, r) => {\n      Reflect.deleteProperty(e, n);\n      setImmediate(() => t.emit(n, r));\n    }\n  };\n};",
  "3837": "module.exports = require(\"util\");",
  "3905": "function r(e) {\n  return e && \"object\" == typeof e && \"default\" in e ? e : {\n    default: e\n  };\n}\nvar o = r(require(6008));\nconst i = (e, t) => t.some(t => t instanceof RegExp ? t.test(e) : t === e);\nconst s = (e, t = !1) => {\n  const n = /^(?:([a-z_][a-z0-9_-]{0,31})@|https?:\\/\\/)([\\w\\.\\-@]+)[\\/:]([\\~,\\.\\w,\\-,\\_,\\/]+?(?:\\.git|\\/)?)$/,\n    r = t => {\n      const n = new Error(t);\n      throw n.subject_url = e, n;\n    };\n  \"string\" == typeof e && e.trim() || r(\"Invalid url.\");\n  e.length > s.MAX_INPUT_LENGTH && r(\"Input exceeds maximum length. If needed, change the value of parseUrl.MAX_INPUT_LENGTH.\");\n  t && (\"object\" != typeof t && (t = {\n    stripHash: !1\n  }), e = function (e, t) {\n    t = {\n      defaultProtocol: \"http:\",\n      normalizeProtocol: !0,\n      forceHttp: !1,\n      forceHttps: !1,\n      stripAuthentication: !0,\n      stripHash: !1,\n      stripTextFragment: !0,\n      stripWWW: !0,\n      removeQueryParameters: [/^utm_\\w+/i],\n      removeTrailingSlash: !0,\n      removeSingleSlash: !0,\n      removeDirectoryIndex: !1,\n      sortQueryParameters: !0,\n      ...t\n    };\n    e = e.trim();\n    if (/^data:/i.test(e)) return ((e, {\n      stripHash: t\n    }) => {\n      const n = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e);\n      if (!n) throw new Error(`Invalid URL: ${e}`);\n      let {\n        type: r,\n        data: o,\n        hash: i\n      } = n.groups;\n      const s = r.split(\";\");\n      i = t ? \"\" : i;\n      let a = !1;\n      \"base64\" === s[s.length - 1] && (s.pop(), a = !0);\n      const c = (s.shift() || \"\").toLowerCase(),\n        l = [...s.map(e => {\n          let [t, n = \"\"] = e.split(\"=\").map(e => e.trim());\n          return \"charset\" === t && (n = n.toLowerCase(), \"us-ascii\" === n) ? \"\" : `${t}${n ? `=${n}` : \"\"}`;\n        }).filter(Boolean)];\n      return a && l.push(\"base64\"), (l.length > 0 || c && \"text/plain\" !== c) && l.unshift(c), `data:${l.join(\";\")},${a ? o.trim() : o}${i ? `#${i}` : \"\"}`;\n    })(e, t);\n    if (/^view-source:/i.test(e)) throw new Error(\"`view-source:` is not supported as it is a non-standard protocol\");\n    const n = e.startsWith(\"//\");\n    !n && /^\\.*\\//.test(e) || (e = e.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, t.defaultProtocol));\n    const r = new URL(e);\n    if (t.forceHttp && t.forceHttps) throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n    t.forceHttp && \"https:\" === r.protocol && (r.protocol = \"http:\");\n    t.forceHttps && \"http:\" === r.protocol && (r.protocol = \"https:\");\n    t.stripAuthentication && (r.username = \"\", r.password = \"\");\n    t.stripHash ? r.hash = \"\" : t.stripTextFragment && (r.hash = r.hash.replace(/#?:~:text.*?$/i, \"\"));\n    if (r.pathname) {\n      const e = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n      let t = 0,\n        n = \"\";\n      for (;;) {\n        const o = e.exec(r.pathname);\n        if (!o) break;\n        const i = o[0],\n          s = o.index;\n        n += r.pathname.slice(t, s).replace(/\\/{2,}/g, \"/\"), n += i, t = s + i.length;\n      }\n      n += r.pathname.slice(t, r.pathname.length).replace(/\\/{2,}/g, \"/\"), r.pathname = n;\n    }\n    if (r.pathname) try {\n      r.pathname = decodeURI(r.pathname);\n    } catch {}\n    !0 === t.removeDirectoryIndex && (t.removeDirectoryIndex = [/^index\\.[a-z]+$/]);\n    if (Array.isArray(t.removeDirectoryIndex) && t.removeDirectoryIndex.length > 0) {\n      let e = r.pathname.split(\"/\");\n      const n = e[e.length - 1];\n      i(n, t.removeDirectoryIndex) && (e = e.slice(0, -1), r.pathname = e.slice(1).join(\"/\") + \"/\");\n    }\n    r.hostname && (r.hostname = r.hostname.replace(/\\.$/, \"\"), t.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(r.hostname) && (r.hostname = r.hostname.replace(/^www\\./, \"\")));\n    if (Array.isArray(t.removeQueryParameters)) for (const e of [...r.searchParams.keys()]) i(e, t.removeQueryParameters) && r.searchParams.delete(e);\n    !0 === t.removeQueryParameters && (r.search = \"\");\n    if (t.sortQueryParameters) {\n      r.searchParams.sort();\n      try {\n        r.search = decodeURIComponent(r.search);\n      } catch {}\n    }\n    t.removeTrailingSlash && (r.pathname = r.pathname.replace(/\\/$/, \"\"));\n    const o = e;\n    e = r.toString();\n    t.removeSingleSlash || \"/\" !== r.pathname || o.endsWith(\"/\") || \"\" !== r.hash || (e = e.replace(/\\/$/, \"\"));\n    (t.removeTrailingSlash || \"/\" === r.pathname) && \"\" === r.hash && t.removeSingleSlash && (e = e.replace(/\\/$/, \"\"));\n    n && !t.normalizeProtocol && (e = e.replace(/^http:\\/\\//, \"//\"));\n    t.stripProtocol && (e = e.replace(/^(?:https?:)?\\/\\//, \"\"));\n    return e;\n  }(e, t));\n  const a = o.default(e);\n  if (a.parse_failed) {\n    const e = a.href.match(n);\n    e ? (a.protocols = [\"ssh\"], a.protocol = \"ssh\", a.resource = e[2], a.host = e[2], a.user = e[1], a.pathname = `/${e[3]}`, a.parse_failed = !1) : r(\"URL parsing failed.\");\n  }\n  return a;\n};\ns.MAX_INPUT_LENGTH = 2048;\nmodule.exports = s;",
  "3924": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(5684),\n  o = require(2649),\n  i = require(8200),\n  s = require(9502),\n  a = require(6167),\n  c = [r.default, o.default, i.default(), s.default, a.metadataVocabulary, a.contentVocabulary];\nexports.default = c;",
  "3964": "const r = require(3837),\n  o = require(9491),\n  i = require(9867),\n  s = require(852),\n  a = \"error@context\",\n  c = process.env.DEBUG_CLS_HOOKED;\nlet l = -1;\nfunction u(e) {\n  this.name = e;\n  this.active = null;\n  this._set = [];\n  this.id = null;\n  this._contexts = new Map();\n  this._indent = 0;\n}\nfunction d(e) {\n  return process.namespaces[e];\n}\nfunction p(e) {\n  let t = d(e);\n  o.ok(t, \"can't delete nonexistent namespace! \\\"\" + e + '\"');\n  o.ok(t.id, \"don't assign to process.namespaces directly! \" + r.inspect(t));\n  process.namespaces[e] = null;\n}\nfunction h(...e) {\n  c && process._rawDebug(`${r.format(...e)}`);\n}\nmodule.exports = {\n  getNamespace: d,\n  createNamespace: function (e) {\n    o.ok(e, \"namespace must be given a name.\");\n    c && h(`NS-CREATING NAMESPACE (${e})`);\n    let t = new u(e);\n    t.id = l;\n    s.createHook({\n      init(n, o, i, a) {\n        l = s.executionAsyncId();\n        if (t.active) {\n          if (t._contexts.set(n, t.active), c) {\n            h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}INIT [${o}] (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(t.active, {\n              showHidden: !0,\n              depth: 2,\n              colors: !0\n            })} resource:${a}`);\n          }\n        } else if (0 === l) {\n          const i = s.triggerAsyncId(),\n            u = t._contexts.get(i);\n          if (u) {\n            if (t._contexts.set(n, u), c) {\n              h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}INIT USING CONTEXT FROM TRIGGERID [${o}] (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(t.active, {\n                showHidden: !0,\n                depth: 2,\n                colors: !0\n              })} resource:${a}`);\n            }\n          } else if (c) {\n            h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}INIT MISSING CONTEXT [${o}] (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(t.active, {\n              showHidden: !0,\n              depth: 2,\n              colors: !0\n            })} resource:${a}`);\n          }\n        }\n        if (c && \"PROMISE\" === o) {\n          h(r.inspect(a, {\n            showHidden: !0\n          }));\n          const s = a.parentId;\n          h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}INIT RESOURCE-PROMISE [${o}] (${e}) parentId:${s} asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(t.active, {\n            showHidden: !0,\n            depth: 2,\n            colors: !0\n          })} resource:${a}`);\n        }\n      },\n      before(n) {\n        let o;\n        l = s.executionAsyncId();\n        o = t._contexts.get(n) || t._contexts.get(l);\n        if (o) {\n          if (c) {\n            const i = s.triggerAsyncId();\n            h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}BEFORE (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(t.active, {\n              showHidden: !0,\n              depth: 2,\n              colors: !0\n            })} context:${r.inspect(o)}`), t._indent += 2;\n          }\n          t.enter(o);\n        } else if (c) {\n          const o = s.triggerAsyncId();\n          h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}BEFORE MISSING CONTEXT (${e}) asyncId:${n} currentUid:${l} triggerId:${o} active:${r.inspect(t.active, {\n            showHidden: !0,\n            depth: 2,\n            colors: !0\n          })} namespace._contexts:${r.inspect(t._contexts, {\n            showHidden: !0,\n            depth: 2,\n            colors: !0\n          })}`), t._indent += 2;\n        }\n      },\n      after(n) {\n        let o;\n        l = s.executionAsyncId();\n        o = t._contexts.get(n) || t._contexts.get(l);\n        if (o) {\n          if (c) {\n            const i = s.triggerAsyncId();\n            t._indent -= 2;\n            h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}AFTER (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(t.active, {\n              showHidden: !0,\n              depth: 2,\n              colors: !0\n            })} context:${r.inspect(o)}`);\n          }\n          t.exit(o);\n        } else if (c) {\n          const i = s.triggerAsyncId();\n          t._indent -= 2;\n          h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}AFTER MISSING CONTEXT (${e}) asyncId:${n} currentUid:${l} triggerId:${i} active:${r.inspect(t.active, {\n            showHidden: !0,\n            depth: 2,\n            colors: !0\n          })} context:${r.inspect(o)}`);\n        }\n      },\n      destroy(n) {\n        l = s.executionAsyncId();\n        if (c) {\n          const o = s.triggerAsyncId();\n          h(`${\" \".repeat(t._indent < 0 ? 0 : t._indent)}DESTROY (${e}) currentUid:${l} asyncId:${n} triggerId:${o} active:${r.inspect(t.active, {\n            showHidden: !0,\n            depth: 2,\n            colors: !0\n          })} context:${r.inspect(t._contexts.get(l))}`);\n        }\n        t._contexts.delete(n);\n      }\n    }).enable();\n    process.namespaces[e] = t;\n    return t;\n  },\n  destroyNamespace: p,\n  reset: function () {\n    process.namespaces && Object.keys(process.namespaces).forEach(function (e) {\n      p(e);\n    });\n    process.namespaces = Object.create(null);\n  },\n  ERROR_SYMBOL: a\n};\nu.prototype.set = function (e, t) {\n  if (!this.active) throw new Error(\"No context available. ns.run() or ns.bind() must be called first.\");\n  this.active[e] = t;\n  c && h(\" \".repeat(this._indent < 0 ? 0 : this._indent) + \"CONTEXT-SET KEY:\" + e + \"=\" + t + \" in ns:\" + this.name + \" currentUid:\" + l + \" active:\" + r.inspect(this.active, {\n    showHidden: !0,\n    depth: 2,\n    colors: !0\n  }));\n  return t;\n};\nu.prototype.get = function (e) {\n  if (this.active) {\n    if (c) {\n      const t = s.executionAsyncId(),\n        n = s.triggerAsyncId(),\n        o = \" \".repeat(this._indent < 0 ? 0 : this._indent);\n      h(o + \"CONTEXT-GETTING KEY:\" + e + \"=\" + this.active[e] + \" (\" + this.name + \") currentUid:\" + l + \" active:\" + r.inspect(this.active, {\n        showHidden: !0,\n        depth: 2,\n        colors: !0\n      }));\n      h(`${o}CONTEXT-GETTING KEY: (${this.name}) ${e}=${this.active[e]} currentUid:${l} asyncHooksCurrentId:${t} triggerId:${n} len:${this._set.length} active:${r.inspect(this.active)}`);\n    }\n    return this.active[e];\n  }\n  if (c) {\n    const t = s.currentId(),\n      n = s.triggerAsyncId();\n    h(`${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-GETTING KEY NO ACTIVE NS: (${this.name}) ${e}=undefined currentUid:${l} asyncHooksCurrentId:${t} triggerId:${n} len:${this._set.length}`);\n  }\n};\nu.prototype.createContext = function () {\n  let e = Object.create(this.active ? this.active : Object.prototype);\n  e._ns_name = this.name;\n  e.id = l;\n  if (c) {\n    const t = s.executionAsyncId(),\n      n = s.triggerAsyncId();\n    h(`${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-CREATED Context: (${this.name}) currentUid:${l} asyncHooksCurrentId:${t} triggerId:${n} len:${this._set.length} context:${r.inspect(e, {\n      showHidden: !0,\n      depth: 2,\n      colors: !0\n    })}`);\n  }\n  return e;\n};\nu.prototype.run = function (e) {\n  let t = this.createContext();\n  this.enter(t);\n  try {\n    if (c) {\n      const e = s.triggerAsyncId(),\n        n = s.executionAsyncId();\n      h(`${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-RUN BEGIN: (${this.name}) currentUid:${l} triggerId:${e} asyncHooksCurrentId:${n} len:${this._set.length} context:${r.inspect(t)}`);\n    }\n    e(t);\n    return t;\n  } catch (e) {\n    throw e && (e[a] = t), e;\n  } finally {\n    if (c) {\n      const e = s.triggerAsyncId(),\n        n = s.executionAsyncId();\n      h(`${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-RUN END: (${this.name}) currentUid:${l} triggerId:${e} asyncHooksCurrentId:${n} len:${this._set.length} ${r.inspect(t)}`);\n    }\n    this.exit(t);\n  }\n};\nu.prototype.runAndReturn = function (e) {\n  let t;\n  this.run(function (n) {\n    t = e(n);\n  });\n  return t;\n};\nu.prototype.runPromise = function (e) {\n  let t = this.createContext();\n  this.enter(t);\n  let n = e(t);\n  if (!n || !n.then || !n.catch) throw new Error(\"fn must return a promise.\");\n  c && h(\"CONTEXT-runPromise BEFORE: (\" + this.name + \") currentUid:\" + l + \" len:\" + this._set.length + \" \" + r.inspect(t));\n  return n.then(e => (c && h(\"CONTEXT-runPromise AFTER then: (\" + this.name + \") currentUid:\" + l + \" len:\" + this._set.length + \" \" + r.inspect(t)), this.exit(t), e)).catch(e => {\n    throw e[a] = t, c && h(\"CONTEXT-runPromise AFTER catch: (\" + this.name + \") currentUid:\" + l + \" len:\" + this._set.length + \" \" + r.inspect(t)), this.exit(t), e;\n  });\n};\nu.prototype.bind = function (e, t) {\n  t || (t = this.active ? this.active : this.createContext());\n  let n = this;\n  return function () {\n    n.enter(t);\n    try {\n      return e.apply(this, arguments);\n    } catch (e) {\n      throw e && (e[a] = t), e;\n    } finally {\n      n.exit(t);\n    }\n  };\n};\nu.prototype.enter = function (e) {\n  o.ok(e, \"context must be provided for entering\");\n  if (c) {\n    const t = s.executionAsyncId(),\n      n = s.triggerAsyncId();\n    h(`${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-ENTER: (${this.name}) currentUid:${l} triggerId:${n} asyncHooksCurrentId:${t} len:${this._set.length} ${r.inspect(e)}`);\n  }\n  this._set.push(this.active);\n  this.active = e;\n};\nu.prototype.exit = function (e) {\n  o.ok(e, \"context must be provided for exiting\");\n  if (c) {\n    const t = s.executionAsyncId(),\n      n = s.triggerAsyncId();\n    h(`${\" \".repeat(this._indent < 0 ? 0 : this._indent)}CONTEXT-EXIT: (${this.name}) currentUid:${l} triggerId:${n} asyncHooksCurrentId:${t} len:${this._set.length} ${r.inspect(e)}`);\n  }\n  if (this.active === e) {\n    o.ok(this._set.length, \"can't remove top context\");\n    return void (this.active = this._set.pop());\n  }\n  let t = this._set.lastIndexOf(e);\n  t < 0 ? (c && h(\"??ERROR?? context exiting but not entered - ignoring: \" + r.inspect(e)), o.ok(t >= 0, \"context not currently entered; can't exit. \\n\" + r.inspect(this) + \"\\n\" + r.inspect(e))) : (o.ok(t, \"can't remove top context\"), this._set.splice(t, 1));\n};\nu.prototype.bindEmitter = function (e) {\n  o.ok(e.on && e.addListener && e.emit, \"can only bind real EEs\");\n  let t = this,\n    n = \"context@\" + this.name;\n  i(e, function (e) {\n    e && (e[\"cls@contexts\"] || (e[\"cls@contexts\"] = Object.create(null)), e[\"cls@contexts\"][n] = {\n      namespace: t,\n      context: t.active\n    });\n  }, function (e) {\n    if (!e || !e[\"cls@contexts\"]) return e;\n    let t = e,\n      n = e[\"cls@contexts\"];\n    Object.keys(n).forEach(function (e) {\n      let r = n[e];\n      t = r.namespace.bind(t, r.context);\n    });\n    return t;\n  });\n};\nu.prototype.fromException = function (e) {\n  return e[a];\n};\nprocess.namespaces = {};",
  "3974": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib.StreamCipher,\n    n = e.algo,\n    o = [],\n    i = [],\n    s = [],\n    a = n.RabbitLegacy = t.extend({\n      _doReset: function () {\n        var e = this._key.words,\n          t = this.cfg.iv,\n          n = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16],\n          r = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]];\n        this._b = 0;\n        for (var o = 0; o < 4; o++) c.call(this);\n        for (o = 0; o < 8; o++) r[o] ^= n[o + 4 & 7];\n        if (t) {\n          var i = t.words,\n            s = i[0],\n            a = i[1],\n            l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8),\n            u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),\n            d = l >>> 16 | 4294901760 & u,\n            p = u << 16 | 65535 & l;\n          for (r[0] ^= l, r[1] ^= d, r[2] ^= u, r[3] ^= p, r[4] ^= l, r[5] ^= d, r[6] ^= u, r[7] ^= p, o = 0; o < 4; o++) c.call(this);\n        }\n      },\n      _doProcessBlock: function (e, t) {\n        var n = this._X;\n        c.call(this);\n        o[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16;\n        o[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16;\n        o[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16;\n        o[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16;\n        for (var r = 0; r < 4; r++) {\n          o[r] = 16711935 & (o[r] << 8 | o[r] >>> 24) | 4278255360 & (o[r] << 24 | o[r] >>> 8);\n          e[t + r] ^= o[r];\n        }\n      },\n      blockSize: 4,\n      ivSize: 2\n    });\n  function c() {\n    for (var e = this._X, t = this._C, n = 0; n < 8; n++) i[n] = t[n];\n    for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < i[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < i[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < i[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < i[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < i[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < i[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < i[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < i[7] >>> 0 ? 1 : 0, n = 0; n < 8; n++) {\n      var r = e[n] + t[n],\n        o = 65535 & r,\n        a = r >>> 16,\n        c = ((o * o >>> 17) + o * a >>> 15) + a * a,\n        l = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);\n      s[n] = c ^ l;\n    }\n    e[0] = s[0] + (s[7] << 16 | s[7] >>> 16) + (s[6] << 16 | s[6] >>> 16) | 0;\n    e[1] = s[1] + (s[0] << 8 | s[0] >>> 24) + s[7] | 0;\n    e[2] = s[2] + (s[1] << 16 | s[1] >>> 16) + (s[0] << 16 | s[0] >>> 16) | 0;\n    e[3] = s[3] + (s[2] << 8 | s[2] >>> 24) + s[1] | 0;\n    e[4] = s[4] + (s[3] << 16 | s[3] >>> 16) + (s[2] << 16 | s[2] >>> 16) | 0;\n    e[5] = s[5] + (s[4] << 8 | s[4] >>> 24) + s[3] | 0;\n    e[6] = s[6] + (s[5] << 16 | s[5] >>> 16) + (s[4] << 16 | s[4] >>> 16) | 0;\n    e[7] = s[7] + (s[6] << 8 | s[6] >>> 24) + s[5] | 0;\n  }\n  e.RabbitLegacy = t._createHelper(a);\n})();\nmodule.exports = r.RabbitLegacy;",
  "3983": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = r.operators,\n  i = {\n    maximum: {\n      okStr: \"<=\",\n      ok: o.LTE,\n      fail: o.GT\n    },\n    minimum: {\n      okStr: \">=\",\n      ok: o.GTE,\n      fail: o.LT\n    },\n    exclusiveMaximum: {\n      okStr: \"<\",\n      ok: o.LT,\n      fail: o.GTE\n    },\n    exclusiveMinimum: {\n      okStr: \">\",\n      ok: o.GT,\n      fail: o.LTE\n    }\n  },\n  s = {\n    message: ({\n      keyword: e,\n      schemaCode: t\n    }) => r.str`must be ${i[e].okStr} ${t}`,\n    params: ({\n      keyword: e,\n      schemaCode: t\n    }) => r._`{comparison: ${i[e].okStr}, limit: ${t}}`\n  },\n  a = {\n    keyword: Object.keys(i),\n    type: \"number\",\n    schemaType: \"number\",\n    $data: !0,\n    error: s,\n    code(e) {\n      const {\n        keyword: t,\n        data: n,\n        schemaCode: o\n      } = e;\n      e.fail$data(r._`${n} ${i[t].fail} ${o} || isNaN(${n})`);\n    }\n  };\nexports.default = a;",
  "4014": "var n;\nexports = module.exports = SemVer;\nn = \"object\" == typeof process && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? function () {\n  var e = Array.prototype.slice.call(arguments, 0);\n  e.unshift(\"SEMVER\");\n  console.log.apply(console, e);\n} : function () {};\nexports.SEMVER_SPEC_VERSION = \"2.0.0\";\nvar r = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  o = exports.re = [],\n  i = exports.src = [],\n  s = 0,\n  a = s++;\ni[a] = \"0|[1-9]\\\\d*\";\nvar c = s++;\ni[c] = \"[0-9]+\";\nvar l = s++;\ni[l] = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";\nvar u = s++;\ni[u] = \"(\" + i[a] + \")\\\\.(\" + i[a] + \")\\\\.(\" + i[a] + \")\";\nvar d = s++;\ni[d] = \"(\" + i[c] + \")\\\\.(\" + i[c] + \")\\\\.(\" + i[c] + \")\";\nvar p = s++;\ni[p] = \"(?:\" + i[a] + \"|\" + i[l] + \")\";\nvar h = s++;\ni[h] = \"(?:\" + i[c] + \"|\" + i[l] + \")\";\nvar f = s++;\ni[f] = \"(?:-(\" + i[p] + \"(?:\\\\.\" + i[p] + \")*))\";\nvar m = s++;\ni[m] = \"(?:-?(\" + i[h] + \"(?:\\\\.\" + i[h] + \")*))\";\nvar g = s++;\ni[g] = \"[0-9A-Za-z-]+\";\nvar _ = s++;\ni[_] = \"(?:\\\\+(\" + i[g] + \"(?:\\\\.\" + i[g] + \")*))\";\nvar y = s++,\n  v = \"v?\" + i[u] + i[f] + \"?\" + i[_] + \"?\";\ni[y] = \"^\" + v + \"$\";\nvar b = \"[v=\\\\s]*\" + i[d] + i[m] + \"?\" + i[_] + \"?\",\n  w = s++;\ni[w] = \"^\" + b + \"$\";\nvar x = s++;\ni[x] = \"((?:<|>)?=?)\";\nvar E = s++;\ni[E] = i[c] + \"|x|X|\\\\*\";\nvar C = s++;\ni[C] = i[a] + \"|x|X|\\\\*\";\nvar S = s++;\ni[S] = \"[v=\\\\s]*(\" + i[C] + \")(?:\\\\.(\" + i[C] + \")(?:\\\\.(\" + i[C] + \")(?:\" + i[f] + \")?\" + i[_] + \"?)?)?\";\nvar T = s++;\ni[T] = \"[v=\\\\s]*(\" + i[E] + \")(?:\\\\.(\" + i[E] + \")(?:\\\\.(\" + i[E] + \")(?:\" + i[m] + \")?\" + i[_] + \"?)?)?\";\nvar k = s++;\ni[k] = \"^\" + i[x] + \"\\\\s*\" + i[S] + \"$\";\nvar I = s++;\ni[I] = \"^\" + i[x] + \"\\\\s*\" + i[T] + \"$\";\nvar P = s++;\ni[P] = \"(?:^|[^\\\\d])(\\\\d{1,16})(?:\\\\.(\\\\d{1,16}))?(?:\\\\.(\\\\d{1,16}))?(?:$|[^\\\\d])\";\nvar A = s++;\ni[A] = \"(?:~>?)\";\nvar O = s++;\ni[O] = \"(\\\\s*)\" + i[A] + \"\\\\s+\";\no[O] = new RegExp(i[O], \"g\");\nvar N = s++;\ni[N] = \"^\" + i[A] + i[S] + \"$\";\nvar R = s++;\ni[R] = \"^\" + i[A] + i[T] + \"$\";\nvar M = s++;\ni[M] = \"(?:\\\\^)\";\nvar L = s++;\ni[L] = \"(\\\\s*)\" + i[M] + \"\\\\s+\";\no[L] = new RegExp(i[L], \"g\");\nvar $ = s++;\ni[$] = \"^\" + i[M] + i[S] + \"$\";\nvar D = s++;\ni[D] = \"^\" + i[M] + i[T] + \"$\";\nvar F = s++;\ni[F] = \"^\" + i[x] + \"\\\\s*(\" + b + \")$|^$\";\nvar j = s++;\ni[j] = \"^\" + i[x] + \"\\\\s*(\" + v + \")$|^$\";\nvar q = s++;\ni[q] = \"(\\\\s*)\" + i[x] + \"\\\\s*(\" + b + \"|\" + i[S] + \")\";\no[q] = new RegExp(i[q], \"g\");\nvar B = s++;\ni[B] = \"^\\\\s*(\" + i[S] + \")\\\\s+-\\\\s+(\" + i[S] + \")\\\\s*$\";\nvar U = s++;\ni[U] = \"^\\\\s*(\" + i[T] + \")\\\\s+-\\\\s+(\" + i[T] + \")\\\\s*$\";\nvar H = s++;\ni[H] = \"(<|>)?=?\\\\s*\\\\*\";\nfor (var z = 0; z < 35; z++) {\n  n(z, i[z]);\n  o[z] || (o[z] = new RegExp(i[z]));\n}\nfunction parse(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  if (e.length > 256) return null;\n  if (!(t.loose ? o[w] : o[y]).test(e)) return null;\n  try {\n    return new SemVer(e, t);\n  } catch (e) {\n    return null;\n  }\n}\nfunction SemVer(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof SemVer) {\n    if (e.loose === t.loose) return e;\n    e = e.version;\n  } else if (\"string\" != typeof e) throw new TypeError(\"Invalid Version: \" + e);\n  if (e.length > 256) throw new TypeError(\"version is longer than 256 characters\");\n  if (!(this instanceof SemVer)) return new SemVer(e, t);\n  n(\"SemVer\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  var i = e.trim().match(t.loose ? o[w] : o[y]);\n  if (!i) throw new TypeError(\"Invalid Version: \" + e);\n  this.raw = e;\n  this.major = +i[1];\n  this.minor = +i[2];\n  this.patch = +i[3];\n  if (this.major > r || this.major < 0) throw new TypeError(\"Invalid major version\");\n  if (this.minor > r || this.minor < 0) throw new TypeError(\"Invalid minor version\");\n  if (this.patch > r || this.patch < 0) throw new TypeError(\"Invalid patch version\");\n  i[4] ? this.prerelease = i[4].split(\".\").map(function (e) {\n    if (/^[0-9]+$/.test(e)) {\n      var t = +e;\n      if (t >= 0 && t < r) return t;\n    }\n    return e;\n  }) : this.prerelease = [];\n  this.build = i[5] ? i[5].split(\".\") : [];\n  this.format();\n}\nexports.parse = parse;\nexports.valid = function (e, t) {\n  var n = parse(e, t);\n  return n ? n.version : null;\n};\nexports.clean = function (e, t) {\n  var n = parse(e.trim().replace(/^[=v]+/, \"\"), t);\n  return n ? n.version : null;\n};\nexports.SemVer = SemVer;\nSemVer.prototype.format = function () {\n  this.version = this.major + \".\" + this.minor + \".\" + this.patch;\n  this.prerelease.length && (this.version += \"-\" + this.prerelease.join(\".\"));\n  return this.version;\n};\nSemVer.prototype.toString = function () {\n  return this.version;\n};\nSemVer.prototype.compare = function (e) {\n  n(\"SemVer.compare\", this.version, this.options, e);\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  return this.compareMain(e) || this.comparePre(e);\n};\nSemVer.prototype.compareMain = function (e) {\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  return compareIdentifiers(this.major, e.major) || compareIdentifiers(this.minor, e.minor) || compareIdentifiers(this.patch, e.patch);\n};\nSemVer.prototype.comparePre = function (e) {\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  if (this.prerelease.length && !e.prerelease.length) return -1;\n  if (!this.prerelease.length && e.prerelease.length) return 1;\n  if (!this.prerelease.length && !e.prerelease.length) return 0;\n  var t = 0;\n  do {\n    var r = this.prerelease[t],\n      o = e.prerelease[t];\n    n(\"prerelease compare\", t, r, o);\n    if (void 0 === r && void 0 === o) return 0;\n    if (undefined === o) return 1;\n    if (undefined === r) return -1;\n    if (r !== o) return compareIdentifiers(r, o);\n  } while (++t);\n};\nSemVer.prototype.inc = function (e, t) {\n  switch (e) {\n    case \"premajor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc(\"pre\", t);\n      break;\n    case \"preminor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc(\"pre\", t);\n      break;\n    case \"prepatch\":\n      this.prerelease.length = 0;\n      this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"prerelease\":\n      0 === this.prerelease.length && this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"major\":\n      0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"minor\":\n      0 === this.patch && 0 !== this.prerelease.length || this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"patch\":\n      0 === this.prerelease.length && this.patch++;\n      this.prerelease = [];\n      break;\n    case \"pre\":\n      if (0 === this.prerelease.length) this.prerelease = [0];else {\n        for (var n = this.prerelease.length; --n >= 0;) \"number\" == typeof this.prerelease[n] && (this.prerelease[n]++, n = -2);\n        -1 === n && this.prerelease.push(0);\n      }\n      t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);\n      break;\n    default:\n      throw new Error(\"invalid increment argument: \" + e);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\nexports.inc = function (e, t, n, r) {\n  \"string\" == typeof n && (r = n, n = undefined);\n  try {\n    return new SemVer(e, n).inc(t, r).version;\n  } catch (e) {\n    return null;\n  }\n};\nexports.diff = function (e, t) {\n  if (eq(e, t)) return null;\n  var n = parse(e),\n    r = parse(t),\n    o = \"\";\n  if (n.prerelease.length || r.prerelease.length) {\n    o = \"pre\";\n    var i = \"prerelease\";\n  }\n  for (var s in n) if ((\"major\" === s || \"minor\" === s || \"patch\" === s) && n[s] !== r[s]) return o + s;\n  return i;\n};\nexports.compareIdentifiers = compareIdentifiers;\nvar W = /^[0-9]+$/;\nfunction compareIdentifiers(e, t) {\n  var n = W.test(e),\n    r = W.test(t);\n  n && r && (e = +e, t = +t);\n  return e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;\n}\nfunction compare(e, t, n) {\n  return new SemVer(e, n).compare(new SemVer(t, n));\n}\nfunction gt(e, t, n) {\n  return compare(e, t, n) > 0;\n}\nfunction lt(e, t, n) {\n  return compare(e, t, n) < 0;\n}\nfunction eq(e, t, n) {\n  return 0 === compare(e, t, n);\n}\nfunction neq(e, t, n) {\n  return 0 !== compare(e, t, n);\n}\nfunction ee(e, t, n) {\n  return compare(e, t, n) >= 0;\n}\nfunction te(e, t, n) {\n  return compare(e, t, n) <= 0;\n}\nfunction ne(e, t, n, r) {\n  switch (t) {\n    case \"===\":\n      \"object\" == typeof e && (e = e.version);\n      \"object\" == typeof n && (n = n.version);\n      return e === n;\n    case \"!==\":\n      \"object\" == typeof e && (e = e.version);\n      \"object\" == typeof n && (n = n.version);\n      return e !== n;\n    case \"\":\n    case \"=\":\n    case \"==\":\n      return eq(e, n, r);\n    case \"!=\":\n      return neq(e, n, r);\n    case \">\":\n      return gt(e, n, r);\n    case \">=\":\n      return ee(e, n, r);\n    case \"<\":\n      return lt(e, n, r);\n    case \"<=\":\n      return te(e, n, r);\n    default:\n      throw new TypeError(\"Invalid operator: \" + t);\n  }\n}\nfunction re(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof re) {\n    if (e.loose === !!t.loose) return e;\n    e = e.value;\n  }\n  if (!(this instanceof re)) return new re(e, t);\n  n(\"comparator\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.parse(e);\n  this.semver === oe ? this.value = \"\" : this.value = this.operator + this.semver.version;\n  n(\"comp\", this);\n}\nexports.rcompareIdentifiers = function (e, t) {\n  return compareIdentifiers(t, e);\n};\nexports.major = function (e, t) {\n  return new SemVer(e, t).major;\n};\nexports.minor = function (e, t) {\n  return new SemVer(e, t).minor;\n};\nexports.patch = function (e, t) {\n  return new SemVer(e, t).patch;\n};\nexports.compare = compare;\nexports.compareLoose = function (e, t) {\n  return compare(e, t, !0);\n};\nexports.rcompare = function (e, t, n) {\n  return compare(t, e, n);\n};\nexports.sort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.compare(e, r, n);\n  });\n};\nexports.rsort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.rcompare(e, r, n);\n  });\n};\nexports.gt = gt;\nexports.lt = lt;\nexports.eq = eq;\nexports.neq = neq;\nexports.gte = ee;\nexports.lte = te;\nexports.cmp = ne;\nexports.Comparator = re;\nvar oe = {};\nfunction ie(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof ie) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new ie(e.raw, t);\n  if (e instanceof re) return new ie(e.value, t);\n  if (!(this instanceof ie)) return new ie(e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.includePrerelease = !!t.includePrerelease;\n  this.raw = e;\n  this.set = e.split(/\\s*\\|\\|\\s*/).map(function (e) {\n    return this.parseRange(e.trim());\n  }, this).filter(function (e) {\n    return e.length;\n  });\n  if (!this.set.length) throw new TypeError(\"Invalid SemVer Range: \" + e);\n  this.format();\n}\nfunction se(e) {\n  return !e || \"x\" === e.toLowerCase() || \"*\" === e;\n}\nfunction ae(e, t, n, r, o, i, s, a, c, l, u, d, p) {\n  return ((t = se(n) ? \"\" : se(r) ? \">=\" + n + \".0.0\" : se(o) ? \">=\" + n + \".\" + r + \".0\" : \">=\" + t) + \" \" + (a = se(c) ? \"\" : se(l) ? \"<\" + (+c + 1) + \".0.0\" : se(u) ? \"<\" + c + \".\" + (+l + 1) + \".0\" : d ? \"<=\" + c + \".\" + l + \".\" + u + \"-\" + d : \"<=\" + a)).trim();\n}\nfunction ce(e, t, r) {\n  for (var o = 0; o < e.length; o++) if (!e[o].test(t)) return !1;\n  if (t.prerelease.length && !r.includePrerelease) {\n    for (o = 0; o < e.length; o++) {\n      n(e[o].semver);\n      if (e[o].semver !== oe && e[o].semver.prerelease.length > 0) {\n        var i = e[o].semver;\n        if (i.major === t.major && i.minor === t.minor && i.patch === t.patch) return !0;\n      }\n    }\n    return !1;\n  }\n  return !0;\n}\nfunction le(e, t, n) {\n  try {\n    t = new ie(t, n);\n  } catch (e) {\n    return !1;\n  }\n  return t.test(e);\n}\nfunction ue(e, t, n, r) {\n  var o, i, s, a, c;\n  switch (e = new SemVer(e, r), t = new ie(t, r), n) {\n    case \">\":\n      o = gt;\n      i = te;\n      s = lt;\n      a = \">\";\n      c = \">=\";\n      break;\n    case \"<\":\n      o = lt;\n      i = ee;\n      s = gt;\n      a = \"<\";\n      c = \"<=\";\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n  if (le(e, t, r)) return !1;\n  for (var l = 0; l < t.set.length; ++l) {\n    var u = t.set[l],\n      d = null,\n      p = null;\n    u.forEach(function (e) {\n      e.semver === oe && (e = new re(\">=0.0.0\"));\n      d = d || e;\n      p = p || e;\n      o(e.semver, d.semver, r) ? d = e : s(e.semver, p.semver, r) && (p = e);\n    });\n    if (d.operator === a || d.operator === c) return !1;\n    if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;\n    if (p.operator === c && s(e, p.semver)) return !1;\n  }\n  return !0;\n}\nre.prototype.parse = function (e) {\n  var t = this.options.loose ? o[F] : o[j],\n    n = e.match(t);\n  if (!n) throw new TypeError(\"Invalid comparator: \" + e);\n  this.operator = n[1];\n  \"=\" === this.operator && (this.operator = \"\");\n  n[2] ? this.semver = new SemVer(n[2], this.options.loose) : this.semver = oe;\n};\nre.prototype.toString = function () {\n  return this.value;\n};\nre.prototype.test = function (e) {\n  n(\"Comparator.test\", e, this.options.loose);\n  return this.semver === oe || (\"string\" == typeof e && (e = new SemVer(e, this.options)), ne(e, this.operator, this.semver, this.options));\n};\nre.prototype.intersects = function (e, t) {\n  if (!(e instanceof re)) throw new TypeError(\"a Comparator is required\");\n  var n;\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (\"\" === this.operator) return n = new ie(e.value, t), le(this.value, n, t);\n  if (\"\" === e.operator) {\n    n = new ie(this.value, t);\n    return le(e.semver, n, t);\n  }\n  var r = !(\">=\" !== this.operator && \">\" !== this.operator || \">=\" !== e.operator && \">\" !== e.operator),\n    o = !(\"<=\" !== this.operator && \"<\" !== this.operator || \"<=\" !== e.operator && \"<\" !== e.operator),\n    i = this.semver.version === e.semver.version,\n    s = !(\">=\" !== this.operator && \"<=\" !== this.operator || \">=\" !== e.operator && \"<=\" !== e.operator),\n    a = ne(this.semver, \"<\", e.semver, t) && (\">=\" === this.operator || \">\" === this.operator) && (\"<=\" === e.operator || \"<\" === e.operator),\n    c = ne(this.semver, \">\", e.semver, t) && (\"<=\" === this.operator || \"<\" === this.operator) && (\">=\" === e.operator || \">\" === e.operator);\n  return r || o || i && s || a || c;\n};\nexports.Range = ie;\nie.prototype.format = function () {\n  this.range = this.set.map(function (e) {\n    return e.join(\" \").trim();\n  }).join(\"||\").trim();\n  return this.range;\n};\nie.prototype.toString = function () {\n  return this.range;\n};\nie.prototype.parseRange = function (e) {\n  var t = this.options.loose;\n  e = e.trim();\n  var r = t ? o[U] : o[B];\n  e = e.replace(r, ae);\n  n(\"hyphen replace\", e);\n  e = e.replace(o[q], \"$1$2$3\");\n  n(\"comparator trim\", e, o[q]);\n  e = (e = (e = e.replace(o[O], \"$1~\")).replace(o[L], \"$1^\")).split(/\\s+/).join(\" \");\n  var i = t ? o[F] : o[j],\n    s = e.split(\" \").map(function (e) {\n      return function (e, t) {\n        n(\"comp\", e, t);\n        e = function (e, t) {\n          return e.trim().split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              n(\"caret\", e, t);\n              var r = t.loose ? o[D] : o[$];\n              return e.replace(r, function (t, r, o, i, s) {\n                var a;\n                n(\"caret\", e, t, r, o, i, s);\n                se(r) ? a = \"\" : se(o) ? a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\" : se(i) ? a = \"0\" === r ? \">=\" + r + \".\" + o + \".0 <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".0 <\" + (+r + 1) + \".0.0\" : s ? (n(\"replaceCaret pr\", s), a = \"0\" === r ? \"0\" === o ? \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + o + \".\" + (+i + 1) : \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + (+r + 1) + \".0.0\") : (n(\"no pr\"), a = \"0\" === r ? \"0\" === o ? \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + o + \".\" + (+i + 1) : \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".\" + i + \" <\" + (+r + 1) + \".0.0\");\n                n(\"caret return\", a);\n                return a;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"caret\", e);\n        e = function (e, t) {\n          return e.trim().split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              var r = t.loose ? o[R] : o[N];\n              return e.replace(r, function (t, r, o, i, s) {\n                var a;\n                n(\"tilde\", e, t, r, o, i, s);\n                se(r) ? a = \"\" : se(o) ? a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\" : se(i) ? a = \">=\" + r + \".\" + o + \".0 <\" + r + \".\" + (+o + 1) + \".0\" : s ? (n(\"replaceTilde pr\", s), a = \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + (+o + 1) + \".0\") : a = \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + (+o + 1) + \".0\";\n                n(\"tilde return\", a);\n                return a;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"tildes\", e);\n        e = function (e, t) {\n          n(\"replaceXRanges\", e, t);\n          return e.split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              e = e.trim();\n              var r = t.loose ? o[I] : o[k];\n              return e.replace(r, function (t, r, o, i, s, a) {\n                n(\"xRange\", e, t, r, o, i, s, a);\n                var c = se(o),\n                  l = c || se(i),\n                  u = l || se(s);\n                \"=\" === r && u && (r = \"\");\n                c ? t = \">\" === r || \"<\" === r ? \"<0.0.0\" : \"*\" : r && u ? (l && (i = 0), s = 0, \">\" === r ? (r = \">=\", l ? (o = +o + 1, i = 0, s = 0) : (i = +i + 1, s = 0)) : \"<=\" === r && (r = \"<\", l ? o = +o + 1 : i = +i + 1), t = r + o + \".\" + i + \".\" + s) : l ? t = \">=\" + o + \".0.0 <\" + (+o + 1) + \".0.0\" : u && (t = \">=\" + o + \".\" + i + \".0 <\" + o + \".\" + (+i + 1) + \".0\");\n                n(\"xRange return\", t);\n                return t;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"xrange\", e);\n        e = function (e, t) {\n          n(\"replaceStars\", e, t);\n          return e.trim().replace(o[H], \"\");\n        }(e, t);\n        n(\"stars\", e);\n        return e;\n      }(e, this.options);\n    }, this).join(\" \").split(/\\s+/);\n  this.options.loose && (s = s.filter(function (e) {\n    return !!e.match(i);\n  }));\n  return s.map(function (e) {\n    return new re(e, this.options);\n  }, this);\n};\nie.prototype.intersects = function (e, t) {\n  if (!(e instanceof ie)) throw new TypeError(\"a Range is required\");\n  return this.set.some(function (n) {\n    return n.every(function (n) {\n      return e.set.some(function (e) {\n        return e.every(function (e) {\n          return n.intersects(e, t);\n        });\n      });\n    });\n  });\n};\nexports.toComparators = function (e, t) {\n  return new ie(e, t).set.map(function (e) {\n    return e.map(function (e) {\n      return e.value;\n    }).join(\" \").trim().split(\" \");\n  });\n};\nie.prototype.test = function (e) {\n  if (!e) return !1;\n  \"string\" == typeof e && (e = new SemVer(e, this.options));\n  for (var t = 0; t < this.set.length; t++) if (ce(this.set[t], e, this.options)) return !0;\n  return !1;\n};\nexports.satisfies = le;\nexports.maxSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    i.test(e) && (r && -1 !== o.compare(e) || (o = new SemVer(r = e, n)));\n  });\n  return r;\n};\nexports.minSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    i.test(e) && (r && 1 !== o.compare(e) || (o = new SemVer(r = e, n)));\n  });\n  return r;\n};\nexports.minVersion = function (e, t) {\n  e = new ie(e, t);\n  var n = new SemVer(\"0.0.0\");\n  if (e.test(n)) return n;\n  n = new SemVer(\"0.0.0-0\");\n  if (e.test(n)) return n;\n  n = null;\n  for (var r = 0; r < e.set.length; ++r) e.set[r].forEach(function (e) {\n    var t = new SemVer(e.semver.version);\n    switch (e.operator) {\n      case \">\":\n        0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0);\n        t.raw = t.format();\n      case \"\":\n      case \">=\":\n        n && !gt(n, t) || (n = t);\n        break;\n      case \"<\":\n      case \"<=\":\n        break;\n      default:\n        throw new Error(\"Unexpected operation: \" + e.operator);\n    }\n  });\n  return n && e.test(n) ? n : null;\n};\nexports.validRange = function (e, t) {\n  try {\n    return new ie(e, t).range || \"*\";\n  } catch (e) {\n    return null;\n  }\n};\nexports.ltr = function (e, t, n) {\n  return ue(e, t, \"<\", n);\n};\nexports.gtr = function (e, t, n) {\n  return ue(e, t, \">\", n);\n};\nexports.outside = ue;\nexports.prerelease = function (e, t) {\n  var n = parse(e, t);\n  return n && n.prerelease.length ? n.prerelease : null;\n};\nexports.intersects = function (e, t, n) {\n  e = new ie(e, n);\n  t = new ie(t, n);\n  return e.intersects(t);\n};\nexports.coerce = function (e) {\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  var t = e.match(o[P]);\n  return null == t ? null : parse(t[1] + \".\" + (t[2] || \"0\") + \".\" + (t[3] || \"0\"));\n};",
  "4046": "const r = require(3837),\n  o = require(9491),\n  i = require(9867),\n  s = require(3223),\n  a = \"error@context\",\n  c = [];\nfor (let e in s.providers) c[s.providers[e]] = e;\nconst l = process.env.DEBUG_CLS_HOOKED;\nlet u = -1;\nfunction d(e) {\n  this.name = e;\n  this.active = null;\n  this._set = [];\n  this.id = null;\n  this._contexts = new Map();\n}\nfunction p(e) {\n  return process.namespaces[e];\n}\nfunction h(e) {\n  let t = p(e);\n  o.ok(t, \"can't delete nonexistent namespace! \\\"\" + e + '\"');\n  o.ok(t.id, \"don't assign to process.namespaces directly! \" + r.inspect(t));\n  process.namespaces[e] = null;\n}\nfunction f(e) {\n  process.env.DEBUG && process._rawDebug(e);\n}\nfunction m(e) {\n  return e ? \"function\" == typeof e ? e.name ? e.name : (e.toString().trim().match(/^function\\s*([^\\s(]+)/) || [])[1] : e.constructor && e.constructor.name ? e.constructor.name : undefined : e;\n}\nmodule.exports = {\n  getNamespace: p,\n  createNamespace: function (e) {\n    o.ok(e, \"namespace must be given a name.\");\n    l && f(\"CREATING NAMESPACE \" + e);\n    let t = new d(e);\n    t.id = u;\n    s.addHooks({\n      init(n, o, i, s, a) {\n        u = n;\n        s ? (t._contexts.set(n, t._contexts.get(s)), l && f(\"PARENTID: \" + e + \" uid:\" + n + \" parent:\" + s + \" provider:\" + i)) : t._contexts.set(u, t.active);\n        l && f(\"INIT \" + e + \" uid:\" + n + \" parent:\" + s + \" provider:\" + c[i] + \" active:\" + r.inspect(t.active, !0));\n      },\n      pre(n, o) {\n        u = n;\n        let i = t._contexts.get(n);\n        i ? (l && f(\" PRE \" + e + \" uid:\" + n + \" handle:\" + m(o) + \" context:\" + r.inspect(i)), t.enter(i)) : l && f(\" PRE MISSING CONTEXT \" + e + \" uid:\" + n + \" handle:\" + m(o));\n      },\n      post(n, o) {\n        u = n;\n        let i = t._contexts.get(n);\n        i ? (l && f(\" POST \" + e + \" uid:\" + n + \" handle:\" + m(o) + \" context:\" + r.inspect(i)), t.exit(i)) : l && f(\" POST MISSING CONTEXT \" + e + \" uid:\" + n + \" handle:\" + m(o));\n      },\n      destroy(n) {\n        u = n;\n        l && f(\"DESTROY \" + e + \" uid:\" + n + \" context:\" + r.inspect(t._contexts.get(u)) + \" active:\" + r.inspect(t.active, !0));\n        t._contexts.delete(n);\n      }\n    });\n    process.namespaces[e] = t;\n    return t;\n  },\n  destroyNamespace: h,\n  reset: function () {\n    process.namespaces && Object.keys(process.namespaces).forEach(function (e) {\n      h(e);\n    });\n    process.namespaces = Object.create(null);\n  },\n  ERROR_SYMBOL: a\n};\nd.prototype.set = function (e, t) {\n  if (!this.active) throw new Error(\"No context available. ns.run() or ns.bind() must be called first.\");\n  l && f(\"    SETTING KEY:\" + e + \"=\" + t + \" in ns:\" + this.name + \" uid:\" + u + \" active:\" + r.inspect(this.active, !0));\n  this.active[e] = t;\n  return t;\n};\nd.prototype.get = function (e) {\n  if (this.active) {\n    l && f(\"    GETTING KEY:\" + e + \"=\" + this.active[e] + \" \" + this.name + \" uid:\" + u + \" active:\" + r.inspect(this.active, !0));\n    return this.active[e];\n  }\n  l && f(\"    GETTING KEY:\" + e + \"=undefined \" + this.name + \" uid:\" + u + \" active:\" + r.inspect(this.active, !0));\n};\nd.prototype.createContext = function () {\n  l && f(\"   CREATING Context: \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \"  active:\" + r.inspect(this.active, !0, 2, !0));\n  let e = Object.create(this.active ? this.active : Object.prototype);\n  e._ns_name = this.name;\n  e.id = u;\n  l && f(\"   CREATED Context: \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \"  context:\" + r.inspect(e, !0, 2, !0));\n  return e;\n};\nd.prototype.run = function (e) {\n  let t = this.createContext();\n  this.enter(t);\n  try {\n    l && f(\" BEFORE RUN: \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \" \" + r.inspect(t));\n    e(t);\n    return t;\n  } catch (e) {\n    throw e && (e[a] = t), e;\n  } finally {\n    l && f(\" AFTER RUN: \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \" \" + r.inspect(t));\n    this.exit(t);\n  }\n};\nd.prototype.runAndReturn = function (e) {\n  var t;\n  this.run(function (n) {\n    t = e(n);\n  });\n  return t;\n};\nd.prototype.runPromise = function (e) {\n  let t = this.createContext();\n  this.enter(t);\n  let n = e(t);\n  if (!n || !n.then || !n.catch) throw new Error(\"fn must return a promise.\");\n  l && f(\" BEFORE runPromise: \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \" \" + r.inspect(t));\n  return n.then(e => (l && f(\" AFTER runPromise: \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \" \" + r.inspect(t)), this.exit(t), e)).catch(e => {\n    throw e[a] = t, l && f(\" AFTER runPromise: \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \" \" + r.inspect(t)), this.exit(t), e;\n  });\n};\nd.prototype.bind = function (e, t) {\n  t || (t = this.active ? this.active : this.createContext());\n  let n = this;\n  return function () {\n    n.enter(t);\n    try {\n      return e.apply(this, arguments);\n    } catch (e) {\n      throw e && (e[a] = t), e;\n    } finally {\n      n.exit(t);\n    }\n  };\n};\nd.prototype.enter = function (e) {\n  o.ok(e, \"context must be provided for entering\");\n  l && f(\"  ENTER \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \" context: \" + r.inspect(e));\n  this._set.push(this.active);\n  this.active = e;\n};\nd.prototype.exit = function (e) {\n  o.ok(e, \"context must be provided for exiting\");\n  l && f(\"  EXIT \" + this.name + \" uid:\" + u + \" len:\" + this._set.length + \" context: \" + r.inspect(e));\n  if (this.active === e) return o.ok(this._set.length, \"can't remove top context\"), void (this.active = this._set.pop());\n  let t = this._set.lastIndexOf(e);\n  t < 0 ? (l && f(\"??ERROR?? context exiting but not entered - ignoring: \" + r.inspect(e)), o.ok(t >= 0, \"context not currently entered; can't exit. \\n\" + r.inspect(this) + \"\\n\" + r.inspect(e))) : (o.ok(t, \"can't remove top context\"), this._set.splice(t, 1));\n};\nd.prototype.bindEmitter = function (e) {\n  o.ok(e.on && e.addListener && e.emit, \"can only bind real EEs\");\n  let t = this,\n    n = \"context@\" + this.name;\n  i(e, function (e) {\n    e && (e[\"cls@contexts\"] || (e[\"cls@contexts\"] = Object.create(null)), e[\"cls@contexts\"][n] = {\n      namespace: t,\n      context: t.active\n    });\n  }, function (e) {\n    if (!e || !e[\"cls@contexts\"]) return e;\n    let t = e,\n      n = e[\"cls@contexts\"];\n    Object.keys(n).forEach(function (e) {\n      let r = n[e];\n      t = r.namespace.bind(t, r.context);\n    });\n    return t;\n  });\n};\nd.prototype.fromException = function (e) {\n  return e[a];\n};\nprocess.namespaces = {};\ns._state && !s._state.enabled && s.enable();\nif (l) {\n  var g = require(2512);\n  for (var _ in g.filter._modifiers) g.filter.deattach(_);\n}",
  "4063": "module.exports = function e(t, n) {\n  if (t === n) return !0;\n  if (t && n && \"object\" == typeof t && \"object\" == typeof n) {\n    if (t.constructor !== n.constructor) return !1;\n    var r, o, i;\n    if (Array.isArray(t)) {\n      if ((r = t.length) != n.length) return !1;\n      for (o = r; 0 != o--;) if (!e(t[o], n[o])) return !1;\n      return !0;\n    }\n    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;\n    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();\n    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();\n    if ((r = (i = Object.keys(t)).length) !== Object.keys(n).length) return !1;\n    for (o = r; 0 != o--;) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;\n    for (o = r; 0 != o--;) {\n      var s = i[o];\n      if (!e(t[s], n[s])) return !1;\n    }\n    return !0;\n  }\n  return t != t && n != n;\n};",
  "4087": "var r,\n  o = undefined !== o ? o : {};\nundefined === (r = function () {\n  var t,\n    r = {};\n  for (t in o) o.hasOwnProperty(t) && (r[t] = o[t]);\n  var i,\n    s,\n    a = [],\n    c = \"./this.program\",\n    l = function (e, t) {\n      throw t;\n    },\n    u = !1,\n    d = !1;\n  u = \"object\" == typeof window;\n  d = \"function\" == typeof importScripts;\n  i = \"object\" == typeof process && \"object\" == typeof process.versions && \"string\" == typeof process.versions.node;\n  s = !u && !i && !d;\n  var p,\n    h,\n    f,\n    m,\n    g,\n    _ = \"\";\n  i ? (_ = d ? require(1017).dirname(_) + \"/\" : __dirname + \"/\", p = function (e, t) {\n    m || (m = require(7147));\n    g || (g = require(1017));\n    e = g.normalize(e);\n    return m.readFileSync(e, t ? null : \"utf8\");\n  }, f = function (e) {\n    var t = p(e, !0);\n    t.buffer || (t = new Uint8Array(t));\n    O(t.buffer);\n    return t;\n  }, process.argv.length > 1 && (c = process.argv[1].replace(/\\\\/g, \"/\")), a = process.argv.slice(2), module.exports = o, l = function (e) {\n    process.exit(e);\n  }, o.inspect = function () {\n    return \"[Emscripten Module object]\";\n  }) : s ? (\"undefined\" != typeof read && (p = function (e) {\n    return read(e);\n  }), f = function (e) {\n    var t;\n    return \"function\" == typeof readbuffer ? new Uint8Array(readbuffer(e)) : (O(\"object\" == typeof (t = read(e, \"binary\"))), t);\n  }, \"undefined\" != typeof scriptArgs ? a = scriptArgs : undefined !== arguments && (a = arguments), \"function\" == typeof quit && (l = function (e) {\n    quit(e);\n  }), \"undefined\" != typeof print && (\"undefined\" == typeof console && (console = {}), console.log = print, console.warn = console.error = \"undefined\" != typeof printErr ? printErr : print)) : (u || d) && (d ? _ = self.location.href : \"undefined\" != typeof document && document.currentScript && (_ = document.currentScript.src), _ = 0 !== _.indexOf(\"blob:\") ? _.substr(0, _.lastIndexOf(\"/\") + 1) : \"\", p = function (e) {\n    var t = new XMLHttpRequest();\n    t.open(\"GET\", e, !1);\n    t.send(null);\n    return t.responseText;\n  }, d && (f = function (e) {\n    var t = new XMLHttpRequest();\n    t.open(\"GET\", e, !1);\n    t.responseType = \"arraybuffer\";\n    t.send(null);\n    return new Uint8Array(t.response);\n  }), h = function (e, t, n) {\n    var r = new XMLHttpRequest();\n    r.open(\"GET\", e, !0);\n    r.responseType = \"arraybuffer\";\n    r.onload = function () {\n      200 == r.status || 0 == r.status && r.response ? t(r.response) : n();\n    };\n    r.onerror = n;\n    r.send(null);\n  });\n  o.print || console.log.bind(console);\n  var y = o.printErr || console.warn.bind(console);\n  for (t in r) r.hasOwnProperty(t) && (o[t] = r[t]);\n  r = null;\n  o.arguments && (a = o.arguments);\n  o.thisProgram && (c = o.thisProgram);\n  o.quit && (l = o.quit);\n  var v,\n    b = 16,\n    w = [];\n  function x(e, t) {\n    if (!v) {\n      v = new WeakMap();\n      for (var n = 0; n < J.length; n++) {\n        var r = J.get(n);\n        r && v.set(r, n);\n      }\n    }\n    if (v.has(e)) return v.get(e);\n    var o = function () {\n      if (w.length) return w.pop();\n      try {\n        J.grow(1);\n      } catch (e) {\n        if (!(e instanceof RangeError)) throw e;\n        throw \"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.\";\n      }\n      return J.length - 1;\n    }();\n    try {\n      J.set(o, e);\n    } catch (n) {\n      if (!(n instanceof TypeError)) throw n;\n      var i = function (e, t) {\n        if (\"function\" == typeof WebAssembly.Function) {\n          for (var n = {\n              i: \"i32\",\n              j: \"i64\",\n              f: \"f32\",\n              d: \"f64\"\n            }, r = {\n              parameters: [],\n              results: \"v\" == t[0] ? [] : [n[t[0]]]\n            }, o = 1; o < t.length; ++o) r.parameters.push(n[t[o]]);\n          return new WebAssembly.Function(r, e);\n        }\n        var i = [1, 0, 1, 96],\n          s = t.slice(0, 1),\n          a = t.slice(1),\n          c = {\n            i: 127,\n            j: 126,\n            f: 125,\n            d: 124\n          };\n        for (i.push(a.length), o = 0; o < a.length; ++o) i.push(c[a[o]]);\n        \"v\" == s ? i.push(0) : i = i.concat([1, c[s]]);\n        i[1] = i.length - 2;\n        var l = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(i, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0])),\n          u = new WebAssembly.Module(l);\n        return new WebAssembly.Instance(u, {\n          e: {\n            f: e\n          }\n        }).exports.f;\n      }(e, t);\n      J.set(o, i);\n    }\n    v.set(e, o);\n    return o;\n  }\n  var E,\n    C = function (e) {},\n    S = o.dynamicLibraries || [];\n  o.wasmBinary && (E = o.wasmBinary);\n  var T,\n    k = o.noExitRuntime || !0;\n  function I(e, t, n, r) {\n    switch (\"*\" === (n = n || \"i8\").charAt(n.length - 1) && (n = \"i32\"), n) {\n      case \"i1\":\n      case \"i8\":\n        R[e >> 0] = t;\n        break;\n      case \"i16\":\n        L[e >> 1] = t;\n        break;\n      case \"i32\":\n        $[e >> 2] = t;\n        break;\n      case \"i64\":\n        pe = [t >>> 0, (de = t, +Math.abs(de) >= 1 ? de > 0 ? (0 | Math.min(+Math.floor(de / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((de - +(~~de >>> 0)) / 4294967296) >>> 0 : 0)];\n        $[e >> 2] = pe[0];\n        $[e + 4 >> 2] = pe[1];\n        break;\n      case \"float\":\n        D[e >> 2] = t;\n        break;\n      case \"double\":\n        F[e >> 3] = t;\n        break;\n      default:\n        se(\"invalid type for setValue: \" + n);\n    }\n  }\n  function P(e, t, n) {\n    switch (\"*\" === (t = t || \"i8\").charAt(t.length - 1) && (t = \"i32\"), t) {\n      case \"i1\":\n      case \"i8\":\n        return R[e >> 0];\n      case \"i16\":\n        return L[e >> 1];\n      case \"i32\":\n      case \"i64\":\n        return $[e >> 2];\n      case \"float\":\n        return D[e >> 2];\n      case \"double\":\n        return F[e >> 3];\n      default:\n        se(\"invalid type for getValue: \" + t);\n    }\n    return null;\n  }\n  \"object\" != typeof WebAssembly && se(\"no native wasm support detected\");\n  var A = !1;\n  function O(e, t) {\n    e || se(\"Assertion failed: \" + t);\n  }\n  var N,\n    R,\n    M,\n    L,\n    $,\n    D,\n    F,\n    j = 1,\n    q = \"undefined\" != typeof TextDecoder ? new TextDecoder(\"utf8\") : undefined;\n  function B(e, t, n) {\n    for (var r = t + n, o = t; e[o] && !(o >= r);) ++o;\n    if (o - t > 16 && e.subarray && q) return q.decode(e.subarray(t, o));\n    for (var i = \"\"; t < o;) {\n      var s = e[t++];\n      if (128 & s) {\n        var a = 63 & e[t++];\n        if (192 != (224 & s)) {\n          var c = 63 & e[t++];\n          if ((s = 224 == (240 & s) ? (15 & s) << 12 | a << 6 | c : (7 & s) << 18 | a << 12 | c << 6 | 63 & e[t++]) < 65536) i += String.fromCharCode(s);else {\n            var l = s - 65536;\n            i += String.fromCharCode(55296 | l >> 10, 56320 | 1023 & l);\n          }\n        } else i += String.fromCharCode((31 & s) << 6 | a);\n      } else i += String.fromCharCode(s);\n    }\n    return i;\n  }\n  function U(e, t) {\n    return e ? B(M, e, t) : \"\";\n  }\n  function H(e, t, n, r) {\n    if (!(r > 0)) return 0;\n    for (var o = n, i = n + r - 1, s = 0; s < e.length; ++s) {\n      var a = e.charCodeAt(s);\n      a >= 55296 && a <= 57343 && (a = 65536 + ((1023 & a) << 10) | 1023 & e.charCodeAt(++s));\n      if (a <= 127) {\n        if (n >= i) break;\n        t[n++] = a;\n      } else if (a <= 2047) {\n        if (n + 1 >= i) break;\n        t[n++] = 192 | a >> 6, t[n++] = 128 | 63 & a;\n      } else if (a <= 65535) {\n        if (n + 2 >= i) break;\n        t[n++] = 224 | a >> 12, t[n++] = 128 | a >> 6 & 63, t[n++] = 128 | 63 & a;\n      } else {\n        if (n + 3 >= i) break;\n        t[n++] = 240 | a >> 18, t[n++] = 128 | a >> 12 & 63, t[n++] = 128 | a >> 6 & 63, t[n++] = 128 | 63 & a;\n      }\n    }\n    t[n] = 0;\n    return n - o;\n  }\n  function z(e, t, n) {\n    return H(e, M, t, n);\n  }\n  function G(e) {\n    for (var t = 0, n = 0; n < e.length; ++n) {\n      var r = e.charCodeAt(n);\n      r >= 55296 && r <= 57343 && (r = 65536 + ((1023 & r) << 10) | 1023 & e.charCodeAt(++n));\n      r <= 127 ? ++t : t += r <= 2047 ? 2 : r <= 65535 ? 3 : 4;\n    }\n    return t;\n  }\n  function V(e) {\n    var t = G(e) + 1,\n      n = Ve(t);\n    H(e, R, n, t);\n    return n;\n  }\n  function W(e) {\n    N = e;\n    o.HEAP8 = R = new Int8Array(e);\n    o.HEAP16 = L = new Int16Array(e);\n    o.HEAP32 = $ = new Int32Array(e);\n    o.HEAPU8 = M = new Uint8Array(e);\n    o.HEAPU16 = new Uint16Array(e);\n    o.HEAPU32 = new Uint32Array(e);\n    o.HEAPF32 = D = new Float32Array(e);\n    o.HEAPF64 = F = new Float64Array(e);\n  }\n  var K = o.INITIAL_MEMORY || 33554432;\n  (T = o.wasmMemory ? o.wasmMemory : new WebAssembly.Memory({\n    initial: K / 65536,\n    maximum: 32768\n  })) && (N = T.buffer);\n  K = N.byteLength;\n  W(N);\n  var J = new WebAssembly.Table({\n      initial: 13,\n      element: \"anyfunc\"\n    }),\n    X = [],\n    Q = [],\n    Y = [],\n    Z = [],\n    ee = !1,\n    te = 0,\n    ne = null,\n    re = null;\n  function oe(e) {\n    te++;\n    o.monitorRunDependencies && o.monitorRunDependencies(te);\n  }\n  function ie(e) {\n    te--;\n    o.monitorRunDependencies && o.monitorRunDependencies(te);\n    if (0 == te && (null !== ne && (clearInterval(ne), ne = null), re)) {\n      var t = re;\n      re = null, t();\n    }\n  }\n  function se(e) {\n    throw o.onAbort && o.onAbort(e), y(e += \"\"), A = !0, e = \"abort(\" + e + \"). Build with -s ASSERTIONS=1 for more info.\", new WebAssembly.RuntimeError(e);\n  }\n  o.preloadedImages = {};\n  o.preloadedAudios = {};\n  o.preloadedWasm = {};\n  var ae = \"data:application/octet-stream;base64,\";\n  function ce(e) {\n    return e.startsWith(ae);\n  }\n  function le(e) {\n    return e.startsWith(\"file://\");\n  }\n  var ue,\n    de,\n    pe,\n    he = \"tree-sitter.wasm\";\n  function fe(e) {\n    try {\n      if (e == he && E) return new Uint8Array(E);\n      if (f) return f(e);\n      throw \"both async and sync fetching of the wasm failed\";\n    } catch (e) {\n      se(e);\n    }\n  }\n  ce(he) || (ue = he, he = o.locateFile ? o.locateFile(ue, _) : _ + ue);\n  var me = {},\n    ge = {\n      get: function (e, t) {\n        me[t] || (me[t] = new WebAssembly.Global({\n          value: \"i32\",\n          mutable: !0\n        }));\n        return me[t];\n      }\n    };\n  function _e(e) {\n    for (; e.length > 0;) {\n      var t = e.shift();\n      if (\"function\" != typeof t) {\n        var n = t.func;\n        \"number\" == typeof n ? undefined === t.arg ? J.get(n)() : J.get(n)(t.arg) : n(undefined === t.arg ? null : t.arg);\n      } else t(o);\n    }\n  }\n  function ye(e) {\n    var t = 0;\n    function n() {\n      for (var n = 0, r = 1;;) {\n        var o = e[t++];\n        n += (127 & o) * r;\n        r *= 128;\n        if (!(128 & o)) break;\n      }\n      return n;\n    }\n    if (e instanceof WebAssembly.Module) {\n      var r = WebAssembly.Module.customSections(e, \"dylink\");\n      O(0 != r.length, \"need dylink section\");\n      e = new Int8Array(r[0]);\n    } else {\n      O(1836278016 == new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer)[0], \"need to see wasm magic number\");\n      O(0 === e[8], \"need the dylink section to be first\");\n      t = 9;\n      n();\n      O(6 === e[t]);\n      O(e[++t] === \"d\".charCodeAt(0));\n      O(e[++t] === \"y\".charCodeAt(0));\n      O(e[++t] === \"l\".charCodeAt(0));\n      O(e[++t] === \"i\".charCodeAt(0));\n      O(e[++t] === \"n\".charCodeAt(0));\n      O(e[++t] === \"k\".charCodeAt(0));\n      t++;\n    }\n    var o = {};\n    o.memorySize = n();\n    o.memoryAlign = n();\n    o.tableSize = n();\n    o.tableAlign = n();\n    var i = n();\n    o.neededDynlibs = [];\n    for (var s = 0; s < i; ++s) {\n      var a = n(),\n        c = e.subarray(t, t + a);\n      t += a;\n      var l = B(c, 0);\n      o.neededDynlibs.push(l);\n    }\n    return o;\n  }\n  var ve = 0;\n  function be() {\n    return k || ve > 0;\n  }\n  function we(e) {\n    return 0 == e.indexOf(\"dynCall_\") || [\"stackAlloc\", \"stackSave\", \"stackRestore\"].includes(e) ? e : \"_\" + e;\n  }\n  function xe(e, t) {\n    for (var n in e) if (e.hasOwnProperty(n)) {\n      Be.hasOwnProperty(n) || (Be[n] = e[n]);\n      var r = we(n);\n      o.hasOwnProperty(r) || (o[r] = e[n]);\n    }\n  }\n  var Ee = {\n    nextHandle: 1,\n    loadedLibs: {},\n    loadedLibNames: {}\n  };\n  function Ce(e, t, n) {\n    return e.includes(\"j\") ? function (e, t, n) {\n      var r = o[\"dynCall_\" + e];\n      return n && n.length ? r.apply(null, [t].concat(n)) : r.call(null, t);\n    }(e, t, n) : J.get(t).apply(null, n);\n  }\n  var Se = 5250816;\n  function Te(e) {\n    return [\"__cpp_exception\", \"__wasm_apply_data_relocs\", \"__dso_handle\", \"__set_stack_limits\"].includes(e);\n  }\n  function ke(e, t) {\n    var n = {};\n    for (var r in e) {\n      var o = e[r];\n      \"object\" == typeof o && (o = o.value);\n      \"number\" == typeof o && (o += t);\n      n[r] = o;\n    }\n    (function (e) {\n      for (var t in e) if (!Te(t)) {\n        var n = !1,\n          r = e[t];\n        t.startsWith(\"orig$\") && (t = t.split(\"$\")[1], n = !0);\n        me[t] || (me[t] = new WebAssembly.Global({\n          value: \"i32\",\n          mutable: !0\n        }));\n        (n || 0 == me[t].value) && (\"function\" == typeof r ? me[t].value = x(r) : \"number\" == typeof r ? me[t].value = r : y(\"unhandled export type for `\" + t + \"`: \" + typeof r));\n      }\n    })(n);\n    return n;\n  }\n  function Ie(e, t) {\n    var n, r;\n    t && (n = Be[\"orig$\" + e]);\n    n || (n = Be[e]);\n    n || (n = o[we(e)]);\n    !n && e.startsWith(\"invoke_\") && (r = e.split(\"_\")[1], n = function () {\n      var e = ze();\n      try {\n        return Ce(r, arguments[0], Array.prototype.slice.call(arguments, 1));\n      } catch (t) {\n        Ge(e);\n        if (t !== t + 0 && \"longjmp\" !== t) throw t;\n        We(1, 0);\n      }\n    });\n    return n;\n  }\n  function Pe(e, t) {\n    var n = ye(e);\n    function r() {\n      var r = Math.pow(2, n.memoryAlign);\n      r = Math.max(r, b);\n      var o,\n        i,\n        s,\n        a = (o = function (e) {\n          if (ee) return Ue(e);\n          var t = Se,\n            n = t + e + 15 & -16;\n          Se = n;\n          me.__heap_base.value = n;\n          return t;\n        }(n.memorySize + r), (i = r) || (i = b), Math.ceil(o / i) * i),\n        c = J.length;\n      J.grow(n.tableSize);\n      for (var l = a; l < a + n.memorySize; l++) R[l] = 0;\n      for (l = c; l < c + n.tableSize; l++) J.set(l, null);\n      var u = new Proxy({}, {\n          get: function (e, t) {\n            switch (t) {\n              case \"__memory_base\":\n                return a;\n              case \"__table_base\":\n                return c;\n            }\n            return t in Be ? Be[t] : (t in e || (e[t] = function () {\n              n || (n = function (e) {\n                var t = Ie(e, !1);\n                t || (t = s[e]);\n                return t;\n              }(t));\n              return n.apply(null, arguments);\n            }), e[t]);\n            var n;\n          }\n        }),\n        d = {\n          \"GOT.mem\": new Proxy({}, ge),\n          \"GOT.func\": new Proxy({}, ge),\n          env: u,\n          wasi_snapshot_preview1: u\n        };\n      function p(e) {\n        for (var r = 0; r < n.tableSize; r++) {\n          var o = J.get(c + r);\n          o && v.set(o, c + r);\n        }\n        s = ke(e.exports, a);\n        t.allowUndefined || Oe();\n        var i = s.__wasm_call_ctors;\n        i || (i = s.__post_instantiate);\n        i && (ee ? i() : Q.push(i));\n        return s;\n      }\n      if (t.loadAsync) {\n        if (e instanceof WebAssembly.Module) {\n          var h = new WebAssembly.Instance(e, d);\n          return Promise.resolve(p(h));\n        }\n        return WebAssembly.instantiate(e, d).then(function (e) {\n          return p(e.instance);\n        });\n      }\n      var f = e instanceof WebAssembly.Module ? e : new WebAssembly.Module(e);\n      return p(h = new WebAssembly.Instance(f, d));\n    }\n    return t.loadAsync ? n.neededDynlibs.reduce(function (e, n) {\n      return e.then(function () {\n        return Ae(n, t);\n      });\n    }, Promise.resolve()).then(function () {\n      return r();\n    }) : (n.neededDynlibs.forEach(function (e) {\n      Ae(e, t);\n    }), r());\n  }\n  function Ae(e, t) {\n    \"__main__\" != e || Ee.loadedLibNames[e] || (Ee.loadedLibs[-1] = {\n      refcount: 1 / 0,\n      name: \"__main__\",\n      module: o.asm,\n      global: !0\n    }, Ee.loadedLibNames.__main__ = -1);\n    t = t || {\n      global: !0,\n      nodelete: !0\n    };\n    var n,\n      r = Ee.loadedLibNames[e];\n    if (r) {\n      n = Ee.loadedLibs[r];\n      t.global && !n.global && (n.global = !0, \"loading\" !== n.module && xe(n.module));\n      t.nodelete && n.refcount !== 1 / 0 && (n.refcount = 1 / 0);\n      n.refcount++;\n      return t.loadAsync ? Promise.resolve(r) : r;\n    }\n    function i(e) {\n      if (t.fs) {\n        var n = t.fs.readFile(e, {\n          encoding: \"binary\"\n        });\n        n instanceof Uint8Array || (n = new Uint8Array(n));\n        return t.loadAsync ? Promise.resolve(n) : n;\n      }\n      return t.loadAsync ? (r = e, fetch(r, {\n        credentials: \"same-origin\"\n      }).then(function (e) {\n        if (!e.ok) throw \"failed to load binary file at '\" + r + \"'\";\n        return e.arrayBuffer();\n      }).then(function (e) {\n        return new Uint8Array(e);\n      })) : f(e);\n      var r;\n    }\n    function s() {\n      if (undefined !== o.preloadedWasm && undefined !== o.preloadedWasm[e]) {\n        var n = o.preloadedWasm[e];\n        return t.loadAsync ? Promise.resolve(n) : n;\n      }\n      return t.loadAsync ? i(e).then(function (e) {\n        return Pe(e, t);\n      }) : Pe(i(e), t);\n    }\n    function a(e) {\n      n.global && xe(e);\n      n.module = e;\n    }\n    r = Ee.nextHandle++;\n    n = {\n      refcount: t.nodelete ? 1 / 0 : 1,\n      name: e,\n      module: \"loading\",\n      global: t.global\n    };\n    Ee.loadedLibNames[e] = r;\n    Ee.loadedLibs[r] = n;\n    return t.loadAsync ? s().then(function (e) {\n      a(e);\n      return r;\n    }) : (a(s()), r);\n  }\n  function Oe() {\n    for (var e in me) if (0 == me[e].value) {\n      var t = Ie(e, !0);\n      \"function\" == typeof t ? me[e].value = x(t, t.sig) : \"number\" == typeof t ? me[e].value = t : O(!1, \"bad export type for `\" + e + \"`: \" + typeof t);\n    }\n  }\n  o.___heap_base = Se;\n  var Ne,\n    Re = new WebAssembly.Global({\n      value: \"i32\",\n      mutable: !0\n    }, 5250816);\n  function Me() {\n    se();\n  }\n  o._abort = Me;\n  Me.sig = \"v\";\n  Ne = i ? function () {\n    var e = process.hrtime();\n    return 1e3 * e[0] + e[1] / 1e6;\n  } : \"undefined\" != typeof dateNow ? dateNow : function () {\n    return performance.now();\n  };\n  var Le = !0;\n  function $e(e, t) {\n    var n;\n    if (0 === e) n = Date.now();else {\n      if (1 !== e && 4 !== e || !Le) {\n        28;\n        $[He() >> 2] = 28;\n        return -1;\n      }\n      n = Ne();\n    }\n    $[t >> 2] = n / 1e3 | 0;\n    $[t + 4 >> 2] = n % 1e3 * 1e3 * 1e3 | 0;\n    return 0;\n  }\n  function De(e) {\n    try {\n      T.grow(e - N.byteLength + 65535 >>> 16);\n      W(T.buffer);\n      return 1;\n    } catch (e) {}\n  }\n  function Fe(e) {\n    Qe(e);\n  }\n  function je(e) {\n    C(e);\n  }\n  $e.sig = \"iii\";\n  Fe.sig = \"vi\";\n  je.sig = \"vi\";\n  var qe,\n    Be = {\n      __heap_base: Se,\n      __indirect_function_table: J,\n      __memory_base: 1024,\n      __stack_pointer: Re,\n      __table_base: 1,\n      abort: Me,\n      clock_gettime: $e,\n      emscripten_memcpy_big: function (e, t, n) {\n        M.copyWithin(e, t, t + n);\n      },\n      emscripten_resize_heap: function (e) {\n        var t,\n          n = M.length;\n        if ((e >>>= 0) > 2147483648) return !1;\n        for (var r = 1; r <= 4; r *= 2) {\n          var o = n * (1 + .2 / r);\n          o = Math.min(o, e + 100663296);\n          if (De(Math.min(2147483648, ((t = Math.max(e, o)) % 65536 > 0 && (t += 65536 - t % 65536), t)))) return !0;\n        }\n        return !1;\n      },\n      exit: Fe,\n      memory: T,\n      setTempRet0: je,\n      tree_sitter_log_callback: function (e, t) {\n        if (ft) {\n          const n = U(t);\n          ft(n, 0 !== e);\n        }\n      },\n      tree_sitter_parse_callback: function (e, t, n, r, o) {\n        var i = ht(t, {\n          row: n,\n          column: r\n        });\n        \"string\" == typeof i ? (I(o, i.length, \"i32\"), function (e, t, n) {\n          undefined === n && (n = 2147483647);\n          if (n < 2) return 0;\n          for (var r = (n -= 2) < 2 * e.length ? n / 2 : e.length, o = 0; o < r; ++o) {\n            var i = e.charCodeAt(o);\n            L[t >> 1] = i;\n            t += 2;\n          }\n          L[t >> 1] = 0;\n        }(i, e, 10240)) : I(o, 0, \"i32\");\n      }\n    },\n    Ue = (function () {\n      var e = {\n        env: Be,\n        wasi_snapshot_preview1: Be,\n        \"GOT.mem\": new Proxy(Be, ge),\n        \"GOT.func\": new Proxy(Be, ge)\n      };\n      function t(e, t) {\n        var n = e.exports;\n        n = ke(n, 1024);\n        o.asm = n;\n        var r,\n          i = ye(t);\n        i.neededDynlibs && (S = i.neededDynlibs.concat(S));\n        xe(n);\n        r = o.asm.__wasm_call_ctors;\n        Q.unshift(r);\n        ie();\n      }\n      function n(e) {\n        t(e.instance, e.module);\n      }\n      function r(t) {\n        return function () {\n          if (!E && (u || d)) {\n            if (\"function\" == typeof fetch && !le(he)) return fetch(he, {\n              credentials: \"same-origin\"\n            }).then(function (e) {\n              if (!e.ok) throw \"failed to load wasm binary file at '\" + he + \"'\";\n              return e.arrayBuffer();\n            }).catch(function () {\n              return fe(he);\n            });\n            if (h) return new Promise(function (e, t) {\n              h(he, function (t) {\n                e(new Uint8Array(t));\n              }, t);\n            });\n          }\n          return Promise.resolve().then(function () {\n            return fe(he);\n          });\n        }().then(function (t) {\n          return WebAssembly.instantiate(t, e);\n        }).then(t, function (e) {\n          y(\"failed to asynchronously prepare wasm: \" + e);\n          se(e);\n        });\n      }\n      oe();\n      if (o.instantiateWasm) try {\n        return o.instantiateWasm(e, t);\n      } catch (e) {\n        return y(\"Module.instantiateWasm callback failed with error: \" + e), !1;\n      }\n      E || \"function\" != typeof WebAssembly.instantiateStreaming || ce(he) || le(he) || \"function\" != typeof fetch ? r(n) : fetch(he, {\n        credentials: \"same-origin\"\n      }).then(function (t) {\n        return WebAssembly.instantiateStreaming(t, e).then(n, function (e) {\n          y(\"wasm streaming compile failed: \" + e);\n          y(\"falling back to ArrayBuffer instantiation\");\n          return r(n);\n        });\n      });\n    }(), o.___wasm_call_ctors = function () {\n      return (o.___wasm_call_ctors = o.asm.__wasm_call_ctors).apply(null, arguments);\n    }, o._malloc = function () {\n      return (Ue = o._malloc = o.asm.malloc).apply(null, arguments);\n    }),\n    He = (o._ts_language_symbol_count = function () {\n      return (o._ts_language_symbol_count = o.asm.ts_language_symbol_count).apply(null, arguments);\n    }, o._ts_language_version = function () {\n      return (o._ts_language_version = o.asm.ts_language_version).apply(null, arguments);\n    }, o._ts_language_field_count = function () {\n      return (o._ts_language_field_count = o.asm.ts_language_field_count).apply(null, arguments);\n    }, o._ts_language_symbol_name = function () {\n      return (o._ts_language_symbol_name = o.asm.ts_language_symbol_name).apply(null, arguments);\n    }, o._ts_language_symbol_for_name = function () {\n      return (o._ts_language_symbol_for_name = o.asm.ts_language_symbol_for_name).apply(null, arguments);\n    }, o._ts_language_symbol_type = function () {\n      return (o._ts_language_symbol_type = o.asm.ts_language_symbol_type).apply(null, arguments);\n    }, o._ts_language_field_name_for_id = function () {\n      return (o._ts_language_field_name_for_id = o.asm.ts_language_field_name_for_id).apply(null, arguments);\n    }, o._memcpy = function () {\n      return (o._memcpy = o.asm.memcpy).apply(null, arguments);\n    }, o._free = function () {\n      return (o._free = o.asm.free).apply(null, arguments);\n    }, o._calloc = function () {\n      return (o._calloc = o.asm.calloc).apply(null, arguments);\n    }, o._ts_parser_delete = function () {\n      return (o._ts_parser_delete = o.asm.ts_parser_delete).apply(null, arguments);\n    }, o._ts_parser_reset = function () {\n      return (o._ts_parser_reset = o.asm.ts_parser_reset).apply(null, arguments);\n    }, o._ts_parser_set_language = function () {\n      return (o._ts_parser_set_language = o.asm.ts_parser_set_language).apply(null, arguments);\n    }, o._ts_parser_timeout_micros = function () {\n      return (o._ts_parser_timeout_micros = o.asm.ts_parser_timeout_micros).apply(null, arguments);\n    }, o._ts_parser_set_timeout_micros = function () {\n      return (o._ts_parser_set_timeout_micros = o.asm.ts_parser_set_timeout_micros).apply(null, arguments);\n    }, o._memcmp = function () {\n      return (o._memcmp = o.asm.memcmp).apply(null, arguments);\n    }, o._ts_query_new = function () {\n      return (o._ts_query_new = o.asm.ts_query_new).apply(null, arguments);\n    }, o._ts_query_delete = function () {\n      return (o._ts_query_delete = o.asm.ts_query_delete).apply(null, arguments);\n    }, o._iswspace = function () {\n      return (o._iswspace = o.asm.iswspace).apply(null, arguments);\n    }, o._iswalnum = function () {\n      return (o._iswalnum = o.asm.iswalnum).apply(null, arguments);\n    }, o._ts_query_pattern_count = function () {\n      return (o._ts_query_pattern_count = o.asm.ts_query_pattern_count).apply(null, arguments);\n    }, o._ts_query_capture_count = function () {\n      return (o._ts_query_capture_count = o.asm.ts_query_capture_count).apply(null, arguments);\n    }, o._ts_query_string_count = function () {\n      return (o._ts_query_string_count = o.asm.ts_query_string_count).apply(null, arguments);\n    }, o._ts_query_capture_name_for_id = function () {\n      return (o._ts_query_capture_name_for_id = o.asm.ts_query_capture_name_for_id).apply(null, arguments);\n    }, o._ts_query_string_value_for_id = function () {\n      return (o._ts_query_string_value_for_id = o.asm.ts_query_string_value_for_id).apply(null, arguments);\n    }, o._ts_query_predicates_for_pattern = function () {\n      return (o._ts_query_predicates_for_pattern = o.asm.ts_query_predicates_for_pattern).apply(null, arguments);\n    }, o._ts_tree_copy = function () {\n      return (o._ts_tree_copy = o.asm.ts_tree_copy).apply(null, arguments);\n    }, o._ts_tree_delete = function () {\n      return (o._ts_tree_delete = o.asm.ts_tree_delete).apply(null, arguments);\n    }, o._ts_init = function () {\n      return (o._ts_init = o.asm.ts_init).apply(null, arguments);\n    }, o._ts_parser_new_wasm = function () {\n      return (o._ts_parser_new_wasm = o.asm.ts_parser_new_wasm).apply(null, arguments);\n    }, o._ts_parser_enable_logger_wasm = function () {\n      return (o._ts_parser_enable_logger_wasm = o.asm.ts_parser_enable_logger_wasm).apply(null, arguments);\n    }, o._ts_parser_parse_wasm = function () {\n      return (o._ts_parser_parse_wasm = o.asm.ts_parser_parse_wasm).apply(null, arguments);\n    }, o._ts_language_type_is_named_wasm = function () {\n      return (o._ts_language_type_is_named_wasm = o.asm.ts_language_type_is_named_wasm).apply(null, arguments);\n    }, o._ts_language_type_is_visible_wasm = function () {\n      return (o._ts_language_type_is_visible_wasm = o.asm.ts_language_type_is_visible_wasm).apply(null, arguments);\n    }, o._ts_tree_root_node_wasm = function () {\n      return (o._ts_tree_root_node_wasm = o.asm.ts_tree_root_node_wasm).apply(null, arguments);\n    }, o._ts_tree_edit_wasm = function () {\n      return (o._ts_tree_edit_wasm = o.asm.ts_tree_edit_wasm).apply(null, arguments);\n    }, o._ts_tree_get_changed_ranges_wasm = function () {\n      return (o._ts_tree_get_changed_ranges_wasm = o.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_new_wasm = function () {\n      return (o._ts_tree_cursor_new_wasm = o.asm.ts_tree_cursor_new_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_delete_wasm = function () {\n      return (o._ts_tree_cursor_delete_wasm = o.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_reset_wasm = function () {\n      return (o._ts_tree_cursor_reset_wasm = o.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_goto_first_child_wasm = function () {\n      return (o._ts_tree_cursor_goto_first_child_wasm = o.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_goto_next_sibling_wasm = function () {\n      return (o._ts_tree_cursor_goto_next_sibling_wasm = o.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_goto_parent_wasm = function () {\n      return (o._ts_tree_cursor_goto_parent_wasm = o.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_current_node_type_id_wasm = function () {\n      return (o._ts_tree_cursor_current_node_type_id_wasm = o.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_current_node_is_named_wasm = function () {\n      return (o._ts_tree_cursor_current_node_is_named_wasm = o.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_current_node_is_missing_wasm = function () {\n      return (o._ts_tree_cursor_current_node_is_missing_wasm = o.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_current_node_id_wasm = function () {\n      return (o._ts_tree_cursor_current_node_id_wasm = o.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_start_position_wasm = function () {\n      return (o._ts_tree_cursor_start_position_wasm = o.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_end_position_wasm = function () {\n      return (o._ts_tree_cursor_end_position_wasm = o.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_start_index_wasm = function () {\n      return (o._ts_tree_cursor_start_index_wasm = o.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_end_index_wasm = function () {\n      return (o._ts_tree_cursor_end_index_wasm = o.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_current_field_id_wasm = function () {\n      return (o._ts_tree_cursor_current_field_id_wasm = o.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);\n    }, o._ts_tree_cursor_current_node_wasm = function () {\n      return (o._ts_tree_cursor_current_node_wasm = o.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);\n    }, o._ts_node_symbol_wasm = function () {\n      return (o._ts_node_symbol_wasm = o.asm.ts_node_symbol_wasm).apply(null, arguments);\n    }, o._ts_node_child_count_wasm = function () {\n      return (o._ts_node_child_count_wasm = o.asm.ts_node_child_count_wasm).apply(null, arguments);\n    }, o._ts_node_named_child_count_wasm = function () {\n      return (o._ts_node_named_child_count_wasm = o.asm.ts_node_named_child_count_wasm).apply(null, arguments);\n    }, o._ts_node_child_wasm = function () {\n      return (o._ts_node_child_wasm = o.asm.ts_node_child_wasm).apply(null, arguments);\n    }, o._ts_node_named_child_wasm = function () {\n      return (o._ts_node_named_child_wasm = o.asm.ts_node_named_child_wasm).apply(null, arguments);\n    }, o._ts_node_child_by_field_id_wasm = function () {\n      return (o._ts_node_child_by_field_id_wasm = o.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);\n    }, o._ts_node_next_sibling_wasm = function () {\n      return (o._ts_node_next_sibling_wasm = o.asm.ts_node_next_sibling_wasm).apply(null, arguments);\n    }, o._ts_node_prev_sibling_wasm = function () {\n      return (o._ts_node_prev_sibling_wasm = o.asm.ts_node_prev_sibling_wasm).apply(null, arguments);\n    }, o._ts_node_next_named_sibling_wasm = function () {\n      return (o._ts_node_next_named_sibling_wasm = o.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);\n    }, o._ts_node_prev_named_sibling_wasm = function () {\n      return (o._ts_node_prev_named_sibling_wasm = o.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);\n    }, o._ts_node_parent_wasm = function () {\n      return (o._ts_node_parent_wasm = o.asm.ts_node_parent_wasm).apply(null, arguments);\n    }, o._ts_node_descendant_for_index_wasm = function () {\n      return (o._ts_node_descendant_for_index_wasm = o.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);\n    }, o._ts_node_named_descendant_for_index_wasm = function () {\n      return (o._ts_node_named_descendant_for_index_wasm = o.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments);\n    }, o._ts_node_descendant_for_position_wasm = function () {\n      return (o._ts_node_descendant_for_position_wasm = o.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);\n    }, o._ts_node_named_descendant_for_position_wasm = function () {\n      return (o._ts_node_named_descendant_for_position_wasm = o.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments);\n    }, o._ts_node_start_point_wasm = function () {\n      return (o._ts_node_start_point_wasm = o.asm.ts_node_start_point_wasm).apply(null, arguments);\n    }, o._ts_node_end_point_wasm = function () {\n      return (o._ts_node_end_point_wasm = o.asm.ts_node_end_point_wasm).apply(null, arguments);\n    }, o._ts_node_start_index_wasm = function () {\n      return (o._ts_node_start_index_wasm = o.asm.ts_node_start_index_wasm).apply(null, arguments);\n    }, o._ts_node_end_index_wasm = function () {\n      return (o._ts_node_end_index_wasm = o.asm.ts_node_end_index_wasm).apply(null, arguments);\n    }, o._ts_node_to_string_wasm = function () {\n      return (o._ts_node_to_string_wasm = o.asm.ts_node_to_string_wasm).apply(null, arguments);\n    }, o._ts_node_children_wasm = function () {\n      return (o._ts_node_children_wasm = o.asm.ts_node_children_wasm).apply(null, arguments);\n    }, o._ts_node_named_children_wasm = function () {\n      return (o._ts_node_named_children_wasm = o.asm.ts_node_named_children_wasm).apply(null, arguments);\n    }, o._ts_node_descendants_of_type_wasm = function () {\n      return (o._ts_node_descendants_of_type_wasm = o.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);\n    }, o._ts_node_is_named_wasm = function () {\n      return (o._ts_node_is_named_wasm = o.asm.ts_node_is_named_wasm).apply(null, arguments);\n    }, o._ts_node_has_changes_wasm = function () {\n      return (o._ts_node_has_changes_wasm = o.asm.ts_node_has_changes_wasm).apply(null, arguments);\n    }, o._ts_node_has_error_wasm = function () {\n      return (o._ts_node_has_error_wasm = o.asm.ts_node_has_error_wasm).apply(null, arguments);\n    }, o._ts_node_is_missing_wasm = function () {\n      return (o._ts_node_is_missing_wasm = o.asm.ts_node_is_missing_wasm).apply(null, arguments);\n    }, o._ts_query_matches_wasm = function () {\n      return (o._ts_query_matches_wasm = o.asm.ts_query_matches_wasm).apply(null, arguments);\n    }, o._ts_query_captures_wasm = function () {\n      return (o._ts_query_captures_wasm = o.asm.ts_query_captures_wasm).apply(null, arguments);\n    }, o._iswdigit = function () {\n      return (o._iswdigit = o.asm.iswdigit).apply(null, arguments);\n    }, o._iswalpha = function () {\n      return (o._iswalpha = o.asm.iswalpha).apply(null, arguments);\n    }, o._iswlower = function () {\n      return (o._iswlower = o.asm.iswlower).apply(null, arguments);\n    }, o._towupper = function () {\n      return (o._towupper = o.asm.towupper).apply(null, arguments);\n    }, o.___errno_location = function () {\n      return (He = o.___errno_location = o.asm.__errno_location).apply(null, arguments);\n    }),\n    ze = (o._memchr = function () {\n      return (o._memchr = o.asm.memchr).apply(null, arguments);\n    }, o._strlen = function () {\n      return (o._strlen = o.asm.strlen).apply(null, arguments);\n    }, o.stackSave = function () {\n      return (ze = o.stackSave = o.asm.stackSave).apply(null, arguments);\n    }),\n    Ge = o.stackRestore = function () {\n      return (Ge = o.stackRestore = o.asm.stackRestore).apply(null, arguments);\n    },\n    Ve = o.stackAlloc = function () {\n      return (Ve = o.stackAlloc = o.asm.stackAlloc).apply(null, arguments);\n    },\n    We = o._setThrew = function () {\n      return (We = o._setThrew = o.asm.setThrew).apply(null, arguments);\n    };\n  function Ke(e) {\n    this.name = \"ExitStatus\";\n    this.message = \"Program terminated with exit(\" + e + \")\";\n    this.status = e;\n  }\n  o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function () {\n    return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments);\n  };\n  o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function () {\n    return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments);\n  };\n  o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function () {\n    return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments);\n  };\n  o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function () {\n    return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments);\n  };\n  o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function () {\n    return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments);\n  };\n  o.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function () {\n    return (o.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = o.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments);\n  };\n  o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function () {\n    return (o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = o.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments);\n  };\n  o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function () {\n    return (o.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = o.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments);\n  };\n  o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ = function () {\n    return (o.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_ = o.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEC1ERKS5_).apply(null, arguments);\n  };\n  o.__Znwm = function () {\n    return (o.__Znwm = o.asm._Znwm).apply(null, arguments);\n  };\n  o.__ZdlPv = function () {\n    return (o.__ZdlPv = o.asm._ZdlPv).apply(null, arguments);\n  };\n  o.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = function () {\n    return (o.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = o.asm._ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv).apply(null, arguments);\n  };\n  o._orig$ts_parser_timeout_micros = function () {\n    return (o._orig$ts_parser_timeout_micros = o.asm.orig$ts_parser_timeout_micros).apply(null, arguments);\n  };\n  o._orig$ts_parser_set_timeout_micros = function () {\n    return (o._orig$ts_parser_set_timeout_micros = o.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);\n  };\n  o.allocate = function (e, t) {\n    var n;\n    n = t == j ? Ve(e.length) : Ue(e.length);\n    e.subarray || e.slice ? M.set(e, n) : M.set(new Uint8Array(e), n);\n    return n;\n  };\n  re = function e() {\n    qe || Xe();\n    qe || (re = e);\n  };\n  var Je = !1;\n  function Xe(e) {\n    function t() {\n      qe || (qe = !0, o.calledRun = !0, A || (ee = !0, _e(Q), _e(Y), o.onRuntimeInitialized && o.onRuntimeInitialized(), Ye && function (e) {\n        var t = o._main;\n        if (t) {\n          var n = (e = e || []).length + 1,\n            r = Ve(4 * (n + 1));\n          $[r >> 2] = V(c);\n          for (var i = 1; i < n; i++) $[(r >> 2) + i] = V(e[i - 1]);\n          $[(r >> 2) + n] = 0;\n          try {\n            Qe(t(n, r), !0);\n          } catch (e) {\n            if (e instanceof Ke) return;\n            if (\"unwind\" == e) return;\n            var s = e;\n            e && \"object\" == typeof e && e.stack && (s = [e, e.stack]);\n            y(\"exception thrown: \" + s);\n            l(1, e);\n          }\n        }\n      }(e), function () {\n        if (o.postRun) for (\"function\" == typeof o.postRun && (o.postRun = [o.postRun]); o.postRun.length;) {\n          e = o.postRun.shift();\n          Z.unshift(e);\n        }\n        var e;\n        _e(Z);\n      }()));\n    }\n    e = e || a;\n    te > 0 || !Je && (function () {\n      if (S.length) {\n        if (!f) {\n          oe();\n          return void S.reduce(function (e, t) {\n            return e.then(function () {\n              return Ae(t, {\n                loadAsync: !0,\n                global: !0,\n                nodelete: !0,\n                allowUndefined: !0\n              });\n            });\n          }, Promise.resolve()).then(function () {\n            ie();\n            Oe();\n          });\n        }\n        S.forEach(function (e) {\n          Ae(e, {\n            global: !0,\n            nodelete: !0,\n            allowUndefined: !0\n          });\n        });\n        Oe();\n      } else Oe();\n    }(), Je = !0, te > 0) || (function () {\n      if (o.preRun) for (\"function\" == typeof o.preRun && (o.preRun = [o.preRun]); o.preRun.length;) {\n        e = o.preRun.shift();\n        X.unshift(e);\n      }\n      var e;\n      _e(X);\n    }(), te > 0 || (o.setStatus ? (o.setStatus(\"Running...\"), setTimeout(function () {\n      setTimeout(function () {\n        o.setStatus(\"\");\n      }, 1);\n      t();\n    }, 1)) : t()));\n  }\n  function Qe(e, t) {\n    t && be() && 0 === e || (be() || (o.onExit && o.onExit(e), A = !0), l(e, new Ke(e)));\n  }\n  o.run = Xe;\n  if (o.preInit) for (\"function\" == typeof o.preInit && (o.preInit = [o.preInit]); o.preInit.length > 0;) o.preInit.pop()();\n  var Ye = !0;\n  o.noInitialRun && (Ye = !1);\n  Xe();\n  const Ze = o,\n    et = {},\n    tt = 4,\n    nt = 5 * tt,\n    rt = 2 * tt,\n    ot = 2 * tt + 2 * rt,\n    it = {\n      row: 0,\n      column: 0\n    },\n    st = /[\\w-.]*/g,\n    at = 1,\n    ct = 2,\n    lt = /^_?tree_sitter_\\w+/;\n  var ut,\n    dt,\n    pt,\n    ht,\n    ft,\n    mt = new Promise(e => {\n      o.onRuntimeInitialized = e;\n    }).then(() => {\n      pt = Ze._ts_init();\n      ut = P(pt, \"i32\");\n      dt = P(pt + tt, \"i32\");\n    });\n  class gt {\n    static init() {\n      return mt;\n    }\n    constructor() {\n      if (null == pt) throw new Error(\"You must first call Parser.init() and wait for it to resolve.\");\n      Ze._ts_parser_new_wasm();\n      this[0] = P(pt, \"i32\");\n      this[1] = P(pt + tt, \"i32\");\n    }\n    delete() {\n      Ze._ts_parser_delete(this[0]);\n      Ze._free(this[1]);\n      this[0] = 0;\n      this[1] = 0;\n    }\n    setLanguage(e) {\n      let t;\n      if (e) {\n        if (e.constructor !== bt) throw new Error(\"Argument must be a Language\");\n        {\n          t = e[0];\n          const n = Ze._ts_language_version(t);\n          if (n < dt || ut < n) throw new Error(`Incompatible language version ${n}. Compatibility range ${dt} through ${ut}.`);\n        }\n      } else {\n        t = 0;\n        e = null;\n      }\n      this.language = e;\n      Ze._ts_parser_set_language(this[0], t);\n      return this;\n    }\n    getLanguage() {\n      return this.language;\n    }\n    parse(e, t, n) {\n      if (\"string\" == typeof e) ht = (t, n, r) => e.slice(t, r);else {\n        if (\"function\" != typeof e) throw new Error(\"Argument must be a string or a function\");\n        ht = e;\n      }\n      this.logCallback ? (ft = this.logCallback, Ze._ts_parser_enable_logger_wasm(this[0], 1)) : (ft = null, Ze._ts_parser_enable_logger_wasm(this[0], 0));\n      let r = 0,\n        o = 0;\n      if (n && n.includedRanges) {\n        r = n.includedRanges.length;\n        let e = o = Ze._calloc(r, ot);\n        for (let t = 0; t < r; t++) {\n          Nt(e, n.includedRanges[t]);\n          e += ot;\n        }\n      }\n      const i = Ze._ts_parser_parse_wasm(this[0], this[1], t ? t[0] : 0, o, r);\n      if (!i) throw ht = null, ft = null, new Error(\"Parsing failed\");\n      const s = new _t(et, i, this.language, ht);\n      ht = null;\n      ft = null;\n      return s;\n    }\n    reset() {\n      Ze._ts_parser_reset(this[0]);\n    }\n    setTimeoutMicros(e) {\n      Ze._ts_parser_set_timeout_micros(this[0], e);\n    }\n    getTimeoutMicros() {\n      return Ze._ts_parser_timeout_micros(this[0]);\n    }\n    setLogger(e) {\n      if (e) {\n        if (\"function\" != typeof e) throw new Error(\"Logger callback must be a function\");\n      } else e = null;\n      this.logCallback = e;\n      return this;\n    }\n    getLogger() {\n      return this.logCallback;\n    }\n  }\n  class _t {\n    constructor(e, t, n, r) {\n      Ct(e);\n      this[0] = t;\n      this.language = n;\n      this.textCallback = r;\n    }\n    copy() {\n      const e = Ze._ts_tree_copy(this[0]);\n      return new _t(et, e, this.language, this.textCallback);\n    }\n    delete() {\n      Ze._ts_tree_delete(this[0]);\n      this[0] = 0;\n    }\n    edit(e) {\n      !function (e) {\n        let t = pt;\n        At(t, e.startPosition);\n        At(t += rt, e.oldEndPosition);\n        At(t += rt, e.newEndPosition);\n        I(t += rt, e.startIndex, \"i32\");\n        I(t += tt, e.oldEndIndex, \"i32\");\n        I(t += tt, e.newEndIndex, \"i32\");\n        t += tt;\n      }(e);\n      Ze._ts_tree_edit_wasm(this[0]);\n    }\n    get rootNode() {\n      Ze._ts_tree_root_node_wasm(this[0]);\n      return kt(this);\n    }\n    getLanguage() {\n      return this.language;\n    }\n    walk() {\n      return this.rootNode.walk();\n    }\n    getChangedRanges(e) {\n      if (e.constructor !== _t) throw new TypeError(\"Argument must be a Tree\");\n      Ze._ts_tree_get_changed_ranges_wasm(this[0], e[0]);\n      const t = P(pt, \"i32\"),\n        n = P(pt + tt, \"i32\"),\n        r = new Array(t);\n      if (t > 0) {\n        let e = n;\n        for (let n = 0; n < t; n++) {\n          r[n] = Rt(e);\n          e += ot;\n        }\n        Ze._free(n);\n      }\n      return r;\n    }\n  }\n  class yt {\n    constructor(e, t) {\n      Ct(e);\n      this.tree = t;\n    }\n    get typeId() {\n      Tt(this);\n      return Ze._ts_node_symbol_wasm(this.tree[0]);\n    }\n    get type() {\n      return this.tree.language.types[this.typeId] || \"ERROR\";\n    }\n    get endPosition() {\n      Tt(this);\n      Ze._ts_node_end_point_wasm(this.tree[0]);\n      return Ot(pt);\n    }\n    get endIndex() {\n      Tt(this);\n      return Ze._ts_node_end_index_wasm(this.tree[0]);\n    }\n    get text() {\n      return xt(this.tree, this.startIndex, this.endIndex);\n    }\n    isNamed() {\n      Tt(this);\n      return 1 === Ze._ts_node_is_named_wasm(this.tree[0]);\n    }\n    hasError() {\n      Tt(this);\n      return 1 === Ze._ts_node_has_error_wasm(this.tree[0]);\n    }\n    hasChanges() {\n      Tt(this);\n      return 1 === Ze._ts_node_has_changes_wasm(this.tree[0]);\n    }\n    isMissing() {\n      Tt(this);\n      return 1 === Ze._ts_node_is_missing_wasm(this.tree[0]);\n    }\n    equals(e) {\n      return this.id === e.id;\n    }\n    child(e) {\n      Tt(this);\n      Ze._ts_node_child_wasm(this.tree[0], e);\n      return kt(this.tree);\n    }\n    namedChild(e) {\n      Tt(this);\n      Ze._ts_node_named_child_wasm(this.tree[0], e);\n      return kt(this.tree);\n    }\n    childForFieldId(e) {\n      Tt(this);\n      Ze._ts_node_child_by_field_id_wasm(this.tree[0], e);\n      return kt(this.tree);\n    }\n    childForFieldName(e) {\n      const t = this.tree.language.fields.indexOf(e);\n      if (-1 !== t) return this.childForFieldId(t);\n    }\n    get childCount() {\n      Tt(this);\n      return Ze._ts_node_child_count_wasm(this.tree[0]);\n    }\n    get namedChildCount() {\n      Tt(this);\n      return Ze._ts_node_named_child_count_wasm(this.tree[0]);\n    }\n    get firstChild() {\n      return this.child(0);\n    }\n    get firstNamedChild() {\n      return this.namedChild(0);\n    }\n    get lastChild() {\n      return this.child(this.childCount - 1);\n    }\n    get lastNamedChild() {\n      return this.namedChild(this.namedChildCount - 1);\n    }\n    get children() {\n      if (!this._children) {\n        Tt(this);\n        Ze._ts_node_children_wasm(this.tree[0]);\n        const e = P(pt, \"i32\"),\n          t = P(pt + tt, \"i32\");\n        this._children = new Array(e);\n        if (e > 0) {\n          let n = t;\n          for (let t = 0; t < e; t++) this._children[t] = kt(this.tree, n), n += nt;\n          Ze._free(t);\n        }\n      }\n      return this._children;\n    }\n    get namedChildren() {\n      if (!this._namedChildren) {\n        Tt(this);\n        Ze._ts_node_named_children_wasm(this.tree[0]);\n        const e = P(pt, \"i32\"),\n          t = P(pt + tt, \"i32\");\n        this._namedChildren = new Array(e);\n        if (e > 0) {\n          let n = t;\n          for (let t = 0; t < e; t++) this._namedChildren[t] = kt(this.tree, n), n += nt;\n          Ze._free(t);\n        }\n      }\n      return this._namedChildren;\n    }\n    descendantsOfType(e, t, n) {\n      Array.isArray(e) || (e = [e]);\n      t || (t = it);\n      n || (n = it);\n      const r = [],\n        o = this.tree.language.types;\n      for (let t = 0, n = o.length; t < n; t++) e.includes(o[t]) && r.push(t);\n      const i = Ze._malloc(tt * r.length);\n      for (let e = 0, t = r.length; e < t; e++) I(i + e * tt, r[e], \"i32\");\n      Tt(this);\n      Ze._ts_node_descendants_of_type_wasm(this.tree[0], i, r.length, t.row, t.column, n.row, n.column);\n      const s = P(pt, \"i32\"),\n        a = P(pt + tt, \"i32\"),\n        c = new Array(s);\n      if (s > 0) {\n        let e = a;\n        for (let t = 0; t < s; t++) {\n          c[t] = kt(this.tree, e);\n          e += nt;\n        }\n      }\n      Ze._free(a);\n      Ze._free(i);\n      return c;\n    }\n    get nextSibling() {\n      Tt(this);\n      Ze._ts_node_next_sibling_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    get previousSibling() {\n      Tt(this);\n      Ze._ts_node_prev_sibling_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    get nextNamedSibling() {\n      Tt(this);\n      Ze._ts_node_next_named_sibling_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    get previousNamedSibling() {\n      Tt(this);\n      Ze._ts_node_prev_named_sibling_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    get parent() {\n      Tt(this);\n      Ze._ts_node_parent_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    descendantForIndex(e, t = e) {\n      if (\"number\" != typeof e || \"number\" != typeof t) throw new Error(\"Arguments must be numbers\");\n      Tt(this);\n      let n = pt + nt;\n      I(n, e, \"i32\");\n      I(n + tt, t, \"i32\");\n      Ze._ts_node_descendant_for_index_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    namedDescendantForIndex(e, t = e) {\n      if (\"number\" != typeof e || \"number\" != typeof t) throw new Error(\"Arguments must be numbers\");\n      Tt(this);\n      let n = pt + nt;\n      I(n, e, \"i32\");\n      I(n + tt, t, \"i32\");\n      Ze._ts_node_named_descendant_for_index_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    descendantForPosition(e, t = e) {\n      if (!St(e) || !St(t)) throw new Error(\"Arguments must be {row, column} objects\");\n      Tt(this);\n      let n = pt + nt;\n      At(n, e);\n      At(n + rt, t);\n      Ze._ts_node_descendant_for_position_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    namedDescendantForPosition(e, t = e) {\n      if (!St(e) || !St(t)) throw new Error(\"Arguments must be {row, column} objects\");\n      Tt(this);\n      let n = pt + nt;\n      At(n, e);\n      At(n + rt, t);\n      Ze._ts_node_named_descendant_for_position_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    walk() {\n      Tt(this);\n      Ze._ts_tree_cursor_new_wasm(this.tree[0]);\n      return new vt(et, this.tree);\n    }\n    toString() {\n      Tt(this);\n      const e = Ze._ts_node_to_string_wasm(this.tree[0]),\n        t = function (e) {\n          for (var t = \"\";;) {\n            var n = M[e++ >> 0];\n            if (!n) return t;\n            t += String.fromCharCode(n);\n          }\n        }(e);\n      Ze._free(e);\n      return t;\n    }\n  }\n  class vt {\n    constructor(e, t) {\n      Ct(e);\n      this.tree = t;\n      Pt(this);\n    }\n    delete() {\n      It(this);\n      Ze._ts_tree_cursor_delete_wasm(this.tree[0]);\n      this[0] = this[1] = this[2] = 0;\n    }\n    reset(e) {\n      Tt(e);\n      It(this, pt + nt);\n      Ze._ts_tree_cursor_reset_wasm(this.tree[0]);\n      Pt(this);\n    }\n    get nodeType() {\n      return this.tree.language.types[this.nodeTypeId] || \"ERROR\";\n    }\n    get nodeTypeId() {\n      It(this);\n      return Ze._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);\n    }\n    get nodeId() {\n      It(this);\n      return Ze._ts_tree_cursor_current_node_id_wasm(this.tree[0]);\n    }\n    get nodeIsNamed() {\n      It(this);\n      return 1 === Ze._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]);\n    }\n    get nodeIsMissing() {\n      It(this);\n      return 1 === Ze._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]);\n    }\n    get nodeText() {\n      It(this);\n      const e = Ze._ts_tree_cursor_start_index_wasm(this.tree[0]),\n        t = Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);\n      return xt(this.tree, e, t);\n    }\n    get startPosition() {\n      It(this);\n      Ze._ts_tree_cursor_start_position_wasm(this.tree[0]);\n      return Ot(pt);\n    }\n    get endPosition() {\n      It(this);\n      Ze._ts_tree_cursor_end_position_wasm(this.tree[0]);\n      return Ot(pt);\n    }\n    get startIndex() {\n      It(this);\n      return Ze._ts_tree_cursor_start_index_wasm(this.tree[0]);\n    }\n    get endIndex() {\n      It(this);\n      return Ze._ts_tree_cursor_end_index_wasm(this.tree[0]);\n    }\n    currentNode() {\n      It(this);\n      Ze._ts_tree_cursor_current_node_wasm(this.tree[0]);\n      return kt(this.tree);\n    }\n    currentFieldId() {\n      It(this);\n      return Ze._ts_tree_cursor_current_field_id_wasm(this.tree[0]);\n    }\n    currentFieldName() {\n      return this.tree.language.fields[this.currentFieldId()];\n    }\n    gotoFirstChild() {\n      It(this);\n      const e = Ze._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);\n      Pt(this);\n      return 1 === e;\n    }\n    gotoNextSibling() {\n      It(this);\n      const e = Ze._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);\n      Pt(this);\n      return 1 === e;\n    }\n    gotoParent() {\n      It(this);\n      const e = Ze._ts_tree_cursor_goto_parent_wasm(this.tree[0]);\n      Pt(this);\n      return 1 === e;\n    }\n  }\n  class bt {\n    constructor(e, t) {\n      Ct(e);\n      this[0] = t;\n      this.types = new Array(Ze._ts_language_symbol_count(this[0]));\n      for (let e = 0, t = this.types.length; e < t; e++) Ze._ts_language_symbol_type(this[0], e) < 2 && (this.types[e] = U(Ze._ts_language_symbol_name(this[0], e)));\n      this.fields = new Array(Ze._ts_language_field_count(this[0]) + 1);\n      for (let e = 0, t = this.fields.length; e < t; e++) {\n        const t = Ze._ts_language_field_name_for_id(this[0], e);\n        this.fields[e] = 0 !== t ? U(t) : null;\n      }\n    }\n    get version() {\n      return Ze._ts_language_version(this[0]);\n    }\n    get fieldCount() {\n      return this.fields.length - 1;\n    }\n    fieldIdForName(e) {\n      const t = this.fields.indexOf(e);\n      return -1 !== t ? t : null;\n    }\n    fieldNameForId(e) {\n      return this.fields[e] || null;\n    }\n    idForNodeType(e, t) {\n      const n = G(e),\n        r = Ze._malloc(n + 1);\n      z(e, r, n + 1);\n      const o = Ze._ts_language_symbol_for_name(this[0], r, n, t);\n      Ze._free(r);\n      return o || null;\n    }\n    get nodeTypeCount() {\n      return Ze._ts_language_symbol_count(this[0]);\n    }\n    nodeTypeForId(e) {\n      const t = Ze._ts_language_symbol_name(this[0], e);\n      return t ? U(t) : null;\n    }\n    nodeTypeIsNamed(e) {\n      return !!Ze._ts_language_type_is_named_wasm(this[0], e);\n    }\n    nodeTypeIsVisible(e) {\n      return !!Ze._ts_language_type_is_visible_wasm(this[0], e);\n    }\n    query(e) {\n      const t = G(e),\n        n = Ze._malloc(t + 1);\n      z(e, n, t + 1);\n      const r = Ze._ts_query_new(this[0], n, t, pt, pt + tt);\n      if (!r) {\n        const t = P(pt + tt, \"i32\"),\n          r = U(n, P(pt, \"i32\")).length,\n          o = e.substr(r, 100).split(\"\\n\")[0];\n        let i,\n          s = o.match(st)[0];\n        switch (t) {\n          case 2:\n            i = new RangeError(`Bad node name '${s}'`);\n            break;\n          case 3:\n            i = new RangeError(`Bad field name '${s}'`);\n            break;\n          case 4:\n            i = new RangeError(`Bad capture name @${s}`);\n            break;\n          case 5:\n            i = new TypeError(`Bad pattern structure at offset ${r}: '${o}'...`);\n            s = \"\";\n            break;\n          default:\n            i = new SyntaxError(`Bad syntax at offset ${r}: '${o}'...`);\n            s = \"\";\n        }\n        throw i.index = r, i.length = s.length, Ze._free(n), i;\n      }\n      const o = Ze._ts_query_string_count(r),\n        i = Ze._ts_query_capture_count(r),\n        s = Ze._ts_query_pattern_count(r),\n        a = new Array(i),\n        c = new Array(o);\n      for (let e = 0; e < i; e++) {\n        const t = Ze._ts_query_capture_name_for_id(r, e, pt),\n          n = P(pt, \"i32\");\n        a[e] = U(t, n);\n      }\n      for (let e = 0; e < o; e++) {\n        const t = Ze._ts_query_string_value_for_id(r, e, pt),\n          n = P(pt, \"i32\");\n        c[e] = U(t, n);\n      }\n      const l = new Array(s),\n        u = new Array(s),\n        d = new Array(s),\n        p = new Array(s),\n        h = new Array(s);\n      for (let e = 0; e < s; e++) {\n        const t = Ze._ts_query_predicates_for_pattern(r, e, pt),\n          n = P(pt, \"i32\");\n        p[e] = [];\n        h[e] = [];\n        const o = [];\n        let i = t;\n        for (let t = 0; t < n; t++) {\n          const t = P(i, \"i32\"),\n            n = P(i += tt, \"i32\");\n          i += tt;\n          if (t === at) o.push({\n            type: \"capture\",\n            name: a[n]\n          });else if (t === ct) o.push({\n            type: \"string\",\n            value: c[n]\n          });else if (o.length > 0) {\n            if (\"string\" !== o[0].type) throw new Error(\"Predicates must begin with a literal value\");\n            const t = o[0].value;\n            let n = !0;\n            switch (t) {\n              case \"not-eq?\":\n                n = !1;\n              case \"eq?\":\n                if (3 !== o.length) throw new Error(\"Wrong number of arguments to `#eq?` predicate. Expected 2, got \" + (o.length - 1));\n                if (\"capture\" !== o[1].type) throw new Error(`First argument of \\`#eq?\\` predicate must be a capture. Got \"${o[1].value}\"`);\n                if (\"capture\" === o[2].type) {\n                  const t = o[1].name,\n                    r = o[2].name;\n                  h[e].push(function (e) {\n                    let o, i;\n                    for (const n of e) n.name === t && (o = n.node), n.name === r && (i = n.node);\n                    return o.text === i.text === n;\n                  });\n                } else {\n                  const t = o[1].name,\n                    r = o[2].value;\n                  h[e].push(function (e) {\n                    for (const o of e) if (o.name === t) return o.node.text === r === n;\n                    return !1;\n                  });\n                }\n                break;\n              case \"not-match?\":\n                n = !1;\n              case \"match?\":\n                if (3 !== o.length) throw new Error(`Wrong number of arguments to \\`#match?\\` predicate. Expected 2, got ${o.length - 1}.`);\n                if (\"capture\" !== o[1].type) throw new Error(`First argument of \\`#match?\\` predicate must be a capture. Got \"${o[1].value}\".`);\n                if (\"string\" !== o[2].type) throw new Error(`Second argument of \\`#match?\\` predicate must be a string. Got @${o[2].value}.`);\n                const r = o[1].name,\n                  i = new RegExp(o[2].value);\n                h[e].push(function (e) {\n                  for (const t of e) if (t.name === r) return i.test(t.node.text) === n;\n                  return !1;\n                });\n                break;\n              case \"set!\":\n                if (o.length < 2 || o.length > 3) throw new Error(`Wrong number of arguments to \\`#set!\\` predicate. Expected 1 or 2. Got ${o.length - 1}.`);\n                if (o.some(e => \"string\" !== e.type)) throw new Error('Arguments to `#set!` predicate must be a strings.\".');\n                l[e] || (l[e] = {}), l[e][o[1].value] = o[2] ? o[2].value : null;\n                break;\n              case \"is?\":\n              case \"is-not?\":\n                if (o.length < 2 || o.length > 3) throw new Error(`Wrong number of arguments to \\`#${t}\\` predicate. Expected 1 or 2. Got ${o.length - 1}.`);\n                if (o.some(e => \"string\" !== e.type)) throw new Error(`Arguments to \\`#${t}\\` predicate must be a strings.\".`);\n                const s = \"is?\" === t ? u : d;\n                s[e] || (s[e] = {}), s[e][o[1].value] = o[2] ? o[2].value : null;\n                break;\n              default:\n                p[e].push({\n                  operator: t,\n                  operands: o.slice(1)\n                });\n            }\n            o.length = 0;\n          }\n        }\n        Object.freeze(l[e]);\n        Object.freeze(u[e]);\n        Object.freeze(d[e]);\n      }\n      Ze._free(n);\n      return new wt(et, r, a, h, p, Object.freeze(l), Object.freeze(u), Object.freeze(d));\n    }\n    static load(e) {\n      let t;\n      if (e instanceof Uint8Array) t = Promise.resolve(e);else {\n        const r = e;\n        if (\"undefined\" != typeof process && process.versions && process.versions.node) {\n          const e = require(7147);\n          t = Promise.resolve(e.readFileSync(r));\n        } else t = fetch(r).then(e => e.arrayBuffer().then(t => {\n          if (e.ok) return new Uint8Array(t);\n          {\n            const n = new TextDecoder(\"utf-8\").decode(t);\n            throw new Error(`Language.load failed with status ${e.status}.\\n\\n${n}`);\n          }\n        }));\n      }\n      const r = \"function\" == typeof loadSideModule ? loadSideModule : Pe;\n      return t.then(e => r(e, {\n        loadAsync: !0\n      })).then(e => {\n        const t = Object.keys(e),\n          n = t.find(e => lt.test(e) && !e.includes(\"external_scanner_\"));\n        n || console.log(`Couldn't find language function in WASM file. Symbols:\\n${JSON.stringify(t, null, 2)}`);\n        const r = e[n]();\n        return new bt(et, r);\n      });\n    }\n  }\n  class wt {\n    constructor(e, t, n, r, o, i, s, a) {\n      Ct(e);\n      this[0] = t;\n      this.captureNames = n;\n      this.textPredicates = r;\n      this.predicates = o;\n      this.setProperties = i;\n      this.assertedProperties = s;\n      this.refutedProperties = a;\n      this.exceededMatchLimit = !1;\n    }\n    delete() {\n      Ze._ts_query_delete(this[0]);\n      this[0] = 0;\n    }\n    matches(e, t, n) {\n      t || (t = it);\n      n || (n = it);\n      Tt(e);\n      Ze._ts_query_matches_wasm(this[0], e.tree[0], t.row, t.column, n.row, n.column);\n      const r = P(pt, \"i32\"),\n        o = P(pt + tt, \"i32\"),\n        i = P(pt + 2 * tt, \"i32\"),\n        s = new Array(r);\n      this.exceededMatchLimit = !!i;\n      let a = 0,\n        c = o;\n      for (let t = 0; t < r; t++) {\n        const n = P(c, \"i32\"),\n          r = P(c += tt, \"i32\");\n        c += tt;\n        const o = new Array(r);\n        c = Et(this, e.tree, c, o);\n        if (this.textPredicates[n].every(e => e(o))) {\n          s[a++] = {\n            pattern: n,\n            captures: o\n          };\n          const e = this.setProperties[n];\n          e && (s[t].setProperties = e);\n          const r = this.assertedProperties[n];\n          r && (s[t].assertedProperties = r);\n          const i = this.refutedProperties[n];\n          i && (s[t].refutedProperties = i);\n        }\n      }\n      s.length = a;\n      Ze._free(o);\n      return s;\n    }\n    captures(e, t, n) {\n      t || (t = it);\n      n || (n = it);\n      Tt(e);\n      Ze._ts_query_captures_wasm(this[0], e.tree[0], t.row, t.column, n.row, n.column);\n      const r = P(pt, \"i32\"),\n        o = P(pt + tt, \"i32\"),\n        i = P(pt + 2 * tt, \"i32\"),\n        s = [];\n      this.exceededMatchLimit = !!i;\n      const a = [];\n      let c = o;\n      for (let t = 0; t < r; t++) {\n        const t = P(c, \"i32\"),\n          n = P(c += tt, \"i32\"),\n          r = P(c += tt, \"i32\");\n        c += tt;\n        a.length = n;\n        c = Et(this, e.tree, c, a);\n        if (this.textPredicates[t].every(e => e(a))) {\n          const e = a[r],\n            n = this.setProperties[t];\n          n && (e.setProperties = n);\n          const o = this.assertedProperties[t];\n          o && (e.assertedProperties = o);\n          const i = this.refutedProperties[t];\n          i && (e.refutedProperties = i), s.push(e);\n        }\n      }\n      Ze._free(o);\n      return s;\n    }\n    predicatesForPattern(e) {\n      return this.predicates[e];\n    }\n    didExceedMatchLimit() {\n      return this.exceededMatchLimit;\n    }\n  }\n  function xt(e, t, n) {\n    const r = n - t;\n    let o = e.textCallback(t, null, n);\n    for (t += o.length; t < n;) {\n      const r = e.textCallback(t, null, n);\n      if (!(r && r.length > 0)) break;\n      t += r.length;\n      o += r;\n    }\n    t > n && (o = o.slice(0, r));\n    return o;\n  }\n  function Et(e, t, n, r) {\n    for (let o = 0, i = r.length; o < i; o++) {\n      const i = P(n, \"i32\"),\n        s = kt(t, n += tt);\n      n += nt;\n      r[o] = {\n        name: e.captureNames[i],\n        node: s\n      };\n    }\n    return n;\n  }\n  function Ct(e) {\n    if (e !== et) throw new Error(\"Illegal constructor\");\n  }\n  function St(e) {\n    return e && \"number\" == typeof e.row && \"number\" == typeof e.column;\n  }\n  function Tt(e) {\n    let t = pt;\n    I(t, e.id, \"i32\");\n    I(t += tt, e.startIndex, \"i32\");\n    I(t += tt, e.startPosition.row, \"i32\");\n    I(t += tt, e.startPosition.column, \"i32\");\n    I(t += tt, e[0], \"i32\");\n  }\n  function kt(e, t = pt) {\n    const n = P(t, \"i32\");\n    if (0 === n) return null;\n    const r = P(t += tt, \"i32\"),\n      o = P(t += tt, \"i32\"),\n      i = P(t += tt, \"i32\"),\n      s = P(t += tt, \"i32\"),\n      a = new yt(et, e);\n    a.id = n;\n    a.startIndex = r;\n    a.startPosition = {\n      row: o,\n      column: i\n    };\n    a[0] = s;\n    return a;\n  }\n  function It(e, t = pt) {\n    I(t + 0 * tt, e[0], \"i32\");\n    I(t + 1 * tt, e[1], \"i32\");\n    I(t + 2 * tt, e[2], \"i32\");\n  }\n  function Pt(e) {\n    e[0] = P(pt + 0 * tt, \"i32\");\n    e[1] = P(pt + 1 * tt, \"i32\");\n    e[2] = P(pt + 2 * tt, \"i32\");\n  }\n  function At(e, t) {\n    I(e, t.row, \"i32\");\n    I(e + tt, t.column, \"i32\");\n  }\n  function Ot(e) {\n    return {\n      row: P(e, \"i32\"),\n      column: P(e + tt, \"i32\")\n    };\n  }\n  function Nt(e, t) {\n    At(e, t.startPosition);\n    At(e += rt, t.endPosition);\n    I(e += rt, t.startIndex, \"i32\");\n    I(e += tt, t.endIndex, \"i32\");\n    e += tt;\n  }\n  function Rt(e) {\n    const t = {};\n    t.startPosition = Ot(e);\n    e += rt;\n    t.endPosition = Ot(e);\n    e += rt;\n    t.startIndex = P(e, \"i32\");\n    e += tt;\n    t.endIndex = P(e, \"i32\");\n    return t;\n  }\n  gt.Language = bt;\n  gt.Parser = gt;\n  return gt;\n}.apply(exports, [])) || (module.exports = r);",
  "4101": "module.exports = function () {};",
  "4106": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar azuresdk = require(8604);\nexports.azuresdk = azuresdk;\nvar bunyan = require(8859);\nexports.bunyan = bunyan;\nvar console = require(2495);\nexports.console = console;\nvar mongodbCore = require(2028);\nexports.mongodbCore = mongodbCore;\nvar mongodb = require(8436);\nexports.mongodb = mongodb;\nvar mysql = require(8002);\nexports.mysql = mysql;\nvar pgPool = require(9024);\nexports.pgPool = pgPool;\nvar pg = require(8060);\nexports.pg = pg;\nvar redis = require(4487);\nexports.redis = redis;\nvar tedious = require(6661);\nexports.tedious = tedious;\nvar winston = require(4650);\nexports.winston = winston;\nexports.enable = function () {\n  bunyan.enable();\n  console.enable();\n  mongodbCore.enable();\n  mongodb.enable();\n  mysql.enable();\n  pg.enable();\n  pgPool.enable();\n  redis.enable();\n  winston.enable();\n  azuresdk.enable();\n  tedious.enable();\n};",
  "4127": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(4350),\n  o = require(5290);\nexports.performanceMetricsTelemetryProcessor = function (e, t) {\n  switch (t && t.addDocument(e), e.data.baseType) {\n    case o.TelemetryTypeString.Exception:\n      r.countException();\n      break;\n    case o.TelemetryTypeString.Request:\n      var n = e.data.baseData;\n      r.countRequest(n.duration, n.success);\n      break;\n    case o.TelemetryTypeString.Dependency:\n      var i = e.data.baseData;\n      r.countDependency(i.duration, i.success);\n  }\n  return !0;\n};",
  "4147": "module.exports = JSON.parse('{\"name\":\"copilot\",\"displayName\":\"GitHub Copilot\",\"description\":\"Your AI pair programmer\",\"version\":\"1.57.7193\",\"build\":\"7193\",\"buildType\":\"prod\",\"publisher\":\"GitHub\",\"preview\":false,\"homepage\":\"https://github.com/features/copilot\",\"bugs\":{\"url\":\"https://github.com/community/community/discussions/categories/copilot\"},\"qna\":\"https://github.com/github-community/community/discussions/categories/copilot\",\"icon\":\"assets/Copilot-App-Icon.png\",\"engines\":{\"vscode\":\"^1.68.0\",\"npm\":\">=7.0.0\"},\"categories\":[\"Other\"],\"badges\":[{\"url\":\"https://img.shields.io/badge/GitHub%20Copilot-Subscription%20Required-orange\",\"href\":\"https://github.com/github-copilot/signup\",\"description\":\"Sign up for GitHub Copilot\"}],\"activationEvents\":[\"onStartupFinished\"],\"main\":\"./dist/extension\",\"enabledApiProposals\":[\"inlineCompletionsAdditions\"],\"contributes\":{\"commands\":[{\"command\":\"github.copilot.generate\",\"title\":\"Open GitHub Copilot\"},{\"command\":\"github.copilot.toggleCopilot\",\"title\":\"GitHub Copilot: Configure Enabled/Disabled\"},{\"command\":\"github.copilot.sendFeedback\",\"title\":\"GitHub Copilot: Send Feedback\"}],\"keybindings\":[{\"command\":\"github.copilot.generate\",\"key\":\"ctrl+enter\",\"mac\":\"ctrl+enter\",\"when\":\"editorTextFocus && github.copilot.activated\"},{\"command\":\"editor.action.inlineSuggest.trigger\",\"key\":\"alt+\\\\\\\\\",\"when\":\"editorTextFocus && !editorHasSelection && config.github.copilot.inlineSuggest.enable && !inlineSuggestionsVisible\"}],\"menus\":{\"editor/inlineCompletions/actions\":[{\"command\":\"github.copilot.generate\",\"when\":\"github.copilot.activated\"}],\"commandPalette\":[{\"command\":\"github.copilot.generate\",\"when\":\"github.copilot.activated\"},{\"command\":\"github.copilot.toggleCopilot\",\"when\":\"github.copilot.activated\"},{\"command\":\"github.copilot.sendFeedback\",\"when\":\"github.copilot.activated\"}]},\"configuration\":[{\"title\":\"Copilot\",\"properties\":{\"github.copilot.advanced\":{\"type\":\"object\",\"title\":\"Advanced Settings\",\"properties\":{\"secret_key\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Secret API key\"},\"length\":{\"type\":\"integer\",\"default\":500,\"description\":\"Length of code to generate in tokens\"},\"temperature\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Override sampling temperature (range 0.0 - 1.0)\"},\"top_p\":{\"type\":\"number\",\"default\":1,\"description\":\"Top probability mass to consider\"},\"stops\":{\"type\":\"object\",\"default\":{\"*\":[\"\\\\n\\\\n\\\\n\"],\"python\":[\"\\\\ndef \",\"\\\\nclass \",\"\\\\nif \",\"\\\\n\\\\n#\"]},\"description\":\"Configure per-language stop sequences\"},\"indentationMode\":{\"type\":\"object\",\"default\":{\"python\":false,\"javascript\":false,\"javascriptreact\":false,\"jsx\":false,\"typescript\":false,\"typescriptreact\":false,\"go\":false,\"ruby\":false,\"*\":true},\"markdownDescription\":\"Enable or disable indentation block termination for specified [languages](https://code.visualstudio.com/docs/languages/identifiers). Set to \\'clientandserver\\' to run both parser-based and indent-based termination.\"},\"inlineSuggestCount\":{\"type\":\"integer\",\"default\":3,\"description\":\"Number of inline suggestions to fetch\"},\"listCount\":{\"type\":\"integer\",\"default\":10,\"description\":\"Number of solutions to list in Open GitHub Copilot\"},\"debug.showScores\":{\"type\":\"boolean\",\"default\":false,\"description\":\"Show scores in sorted solutions\"},\"debug.overrideEngine\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Override engine name\"},\"debug.overrideProxyUrl\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Override GitHub authentication proxy full URL\"},\"debug.testOverrideProxyUrl\":{\"type\":\"string\",\"default\":\"\",\"description\":\"Override GitHub authentication proxy URL when running tests\"},\"debug.filterLogCategories\":{\"type\":\"array\",\"default\":[],\"description\":\"Show only log categories listed in this setting. If an array is empty, show all loggers\"}}},\"github.copilot.enable\":{\"type\":\"object\",\"default\":{\"*\":true,\"yaml\":false,\"plaintext\":false,\"markdown\":false},\"markdownDescription\":\"Enable or disable Copilot for specified [languages](https://code.visualstudio.com/docs/languages/identifiers)\"},\"github.copilot.inlineSuggest.enable\":{\"type\":\"boolean\",\"default\":true,\"description\":\"Show inline suggestions\"}}}],\"icons\":{\"copilot-logo\":{\"description\":\"GitHub Copilot icon\",\"default\":{\"fontPath\":\"assets/copilot.woff\",\"fontCharacter\":\"\\\\\\\\0041\"}},\"copilot-warning\":{\"description\":\"GitHub Copilot icon\",\"default\":{\"fontPath\":\"assets/copilot.woff\",\"fontCharacter\":\"\\\\\\\\0042\"}},\"copilot-notconnected\":{\"description\":\"GitHub Copilot icon\",\"default\":{\"fontPath\":\"assets/copilot.woff\",\"fontCharacter\":\"\\\\\\\\0043\"}}},\"iconFonts\":[{\"id\":\"copilot-font\",\"src\":[{\"path\":\"assets/copilot.woff\",\"format\":\"woff\"}]}]},\"scripts\":{\"postinstall\":\"npx vscode-dts dev && mv vscode.proposed.*.ts extension/src\",\"vscode:prepublish\":\"npm-run-all build:extension\",\"build\":\"npm-run-all build:*\",\"build:agent\":\"cd agent && npm run build\",\"build:agent-no-pkg\":\"cd agent && npm run build-no-pkg\",\"build:extension\":\"webpack --mode production\",\"build:lib\":\"cd lib && npm run build\",\"compile\":\"npm-run-all compile:*\",\"compile:agent\":\"cd agent && npm run compile\",\"compile:extension\":\"webpack --mode development\",\"compile:lib\":\"cd lib && npm run compile\",\"watch\":\"npm-run-all -p watch:*\",\"watch:agent\":\"cd agent && npm run watch\",\"watch:extension\":\"webpack --mode development --watch\",\"watch:lib\":\"cd lib && npm run watch\",\"lint\":\"eslint lib extension agent --ext ts\",\"check_deps\":\"depcruise -c .dependency-cruiser.js .\",\"test\":\"npm-run-all test:*\",\"test:agent\":\"cd agent && npm run test\",\"test:extension\":\"cd extension && ts-node ./test/runTest.ts\",\"test:prompt\":\"cd prompt && npm install && npm run test\",\"test:lib\":\"cd lib && npm run test\",\"test:lsp-client\":\"cd lsp-client && npm run smokeTest\",\"build_test\":\"tsc extension/test/run.ts\",\"get_token\":\"ts-node script/getToken.ts\"},\"devDependencies\":{\"@github/prettier-config\":\"0.0.4\",\"@types/crypto-js\":\"^4.0.1\",\"@types/mocha\":\"^5.2.6\",\"@types/node\":\"^13.11.0\",\"@types/tunnel\":\"^0.0.3\",\"@types/uuid\":\"^8.3.1\",\"@types/vscode\":\"^1.68.0\",\"@typescript-eslint/eslint-plugin\":\"^4.27.0\",\"@typescript-eslint/parser\":\"^4.27.0\",\"dependency-cruiser\":\"^9.26.1\",\"eslint\":\"^7.29.0\",\"eslint-plugin-no-only-tests\":\"^2.6.0\",\"fantasticon\":\"^1.2.2\",\"get-port\":\"^5.1.1\",\"mocha\":\"^6.1.4\",\"npm-run-all\":\"^4.1.5\",\"prettier\":\"2.5.1\",\"prettier-plugin-organize-imports\":\"^2.3.4\",\"ts-dedent\":\"^2.2.0\",\"ts-loader\":\"^8.0.11\",\"ts-node\":\"^9.0.0\",\"typescript\":\"^4.4.3\",\"vsce\":\"1.91.0\",\"vscode-dts\":\"^0.3.2\",\"vscode-test\":\"^1.3.0\",\"webpack\":\"^5.54.0\",\"webpack-cli\":\"^4.2.0\",\"zlib\":\"^1.0.5\"},\"dependencies\":{\"@adobe/helix-fetch\":\"github:bmuskalla/helix-fetch#4e33e47bf6e64b637d5d713558fde504bf71c947\",\"@github/copilot-promptlib\":\"file:prompt\",\"@sinclair/typebox\":\"^0.23.4\",\"@types/git-url-parse\":\"^9.0.1\",\"ajv\":\"^8.6.3\",\"ajv-errors\":\"^3.0.0\",\"crypto-js\":\"^4.0.0\",\"git-url-parse\":\"^13.1.0\",\"open\":\"^8.4.0\",\"source-map-support\":\"^0.5.19\",\"tunnel\":\"^0.0.6\",\"uuid\":\"^8.3.2\",\"vscode-extension-telemetry\":\"^0.1.6\",\"vscode-uri\":\"^3.0.2\"}}');",
  "4181": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = require(2141);\nfunction s(e, t) {\n  const n = e.const(\"err\", t);\n  e.if(r._`${i.default.vErrors} === null`, () => e.assign(i.default.vErrors, r._`[${n}]`), r._`${i.default.vErrors}.push(${n})`);\n  e.code(r._`${i.default.errors}++`);\n}\nfunction a(e, t) {\n  const {\n    gen: n,\n    validateName: o,\n    schemaEnv: i\n  } = e;\n  i.$async ? n.throw(r._`new ${e.ValidationError}(${t})`) : (n.assign(r._`${o}.errors`, t), n.return(!1));\n}\nexports.keywordError = {\n  message: ({\n    keyword: e\n  }) => r.str`must pass \"${e}\" keyword validation`\n};\nexports.keyword$DataError = {\n  message: ({\n    keyword: e,\n    schemaType: t\n  }) => t ? r.str`\"${e}\" keyword must be ${t} ($data)` : r.str`\"${e}\" keyword is invalid ($data)`\n};\nexports.reportError = function (e, n = exports.keywordError, o, i) {\n  const {\n      it: c\n    } = e,\n    {\n      gen: u,\n      compositeRule: d,\n      allErrors: p\n    } = c,\n    h = l(e, n, o);\n  (null != i ? i : d || p) ? s(u, h) : a(c, r._`[${h}]`);\n};\nexports.reportExtraError = function (e, n = exports.keywordError, r) {\n  const {\n      it: o\n    } = e,\n    {\n      gen: c,\n      compositeRule: u,\n      allErrors: d\n    } = o;\n  s(c, l(e, n, r));\n  u || d || a(o, i.default.vErrors);\n};\nexports.resetErrorsCount = function (e, t) {\n  e.assign(i.default.errors, t);\n  e.if(r._`${i.default.vErrors} !== null`, () => e.if(t, () => e.assign(r._`${i.default.vErrors}.length`, t), () => e.assign(i.default.vErrors, null)));\n};\nexports.extendErrors = function ({\n  gen: e,\n  keyword: t,\n  schemaValue: n,\n  data: o,\n  errsCount: s,\n  it: a\n}) {\n  if (undefined === s) throw new Error(\"ajv implementation error\");\n  const c = e.name(\"err\");\n  e.forRange(\"i\", s, i.default.errors, s => {\n    e.const(c, r._`${i.default.vErrors}[${s}]`);\n    e.if(r._`${c}.instancePath === undefined`, () => e.assign(r._`${c}.instancePath`, r.strConcat(i.default.instancePath, a.errorPath)));\n    e.assign(r._`${c}.schemaPath`, r.str`${a.errSchemaPath}/${t}`);\n    a.opts.verbose && (e.assign(r._`${c}.schema`, n), e.assign(r._`${c}.data`, o));\n  });\n};\nconst c = {\n  keyword: new r.Name(\"keyword\"),\n  schemaPath: new r.Name(\"schemaPath\"),\n  params: new r.Name(\"params\"),\n  propertyName: new r.Name(\"propertyName\"),\n  message: new r.Name(\"message\"),\n  schema: new r.Name(\"schema\"),\n  parentSchema: new r.Name(\"parentSchema\")\n};\nfunction l(e, t, n) {\n  const {\n    createErrors: o\n  } = e.it;\n  return !1 === o ? r._`{}` : function (e, t, n = {}) {\n    const {\n        gen: o,\n        it: s\n      } = e,\n      a = [u(s, n), d(e, n)];\n    (function (e, {\n      params: t,\n      message: n\n    }, o) {\n      const {\n          keyword: s,\n          data: a,\n          schemaValue: l,\n          it: u\n        } = e,\n        {\n          opts: d,\n          propertyName: p,\n          topSchemaRef: h,\n          schemaPath: f\n        } = u;\n      o.push([c.keyword, s], [c.params, \"function\" == typeof t ? t(e) : t || r._`{}`]);\n      d.messages && o.push([c.message, \"function\" == typeof n ? n(e) : n]);\n      d.verbose && o.push([c.schema, l], [c.parentSchema, r._`${h}${f}`], [i.default.data, a]);\n      p && o.push([c.propertyName, p]);\n    })(e, t, a);\n    return o.object(...a);\n  }(e, t, n);\n}\nfunction u({\n  errorPath: e\n}, {\n  instancePath: t\n}) {\n  const n = t ? r.str`${e}${o.getErrorPath(t, o.Type.Str)}` : e;\n  return [i.default.instancePath, r.strConcat(i.default.instancePath, n)];\n}\nfunction d({\n  keyword: e,\n  it: {\n    errSchemaPath: t\n  }\n}, {\n  schemaPath: n,\n  parentSchema: i\n}) {\n  let s = i ? t : r.str`${t}/${e}`;\n  n && (s = r.str`${s}${o.getErrorPath(n, o.Type.Str)}`);\n  return [c.schemaPath, s];\n}",
  "4193": "const r = require(6214),\n  {\n    Headers: o\n  } = require(9872),\n  i = e => ({\n    url: e.url,\n    method: e.method,\n    headers: e.headers.plain()\n  }),\n  s = e => ({\n    status: e.status,\n    headers: e.headers.plain()\n  });\nmodule.exports = class {\n  constructor(e, t, n) {\n    this.policy = new r(i(e), s(t), n);\n  }\n  storable() {\n    return this.policy.storable();\n  }\n  satisfiesWithoutRevalidation(e) {\n    return this.policy.satisfiesWithoutRevalidation(i(e));\n  }\n  responseHeaders(e) {\n    return new o(this.policy.responseHeaders(s(e)));\n  }\n  timeToLive() {\n    return this.policy.timeToLive();\n  }\n};",
  "4197": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.CopilotScheme = exports.CopilotConfigPrefix = undefined;\nexports.CopilotConfigPrefix = \"github.copilot\";\nexports.CopilotScheme = \"copilot\";",
  "4200": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"oneOf\",\n    schemaType: \"array\",\n    trackErrors: !0,\n    error: {\n      message: \"must match exactly one schema in oneOf\",\n      params: ({\n        params: e\n      }) => r._`{passingSchemas: ${e.passing}}`\n    },\n    code(e) {\n      const {\n        gen: t,\n        schema: n,\n        parentSchema: i,\n        it: s\n      } = e;\n      if (!Array.isArray(n)) throw new Error(\"ajv implementation error\");\n      if (s.opts.discriminator && i.discriminator) return;\n      const a = n,\n        c = t.let(\"valid\", !1),\n        l = t.let(\"passing\", null),\n        u = t.name(\"_valid\");\n      e.setParams({\n        passing: l\n      });\n      t.block(function () {\n        a.forEach((n, i) => {\n          let a;\n          o.alwaysValidSchema(s, n) ? t.var(u, !0) : a = e.subschema({\n            keyword: \"oneOf\",\n            schemaProp: i,\n            compositeRule: !0\n          }, u);\n          i > 0 && t.if(r._`${u} && ${c}`).assign(c, !1).assign(l, r._`[${l}, ${i}]`).else();\n          t.if(u, () => {\n            t.assign(c, !0);\n            t.assign(l, i);\n            a && e.mergeEvaluated(a, r.Name);\n          });\n        });\n      });\n      e.result(c, () => e.reset(), () => e.error(!0));\n    }\n  };\nexports.default = i;",
  "4242": "var r, o, i;\ni = require(8249);\nrequire(5109);\no = (r = i.lib.BlockCipherMode.extend()).Encryptor = r.extend({\n  processBlock: function (e, t) {\n    var n = this._cipher,\n      r = n.blockSize,\n      o = this._iv,\n      i = this._counter;\n    o && (i = this._counter = o.slice(0), this._iv = undefined);\n    var s = i.slice(0);\n    n.encryptBlock(s, 0);\n    i[r - 1] = i[r - 1] + 1 | 0;\n    for (var a = 0; a < r; a++) e[t + a] ^= s[a];\n  }\n});\nr.Decryptor = o;\ni.mode.CTR = r;\nmodule.exports = i.mode.CTR;",
  "4253": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib,\n    n = t.WordArray,\n    o = t.BlockCipher,\n    i = e.algo,\n    s = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4],\n    a = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32],\n    c = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28],\n    l = [{\n      0: 8421888,\n      268435456: 32768,\n      536870912: 8421378,\n      805306368: 2,\n      1073741824: 512,\n      1342177280: 8421890,\n      1610612736: 8389122,\n      1879048192: 8388608,\n      2147483648: 514,\n      2415919104: 8389120,\n      2684354560: 33280,\n      2952790016: 8421376,\n      3221225472: 32770,\n      3489660928: 8388610,\n      3758096384: 0,\n      4026531840: 33282,\n      134217728: 0,\n      402653184: 8421890,\n      671088640: 33282,\n      939524096: 32768,\n      1207959552: 8421888,\n      1476395008: 512,\n      1744830464: 8421378,\n      2013265920: 2,\n      2281701376: 8389120,\n      2550136832: 33280,\n      2818572288: 8421376,\n      3087007744: 8389122,\n      3355443200: 8388610,\n      3623878656: 32770,\n      3892314112: 514,\n      4160749568: 8388608,\n      1: 32768,\n      268435457: 2,\n      536870913: 8421888,\n      805306369: 8388608,\n      1073741825: 8421378,\n      1342177281: 33280,\n      1610612737: 512,\n      1879048193: 8389122,\n      2147483649: 8421890,\n      2415919105: 8421376,\n      2684354561: 8388610,\n      2952790017: 33282,\n      3221225473: 514,\n      3489660929: 8389120,\n      3758096385: 32770,\n      4026531841: 0,\n      134217729: 8421890,\n      402653185: 8421376,\n      671088641: 8388608,\n      939524097: 512,\n      1207959553: 32768,\n      1476395009: 8388610,\n      1744830465: 2,\n      2013265921: 33282,\n      2281701377: 32770,\n      2550136833: 8389122,\n      2818572289: 514,\n      3087007745: 8421888,\n      3355443201: 8389120,\n      3623878657: 0,\n      3892314113: 33280,\n      4160749569: 8421378\n    }, {\n      0: 1074282512,\n      16777216: 16384,\n      33554432: 524288,\n      50331648: 1074266128,\n      67108864: 1073741840,\n      83886080: 1074282496,\n      100663296: 1073758208,\n      117440512: 16,\n      134217728: 540672,\n      150994944: 1073758224,\n      167772160: 1073741824,\n      184549376: 540688,\n      201326592: 524304,\n      218103808: 0,\n      234881024: 16400,\n      251658240: 1074266112,\n      8388608: 1073758208,\n      25165824: 540688,\n      41943040: 16,\n      58720256: 1073758224,\n      75497472: 1074282512,\n      92274688: 1073741824,\n      109051904: 524288,\n      125829120: 1074266128,\n      142606336: 524304,\n      159383552: 0,\n      176160768: 16384,\n      192937984: 1074266112,\n      209715200: 1073741840,\n      226492416: 540672,\n      243269632: 1074282496,\n      260046848: 16400,\n      268435456: 0,\n      285212672: 1074266128,\n      301989888: 1073758224,\n      318767104: 1074282496,\n      335544320: 1074266112,\n      352321536: 16,\n      369098752: 540688,\n      385875968: 16384,\n      402653184: 16400,\n      419430400: 524288,\n      436207616: 524304,\n      452984832: 1073741840,\n      469762048: 540672,\n      486539264: 1073758208,\n      503316480: 1073741824,\n      520093696: 1074282512,\n      276824064: 540688,\n      293601280: 524288,\n      310378496: 1074266112,\n      327155712: 16384,\n      343932928: 1073758208,\n      360710144: 1074282512,\n      377487360: 16,\n      394264576: 1073741824,\n      411041792: 1074282496,\n      427819008: 1073741840,\n      444596224: 1073758224,\n      461373440: 524304,\n      478150656: 0,\n      494927872: 16400,\n      511705088: 1074266128,\n      528482304: 540672\n    }, {\n      0: 260,\n      1048576: 0,\n      2097152: 67109120,\n      3145728: 65796,\n      4194304: 65540,\n      5242880: 67108868,\n      6291456: 67174660,\n      7340032: 67174400,\n      8388608: 67108864,\n      9437184: 67174656,\n      10485760: 65792,\n      11534336: 67174404,\n      12582912: 67109124,\n      13631488: 65536,\n      14680064: 4,\n      15728640: 256,\n      524288: 67174656,\n      1572864: 67174404,\n      2621440: 0,\n      3670016: 67109120,\n      4718592: 67108868,\n      5767168: 65536,\n      6815744: 65540,\n      7864320: 260,\n      8912896: 4,\n      9961472: 256,\n      11010048: 67174400,\n      12058624: 65796,\n      13107200: 65792,\n      14155776: 67109124,\n      15204352: 67174660,\n      16252928: 67108864,\n      16777216: 67174656,\n      17825792: 65540,\n      18874368: 65536,\n      19922944: 67109120,\n      20971520: 256,\n      22020096: 67174660,\n      23068672: 67108868,\n      24117248: 0,\n      25165824: 67109124,\n      26214400: 67108864,\n      27262976: 4,\n      28311552: 65792,\n      29360128: 67174400,\n      30408704: 260,\n      31457280: 65796,\n      32505856: 67174404,\n      17301504: 67108864,\n      18350080: 260,\n      19398656: 67174656,\n      20447232: 0,\n      21495808: 65540,\n      22544384: 67109120,\n      23592960: 256,\n      24641536: 67174404,\n      25690112: 65536,\n      26738688: 67174660,\n      27787264: 65796,\n      28835840: 67108868,\n      29884416: 67109124,\n      30932992: 67174400,\n      31981568: 4,\n      33030144: 65792\n    }, {\n      0: 2151682048,\n      65536: 2147487808,\n      131072: 4198464,\n      196608: 2151677952,\n      262144: 0,\n      327680: 4198400,\n      393216: 2147483712,\n      458752: 4194368,\n      524288: 2147483648,\n      589824: 4194304,\n      655360: 64,\n      720896: 2147487744,\n      786432: 2151678016,\n      851968: 4160,\n      917504: 4096,\n      983040: 2151682112,\n      32768: 2147487808,\n      98304: 64,\n      163840: 2151678016,\n      229376: 2147487744,\n      294912: 4198400,\n      360448: 2151682112,\n      425984: 0,\n      491520: 2151677952,\n      557056: 4096,\n      622592: 2151682048,\n      688128: 4194304,\n      753664: 4160,\n      819200: 2147483648,\n      884736: 4194368,\n      950272: 4198464,\n      1015808: 2147483712,\n      1048576: 4194368,\n      1114112: 4198400,\n      1179648: 2147483712,\n      1245184: 0,\n      1310720: 4160,\n      1376256: 2151678016,\n      1441792: 2151682048,\n      1507328: 2147487808,\n      1572864: 2151682112,\n      1638400: 2147483648,\n      1703936: 2151677952,\n      1769472: 4198464,\n      1835008: 2147487744,\n      1900544: 4194304,\n      1966080: 64,\n      2031616: 4096,\n      1081344: 2151677952,\n      1146880: 2151682112,\n      1212416: 0,\n      1277952: 4198400,\n      1343488: 4194368,\n      1409024: 2147483648,\n      1474560: 2147487808,\n      1540096: 64,\n      1605632: 2147483712,\n      1671168: 4096,\n      1736704: 2147487744,\n      1802240: 2151678016,\n      1867776: 4160,\n      1933312: 2151682048,\n      1998848: 4194304,\n      2064384: 4198464\n    }, {\n      0: 128,\n      4096: 17039360,\n      8192: 262144,\n      12288: 536870912,\n      16384: 537133184,\n      20480: 16777344,\n      24576: 553648256,\n      28672: 262272,\n      32768: 16777216,\n      36864: 537133056,\n      40960: 536871040,\n      45056: 553910400,\n      49152: 553910272,\n      53248: 0,\n      57344: 17039488,\n      61440: 553648128,\n      2048: 17039488,\n      6144: 553648256,\n      10240: 128,\n      14336: 17039360,\n      18432: 262144,\n      22528: 537133184,\n      26624: 553910272,\n      30720: 536870912,\n      34816: 537133056,\n      38912: 0,\n      43008: 553910400,\n      47104: 16777344,\n      51200: 536871040,\n      55296: 553648128,\n      59392: 16777216,\n      63488: 262272,\n      65536: 262144,\n      69632: 128,\n      73728: 536870912,\n      77824: 553648256,\n      81920: 16777344,\n      86016: 553910272,\n      90112: 537133184,\n      94208: 16777216,\n      98304: 553910400,\n      102400: 553648128,\n      106496: 17039360,\n      110592: 537133056,\n      114688: 262272,\n      118784: 536871040,\n      122880: 0,\n      126976: 17039488,\n      67584: 553648256,\n      71680: 16777216,\n      75776: 17039360,\n      79872: 537133184,\n      83968: 536870912,\n      88064: 17039488,\n      92160: 128,\n      96256: 553910272,\n      100352: 262272,\n      104448: 553910400,\n      108544: 0,\n      112640: 553648128,\n      116736: 16777344,\n      120832: 262144,\n      124928: 537133056,\n      129024: 536871040\n    }, {\n      0: 268435464,\n      256: 8192,\n      512: 270532608,\n      768: 270540808,\n      1024: 268443648,\n      1280: 2097152,\n      1536: 2097160,\n      1792: 268435456,\n      2048: 0,\n      2304: 268443656,\n      2560: 2105344,\n      2816: 8,\n      3072: 270532616,\n      3328: 2105352,\n      3584: 8200,\n      3840: 270540800,\n      128: 270532608,\n      384: 270540808,\n      640: 8,\n      896: 2097152,\n      1152: 2105352,\n      1408: 268435464,\n      1664: 268443648,\n      1920: 8200,\n      2176: 2097160,\n      2432: 8192,\n      2688: 268443656,\n      2944: 270532616,\n      3200: 0,\n      3456: 270540800,\n      3712: 2105344,\n      3968: 268435456,\n      4096: 268443648,\n      4352: 270532616,\n      4608: 270540808,\n      4864: 8200,\n      5120: 2097152,\n      5376: 268435456,\n      5632: 268435464,\n      5888: 2105344,\n      6144: 2105352,\n      6400: 0,\n      6656: 8,\n      6912: 270532608,\n      7168: 8192,\n      7424: 268443656,\n      7680: 270540800,\n      7936: 2097160,\n      4224: 8,\n      4480: 2105344,\n      4736: 2097152,\n      4992: 268435464,\n      5248: 268443648,\n      5504: 8200,\n      5760: 270540808,\n      6016: 270532608,\n      6272: 270540800,\n      6528: 270532616,\n      6784: 8192,\n      7040: 2105352,\n      7296: 2097160,\n      7552: 0,\n      7808: 268435456,\n      8064: 268443656\n    }, {\n      0: 1048576,\n      16: 33555457,\n      32: 1024,\n      48: 1049601,\n      64: 34604033,\n      80: 0,\n      96: 1,\n      112: 34603009,\n      128: 33555456,\n      144: 1048577,\n      160: 33554433,\n      176: 34604032,\n      192: 34603008,\n      208: 1025,\n      224: 1049600,\n      240: 33554432,\n      8: 34603009,\n      24: 0,\n      40: 33555457,\n      56: 34604032,\n      72: 1048576,\n      88: 33554433,\n      104: 33554432,\n      120: 1025,\n      136: 1049601,\n      152: 33555456,\n      168: 34603008,\n      184: 1048577,\n      200: 1024,\n      216: 34604033,\n      232: 1,\n      248: 1049600,\n      256: 33554432,\n      272: 1048576,\n      288: 33555457,\n      304: 34603009,\n      320: 1048577,\n      336: 33555456,\n      352: 34604032,\n      368: 1049601,\n      384: 1025,\n      400: 34604033,\n      416: 1049600,\n      432: 1,\n      448: 0,\n      464: 34603008,\n      480: 33554433,\n      496: 1024,\n      264: 1049600,\n      280: 33555457,\n      296: 34603009,\n      312: 1,\n      328: 33554432,\n      344: 1048576,\n      360: 1025,\n      376: 34604032,\n      392: 33554433,\n      408: 34603008,\n      424: 0,\n      440: 34604033,\n      456: 1049601,\n      472: 1024,\n      488: 33555456,\n      504: 1048577\n    }, {\n      0: 134219808,\n      1: 131072,\n      2: 134217728,\n      3: 32,\n      4: 131104,\n      5: 134350880,\n      6: 134350848,\n      7: 2048,\n      8: 134348800,\n      9: 134219776,\n      10: 133120,\n      11: 134348832,\n      12: 2080,\n      13: 0,\n      14: 134217760,\n      15: 133152,\n      2147483648: 2048,\n      2147483649: 134350880,\n      2147483650: 134219808,\n      2147483651: 134217728,\n      2147483652: 134348800,\n      2147483653: 133120,\n      2147483654: 133152,\n      2147483655: 32,\n      2147483656: 134217760,\n      2147483657: 2080,\n      2147483658: 131104,\n      2147483659: 134350848,\n      2147483660: 0,\n      2147483661: 134348832,\n      2147483662: 134219776,\n      2147483663: 131072,\n      16: 133152,\n      17: 134350848,\n      18: 32,\n      19: 2048,\n      20: 134219776,\n      21: 134217760,\n      22: 134348832,\n      23: 131072,\n      24: 0,\n      25: 131104,\n      26: 134348800,\n      27: 134219808,\n      28: 134350880,\n      29: 133120,\n      30: 2080,\n      31: 134217728,\n      2147483664: 131072,\n      2147483665: 2048,\n      2147483666: 134348832,\n      2147483667: 133152,\n      2147483668: 32,\n      2147483669: 134348800,\n      2147483670: 134217728,\n      2147483671: 134219808,\n      2147483672: 134350880,\n      2147483673: 134217760,\n      2147483674: 134219776,\n      2147483675: 0,\n      2147483676: 133120,\n      2147483677: 2080,\n      2147483678: 131104,\n      2147483679: 134350848\n    }],\n    u = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679],\n    d = i.DES = o.extend({\n      _doReset: function () {\n        for (var e = this._key.words, t = [], n = 0; n < 56; n++) {\n          var r = s[n] - 1;\n          t[n] = e[r >>> 5] >>> 31 - r % 32 & 1;\n        }\n        for (var o = this._subKeys = [], i = 0; i < 16; i++) {\n          var l = o[i] = [],\n            u = c[i];\n          for (n = 0; n < 24; n++) {\n            l[n / 6 | 0] |= t[(a[n] - 1 + u) % 28] << 31 - n % 6;\n            l[4 + (n / 6 | 0)] |= t[28 + (a[n + 24] - 1 + u) % 28] << 31 - n % 6;\n          }\n          for (l[0] = l[0] << 1 | l[0] >>> 31, n = 1; n < 7; n++) l[n] = l[n] >>> 4 * (n - 1) + 3;\n          l[7] = l[7] << 5 | l[7] >>> 27;\n        }\n        var d = this._invSubKeys = [];\n        for (n = 0; n < 16; n++) d[n] = o[15 - n];\n      },\n      encryptBlock: function (e, t) {\n        this._doCryptBlock(e, t, this._subKeys);\n      },\n      decryptBlock: function (e, t) {\n        this._doCryptBlock(e, t, this._invSubKeys);\n      },\n      _doCryptBlock: function (e, t, n) {\n        this._lBlock = e[t];\n        this._rBlock = e[t + 1];\n        p.call(this, 4, 252645135);\n        p.call(this, 16, 65535);\n        h.call(this, 2, 858993459);\n        h.call(this, 8, 16711935);\n        p.call(this, 1, 1431655765);\n        for (var r = 0; r < 16; r++) {\n          for (var o = n[r], i = this._lBlock, s = this._rBlock, a = 0, c = 0; c < 8; c++) a |= l[c][((s ^ o[c]) & u[c]) >>> 0];\n          this._lBlock = s;\n          this._rBlock = i ^ a;\n        }\n        var d = this._lBlock;\n        this._lBlock = this._rBlock;\n        this._rBlock = d;\n        p.call(this, 1, 1431655765);\n        h.call(this, 8, 16711935);\n        h.call(this, 2, 858993459);\n        p.call(this, 16, 65535);\n        p.call(this, 4, 252645135);\n        e[t] = this._lBlock;\n        e[t + 1] = this._rBlock;\n      },\n      keySize: 2,\n      ivSize: 2,\n      blockSize: 2\n    });\n  function p(e, t) {\n    var n = (this._lBlock >>> e ^ this._rBlock) & t;\n    this._rBlock ^= n;\n    this._lBlock ^= n << e;\n  }\n  function h(e, t) {\n    var n = (this._rBlock >>> e ^ this._lBlock) & t;\n    this._lBlock ^= n;\n    this._rBlock ^= n << e;\n  }\n  e.DES = o._createHelper(d);\n  var f = i.TripleDES = o.extend({\n    _doReset: function () {\n      var e = this._key.words;\n      if (2 !== e.length && 4 !== e.length && e.length < 6) throw new Error(\"Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.\");\n      var t = e.slice(0, 2),\n        r = e.length < 4 ? e.slice(0, 2) : e.slice(2, 4),\n        o = e.length < 6 ? e.slice(0, 2) : e.slice(4, 6);\n      this._des1 = d.createEncryptor(n.create(t));\n      this._des2 = d.createEncryptor(n.create(r));\n      this._des3 = d.createEncryptor(n.create(o));\n    },\n    encryptBlock: function (e, t) {\n      this._des1.encryptBlock(e, t);\n      this._des2.decryptBlock(e, t);\n      this._des3.encryptBlock(e, t);\n    },\n    decryptBlock: function (e, t) {\n      this._des3.decryptBlock(e, t);\n      this._des2.encryptBlock(e, t);\n      this._des1.decryptBlock(e, t);\n    },\n    keySize: 6,\n    ivSize: 2,\n    blockSize: 2\n  });\n  e.TripleDES = o._createHelper(f);\n})();\nmodule.exports = r.TripleDES;",
  "4300": "module.exports = require(\"buffer\");",
  "4309": "var r = require(5290),\n  o = require(4953),\n  i = [],\n  s = function (e) {\n    var t = e.data.message;\n    i.forEach(function (n) {\n      t instanceof Error ? n.trackException({\n        exception: t\n      }) : (t.lastIndexOf(\"\\n\") == t.length - 1 && (t = t.substring(0, t.length - 1)), n.trackTrace({\n        message: t,\n        severity: e.data.stderr ? r.SeverityLevel.Warning : r.SeverityLevel.Information\n      }));\n    });\n  };\nexports.wp = function (e, t) {\n  e ? (0 === i.length && o.channel.subscribe(\"console\", s), i.push(t)) : 0 === (i = i.filter(function (e) {\n    return e != t;\n  })).length && o.channel.unsubscribe(\"console\", s);\n};",
  "4336": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(412),\n  o = require(3487),\n  i = {\n    keyword: \"pattern\",\n    type: \"string\",\n    schemaType: \"string\",\n    $data: !0,\n    error: {\n      message: ({\n        schemaCode: e\n      }) => o.str`must match pattern \"${e}\"`,\n      params: ({\n        schemaCode: e\n      }) => o._`{pattern: ${e}}`\n    },\n    code(e) {\n      const {\n          data: t,\n          $data: n,\n          schema: i,\n          schemaCode: s,\n          it: a\n        } = e,\n        c = a.opts.unicodeRegExp ? \"u\" : \"\",\n        l = n ? o._`(new RegExp(${s}, ${c}))` : r.usePattern(e, i);\n      e.fail$data(o._`!${l}.test(${t})`);\n    }\n  };\nexports.default = i;",
  "4350": "var r = require(2037),\n  o = require(3580),\n  i = function () {\n    function e(t, n, r) {\n      undefined === n && (n = 6e4);\n      undefined === r && (r = !1);\n      this._lastIntervalRequestExecutionTime = 0;\n      this._lastIntervalDependencyExecutionTime = 0;\n      e.INSTANCE || (e.INSTANCE = this);\n      this._isInitialized = !1;\n      this._client = t;\n      this._collectionInterval = n;\n      this._enableLiveMetricsCounters = r;\n    }\n    e.prototype.enable = function (t, n) {\n      var o = this;\n      this._isEnabled = t;\n      this._isEnabled && !this._isInitialized && (this._isInitialized = !0);\n      t ? this._handle || (this._lastCpus = r.cpus(), this._lastRequests = {\n        totalRequestCount: e._totalRequestCount,\n        totalFailedRequestCount: e._totalFailedRequestCount,\n        time: +new Date()\n      }, this._lastDependencies = {\n        totalDependencyCount: e._totalDependencyCount,\n        totalFailedDependencyCount: e._totalFailedDependencyCount,\n        time: +new Date()\n      }, this._lastExceptions = {\n        totalExceptionCount: e._totalExceptionCount,\n        time: +new Date()\n      }, \"function\" == typeof process.cpuUsage && (this._lastAppCpuUsage = process.cpuUsage()), this._lastHrtime = process.hrtime(), this._collectionInterval = n || this._collectionInterval, this._handle = setInterval(function () {\n        return o.trackPerformance();\n      }, this._collectionInterval), this._handle.unref()) : this._handle && (clearInterval(this._handle), this._handle = undefined);\n    };\n    e.countRequest = function (t, n) {\n      var r;\n      if (e.isEnabled()) {\n        if (\"string\" == typeof t) r = +new Date(\"1970-01-01T\" + t + \"Z\");else {\n          if (\"number\" != typeof t) return;\n          r = t;\n        }\n        e._intervalRequestExecutionTime += r;\n        !1 === n && e._totalFailedRequestCount++;\n        e._totalRequestCount++;\n      }\n    };\n    e.countException = function () {\n      e._totalExceptionCount++;\n    };\n    e.countDependency = function (t, n) {\n      var r;\n      if (e.isEnabled()) {\n        if (\"string\" == typeof t) r = +new Date(\"1970-01-01T\" + t + \"Z\");else {\n          if (\"number\" != typeof t) return;\n          r = t;\n        }\n        e._intervalDependencyExecutionTime += r;\n        !1 === n && e._totalFailedDependencyCount++;\n        e._totalDependencyCount++;\n      }\n    };\n    e.prototype.isInitialized = function () {\n      return this._isInitialized;\n    };\n    e.isEnabled = function () {\n      return e.INSTANCE && e.INSTANCE._isEnabled;\n    };\n    e.prototype.trackPerformance = function () {\n      this._trackCpu();\n      this._trackMemory();\n      this._trackNetwork();\n      this._trackDependencyRate();\n      this._trackExceptionRate();\n    };\n    e.prototype._trackCpu = function () {\n      var e = r.cpus();\n      if (e && e.length && this._lastCpus && e.length === this._lastCpus.length) {\n        for (var t = 0, n = 0, i = 0, s = 0, a = 0, c = 0; e && c < e.length; c++) {\n          var l = e[c],\n            u = this._lastCpus[c],\n            d = (l.model, l.speed, l.times),\n            p = u.times;\n          t += d.user - p.user || 0;\n          n += d.sys - p.sys || 0;\n          i += d.nice - p.nice || 0;\n          s += d.idle - p.idle || 0;\n          a += d.irq - p.irq || 0;\n        }\n        var h = undefined;\n        if (\"function\" == typeof process.cpuUsage) {\n          var f = process.cpuUsage(),\n            m = process.hrtime(),\n            g = f.user - this._lastAppCpuUsage.user + (f.system - this._lastAppCpuUsage.system) || 0;\n          undefined !== this._lastHrtime && 2 === this._lastHrtime.length && (h = 100 * g / ((1e6 * (m[0] - this._lastHrtime[0]) + (m[1] - this._lastHrtime[1]) / 1e3 || 0) * e.length));\n          this._lastAppCpuUsage = f;\n          this._lastHrtime = m;\n        }\n        var _ = t + n + i + s + a || 1;\n        this._client.trackMetric({\n          name: o.PerformanceCounter.PROCESSOR_TIME,\n          value: (_ - s) / _ * 100\n        });\n        this._client.trackMetric({\n          name: o.PerformanceCounter.PROCESS_TIME,\n          value: h || t / _ * 100\n        });\n      }\n      this._lastCpus = e;\n    };\n    e.prototype._trackMemory = function () {\n      var e = r.freemem(),\n        t = process.memoryUsage().rss,\n        n = r.totalmem() - e;\n      this._client.trackMetric({\n        name: o.PerformanceCounter.PRIVATE_BYTES,\n        value: t\n      });\n      this._client.trackMetric({\n        name: o.PerformanceCounter.AVAILABLE_BYTES,\n        value: e\n      });\n      this._enableLiveMetricsCounters && this._client.trackMetric({\n        name: o.QuickPulseCounter.COMMITTED_BYTES,\n        value: n\n      });\n    };\n    e.prototype._trackNetwork = function () {\n      var t = this._lastRequests,\n        n = {\n          totalRequestCount: e._totalRequestCount,\n          totalFailedRequestCount: e._totalFailedRequestCount,\n          time: +new Date()\n        },\n        r = n.totalRequestCount - t.totalRequestCount || 0,\n        i = n.totalFailedRequestCount - t.totalFailedRequestCount || 0,\n        s = n.time - t.time,\n        a = s / 1e3,\n        c = (e._intervalRequestExecutionTime - this._lastIntervalRequestExecutionTime) / r || 0;\n      this._lastIntervalRequestExecutionTime = e._intervalRequestExecutionTime;\n      if (s > 0) {\n        var l = r / a,\n          u = i / a;\n        this._client.trackMetric({\n          name: o.PerformanceCounter.REQUEST_RATE,\n          value: l\n        }), (!this._enableLiveMetricsCounters || r > 0) && this._client.trackMetric({\n          name: o.PerformanceCounter.REQUEST_DURATION,\n          value: c\n        }), this._enableLiveMetricsCounters && this._client.trackMetric({\n          name: o.QuickPulseCounter.REQUEST_FAILURE_RATE,\n          value: u\n        });\n      }\n      this._lastRequests = n;\n    };\n    e.prototype._trackDependencyRate = function () {\n      if (this._enableLiveMetricsCounters) {\n        var t = this._lastDependencies,\n          n = {\n            totalDependencyCount: e._totalDependencyCount,\n            totalFailedDependencyCount: e._totalFailedDependencyCount,\n            time: +new Date()\n          },\n          r = n.totalDependencyCount - t.totalDependencyCount || 0,\n          i = n.totalFailedDependencyCount - t.totalFailedDependencyCount || 0,\n          s = n.time - t.time,\n          a = s / 1e3,\n          c = (e._intervalDependencyExecutionTime - this._lastIntervalDependencyExecutionTime) / r || 0;\n        this._lastIntervalDependencyExecutionTime = e._intervalDependencyExecutionTime;\n        if (s > 0) {\n          var l = r / a,\n            u = i / a;\n          this._client.trackMetric({\n            name: o.QuickPulseCounter.DEPENDENCY_RATE,\n            value: l\n          }), this._client.trackMetric({\n            name: o.QuickPulseCounter.DEPENDENCY_FAILURE_RATE,\n            value: u\n          }), (!this._enableLiveMetricsCounters || r > 0) && this._client.trackMetric({\n            name: o.QuickPulseCounter.DEPENDENCY_DURATION,\n            value: c\n          });\n        }\n        this._lastDependencies = n;\n      }\n    };\n    e.prototype._trackExceptionRate = function () {\n      if (this._enableLiveMetricsCounters) {\n        var t = this._lastExceptions,\n          n = {\n            totalExceptionCount: e._totalExceptionCount,\n            time: +new Date()\n          },\n          r = n.totalExceptionCount - t.totalExceptionCount || 0,\n          i = n.time - t.time;\n        if (i > 0) {\n          var s = r / (i / 1e3);\n          this._client.trackMetric({\n            name: o.QuickPulseCounter.EXCEPTION_RATE,\n            value: s\n          });\n        }\n        this._lastExceptions = n;\n      }\n    };\n    e.prototype.dispose = function () {\n      e.INSTANCE = null;\n      this.enable(!1);\n      this._isInitialized = !1;\n    };\n    e._totalRequestCount = 0;\n    e._totalFailedRequestCount = 0;\n    e._lastRequestExecutionTime = 0;\n    e._totalDependencyCount = 0;\n    e._totalFailedDependencyCount = 0;\n    e._lastDependencyExecutionTime = 0;\n    e._totalExceptionCount = 0;\n    e._intervalDependencyExecutionTime = 0;\n    e._intervalRequestExecutionTime = 0;\n    return e;\n  }();\nmodule.exports = i;",
  "4398": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nprocess.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL = !0;\nvar r = require(7147),\n  o = require(2037),\n  i = require(1017),\n  s = require(9496),\n  a = require(9574),\n  c = function () {\n    function e(e, t, n, o) {\n      var a = this;\n      this.extensionId = e;\n      this.extensionVersion = t;\n      this.firstParty = !1;\n      this.userOptIn = !1;\n      this.firstParty = !!o;\n      var c = process.env.VSCODE_LOGS || \"\";\n      c && e && \"trace\" === process.env.VSCODE_LOG_LEVEL && (c = i.join(c, e + \".txt\"), this.logStream = r.createWriteStream(c, {\n        flags: \"a\",\n        encoding: \"utf8\",\n        autoClose: !0\n      }));\n      this.updateUserOptIn(n);\n      undefined !== s.env.onDidChangeTelemetryEnabled ? this.optOutListener = s.env.onDidChangeTelemetryEnabled(function () {\n        return a.updateUserOptIn(n);\n      }) : this.optOutListener = s.workspace.onDidChangeConfiguration(function () {\n        return a.updateUserOptIn(n);\n      });\n    }\n    e.prototype.updateUserOptIn = function (t) {\n      var n = s.workspace.getConfiguration(e.TELEMETRY_CONFIG_ID),\n        r = undefined === s.env.isTelemetryEnabled ? n.get(e.TELEMETRY_CONFIG_ENABLED_ID, !0) : s.env.isTelemetryEnabled;\n      this.userOptIn !== r && (this.userOptIn = r, this.userOptIn ? this.createAppInsightsClient(t) : this.dispose());\n    };\n    e.prototype.createAppInsightsClient = function (e) {\n      a.defaultClient ? (this.appInsightsClient = new a.TelemetryClient(e), this.appInsightsClient.channel.setUseDiskRetryCaching(!0)) : (a.setup(e).setAutoCollectRequests(!1).setAutoCollectPerformance(!1).setAutoCollectExceptions(!1).setAutoCollectDependencies(!1).setAutoDependencyCorrelation(!1).setAutoCollectConsole(!1).setUseDiskRetryCaching(!0).start(), this.appInsightsClient = a.defaultClient);\n      this.appInsightsClient.commonProperties = this.getCommonProperties();\n      s && s.env && (this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.userId] = s.env.machineId, this.appInsightsClient.context.tags[this.appInsightsClient.context.keys.sessionId] = s.env.sessionId);\n      e && 0 === e.indexOf(\"AIF-\") && (this.appInsightsClient.config.endpointUrl = \"https://vortex.data.microsoft.com/collect/v1\", this.firstParty = !0);\n    };\n    e.prototype.getCommonProperties = function () {\n      var e = Object.create(null);\n      e[\"common.os\"] = o.platform();\n      e[\"common.platformversion\"] = (o.release() || \"\").replace(/^(\\d+)(\\.\\d+)?(\\.\\d+)?(.*)/, \"$1$2$3\");\n      e[\"common.extname\"] = this.extensionId;\n      e[\"common.extversion\"] = this.extensionVersion;\n      if (s && s.env) {\n        switch (e[\"common.vscodemachineid\"] = s.env.machineId, e[\"common.vscodesessionid\"] = s.env.sessionId, e[\"common.vscodeversion\"] = s.version, e[\"common.isnewappinstall\"] = s.env.isNewAppInstall, s.env.uiKind) {\n          case s.UIKind.Web:\n            e[\"common.uikind\"] = \"web\";\n            break;\n          case s.UIKind.Desktop:\n            e[\"common.uikind\"] = \"desktop\";\n            break;\n          default:\n            e[\"common.uikind\"] = \"unknown\";\n        }\n        e[\"common.remotename\"] = this.cleanRemoteName(s.env.remoteName);\n      }\n      return e;\n    };\n    e.prototype.cleanRemoteName = function (e) {\n      if (!e) return \"none\";\n      var t = \"other\";\n      [\"ssh-remote\", \"dev-container\", \"attached-container\", \"wsl\"].forEach(function (n) {\n        0 === e.indexOf(n + \"+\") && (t = n);\n      });\n      return t;\n    };\n    e.prototype.shouldSendErrorTelemetry = function () {\n      return !this.firstParty || \"other\" !== this.cleanRemoteName(s.env.remoteName) || undefined !== this.extension && this.extension.extensionKind !== s.ExtensionKind.Workspace && s.env.uiKind !== s.UIKind.Web;\n    };\n    Object.defineProperty(e.prototype, \"extension\", {\n      get: function () {\n        undefined === this._extension && (this._extension = s.extensions.getExtension(this.extensionId));\n        return this._extension;\n      },\n      enumerable: !1,\n      configurable: !0\n    });\n    e.prototype.cloneAndChange = function (e, t) {\n      if (null === e || \"object\" != typeof e) return e;\n      if (\"function\" != typeof t) return e;\n      var n = {};\n      for (var r in e) n[r] = t(r, e[r]);\n      return n;\n    };\n    e.prototype.anonymizeFilePaths = function (e, t) {\n      if (null == e) return \"\";\n      var n = [new RegExp(s.env.appRoot.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"gi\")];\n      this.extension && n.push(new RegExp(this.extension.extensionPath.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"gi\"));\n      var r = e;\n      if (t) {\n        for (var o = [], i = 0, a = n; i < a.length; i++) for (var c = a[i];;) {\n          var l = c.exec(e);\n          if (!l) break;\n          o.push([l.index, c.lastIndex]);\n        }\n        var u = /^[\\\\\\/]?(node_modules|node_modules\\.asar)[\\\\\\/]/,\n          d = /(file:\\/\\/)?([a-zA-Z]:(\\\\\\\\|\\\\|\\/)|(\\\\\\\\|\\\\|\\/))?([\\w-\\._]+(\\\\\\\\|\\\\|\\/))+[\\w-\\._]*/g,\n          p = 0;\n        r = \"\";\n        for (var h = function () {\n          var t = d.exec(e);\n          if (!t) return \"break\";\n          !u.test(t[0]) && o.every(function (e) {\n            var n = e[0],\n              r = e[1];\n            return t.index < n || t.index >= r;\n          }) && (r += e.substring(p, t.index) + \"<REDACTED: user-file-path>\", p = d.lastIndex);\n        }; \"break\" !== h(););\n        p < e.length && (r += e.substr(p));\n      }\n      for (var f = 0, m = n; f < m.length; f++) {\n        c = m[f];\n        r = r.replace(c, \"\");\n      }\n      return r;\n    };\n    e.prototype.sendTelemetryEvent = function (e, t, n) {\n      var r = this;\n      if (this.userOptIn && e && this.appInsightsClient) {\n        var o = this.cloneAndChange(t, function (e, t) {\n          return r.anonymizeFilePaths(t, r.firstParty);\n        });\n        this.appInsightsClient.trackEvent({\n          name: this.extensionId + \"/\" + e,\n          properties: o,\n          measurements: n\n        });\n        this.logStream && this.logStream.write(\"telemetry/\" + e + \" \" + JSON.stringify({\n          properties: t,\n          measurements: n\n        }) + \"\\n\");\n      }\n    };\n    e.prototype.sendTelemetryErrorEvent = function (e, t, n, r) {\n      var o = this;\n      if (this.userOptIn && e && this.appInsightsClient) {\n        var i = this.cloneAndChange(t, function (e, t) {\n          return o.shouldSendErrorTelemetry() ? o.anonymizeFilePaths(t, o.firstParty) : undefined === r || -1 !== r.indexOf(e) ? \"REDACTED\" : o.anonymizeFilePaths(t, o.firstParty);\n        });\n        this.appInsightsClient.trackEvent({\n          name: this.extensionId + \"/\" + e,\n          properties: i,\n          measurements: n\n        });\n        this.logStream && this.logStream.write(\"telemetry/\" + e + \" \" + JSON.stringify({\n          properties: t,\n          measurements: n\n        }) + \"\\n\");\n      }\n    };\n    e.prototype.sendTelemetryException = function (e, t, n) {\n      var r = this;\n      if (this.shouldSendErrorTelemetry() && this.userOptIn && e && this.appInsightsClient) {\n        var o = this.cloneAndChange(t, function (e, t) {\n          return r.anonymizeFilePaths(t, r.firstParty);\n        });\n        this.appInsightsClient.trackException({\n          exception: e,\n          properties: o,\n          measurements: n\n        });\n        this.logStream && this.logStream.write(\"telemetry/\" + e.name + \" \" + e.message + \" \" + JSON.stringify({\n          properties: t,\n          measurements: n\n        }) + \"\\n\");\n      }\n    };\n    e.prototype.dispose = function () {\n      var e = this;\n      this.optOutListener.dispose();\n      var t = new Promise(function (t) {\n          if (!e.logStream) return t(undefined);\n          e.logStream.on(\"finish\", t);\n          e.logStream.end();\n        }),\n        n = new Promise(function (t) {\n          e.appInsightsClient ? e.appInsightsClient.flush({\n            callback: function () {\n              e.appInsightsClient = undefined;\n              t(undefined);\n            }\n          }) : t(undefined);\n        });\n      return Promise.all([n, t]);\n    };\n    e.TELEMETRY_CONFIG_ID = \"telemetry\";\n    e.TELEMETRY_CONFIG_ENABLED_ID = \"enableTelemetry\";\n    return e;\n  }();\nexports.default = c;",
  "4404": "module.exports = require(\"tls\");",
  "4419": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.LiveOpenAIFetcher = exports.postProcessChoices = exports.OpenAIFetcher = exports.extractEngineName = exports.getProcessingTime = exports.getRequestId = exports.CopilotUiKind = undefined;\nconst r = require(3837),\n  o = require(362),\n  i = require(6932),\n  s = require(1133),\n  a = require(9189),\n  c = require(5413),\n  l = require(9899),\n  u = require(2279),\n  d = require(6722),\n  p = require(766),\n  h = require(9657),\n  f = require(6333),\n  m = require(937),\n  g = require(2901),\n  _ = new l.Logger(l.LogLevel.INFO, \"fetch\");\nvar y;\nfunction getRequestId(e, t) {\n  return {\n    headerRequestId: e.headers.get(\"x-request-id\") || \"\",\n    completionId: t && t.id ? t.id : \"\",\n    created: t && t.created ? t.created : 0,\n    serverExperiments: e.headers.get(\"X-Copilot-Experiment\") || \"\",\n    deploymentId: e.headers.get(\"azureml-model-deployment\") || \"\"\n  };\n}\nfunction getProcessingTime(e) {\n  const t = e.headers.get(\"openai-processing-ms\");\n  return t ? parseInt(t, 10) : 0;\n}\nfunction extractEngineName(e, t) {\n  return t.split(\"/\").pop() || (_.error(e, \"Malformed engine URL: \" + t), t);\n}\n!function (e) {\n  e.GhostText = \"ghostText\";\n  e.Panel = \"synthesize\";\n}(y = exports.CopilotUiKind || (exports.CopilotUiKind = {}));\nexports.getRequestId = getRequestId;\nexports.getProcessingTime = getProcessingTime;\nexports.extractEngineName = extractEngineName;\nclass OpenAIFetcher {}\nfunction postProcessChoices(e, t) {\n  return null != t && t ? e : i.asyncIterableFilter(e, async e => e.completionText.trim().length > 0);\n}\nexports.OpenAIFetcher = OpenAIFetcher;\nexports.postProcessChoices = postProcessChoices;\nexports.LiveOpenAIFetcher = class extends OpenAIFetcher {\n  async fetchAndStreamCompletions(e, t, n, r, o) {\n    const s = e.get(d.StatusReporter),\n      a = \"completions\",\n      c = await this.fetchWithParameters(e, a, t, o);\n    if (\"not-sent\" === c) return {\n      type: \"canceled\",\n      reason: \"before fetch request\"\n    };\n    if (null == o ? undefined : o.isCancellationRequested) {\n      const t = await c.body();\n      try {\n        t.destroy();\n      } catch (t) {\n        l.logger.error(e, `Error destroying stream: ${t}`);\n      }\n      return {\n        type: \"canceled\",\n        reason: \"after fetch request\"\n      };\n    }\n    if (undefined === c) {\n      const n = this.createTelemetryData(a, e, t);\n      s.setWarning();\n      n.properties.error = \"Response was undefined\";\n      f.telemetry(e, \"request.shownWarning\", n);\n      return {\n        type: \"failed\",\n        reason: \"fetch response was undefined\"\n      };\n    }\n    if (200 !== c.status) {\n      const n = this.createTelemetryData(a, e, t);\n      return this.handleError(e, s, n, c);\n    }\n    return {\n      type: \"success\",\n      choices: postProcessChoices(i.asyncIterableMap(g.processSSE(e, c, r, n, o), async t => g.prepareSolutionForReturn(e, t, n)), t.allowEmptyChoices),\n      getProcessingTime: () => getProcessingTime(c)\n    };\n  }\n  createTelemetryData(e, t, n) {\n    return f.TelemetryData.createAndMarkAsIssued({\n      endpoint: e,\n      engineName: extractEngineName(t, n.engineUrl),\n      uiKind: n.uiKind,\n      headerRequestId: n.ourRequestId\n    });\n  }\n  async fetchWithParameters(e, t, n, i) {\n    var g;\n    const _ = s.getLanguageConfig(e, s.ConfigKey.Stops),\n      b = await e.get(a.Features).disableLogProb(),\n      x = {\n        prompt: n.prompt.prefix,\n        suffix: n.prompt.suffix,\n        max_tokens: s.getConfig(e, s.ConfigKey.SolutionLength),\n        temperature: m.getTemperatureForSamples(e, n.count),\n        top_p: s.getConfig(e, s.ConfigKey.TopP),\n        n: n.count,\n        stop: _\n      };\n    !n.requestLogProbs && b || (x.logprobs = 2);\n    const E = p.tryGetGitHubNWO(n.repoInfo);\n    undefined !== E && (x.nwo = E);\n    [h.RepetitionFilterMode.PROXY, h.RepetitionFilterMode.BOTH].includes(await e.get(a.Features).repetitionFilterMode()) && (x.feature_flags = [...(null !== (g = x.feature_flags) && undefined !== g ? g : []), \"filter-repetitions\"]);\n    n.postOptions && Object.assign(x, n.postOptions);\n    return (null == i ? undefined : i.isCancellationRequested) ? \"not-sent\" : (l.logger.info(e, `[fetchCompletions] engine ${n.engineUrl}`), await function (e, t, n, o, i, s, a, p, h) {\n      var m;\n      const g = e.get(d.StatusReporter),\n        _ = r.format(\"%s/%s\", n, o);\n      if (!a) return void l.logger.error(e, `Failed to send request to ${_} due to missing key`);\n      const b = f.TelemetryData.createAndMarkAsIssued({\n        endpoint: o,\n        engineName: extractEngineName(e, n),\n        uiKind: p\n      }, f.telemetrizePromptLength(t));\n      for (const [e, t] of Object.entries(s)) \"prompt\" != e && \"suffix\" != e && (b.properties[`request.option.${e}`] = null !== (m = JSON.stringify(t)) && undefined !== m ? m : \"undefined\");\n      b.properties.headerRequestId = i;\n      f.telemetry(e, \"request.sent\", b);\n      const x = f.now(),\n        E = function (e) {\n          switch (e) {\n            case y.GhostText:\n              return \"copilot-ghost\";\n            case y.Panel:\n              return \"copilot-panel\";\n          }\n        }(p);\n      return u.postRequest(e, _, a, E, i, s, h).then(n => {\n        const r = getRequestId(n, undefined);\n        b.extendWithRequestId(r);\n        const o = f.now() - x;\n        b.measurements.totalTimeMs = o;\n        l.logger.info(e, `request.response: [${_}] took ${o} ms`);\n        l.logger.debug(e, \"request.response properties\", b.properties);\n        l.logger.debug(e, \"request.response measurements\", b.measurements);\n        l.logger.debug(e, `prompt: ${JSON.stringify(t)}`);\n        f.telemetry(e, \"request.response\", b);\n        const i = n.headers.get(\"x-copilot-delay\"),\n          s = i ? parseInt(i, 10) : 0;\n        e.get(c.GhostTextDebounceManager).extraDebounceMs = s;\n        return n;\n      }).catch(t => {\n        var n, r, o, i;\n        if (u.isAbortError(t)) throw t;\n        g.setWarning();\n        const s = b.extendedBy({\n          error: \"Network exception\"\n        });\n        f.telemetry(e, \"request.shownWarning\", s);\n        b.properties.code = String(null !== (n = t.code) && undefined !== n ? n : \"\");\n        b.properties.errno = String(null !== (r = t.errno) && undefined !== r ? r : \"\");\n        b.properties.message = String(null !== (o = t.message) && undefined !== o ? o : \"\");\n        b.properties.type = String(null !== (i = t.type) && undefined !== i ? i : \"\");\n        const a = f.now() - x;\n        throw b.measurements.totalTimeMs = a, l.logger.debug(e, `request.response: [${_}] took ${a} ms`), l.logger.debug(e, \"request.error properties\", b.properties), l.logger.debug(e, \"request.error measurements\", b.measurements), l.logger.error(e, `Request Error: ${t.message}`), f.telemetry(e, \"request.error\", b), t;\n      }).finally(() => {\n        f.logEnginePrompt(e, t, b);\n      });\n    }(e, n.prompt, n.engineUrl, t, n.ourRequestId, x, (await e.get(o.CopilotTokenManager).getCopilotToken(e)).token, n.uiKind, i));\n  }\n  async handleError(e, t, n, r) {\n    t.setWarning();\n    n.properties.error = `Response status was ${r.status}`;\n    n.properties.status = String(r.status);\n    f.telemetry(e, \"request.shownWarning\", n);\n    if (401 === r.status || 403 === r.status) return e.get(o.CopilotTokenManager).resetCopilotToken(e, r.status), {\n      type: \"failed\",\n      reason: `token expired or invalid: ${r.status}`\n    };\n    if (499 === r.status) {\n      _.info(e, \"Cancelled by server\");\n      return {\n        type: \"failed\",\n        reason: \"canceled by server\"\n      };\n    }\n    const i = await r.text();\n    return 466 === r.status ? (t.setError(i), _.info(e, i), {\n      type: \"failed\",\n      reason: `client not supported: ${i}`\n    }) : (_.error(e, \"Unhandled status from server:\", r.status, i), {\n      type: \"failed\",\n      reason: `unhandled status from server: ${r.status} ${i}`\n    });\n  }\n};",
  "4428": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.activate = undefined;\nconst r = require(4398),\n  o = require(1133),\n  i = require(6333),\n  s = require(9380);\nfunction a(e, t, n, o, a) {\n  const c = new r.default(t, n, o);\n  s.setupExperimentationService(e);\n  i.configureReporter(e, c);\n  return c;\n}\nexports.activate = function (e, t) {\n  const n = t.extension.packageJSON.name,\n    r = o.getVersion(e),\n    s = a(e, n, r, i.APP_INSIGHTS_KEY, t.globalState),\n    c = a(e, n, r, i.APP_INSIGHTS_KEY_SECURE, t.globalState);\n  t.subscriptions.push(s);\n  t.subscriptions.push(c);\n  return new i.TelemetryReporters(s, c);\n};",
  "4431": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.findEditDistanceScore = undefined;\nconst r = require(9852);\nexports.findEditDistanceScore = function (e, t) {\n  \"string\" == typeof e && (e = r.tokenize(e));\n  \"string\" == typeof t && (t = r.tokenize(t));\n  if (0 === e.length || 0 === t.length) return {\n    score: e.length + t.length\n  };\n  const n = Array.from({\n    length: e.length\n  }).map(() => Array.from({\n    length: t.length\n  }).map(() => 0));\n  for (let t = 0; t < e.length; t++) n[t][0] = t;\n  for (let e = 0; e < t.length; e++) n[0][e] = e;\n  for (let r = 0; r < t.length; r++) for (let o = 0; o < e.length; o++) n[o][r] = Math.min((0 == o ? r : n[o - 1][r]) + 1, (0 == r ? o : n[o][r - 1]) + 1, (0 == o || 0 == r ? Math.max(o, r) : n[o - 1][r - 1]) + (e[o] == t[r] ? 0 : 1));\n  return {\n    score: n[e.length - 1][t.length - 1]\n  };\n};",
  "4433": "var r = require(6400),\n  o = require(2728),\n  i = require(8213).I,\n  s = require(1188).H;\nfunction h(e) {\n  e || (e = {});\n  this._file = o.getArg(e, \"file\", null);\n  this._sourceRoot = o.getArg(e, \"sourceRoot\", null);\n  this._skipValidation = o.getArg(e, \"skipValidation\", !1);\n  this._sources = new i();\n  this._names = new i();\n  this._mappings = new s();\n  this._sourcesContents = null;\n}\nh.prototype._version = 3;\nh.fromSourceMap = function (e) {\n  var t = e.sourceRoot,\n    n = new h({\n      file: e.file,\n      sourceRoot: t\n    });\n  e.eachMapping(function (e) {\n    var r = {\n      generated: {\n        line: e.generatedLine,\n        column: e.generatedColumn\n      }\n    };\n    null != e.source && (r.source = e.source, null != t && (r.source = o.relative(t, r.source)), r.original = {\n      line: e.originalLine,\n      column: e.originalColumn\n    }, null != e.name && (r.name = e.name));\n    n.addMapping(r);\n  });\n  e.sources.forEach(function (r) {\n    var i = r;\n    null !== t && (i = o.relative(t, r));\n    n._sources.has(i) || n._sources.add(i);\n    var s = e.sourceContentFor(r);\n    null != s && n.setSourceContent(r, s);\n  });\n  return n;\n};\nh.prototype.addMapping = function (e) {\n  var t = o.getArg(e, \"generated\"),\n    n = o.getArg(e, \"original\", null),\n    r = o.getArg(e, \"source\", null),\n    i = o.getArg(e, \"name\", null);\n  this._skipValidation || this._validateMapping(t, n, r, i);\n  null != r && (r = String(r), this._sources.has(r) || this._sources.add(r));\n  null != i && (i = String(i), this._names.has(i) || this._names.add(i));\n  this._mappings.add({\n    generatedLine: t.line,\n    generatedColumn: t.column,\n    originalLine: null != n && n.line,\n    originalColumn: null != n && n.column,\n    source: r,\n    name: i\n  });\n};\nh.prototype.setSourceContent = function (e, t) {\n  var n = e;\n  null != this._sourceRoot && (n = o.relative(this._sourceRoot, n));\n  null != t ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), this._sourcesContents[o.toSetString(n)] = t) : this._sourcesContents && (delete this._sourcesContents[o.toSetString(n)], 0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null));\n};\nh.prototype.applySourceMap = function (e, t, n) {\n  var r = t;\n  if (null == t) {\n    if (null == e.file) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\\'s \"file\" property. Both were omitted.');\n    r = e.file;\n  }\n  var s = this._sourceRoot;\n  null != s && (r = o.relative(s, r));\n  var a = new i(),\n    c = new i();\n  this._mappings.unsortedForEach(function (t) {\n    if (t.source === r && null != t.originalLine) {\n      var i = e.originalPositionFor({\n        line: t.originalLine,\n        column: t.originalColumn\n      });\n      null != i.source && (t.source = i.source, null != n && (t.source = o.join(n, t.source)), null != s && (t.source = o.relative(s, t.source)), t.originalLine = i.line, t.originalColumn = i.column, null != i.name && (t.name = i.name));\n    }\n    var l = t.source;\n    null == l || a.has(l) || a.add(l);\n    var u = t.name;\n    null == u || c.has(u) || c.add(u);\n  }, this);\n  this._sources = a;\n  this._names = c;\n  e.sources.forEach(function (t) {\n    var r = e.sourceContentFor(t);\n    null != r && (null != n && (t = o.join(n, t)), null != s && (t = o.relative(s, t)), this.setSourceContent(t, r));\n  }, this);\n};\nh.prototype._validateMapping = function (e, t, n, r) {\n  if (t && \"number\" != typeof t.line && \"number\" != typeof t.column) throw new Error(\"original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.\");\n  if ((!(e && \"line\" in e && \"column\" in e && e.line > 0 && e.column >= 0) || t || n || r) && !(e && \"line\" in e && \"column\" in e && t && \"line\" in t && \"column\" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && n)) throw new Error(\"Invalid mapping: \" + JSON.stringify({\n    generated: e,\n    source: n,\n    original: t,\n    name: r\n  }));\n};\nh.prototype._serializeMappings = function () {\n  for (var e, t, n, i, s = 0, a = 1, c = 0, l = 0, u = 0, d = 0, p = \"\", h = this._mappings.toArray(), f = 0, m = h.length; f < m; f++) {\n    e = \"\";\n    if ((t = h[f]).generatedLine !== a) for (s = 0; t.generatedLine !== a;) e += \";\", a++;else if (f > 0) {\n      if (!o.compareByGeneratedPositionsInflated(t, h[f - 1])) continue;\n      e += \",\";\n    }\n    e += r.encode(t.generatedColumn - s);\n    s = t.generatedColumn;\n    null != t.source && (i = this._sources.indexOf(t.source), e += r.encode(i - d), d = i, e += r.encode(t.originalLine - 1 - l), l = t.originalLine - 1, e += r.encode(t.originalColumn - c), c = t.originalColumn, null != t.name && (n = this._names.indexOf(t.name), e += r.encode(n - u), u = n));\n    p += e;\n  }\n  return p;\n};\nh.prototype._generateSourcesContent = function (e, t) {\n  return e.map(function (e) {\n    if (!this._sourcesContents) return null;\n    null != t && (e = o.relative(t, e));\n    var n = o.toSetString(e);\n    return Object.prototype.hasOwnProperty.call(this._sourcesContents, n) ? this._sourcesContents[n] : null;\n  }, this);\n};\nh.prototype.toJSON = function () {\n  var e = {\n    version: this._version,\n    sources: this._sources.toArray(),\n    names: this._names.toArray(),\n    mappings: this._serializeMappings()\n  };\n  null != this._file && (e.file = this._file);\n  null != this._sourceRoot && (e.sourceRoot = this._sourceRoot);\n  this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot));\n  return e;\n};\nh.prototype.toString = function () {\n  return JSON.stringify(this.toJSON());\n};\nexports.h = h;",
  "4454": "var r;\nr = require(8249);\nrequire(8269);\nrequire(8214);\nrequire(888);\nrequire(5109);\n(function () {\n  var e = r,\n    t = e.lib.StreamCipher,\n    n = e.algo,\n    o = [],\n    i = [],\n    s = [],\n    a = n.Rabbit = t.extend({\n      _doReset: function () {\n        for (var e = this._key.words, t = this.cfg.iv, n = 0; n < 4; n++) e[n] = 16711935 & (e[n] << 8 | e[n] >>> 24) | 4278255360 & (e[n] << 24 | e[n] >>> 8);\n        var r = this._X = [e[0], e[3] << 16 | e[2] >>> 16, e[1], e[0] << 16 | e[3] >>> 16, e[2], e[1] << 16 | e[0] >>> 16, e[3], e[2] << 16 | e[1] >>> 16],\n          o = this._C = [e[2] << 16 | e[2] >>> 16, 4294901760 & e[0] | 65535 & e[1], e[3] << 16 | e[3] >>> 16, 4294901760 & e[1] | 65535 & e[2], e[0] << 16 | e[0] >>> 16, 4294901760 & e[2] | 65535 & e[3], e[1] << 16 | e[1] >>> 16, 4294901760 & e[3] | 65535 & e[0]];\n        for (this._b = 0, n = 0; n < 4; n++) c.call(this);\n        for (n = 0; n < 8; n++) o[n] ^= r[n + 4 & 7];\n        if (t) {\n          var i = t.words,\n            s = i[0],\n            a = i[1],\n            l = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8),\n            u = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8),\n            d = l >>> 16 | 4294901760 & u,\n            p = u << 16 | 65535 & l;\n          for (o[0] ^= l, o[1] ^= d, o[2] ^= u, o[3] ^= p, o[4] ^= l, o[5] ^= d, o[6] ^= u, o[7] ^= p, n = 0; n < 4; n++) c.call(this);\n        }\n      },\n      _doProcessBlock: function (e, t) {\n        var n = this._X;\n        c.call(this);\n        o[0] = n[0] ^ n[5] >>> 16 ^ n[3] << 16;\n        o[1] = n[2] ^ n[7] >>> 16 ^ n[5] << 16;\n        o[2] = n[4] ^ n[1] >>> 16 ^ n[7] << 16;\n        o[3] = n[6] ^ n[3] >>> 16 ^ n[1] << 16;\n        for (var r = 0; r < 4; r++) {\n          o[r] = 16711935 & (o[r] << 8 | o[r] >>> 24) | 4278255360 & (o[r] << 24 | o[r] >>> 8);\n          e[t + r] ^= o[r];\n        }\n      },\n      blockSize: 4,\n      ivSize: 2\n    });\n  function c() {\n    for (var e = this._X, t = this._C, n = 0; n < 8; n++) i[n] = t[n];\n    for (t[0] = t[0] + 1295307597 + this._b | 0, t[1] = t[1] + 3545052371 + (t[0] >>> 0 < i[0] >>> 0 ? 1 : 0) | 0, t[2] = t[2] + 886263092 + (t[1] >>> 0 < i[1] >>> 0 ? 1 : 0) | 0, t[3] = t[3] + 1295307597 + (t[2] >>> 0 < i[2] >>> 0 ? 1 : 0) | 0, t[4] = t[4] + 3545052371 + (t[3] >>> 0 < i[3] >>> 0 ? 1 : 0) | 0, t[5] = t[5] + 886263092 + (t[4] >>> 0 < i[4] >>> 0 ? 1 : 0) | 0, t[6] = t[6] + 1295307597 + (t[5] >>> 0 < i[5] >>> 0 ? 1 : 0) | 0, t[7] = t[7] + 3545052371 + (t[6] >>> 0 < i[6] >>> 0 ? 1 : 0) | 0, this._b = t[7] >>> 0 < i[7] >>> 0 ? 1 : 0, n = 0; n < 8; n++) {\n      var r = e[n] + t[n],\n        o = 65535 & r,\n        a = r >>> 16,\n        c = ((o * o >>> 17) + o * a >>> 15) + a * a,\n        l = ((4294901760 & r) * r | 0) + ((65535 & r) * r | 0);\n      s[n] = c ^ l;\n    }\n    e[0] = s[0] + (s[7] << 16 | s[7] >>> 16) + (s[6] << 16 | s[6] >>> 16) | 0;\n    e[1] = s[1] + (s[0] << 8 | s[0] >>> 24) + s[7] | 0;\n    e[2] = s[2] + (s[1] << 16 | s[1] >>> 16) + (s[0] << 16 | s[0] >>> 16) | 0;\n    e[3] = s[3] + (s[2] << 8 | s[2] >>> 24) + s[1] | 0;\n    e[4] = s[4] + (s[3] << 16 | s[3] >>> 16) + (s[2] << 16 | s[2] >>> 16) | 0;\n    e[5] = s[5] + (s[4] << 8 | s[4] >>> 24) + s[3] | 0;\n    e[6] = s[6] + (s[5] << 16 | s[5] >>> 16) + (s[4] << 16 | s[4] >>> 16) | 0;\n    e[7] = s[7] + (s[6] << 8 | s[6] >>> 24) + s[5] | 0;\n  }\n  e.Rabbit = t._createHelper(a);\n})();\nmodule.exports = r.Rabbit;",
  "4470": "var r = require(2037),\n  o = require(7147),\n  i = require(1017),\n  s = require(5290),\n  a = require(5282),\n  c = function () {\n    function e(e) {\n      this.keys = new s.ContextTagKeys();\n      this.tags = {};\n      this._loadApplicationContext();\n      this._loadDeviceContext();\n      this._loadInternalContext();\n    }\n    e.prototype._loadApplicationContext = function (t) {\n      t = t || i.resolve(__dirname, \"../../../../package.json\");\n      if (!e.appVersion[t]) {\n        e.appVersion[t] = \"unknown\";\n        try {\n          var n = JSON.parse(o.readFileSync(t, \"utf8\"));\n          n && \"string\" == typeof n.version && (e.appVersion[t] = n.version);\n        } catch (e) {\n          a.info(\"unable to read app version: \", e);\n        }\n      }\n      this.tags[this.keys.applicationVersion] = e.appVersion[t];\n    };\n    e.prototype._loadDeviceContext = function () {\n      this.tags[this.keys.deviceId] = \"\";\n      this.tags[this.keys.cloudRoleInstance] = r && r.hostname();\n      this.tags[this.keys.deviceOSVersion] = r && r.type() + \" \" + r.release();\n      this.tags[this.keys.cloudRole] = e.DefaultRoleName;\n      this.tags[\"ai.device.osArchitecture\"] = r && r.arch();\n      this.tags[\"ai.device.osPlatform\"] = r && r.platform();\n    };\n    e.prototype._loadInternalContext = function () {\n      var t = i.resolve(__dirname, \"../../package.json\");\n      if (!e.sdkVersion) {\n        e.sdkVersion = \"unknown\";\n        try {\n          var n = JSON.parse(o.readFileSync(t, \"utf8\"));\n          n && \"string\" == typeof n.version && (e.sdkVersion = n.version);\n        } catch (e) {\n          a.info(\"unable to read app version: \", e);\n        }\n      }\n      this.tags[this.keys.internalSdkVersion] = \"node:\" + e.sdkVersion;\n    };\n    e.DefaultRoleName = \"Web\";\n    e.appVersion = {};\n    e.sdkVersion = null;\n    return e;\n  }();\nmodule.exports = c;",
  "4487": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(4953);\nexports.redis = {\n  versionSpecifier: \">= 2.0.0 < 4.0.0\",\n  patch: function (e) {\n    var t = e.RedisClient.prototype.internal_send_command;\n    e.RedisClient.prototype.internal_send_command = function (e) {\n      if (e) {\n        var n = e.callback;\n        if (!n || !n.pubsubBound) {\n          var o = this.address,\n            i = process.hrtime(),\n            s = new Date();\n          e.callback = r.channel.bindToContext(function (t, a) {\n            var c = process.hrtime(i),\n              l = 1e3 * c[0] + c[1] / 1e6 | 0;\n            r.channel.publish(\"redis\", {\n              duration: l,\n              address: o,\n              commandObj: e,\n              err: t,\n              result: a,\n              time: s\n            });\n            \"function\" == typeof n && n.apply(this, arguments);\n          });\n          e.callback.pubsubBound = !0;\n        }\n      }\n      return t.call(this, e);\n    };\n    return e;\n  }\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"redis\", exports.redis);\n};",
  "4499": "function n(e) {\n  const t = e.length;\n  let n,\n    r = 0,\n    o = 0;\n  for (; o < t;) {\n    r++;\n    n = e.charCodeAt(o++);\n    n >= 55296 && n <= 56319 && o < t && (n = e.charCodeAt(o), 56320 == (64512 & n) && o++);\n  }\n  return r;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.default = n;\nn.code = 'require(\"ajv/dist/runtime/ucs2length\").default';",
  "4526": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  }(require(8934));\nmodule.exports = i;",
  "4540": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ignoreDocument = undefined;\nconst r = require(1133),\n  o = require(4197);\nexports.ignoreDocument = function (e, t) {\n  const n = t.languageId;\n  return !r.getEnabledConfig(e, n) || !![o.CopilotScheme, \"output\", \"search-editor\"].includes(t.uri.scheme);\n};",
  "4544": "const {\n    constants: {\n      MAX_LENGTH: r\n    }\n  } = require(4300),\n  {\n    pipeline: o,\n    PassThrough: i\n  } = require(2781),\n  {\n    promisify: s\n  } = require(3837),\n  {\n    createGunzip: a,\n    createInflate: c,\n    createBrotliDecompress: l,\n    constants: {\n      Z_SYNC_FLUSH: u\n    }\n  } = require(9796),\n  d = require(8104)(\"helix-fetch:utils\"),\n  p = s(o),\n  h = (e, t) => {\n    if (Buffer.isBuffer(e)) return e.length;\n    switch (typeof e) {\n      case \"string\":\n        return 2 * e.length;\n      case \"boolean\":\n        return 4;\n      case \"number\":\n        return 8;\n      case \"symbol\":\n        return Symbol.keyFor(e) ? 2 * Symbol.keyFor(e).length : 2 * (e.toString().length - 8);\n      case \"object\":\n        return Array.isArray(e) ? f(e, t) : m(e, t);\n      default:\n        return 0;\n    }\n  },\n  f = (e, t) => (t.add(e), e.map(e => t.has(e) ? 0 : h(e, t)).reduce((e, t) => e + t, 0)),\n  m = (e, t) => {\n    if (null == e) return 0;\n    t.add(e);\n    let n = 0;\n    const r = [];\n    for (const t in e) r.push(t);\n    r.push(...Object.getOwnPropertySymbols(e));\n    r.forEach(r => {\n      n += h(r, t);\n      if (\"object\" == typeof e[r] && null !== e[r]) {\n        if (t.has(e[r])) return;\n        t.add(e[r]);\n      }\n      n += h(e[r], t);\n    });\n    return n;\n  };\nmodule.exports = {\n  decodeStream: (e, t, n, r) => {\n    if (!((e, t) => 204 !== e && 304 !== e && 0 != +t[\"content-length\"] && /^\\s*(?:(x-)?deflate|(x-)?gzip|br)\\s*$/.test(t[\"content-encoding\"]))(e, t)) return n;\n    const i = e => {\n      e && (d(`encountered error while decoding stream: ${e}`), r(e));\n    };\n    switch (t[\"content-encoding\"].trim()) {\n      case \"gzip\":\n      case \"x-gzip\":\n        return o(n, a({\n          flush: u,\n          finishFlush: u\n        }), i);\n      case \"deflate\":\n      case \"x-deflate\":\n        return o(n, c(), i);\n      case \"br\":\n        return o(n, l(), i);\n      default:\n        return n;\n    }\n  },\n  isPlainObject: e => {\n    if (!e || \"object\" != typeof e) return !1;\n    if (\"[object Object]\" !== Object.prototype.toString.call(e)) return !1;\n    if (null === Object.getPrototypeOf(e)) return !0;\n    let t = e;\n    for (; null !== Object.getPrototypeOf(t);) t = Object.getPrototypeOf(t);\n    return Object.getPrototypeOf(e) === t;\n  },\n  sizeof: e => h(e, new WeakSet()),\n  streamToBuffer: async e => {\n    const t = new i();\n    let n = 0;\n    const o = [];\n    t.on(\"data\", e => {\n      if (n + e.length > r) throw new Error(\"Buffer.constants.MAX_SIZE exceeded\");\n      o.push(e);\n      n += e.length;\n    });\n    await p(e, t);\n    return Buffer.concat(o, n);\n  }\n};",
  "4650": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = this && this.__rest || function (e, t) {\n    var n = {};\n    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);\n    if (null != e && \"function\" == typeof Object.getOwnPropertySymbols) {\n      var o = 0;\n      for (r = Object.getOwnPropertySymbols(e); o < r.length; o++) t.indexOf(r[o]) < 0 && (n[r[o]] = e[r[o]]);\n    }\n    return n;\n  };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar s = require(4953);\nexports.winston3 = {\n  versionSpecifier: \"3.x\",\n  patch: function (e) {\n    var t = function (e) {\n      function t(t, n) {\n        var r = e.call(this, n) || this;\n        r.winston = t;\n        return r;\n      }\n      o(t, e);\n      t.prototype.log = function (e, t) {\n        var n = e.message,\n          r = e.level,\n          o = e.meta,\n          a = i(e, [\"message\", \"level\", \"meta\"]);\n        r = \"function\" == typeof Symbol.for ? e[Symbol.for(\"level\")] : r;\n        n = e instanceof Error ? e : n;\n        var c = function (e, t) {\n          return null != e.config.npm.levels[t] ? \"npm\" : null != e.config.syslog.levels[t] ? \"syslog\" : \"unknown\";\n        }(this.winston, r);\n        for (var l in o = o || {}, a) a.hasOwnProperty(l) && (o[l] = a[l]);\n        s.channel.publish(\"winston\", {\n          message: n,\n          level: r,\n          levelKind: c,\n          meta: o\n        });\n        t();\n      };\n      return t;\n    }(e.Transport);\n    function n() {\n      var n,\n        r = arguments[0].levels || e.config.npm.levels;\n      for (var o in r) r.hasOwnProperty(o) && (n = undefined === n || r[o] > r[n] ? o : n);\n      this.add(new t(e, {\n        level: n\n      }));\n    }\n    var r = e.createLogger;\n    e.createLogger = function () {\n      var o,\n        i = arguments[0].levels || e.config.npm.levels;\n      for (var s in i) i.hasOwnProperty(s) && (o = undefined === o || i[s] > i[o] ? s : o);\n      var a = r.apply(this, arguments);\n      a.add(new t(e, {\n        level: o\n      }));\n      var c = a.configure;\n      a.configure = function () {\n        c.apply(this, arguments);\n        n.apply(this, arguments);\n      };\n      return a;\n    };\n    var a = e.createLogger;\n    e.configure = function () {\n      a.apply(this, arguments);\n      n.apply(this, arguments);\n    };\n    e.add(new t(e));\n    return e;\n  }\n};\nexports.winston2 = {\n  versionSpecifier: \"2.x\",\n  patch: function (e) {\n    var t,\n      n = e.Logger.prototype.log,\n      r = function (n, r, o) {\n        var i;\n        i = t === e.config.npm.levels ? \"npm\" : t === e.config.syslog.levels ? \"syslog\" : \"unknown\";\n        s.channel.publish(\"winston\", {\n          level: n,\n          message: r,\n          meta: o,\n          levelKind: i\n        });\n        return r;\n      };\n    e.Logger.prototype.log = function () {\n      t = this.levels;\n      this.filters && 0 !== this.filters.length ? this.filters[this.filters.length - 1] !== r && (this.filters = this.filters.filter(function (e) {\n        return e !== r;\n      }), this.filters.push(r)) : this.filters = [r];\n      return n.apply(this, arguments);\n    };\n    return e;\n  }\n};\nexports.enable = function () {\n  s.channel.registerMonkeyPatch(\"winston\", exports.winston2);\n  s.channel.registerMonkeyPatch(\"winston\", exports.winston3);\n};",
  "4665": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.validateTuple = undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = require(412),\n  s = {\n    keyword: \"items\",\n    type: \"array\",\n    schemaType: [\"object\", \"array\", \"boolean\"],\n    before: \"uniqueItems\",\n    code(e) {\n      const {\n        schema: t,\n        it: n\n      } = e;\n      if (Array.isArray(t)) return validateTuple(e, \"additionalItems\", t);\n      n.items = !0;\n      o.alwaysValidSchema(n, t) || e.ok(i.validateArray(e));\n    }\n  };\nfunction validateTuple(e, t, n = e.schema) {\n  const {\n    gen: i,\n    parentSchema: s,\n    data: a,\n    keyword: c,\n    it: l\n  } = e;\n  !function (e) {\n    const {\n        opts: r,\n        errSchemaPath: i\n      } = l,\n      s = n.length,\n      a = s === e.minItems && (s === e.maxItems || !1 === e[t]);\n    if (r.strictTuples && !a) {\n      const e = `\"${c}\" is ${s}-tuple, but minItems or maxItems/${t} are not specified or different at path \"${i}\"`;\n      o.checkStrictMode(l, e, r.strictTuples);\n    }\n  }(s);\n  l.opts.unevaluated && n.length && !0 !== l.items && (l.items = o.mergeEvaluated.items(i, n.length, l.items));\n  const u = i.name(\"valid\"),\n    d = i.const(\"len\", r._`${a}.length`);\n  n.forEach((t, n) => {\n    o.alwaysValidSchema(l, t) || (i.if(r._`${d} > ${n}`, () => e.subschema({\n      keyword: c,\n      schemaProp: n,\n      dataProp: n\n    }, u)), e.ok(u));\n  });\n}\nexports.validateTuple = validateTuple;\nexports.default = s;",
  "4693": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(6776),\n  i = require(3510),\n  s = {\n    keyword: \"const\",\n    $data: !0,\n    error: {\n      message: \"must be equal to constant\",\n      params: ({\n        schemaCode: e\n      }) => r._`{allowedValue: ${e}}`\n    },\n    code(e) {\n      const {\n        gen: t,\n        data: n,\n        $data: s,\n        schemaCode: a,\n        schema: c\n      } = e;\n      s || c && \"object\" == typeof c ? e.fail$data(r._`!${o.useFunc(t, i.default)}(${n}, ${a})`) : e.fail(r._`${c} !== ${n}`);\n    }\n  };\nexports.default = s;",
  "4694": "function t(e) {\n  var t = new Error(\"Cannot find module '\" + e + \"'\");\n  throw t.code = \"MODULE_NOT_FOUND\", t;\n}\nt.keys = () => [];\nt.resolve = t;\nt.id = 4694;\nmodule.exports = t;",
  "4723": "var r = this && this.__createBinding || (Object.create ? function (e, t, n, r) {\n    undefined === r && (r = n);\n    Object.defineProperty(e, r, {\n      enumerable: !0,\n      get: function () {\n        return t[n];\n      }\n    });\n  } : function (e, t, n, r) {\n    undefined === r && (r = n);\n    e[r] = t[n];\n  }),\n  o = this && this.__exportStar || function (e, t) {\n    for (var n in e) \"default\" === n || Object.prototype.hasOwnProperty.call(t, n) || r(t, e, n);\n  };\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.createWorker = exports.FileSystem = exports.comment = exports.languageCommentMarkers = undefined;\nconst i = require(1017),\n  s = require(1267);\no(require(464), exports);\no(require(9940), exports);\no(require(1747), exports);\no(require(9852), exports);\nvar a = require(1788);\nexports.languageCommentMarkers = a.languageCommentMarkers;\nexports.comment = a.comment;\nvar c = require(5012);\nexports.FileSystem = c.FileSystem;\nexports.createWorker = function () {\n  return new s.Worker(i.resolve(__dirname, \"..\", \"dist\", \"worker.js\"));\n};",
  "4775": "module.exports = JSON.parse('{\"$id\":\"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\"description\":\"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\"type\":\"object\",\"required\":[\"$data\"],\"properties\":{\"$data\":{\"type\":\"string\",\"anyOf\":[{\"format\":\"relative-json-pointer\"},{\"format\":\"json-pointer\"}]}},\"additionalProperties\":false}');",
  "4777": "var r = require(4953),\n  o = [];\nexports.qP = function (e) {\n  o.forEach(function (t) {\n    var n = e.data.query || {},\n      r = n.sql || \"Unknown query\",\n      o = !e.data.err,\n      i = (n._connection || {}).config || {},\n      s = i.socketPath ? i.socketPath : (i.host || \"localhost\") + \":\" + i.port;\n    t.trackDependency({\n      target: s,\n      data: r,\n      name: r,\n      duration: e.data.duration,\n      success: o,\n      resultCode: o ? \"0\" : \"1\",\n      dependencyTypeName: \"mysql\"\n    });\n  });\n};\nexports.wp = function (e, n) {\n  e ? (0 === o.length && r.channel.subscribe(\"mysql\", exports.qP), o.push(n)) : 0 === (o = o.filter(function (e) {\n    return e != n;\n  })).length && r.channel.unsubscribe(\"mysql\", exports.qP);\n};",
  "4783": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.validateAdditionalItems = undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"additionalItems\",\n    type: \"array\",\n    schemaType: [\"boolean\", \"object\"],\n    before: \"uniqueItems\",\n    error: {\n      message: ({\n        params: {\n          len: e\n        }\n      }) => r.str`must NOT have more than ${e} items`,\n      params: ({\n        params: {\n          len: e\n        }\n      }) => r._`{limit: ${e}}`\n    },\n    code(e) {\n      const {\n          parentSchema: t,\n          it: n\n        } = e,\n        {\n          items: r\n        } = t;\n      Array.isArray(r) ? validateAdditionalItems(e, r) : o.checkStrictMode(n, '\"additionalItems\" is ignored when \"items\" is not an array of schemas');\n    }\n  };\nfunction validateAdditionalItems(e, t) {\n  const {\n    gen: n,\n    schema: i,\n    data: s,\n    keyword: a,\n    it: c\n  } = e;\n  c.items = !0;\n  const l = n.const(\"len\", r._`${s}.length`);\n  if (!1 === i) {\n    e.setParams({\n      len: t.length\n    });\n    e.pass(r._`${l} <= ${t.length}`);\n  } else if (\"object\" == typeof i && !o.alwaysValidSchema(c, i)) {\n    const i = n.var(\"valid\", r._`${l} <= ${t.length}`);\n    n.if(r.not(i), () => function (i) {\n      n.forRange(\"i\", t.length, l, t => {\n        e.subschema({\n          keyword: a,\n          dataProp: t,\n          dataPropType: o.Type.Num\n        }, i);\n        c.allErrors || n.if(r.not(i), () => n.break());\n      });\n    }(i));\n    e.ok(i);\n  }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports.default = i;",
  "4815": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = undefined;\nconst r = require(5667),\n  o = require(453),\n  i = require(8876),\n  s = require(453),\n  a = require(313),\n  c = require(5005),\n  l = require(3099),\n  u = require(3487),\n  d = require(2141),\n  p = require(2531),\n  h = require(6776),\n  f = require(4181);\nfunction m({\n  gen: e,\n  validateName: t,\n  schema: n,\n  schemaEnv: r,\n  opts: o\n}, i) {\n  o.code.es5 ? e.func(t, u._`${d.default.data}, ${d.default.valCxt}`, r.$async, () => {\n    e.code(u._`\"use strict\"; ${g(n, o)}`);\n    (function (e, t) {\n      e.if(d.default.valCxt, () => {\n        e.var(d.default.instancePath, u._`${d.default.valCxt}.${d.default.instancePath}`);\n        e.var(d.default.parentData, u._`${d.default.valCxt}.${d.default.parentData}`);\n        e.var(d.default.parentDataProperty, u._`${d.default.valCxt}.${d.default.parentDataProperty}`);\n        e.var(d.default.rootData, u._`${d.default.valCxt}.${d.default.rootData}`);\n        t.dynamicRef && e.var(d.default.dynamicAnchors, u._`${d.default.valCxt}.${d.default.dynamicAnchors}`);\n      }, () => {\n        e.var(d.default.instancePath, u._`\"\"`);\n        e.var(d.default.parentData, u._`undefined`);\n        e.var(d.default.parentDataProperty, u._`undefined`);\n        e.var(d.default.rootData, d.default.data);\n        t.dynamicRef && e.var(d.default.dynamicAnchors, u._`{}`);\n      });\n    })(e, o);\n    e.code(i);\n  }) : e.func(t, u._`${d.default.data}, ${function (e) {\n    return u._`{${d.default.instancePath}=\"\", ${d.default.parentData}, ${d.default.parentDataProperty}, ${d.default.rootData}=${d.default.data}${e.dynamicRef ? u._`, ${d.default.dynamicAnchors}={}` : u.nil}}={}`;\n  }(o)}`, r.$async, () => e.code(g(n, o)).code(i));\n}\nfunction g(e, t) {\n  const n = \"object\" == typeof e && e[t.schemaId];\n  return n && (t.code.source || t.code.process) ? u._`/*# sourceURL=${n} */` : u.nil;\n}\nfunction _({\n  schema: e,\n  self: t\n}) {\n  if (\"boolean\" == typeof e) return !e;\n  for (const n in e) if (t.RULES.all[n]) return !0;\n  return !1;\n}\nfunction y(e) {\n  return \"boolean\" != typeof e.schema;\n}\nfunction v(e) {\n  h.checkUnknownRules(e);\n  (function (e) {\n    const {\n      schema: t,\n      errSchemaPath: n,\n      opts: r,\n      self: o\n    } = e;\n    t.$ref && r.ignoreKeywordsWithRef && h.schemaHasRulesButRef(t, o.RULES) && o.logger.warn(`$ref: keywords ignored in schema at path \"${n}\"`);\n  })(e);\n}\nfunction b(e, t) {\n  if (e.opts.jtd) return x(e, [], !1, t);\n  const n = o.getSchemaTypes(e.schema);\n  x(e, n, !o.coerceAndCheckDataType(e, n), t);\n}\nfunction w({\n  gen: e,\n  schemaEnv: t,\n  schema: n,\n  errSchemaPath: r,\n  opts: o\n}) {\n  const i = n.$comment;\n  if (!0 === o.$comment) e.code(u._`${d.default.self}.logger.log(${i})`);else if (\"function\" == typeof o.$comment) {\n    const n = u.str`${r}/$comment`,\n      o = e.scopeValue(\"root\", {\n        ref: t.root\n      });\n    e.code(u._`${d.default.self}.opts.$comment(${i}, ${n}, ${o}.schema)`);\n  }\n}\nfunction x(e, t, n, r) {\n  const {\n      gen: o,\n      schema: a,\n      data: c,\n      allErrors: l,\n      opts: p,\n      self: f\n    } = e,\n    {\n      RULES: m\n    } = f;\n  function g(h) {\n    i.shouldUseGroup(a, h) && (h.type ? (o.if(s.checkDataType(h.type, c, p.strictNumbers)), E(e, h), 1 === t.length && t[0] === h.type && n && (o.else(), s.reportTypeError(e)), o.endIf()) : E(e, h), l || o.if(u._`${d.default.errors} === ${r || 0}`));\n  }\n  !a.$ref || !p.ignoreKeywordsWithRef && h.schemaHasRulesButRef(a, m) ? (p.jtd || function (e, t) {\n    !e.schemaEnv.meta && e.opts.strictTypes && (function (e, t) {\n      t.length && (e.dataTypes.length ? (t.forEach(t => {\n        C(e.dataTypes, t) || S(e, `type \"${t}\" not allowed by context \"${e.dataTypes.join(\",\")}\"`);\n      }), e.dataTypes = e.dataTypes.filter(e => C(t, e))) : e.dataTypes = t);\n    }(e, t), e.opts.allowUnionTypes || function (e, t) {\n      t.length > 1 && (2 !== t.length || !t.includes(\"null\")) && S(e, \"use allowUnionTypes to allow union type keyword\");\n    }(e, t), function (e, t) {\n      const n = e.self.RULES.all;\n      for (const r in n) {\n        const o = n[r];\n        if (\"object\" == typeof o && i.shouldUseRule(e.schema, o)) {\n          const {\n            type: n\n          } = o.definition;\n          n.length && !n.some(e => {\n            r = e;\n            return (n = t).includes(r) || \"number\" === r && n.includes(\"integer\");\n            var n, r;\n          }) && S(e, `missing type \"${n.join(\",\")}\" for keyword \"${r}\"`);\n        }\n      }\n    }(e, e.dataTypes));\n  }(e, t), o.block(() => {\n    for (const e of m.rules) g(e);\n    g(m.post);\n  })) : o.block(() => k(e, \"$ref\", m.all.$ref.definition));\n}\nfunction E(e, t) {\n  const {\n    gen: n,\n    schema: r,\n    opts: {\n      useDefaults: o\n    }\n  } = e;\n  o && a.assignDefaults(e, t.type);\n  n.block(() => {\n    for (const n of t.rules) i.shouldUseRule(r, n) && k(e, n.keyword, n.definition, t.type);\n  });\n}\nfunction C(e, t) {\n  return e.includes(t) || \"integer\" === t && e.includes(\"number\");\n}\nfunction S(e, t) {\n  t += ` at \"${e.schemaEnv.baseId + e.errSchemaPath}\" (strictTypes)`;\n  h.checkStrictMode(e, t, e.opts.strictTypes);\n}\nexports.validateFunctionCode = function (e) {\n  y(e) && (v(e), _(e)) ? function (e) {\n    const {\n      schema: t,\n      opts: n,\n      gen: r\n    } = e;\n    m(e, () => {\n      n.$comment && t.$comment && w(e);\n      (function (e) {\n        const {\n          schema: t,\n          opts: n\n        } = e;\n        undefined !== t.default && n.useDefaults && n.strictSchema && h.checkStrictMode(e, \"default is ignored in the schema root\");\n      })(e);\n      r.let(d.default.vErrors, null);\n      r.let(d.default.errors, 0);\n      n.unevaluated && function (e) {\n        const {\n          gen: t,\n          validateName: n\n        } = e;\n        e.evaluated = t.const(\"evaluated\", u._`${n}.evaluated`);\n        t.if(u._`${e.evaluated}.dynamicProps`, () => t.assign(u._`${e.evaluated}.props`, u._`undefined`));\n        t.if(u._`${e.evaluated}.dynamicItems`, () => t.assign(u._`${e.evaluated}.items`, u._`undefined`));\n      }(e);\n      b(e);\n      (function (e) {\n        const {\n          gen: t,\n          schemaEnv: n,\n          validateName: r,\n          ValidationError: o,\n          opts: i\n        } = e;\n        n.$async ? t.if(u._`${d.default.errors} === 0`, () => t.return(d.default.data), () => t.throw(u._`new ${o}(${d.default.vErrors})`)) : (t.assign(u._`${r}.errors`, d.default.vErrors), i.unevaluated && function ({\n          gen: e,\n          evaluated: t,\n          props: n,\n          items: r\n        }) {\n          n instanceof u.Name && e.assign(u._`${t}.props`, n);\n          r instanceof u.Name && e.assign(u._`${t}.items`, r);\n        }(e), t.return(u._`${d.default.errors} === 0`));\n      })(e);\n    });\n  }(e) : m(e, () => r.topBoolOrEmptySchema(e));\n};\nclass KeywordCxt {\n  constructor(e, t, n) {\n    c.validateKeywordUsage(e, t, n);\n    this.gen = e.gen;\n    this.allErrors = e.allErrors;\n    this.keyword = n;\n    this.data = e.data;\n    this.schema = e.schema[n];\n    this.$data = t.$data && e.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = h.schemaRefOrVal(e, this.schema, n, this.$data);\n    this.schemaType = t.schemaType;\n    this.parentSchema = e.schema;\n    this.params = {};\n    this.it = e;\n    this.def = t;\n    if (this.$data) this.schemaCode = e.gen.const(\"vSchema\", getData(this.$data, e));else if (this.schemaCode = this.schemaValue, !(0, c.validSchemaType)(this.schema, t.schemaType, t.allowUndefined)) throw new Error(`${n} value must be ${JSON.stringify(t.schemaType)}`);\n    (\"code\" in t ? t.trackErrors : !1 !== t.errors) && (this.errsCount = e.gen.const(\"_errs\", d.default.errors));\n  }\n  result(e, t, n) {\n    this.failResult(u.not(e), t, n);\n  }\n  failResult(e, t, n) {\n    this.gen.if(e);\n    n ? n() : this.error();\n    t ? (this.gen.else(), t(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();\n  }\n  pass(e, t) {\n    this.failResult(u.not(e), undefined, t);\n  }\n  fail(e) {\n    if (undefined === e) {\n      this.error();\n      return void (this.allErrors || this.gen.if(!1));\n    }\n    this.gen.if(e);\n    this.error();\n    this.allErrors ? this.gen.endIf() : this.gen.else();\n  }\n  fail$data(e) {\n    if (!this.$data) return this.fail(e);\n    const {\n      schemaCode: t\n    } = this;\n    this.fail(u._`${t} !== undefined && (${u.or(this.invalid$data(), e)})`);\n  }\n  error(e, t, n) {\n    if (t) {\n      this.setParams(t);\n      this._error(e, n);\n      return void this.setParams({});\n    }\n    this._error(e, n);\n  }\n  _error(e, t) {\n    (e ? f.reportExtraError : f.reportError)(this, this.def.error, t);\n  }\n  $dataError() {\n    f.reportError(this, this.def.$dataError || f.keyword$DataError);\n  }\n  reset() {\n    if (undefined === this.errsCount) throw new Error('add \"trackErrors\" to keyword definition');\n    f.resetErrorsCount(this.gen, this.errsCount);\n  }\n  ok(e) {\n    this.allErrors || this.gen.if(e);\n  }\n  setParams(e, t) {\n    t ? Object.assign(this.params, e) : this.params = e;\n  }\n  block$data(e, t, n = u.nil) {\n    this.gen.block(() => {\n      this.check$data(e, n);\n      t();\n    });\n  }\n  check$data(e = u.nil, t = u.nil) {\n    if (!this.$data) return;\n    const {\n      gen: n,\n      schemaCode: r,\n      schemaType: o,\n      def: i\n    } = this;\n    n.if(u.or(u._`${r} === undefined`, t));\n    e !== u.nil && n.assign(e, !0);\n    (o.length || i.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), e !== u.nil && n.assign(e, !1));\n    n.else();\n  }\n  invalid$data() {\n    const {\n      gen: e,\n      schemaCode: t,\n      schemaType: n,\n      def: r,\n      it: o\n    } = this;\n    return u.or(function () {\n      if (n.length) {\n        if (!(t instanceof u.Name)) throw new Error(\"ajv implementation error\");\n        const e = Array.isArray(n) ? n : [n];\n        return u._`${s.checkDataTypes(e, t, o.opts.strictNumbers, s.DataType.Wrong)}`;\n      }\n      return u.nil;\n    }(), function () {\n      if (r.validateSchema) {\n        const n = e.scopeValue(\"validate$data\", {\n          ref: r.validateSchema\n        });\n        return u._`!${n}(${t})`;\n      }\n      return u.nil;\n    }());\n  }\n  subschema(e, t) {\n    const n = l.getSubschema(this.it, e);\n    l.extendSubschemaData(n, this.it, e);\n    l.extendSubschemaMode(n, e);\n    const o = {\n      ...this.it,\n      ...n,\n      items: undefined,\n      props: undefined\n    };\n    (function (e, t) {\n      y(e) && (v(e), _(e)) ? function (e, t) {\n        const {\n          schema: n,\n          gen: r,\n          opts: o\n        } = e;\n        o.$comment && n.$comment && w(e);\n        (function (e) {\n          const t = e.schema[e.opts.schemaId];\n          t && (e.baseId = p.resolveUrl(e.baseId, t));\n        })(e);\n        (function (e) {\n          if (e.schema.$async && !e.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n        })(e);\n        const i = r.const(\"_errs\", d.default.errors);\n        b(e, i);\n        r.var(t, u._`${i} === ${d.default.errors}`);\n      }(e, t) : r.boolOrEmptySchema(e, t);\n    })(o, t);\n    return o;\n  }\n  mergeEvaluated(e, t) {\n    const {\n      it: n,\n      gen: r\n    } = this;\n    n.opts.unevaluated && (!0 !== n.props && undefined !== e.props && (n.props = h.mergeEvaluated.props(r, e.props, n.props, t)), !0 !== n.items && undefined !== e.items && (n.items = h.mergeEvaluated.items(r, e.items, n.items, t)));\n  }\n  mergeValidEvaluated(e, t) {\n    const {\n      it: n,\n      gen: r\n    } = this;\n    if (n.opts.unevaluated && (!0 !== n.props || !0 !== n.items)) {\n      r.if(t, () => this.mergeEvaluated(e, u.Name));\n      return !0;\n    }\n  }\n}\nfunction k(e, t, n, r) {\n  const o = new KeywordCxt(e, n, t);\n  \"code\" in n ? n.code(o, r) : o.$data && n.validate ? c.funcKeywordCode(o, n) : \"macro\" in n ? c.macroKeywordCode(o, n) : (n.compile || n.validate) && c.funcKeywordCode(o, n);\n}\nexports.KeywordCxt = KeywordCxt;\nconst I = /^\\/(?:[^~]|~0|~1)*$/,\n  P = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData(e, {\n  dataLevel: t,\n  dataNames: n,\n  dataPathArr: r\n}) {\n  let o, i;\n  if (\"\" === e) return d.default.rootData;\n  if (\"/\" === e[0]) {\n    if (!I.test(e)) throw new Error(`Invalid JSON-pointer: ${e}`);\n    o = e;\n    i = d.default.rootData;\n  } else {\n    const s = P.exec(e);\n    if (!s) throw new Error(`Invalid JSON-pointer: ${e}`);\n    const a = +s[1];\n    o = s[2];\n    if (\"#\" === o) {\n      if (a >= t) throw new Error(c(\"property/index\", a));\n      return r[t - a];\n    }\n    if (a > t) throw new Error(c(\"data\", a));\n    i = n[t - a];\n    if (!o) return i;\n  }\n  let s = i;\n  const a = o.split(\"/\");\n  for (const e of a) e && (i = u._`${i}${u.getProperty(h.unescapeJsonPointer(e))}`, s = u._`${s} && ${i}`);\n  return s;\n  function c(e, n) {\n    return `Cannot access ${e} ${n} levels up, current level is ${t}`;\n  }\n}\nexports.getData = getData;",
  "4855": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getWindowsDelineations = undefined;\nconst r = require(5288),\n  o = require(9829);\nexports.getWindowsDelineations = function (e, t, n, i) {\n  if (e.length < n || 0 == i) return [];\n  const s = [],\n    a = o.clearLabels(r.parseTree(e.join(\"\\n\"), t));\n  o.visitTree(a, e => {\n    if (\"blank\" === e.type) return void (e.label = {\n      totalLength: 1,\n      firstLineAfter: e.lineNumber + 1\n    });\n    let t = \"line\" === e.type ? 1 : 0,\n      r = \"line\" === e.type ? e.lineNumber + 1 : NaN;\n    function o(n) {\n      return -1 == n ? r - t : e.subs[n].label.firstLineAfter - e.subs[n].label.totalLength;\n    }\n    function a(t, n) {\n      return 0 == t ? n + 1 : e.subs[t - 1].label.firstLineAfter;\n    }\n    let c = \"line\" === e.type ? -1 : 0,\n      l = \"line\" === e.type ? 1 : 0,\n      u = 0;\n    for (let d = 0; d < e.subs.length; d++) {\n      for (; c >= 0 && c < e.subs.length && \"blank\" === e.subs[c].type;) {\n        l -= e.subs[c].label.totalLength;\n        c++;\n      }\n      \"blank\" !== e.subs[d].type && (u = d);\n      r = e.subs[d].label.firstLineAfter;\n      t += e.subs[d].label.totalLength;\n      l += e.subs[d].label.totalLength;\n      if (l > i) {\n        const t = o(c),\n          r = a(d, t),\n          p = u == d ? r : a(u, t);\n        for (n <= r - t && s.push([t, p]); l > i;) l -= -1 == c ? \"line\" == e.type ? 1 : 0 : e.subs[c].label.totalLength, c++;\n      }\n    }\n    if (c < e.subs.length) {\n      const t = o(c),\n        i = r,\n        a = -1 == c ? i : e.subs[u].label.firstLineAfter;\n      n <= i - t && s.push([t, a]);\n    }\n    e.label = {\n      totalLength: t,\n      firstLineAfter: r\n    };\n  }, \"bottomUp\");\n  return s.sort((e, t) => e[0] - t[0] || e[1] - t[1]).filter((e, t, n) => 0 == t || e[0] != n[t - 1][0] || e[1] != n[t - 1][1]);\n};",
  "4938": "var r, o, i, s, a, c;\nr = require(8249);\ni = (o = r).lib;\ns = i.Base;\na = i.WordArray;\n(c = o.x64 = {}).Word = s.extend({\n  init: function (e, t) {\n    this.high = e;\n    this.low = t;\n  }\n});\nc.WordArray = s.extend({\n  init: function (e, t) {\n    e = this.words = e || [];\n    this.sigBytes = null != t ? t : 8 * e.length;\n  },\n  toX32: function () {\n    for (var e = this.words, t = e.length, n = [], r = 0; r < t; r++) {\n      var o = e[r];\n      n.push(o.high);\n      n.push(o.low);\n    }\n    return a.create(n, this.sigBytes);\n  },\n  clone: function () {\n    for (var e = s.clone.call(this), t = e.words = this.words.slice(0), n = t.length, r = 0; r < n; r++) t[r] = t[r].clone();\n    return e;\n  }\n});\nmodule.exports = r;",
  "4953": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(7424),\n  o = require(7424);\nexports.makePatchingRequire = o.makePatchingRequire;\nvar i = function (e) {\n    return !0;\n  },\n  s = function () {\n    function e() {\n      this.version = require(130).i8;\n      this.subscribers = {};\n      this.contextPreservationFunction = function (e) {\n        return e;\n      };\n      this.knownPatches = {};\n      this.currentlyPublishing = !1;\n    }\n    e.prototype.shouldPublish = function (e) {\n      var t = this.subscribers[e];\n      return !!t && t.some(function (e) {\n        var t = e.filter;\n        return !t || t(!1);\n      });\n    };\n    e.prototype.publish = function (e, t) {\n      if (!this.currentlyPublishing) {\n        var n = this.subscribers[e];\n        if (n) {\n          var r = {\n            timestamp: Date.now(),\n            data: t\n          };\n          this.currentlyPublishing = !0;\n          n.forEach(function (e) {\n            var t = e.listener,\n              n = e.filter;\n            try {\n              n && n(!0) && t(r);\n            } catch (e) {}\n          });\n          this.currentlyPublishing = !1;\n        }\n      }\n    };\n    e.prototype.subscribe = function (e, t, n) {\n      undefined === n && (n = i);\n      this.subscribers[e] || (this.subscribers[e] = []);\n      this.subscribers[e].push({\n        listener: t,\n        filter: n\n      });\n    };\n    e.prototype.unsubscribe = function (e, t, n) {\n      undefined === n && (n = i);\n      var r = this.subscribers[e];\n      if (r) for (var o = 0; o < r.length; ++o) if (r[o].listener === t && r[o].filter === n) {\n        r.splice(o, 1);\n        return !0;\n      }\n      return !1;\n    };\n    e.prototype.reset = function () {\n      var e = this;\n      this.subscribers = {};\n      this.contextPreservationFunction = function (e) {\n        return e;\n      };\n      Object.getOwnPropertyNames(this.knownPatches).forEach(function (t) {\n        return delete e.knownPatches[t];\n      });\n    };\n    e.prototype.bindToContext = function (e) {\n      return this.contextPreservationFunction(e);\n    };\n    e.prototype.addContextPreservation = function (e) {\n      var t = this.contextPreservationFunction;\n      this.contextPreservationFunction = function (n) {\n        return e(t(n));\n      };\n    };\n    e.prototype.registerMonkeyPatch = function (e, t) {\n      this.knownPatches[e] || (this.knownPatches[e] = []);\n      this.knownPatches[e].push(t);\n    };\n    e.prototype.getPatchesObject = function () {\n      return this.knownPatches;\n    };\n    return e;\n  }();\nglobal.diagnosticsSource || (global.diagnosticsSource = new s(), require(8188).prototype.require = r.makePatchingRequire(global.diagnosticsSource.getPatchesObject()));\nexports.channel = global.diagnosticsSource;",
  "4969": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.extractPrompt = exports.trimLastLine = exports._contextTooShort = exports.MIN_PROMPT_CHARS = undefined;\nconst r = require(3055),\n  o = require(1133),\n  i = require(1839),\n  s = require(9189),\n  a = require(3136),\n  c = require(2533),\n  l = require(766);\nfunction trimLastLine(e) {\n  const t = e.split(\"\\n\"),\n    n = t[t.length - 1],\n    r = n.length - n.trimRight().length,\n    o = e.slice(0, e.length - r),\n    i = e.substr(o.length);\n  return [n.length == r ? o : e, i];\n}\nasync function d(e, n, d, p, h, f) {\n  var m;\n  const g = null !== (m = l.tryGetGitHubNWO(l.extractRepoInfoInBackground(e, h.fsPath))) && undefined !== m ? m : \"\",\n    _ = await o.suffixPercent(e, g, f),\n    y = await o.fimSuffixLengthThreshold(e, g, f);\n  if ((_ > 0 ? n.length : d) < exports.MIN_PROMPT_CHARS) return exports._contextTooShort;\n  const v = Date.now(),\n    {\n      prefix: b,\n      suffix: w,\n      promptChoices: x,\n      promptBackground: E,\n      promptElementRanges: C\n    } = await async function (e, t, n, u, d, p) {\n      var h;\n      let f = [];\n      f = await async function (e, t, n) {\n        const r = [],\n          o = i.sortByAccessTimes(e.get(a.TextDocumentManager).textDocuments);\n        let s = 0;\n        for (const i of o) {\n          if (r.length + 1 > 20 || s + i.getText().length > 2e5) break;\n          \"file\" == i.uri.scheme && i.fileName !== t && i.languageId === n && (r.push({\n            uri: i.uri.toString(),\n            relativePath: await e.get(a.TextDocumentManager).getRelativePath(i),\n            languageId: i.languageId,\n            source: i.getText()\n          }), s += i.getText().length);\n        }\n        return r;\n      }(e, d.fsPath, p);\n      const m = {\n          uri: d.toString(),\n          source: t,\n          offset: n,\n          relativePath: u,\n          languageId: p\n        },\n        g = null !== (h = l.tryGetGitHubNWO(l.extractRepoInfoInBackground(e, d.fsPath))) && undefined !== h ? h : \"\";\n      let _ = {\n        maxPromptLength: 2048 - o.getConfig(e, o.ConfigKey.SolutionLength),\n        neighboringTabs: await e.get(s.Features).neighboringTabsOption(g, p),\n        suffixStartMode: await e.get(s.Features).suffixStartMode(g, p)\n      };\n      const y = await o.suffixPercent(e, g, p),\n        v = await o.suffixMatchThreshold(e, g, p),\n        b = await o.fimSuffixLengthThreshold(e, g, p);\n      y > 0 && (_ = {\n        ..._,\n        includeSiblingFunctions: r.SiblingOption.NoSiblings,\n        suffixPercent: y,\n        suffixMatchThreshold: v,\n        fimSuffixLengthThreshold: b\n      });\n      const w = e.get(r.FileSystem);\n      return await c.getPrompt(w, m, _, f);\n    }(e, n, d, p, h, f),\n    [S, T] = trimLastLine(b),\n    k = Date.now();\n  return {\n    type: \"prompt\",\n    prompt: {\n      prefix: S,\n      suffix: w,\n      isFimEnabled: _ > 0 && w.length > y,\n      promptElementRanges: C.ranges\n    },\n    trailingWs: T,\n    promptChoices: x,\n    computeTimeMs: k - v,\n    promptBackground: E\n  };\n}\nasync function p(e, t, n) {\n  const r = await e.get(a.TextDocumentManager).getRelativePath(t);\n  return d(e, t.getText(), t.offsetAt(n), r, t.uri, t.languageId);\n}\nexports.MIN_PROMPT_CHARS = 10;\nexports._contextTooShort = {\n  type: \"contextTooShort\"\n};\nexports.trimLastLine = trimLastLine;\nexports.extractPrompt = function (e, t, n) {\n  const r = e.get(a.TextDocumentManager).findNotebook(t);\n  return undefined === r ? p(e, t, n) : async function (e, t, n, r) {\n    const o = n.getCells().find(e => e.document.uri === t.uri);\n    if (o) {\n      const i = n.getCells().filter(e => e.index < o.index && e.document.languageId === o.document.languageId),\n        s = i.length > 0 ? i.map(e => e.document.getText()).join(\"\\n\\n\") + \"\\n\\n\" : \"\",\n        c = s + t.getText(),\n        l = s.length + t.offsetAt(r),\n        u = await e.get(a.TextDocumentManager).getRelativePath(t);\n      return d(e, c, l, u, t.uri, o.document.languageId);\n    }\n    return p(e, t, r);\n  }(e, t, r, n);\n};",
  "5005": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = undefined;\nconst r = require(3487),\n  o = require(2141),\n  i = require(412),\n  s = require(4181);\nfunction a(e) {\n  const {\n    gen: t,\n    data: n,\n    it: o\n  } = e;\n  t.if(o.parentData, () => t.assign(n, r._`${o.parentData}[${o.parentDataProperty}]`));\n}\nfunction c(e, t, n) {\n  if (undefined === n) throw new Error(`keyword \"${t}\" failed to compile`);\n  return e.scopeValue(\"keyword\", \"function\" == typeof n ? {\n    ref: n\n  } : {\n    ref: n,\n    code: r.stringify(n)\n  });\n}\nexports.macroKeywordCode = function (e, t) {\n  const {\n      gen: n,\n      keyword: o,\n      schema: i,\n      parentSchema: s,\n      it: a\n    } = e,\n    l = t.macro.call(a.self, i, s, a),\n    u = c(n, o, l);\n  !1 !== a.opts.validateSchema && a.self.validateSchema(l, !0);\n  const d = n.name(\"valid\");\n  e.subschema({\n    schema: l,\n    schemaPath: r.nil,\n    errSchemaPath: `${a.errSchemaPath}/${o}`,\n    topSchemaRef: u,\n    compositeRule: !0\n  }, d);\n  e.pass(d, () => e.error(!0));\n};\nexports.funcKeywordCode = function (e, t) {\n  var n;\n  const {\n    gen: l,\n    keyword: u,\n    schema: d,\n    parentSchema: p,\n    $data: h,\n    it: f\n  } = e;\n  !function ({\n    schemaEnv: e\n  }, t) {\n    if (t.async && !e.$async) throw new Error(\"async keyword in sync schema\");\n  }(f, t);\n  const m = !h && t.compile ? t.compile.call(f.self, d, p, f) : t.validate,\n    g = c(l, u, m),\n    _ = l.let(\"valid\");\n  function y(n = t.async ? r._`await ` : r.nil) {\n    const s = f.opts.passContext ? o.default.this : o.default.self,\n      a = !(\"compile\" in t && !h || !1 === t.schema);\n    l.assign(_, r._`${n}${i.callValidateCode(e, g, s, a)}`, t.modifying);\n  }\n  function v(e) {\n    var n;\n    l.if(r.not(null !== (n = t.valid) && undefined !== n ? n : _), e);\n  }\n  e.block$data(_, function () {\n    if (!1 === t.errors) {\n      y();\n      t.modifying && a(e);\n      v(() => e.error());\n    } else {\n      const n = t.async ? function () {\n        const e = l.let(\"ruleErrs\", null);\n        l.try(() => y(r._`await `), t => l.assign(_, !1).if(r._`${t} instanceof ${f.ValidationError}`, () => l.assign(e, r._`${t}.errors`), () => l.throw(t)));\n        return e;\n      }() : function () {\n        const e = r._`${g}.errors`;\n        l.assign(e, null);\n        y(r.nil);\n        return e;\n      }();\n      t.modifying && a(e);\n      v(() => function (e, t) {\n        const {\n          gen: n\n        } = e;\n        n.if(r._`Array.isArray(${t})`, () => {\n          n.assign(o.default.vErrors, r._`${o.default.vErrors} === null ? ${t} : ${o.default.vErrors}.concat(${t})`).assign(o.default.errors, r._`${o.default.vErrors}.length`);\n          s.extendErrors(e);\n        }, () => e.error());\n      }(e, n));\n    }\n  });\n  e.ok(null !== (n = t.valid) && undefined !== n ? n : _);\n};\nexports.validSchemaType = function (e, t, n = !1) {\n  return !t.length || t.some(t => \"array\" === t ? Array.isArray(e) : \"object\" === t ? e && \"object\" == typeof e && !Array.isArray(e) : typeof e == t || n && undefined === e);\n};\nexports.validateKeywordUsage = function ({\n  schema: e,\n  opts: t,\n  self: n,\n  errSchemaPath: r\n}, o, i) {\n  if (Array.isArray(o.keyword) ? !o.keyword.includes(i) : o.keyword !== i) throw new Error(\"ajv implementation error\");\n  const s = o.dependencies;\n  if (null == s ? undefined : s.some(t => !Object.prototype.hasOwnProperty.call(e, t))) throw new Error(`parent schema must have dependencies of ${i}: ${s.join(\",\")}`);\n  if (o.validateSchema && !o.validateSchema(e[i])) {\n    const e = `keyword \"${i}\" value is invalid at path \"${r}\": ` + n.errorsText(o.validateSchema.errors);\n    if (\"log\" !== t.validateSchema) throw new Error(e);\n    n.logger.error(e);\n  }\n};",
  "5012": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.defaultFileSystem = exports.FileSystem = undefined;\nconst r = require(7147);\nexports.FileSystem = class {};\nexports.defaultFileSystem = {\n  readFile: e => r.promises.readFile(e),\n  mtime: async e => (await r.promises.stat(e)).mtimeMs,\n  async stat(e) {\n    const t = await r.promises.stat(e);\n    return {\n      ctime: t.ctimeMs,\n      mtime: t.mtimeMs,\n      size: t.size\n    };\n  }\n};",
  "5071": "var r = require(4953),\n  o = [];\nexports.qP = function (e) {\n  o.forEach(function (t) {\n    \"info\" !== e.data.commandObj.command && t.trackDependency({\n      target: e.data.address,\n      name: e.data.commandObj.command,\n      data: e.data.commandObj.command,\n      duration: e.data.duration,\n      success: !e.data.err,\n      resultCode: e.data.err ? \"1\" : \"0\",\n      dependencyTypeName: \"redis\"\n    });\n  });\n};\nexports.wp = function (e, n) {\n  e ? (0 === o.length && r.channel.subscribe(\"redis\", exports.qP), o.push(n)) : 0 === (o = o.filter(function (e) {\n    return e != n;\n  })).length && r.channel.unsubscribe(\"redis\", exports.qP);\n};",
  "5109": "var r, o, i, s, a, c, l, u, d, p, h, f, m, g, _, y, v, b, w;\nr = require(8249);\nrequire(888);\nmodule.exports = void (r.lib.Cipher || (o = r, i = o.lib, s = i.Base, a = i.WordArray, c = i.BufferedBlockAlgorithm, l = o.enc, l.Utf8, u = l.Base64, d = o.algo.EvpKDF, p = i.Cipher = c.extend({\n  cfg: s.extend(),\n  createEncryptor: function (e, t) {\n    return this.create(this._ENC_XFORM_MODE, e, t);\n  },\n  createDecryptor: function (e, t) {\n    return this.create(this._DEC_XFORM_MODE, e, t);\n  },\n  init: function (e, t, n) {\n    this.cfg = this.cfg.extend(n), this._xformMode = e, this._key = t, this.reset();\n  },\n  reset: function () {\n    c.reset.call(this), this._doReset();\n  },\n  process: function (e) {\n    return this._append(e), this._process();\n  },\n  finalize: function (e) {\n    return e && this._append(e), this._doFinalize();\n  },\n  keySize: 4,\n  ivSize: 4,\n  _ENC_XFORM_MODE: 1,\n  _DEC_XFORM_MODE: 2,\n  _createHelper: function () {\n    function e(e) {\n      return \"string\" == typeof e ? w : v;\n    }\n    return function (t) {\n      return {\n        encrypt: function (n, r, o) {\n          return e(r).encrypt(t, n, r, o);\n        },\n        decrypt: function (n, r, o) {\n          return e(r).decrypt(t, n, r, o);\n        }\n      };\n    };\n  }()\n}), i.StreamCipher = p.extend({\n  _doFinalize: function () {\n    return this._process(!0);\n  },\n  blockSize: 1\n}), h = o.mode = {}, f = i.BlockCipherMode = s.extend({\n  createEncryptor: function (e, t) {\n    return this.Encryptor.create(e, t);\n  },\n  createDecryptor: function (e, t) {\n    return this.Decryptor.create(e, t);\n  },\n  init: function (e, t) {\n    this._cipher = e, this._iv = t;\n  }\n}), m = h.CBC = function () {\n  var e = f.extend();\n  function t(e, t, n) {\n    var r,\n      o = this._iv;\n    o ? (r = o, this._iv = void 0) : r = this._prevBlock;\n    for (var i = 0; i < n; i++) e[t + i] ^= r[i];\n  }\n  return e.Encryptor = e.extend({\n    processBlock: function (e, n) {\n      var r = this._cipher,\n        o = r.blockSize;\n      t.call(this, e, n, o), r.encryptBlock(e, n), this._prevBlock = e.slice(n, n + o);\n    }\n  }), e.Decryptor = e.extend({\n    processBlock: function (e, n) {\n      var r = this._cipher,\n        o = r.blockSize,\n        i = e.slice(n, n + o);\n      r.decryptBlock(e, n), t.call(this, e, n, o), this._prevBlock = i;\n    }\n  }), e;\n}(), g = (o.pad = {}).Pkcs7 = {\n  pad: function (e, t) {\n    for (var n = 4 * t, r = n - e.sigBytes % n, o = r << 24 | r << 16 | r << 8 | r, i = [], s = 0; s < r; s += 4) i.push(o);\n    var c = a.create(i, r);\n    e.concat(c);\n  },\n  unpad: function (e) {\n    var t = 255 & e.words[e.sigBytes - 1 >>> 2];\n    e.sigBytes -= t;\n  }\n}, i.BlockCipher = p.extend({\n  cfg: p.cfg.extend({\n    mode: m,\n    padding: g\n  }),\n  reset: function () {\n    var e;\n    p.reset.call(this);\n    var t = this.cfg,\n      n = t.iv,\n      r = t.mode;\n    this._xformMode == this._ENC_XFORM_MODE ? e = r.createEncryptor : (e = r.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == e ? this._mode.init(this, n && n.words) : (this._mode = e.call(r, this, n && n.words), this._mode.__creator = e);\n  },\n  _doProcessBlock: function (e, t) {\n    this._mode.processBlock(e, t);\n  },\n  _doFinalize: function () {\n    var e,\n      t = this.cfg.padding;\n    return this._xformMode == this._ENC_XFORM_MODE ? (t.pad(this._data, this.blockSize), e = this._process(!0)) : (e = this._process(!0), t.unpad(e)), e;\n  },\n  blockSize: 4\n}), _ = i.CipherParams = s.extend({\n  init: function (e) {\n    this.mixIn(e);\n  },\n  toString: function (e) {\n    return (e || this.formatter).stringify(this);\n  }\n}), y = (o.format = {}).OpenSSL = {\n  stringify: function (e) {\n    var t = e.ciphertext,\n      n = e.salt;\n    return (n ? a.create([1398893684, 1701076831]).concat(n).concat(t) : t).toString(u);\n  },\n  parse: function (e) {\n    var t,\n      n = u.parse(e),\n      r = n.words;\n    return 1398893684 == r[0] && 1701076831 == r[1] && (t = a.create(r.slice(2, 4)), r.splice(0, 4), n.sigBytes -= 16), _.create({\n      ciphertext: n,\n      salt: t\n    });\n  }\n}, v = i.SerializableCipher = s.extend({\n  cfg: s.extend({\n    format: y\n  }),\n  encrypt: function (e, t, n, r) {\n    r = this.cfg.extend(r);\n    var o = e.createEncryptor(n, r),\n      i = o.finalize(t),\n      s = o.cfg;\n    return _.create({\n      ciphertext: i,\n      key: n,\n      iv: s.iv,\n      algorithm: e,\n      mode: s.mode,\n      padding: s.padding,\n      blockSize: e.blockSize,\n      formatter: r.format\n    });\n  },\n  decrypt: function (e, t, n, r) {\n    return r = this.cfg.extend(r), t = this._parse(t, r.format), e.createDecryptor(n, r).finalize(t.ciphertext);\n  },\n  _parse: function (e, t) {\n    return \"string\" == typeof e ? t.parse(e, this) : e;\n  }\n}), b = (o.kdf = {}).OpenSSL = {\n  execute: function (e, t, n, r) {\n    r || (r = a.random(8));\n    var o = d.create({\n        keySize: t + n\n      }).compute(e, r),\n      i = a.create(o.words.slice(t), 4 * n);\n    return o.sigBytes = 4 * t, _.create({\n      key: o,\n      iv: i,\n      salt: r\n    });\n  }\n}, w = i.PasswordBasedCipher = v.extend({\n  cfg: v.cfg.extend({\n    kdf: b\n  }),\n  encrypt: function (e, t, n, r) {\n    var o = (r = this.cfg.extend(r)).kdf.execute(n, e.keySize, e.ivSize);\n    r.iv = o.iv;\n    var i = v.encrypt.call(this, e, t, o.key, r);\n    return i.mixIn(o), i;\n  },\n  decrypt: function (e, t, n, r) {\n    r = this.cfg.extend(r), t = this._parse(t, r.format);\n    var o = r.kdf.execute(n, e.keySize, e.ivSize, t.salt);\n    return r.iv = o.iv, v.decrypt.call(this, e, t, o.key, r);\n  }\n})));",
  "5120": "function editDistance(e, t, n = (e, t) => e === t ? 0 : 1) {\n  if (0 === t.length || 0 === e.length) return {\n    distance: t.length,\n    startOffset: 0,\n    endOffset: 0\n  };\n  let r = new Array(t.length + 1).fill(0),\n    o = new Array(t.length + 1).fill(0),\n    i = new Array(e.length + 1).fill(0),\n    s = new Array(e.length + 1).fill(0),\n    a = t[0];\n  for (let t = 0; t < e.length + 1; t++) {\n    r[t] = 0 === t ? 1 : n(e[t - 1], a, t - 1, 0);\n    o[t] = t > 0 ? t - 1 : 0;\n  }\n  for (let c = 1; c < t.length; c++) {\n    let l = i;\n    i = r;\n    r = l;\n    l = s;\n    s = o;\n    o = l;\n    a = t[c];\n    r[0] = c + 1;\n    for (let t = 1; t < e.length + 1; t++) {\n      const l = 1 + i[t],\n        u = 1 + r[t - 1],\n        d = n(e[t - 1], a, t - 1, c) + i[t - 1];\n      r[t] = Math.min(u, l, d);\n      r[t] === d ? o[t] = s[t - 1] : r[t] === l ? o[t] = s[t] : o[t] = o[t - 1];\n    }\n  }\n  let c = 0;\n  for (let t = 0; t < e.length + 1; t++) r[t] < r[c] && (c = t);\n  return {\n    distance: r[c],\n    startOffset: o[c],\n    endOffset: c\n  };\n}\nfunction emptyLexDictionary() {\n  return new Map();\n}\nfunction reverseLexDictionary(e) {\n  const t = new Array(e.size);\n  for (const [n, r] of e) t[r] = n;\n  return t;\n}\nfunction* lexGeneratorWords(e) {\n  let t,\n    n = \"\";\n  !function (e) {\n    e[e.Word = 0] = \"Word\";\n    e[e.Space = 1] = \"Space\";\n    e[e.Other = 2] = \"Other\";\n  }(t || (t = {}));\n  let r = t.Word;\n  for (const o of e) {\n    let e;\n    e = /(\\p{L}|\\p{Nd}|_)/u.test(o) ? t.Word : \" \" === o ? t.Space : t.Other;\n    e === r && e !== t.Other ? n += o : (n.length > 0 && (yield n), n = o, r = e);\n  }\n  n.length > 0 && (yield n);\n}\nfunction lexicalAnalyzer(e, t, n, r) {\n  const o = [];\n  let i = 0;\n  for (const s of n(e)) {\n    r(s) && (t.has(s) || t.set(s, t.size), o.push([t.get(s), i]));\n    i += s.length;\n  }\n  return [o, t];\n}\nfunction a(e) {\n  return \" \" !== e;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.lexEditDistance = exports.lexicalAnalyzer = exports.lexGeneratorWords = exports.reverseLexDictionary = exports.emptyLexDictionary = exports.editDistance = undefined;\nexports.editDistance = editDistance;\nexports.emptyLexDictionary = emptyLexDictionary;\nexports.reverseLexDictionary = reverseLexDictionary;\nexports.lexGeneratorWords = lexGeneratorWords;\nexports.lexicalAnalyzer = lexicalAnalyzer;\nexports.lexEditDistance = function (e, t, c = lexGeneratorWords) {\n  const [l, u] = lexicalAnalyzer(e, emptyLexDictionary(), c, a),\n    [d, p] = lexicalAnalyzer(t, u, c, a);\n  if (0 === d.length || 0 === l.length) return {\n    lexDistance: d.length,\n    startOffset: 0,\n    endOffset: 0,\n    haystackLexLength: l.length,\n    needleLexLength: d.length\n  };\n  const h = reverseLexDictionary(p),\n    f = d.length,\n    m = h[d[0][0]],\n    g = h[d[f - 1][0]],\n    _ = editDistance(l.map(e => e[0]), d.map(e => e[0]), function (e, t, n, r) {\n      if (0 === r || r === f - 1) {\n        const e = h[l[n][0]];\n        return 0 == r && e.endsWith(m) || r == f - 1 && e.startsWith(g) ? 0 : 1;\n      }\n      return e === t ? 0 : 1;\n    }),\n    y = l[_.startOffset][1];\n  let v = _.endOffset < l.length ? l[_.endOffset][1] : e.length;\n  v > 0 && \" \" === e[v - 1] && --v;\n  return {\n    lexDistance: _.distance,\n    startOffset: y,\n    endOffset: v,\n    haystackLexLength: l.length,\n    needleLexLength: d.length\n  };\n};",
  "5158": "var r = require(3580),\n  o = function () {\n    function e() {}\n    e.parse = function (t) {\n      if (!t) return {};\n      var n = t.split(e._FIELDS_SEPARATOR).reduce(function (t, n) {\n        var r = n.split(e._FIELD_KEY_VALUE_SEPARATOR);\n        if (2 === r.length) {\n          var o = r[0].toLowerCase(),\n            i = r[1];\n          t[o] = i;\n        }\n        return t;\n      }, {});\n      if (Object.keys(n).length > 0) {\n        if (n.endpointsuffix) {\n          var o = n.location ? n.location + \".\" : \"\";\n          n.ingestionendpoint = n.ingestionendpoint || \"https://\" + o + \"dc.\" + n.endpointsuffix;\n          n.liveendpoint = n.liveendpoint || \"https://\" + o + \"live.\" + n.endpointsuffix;\n        }\n        n.ingestionendpoint = n.ingestionendpoint || r.DEFAULT_BREEZE_ENDPOINT;\n        n.liveendpoint = n.liveendpoint || r.DEFAULT_LIVEMETRICS_ENDPOINT;\n      }\n      return n;\n    };\n    e._FIELDS_SEPARATOR = \";\";\n    e._FIELD_KEY_VALUE_SEPARATOR = \"=\";\n    return e;\n  }();\nmodule.exports = o;",
  "5173": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = undefined;\nconst r = require(3487),\n  o = require(7426),\n  i = require(2141),\n  s = require(2531),\n  a = require(6776),\n  c = require(4815),\n  l = require(540);\nclass SchemaEnv {\n  constructor(e) {\n    var t;\n    let n;\n    this.refs = {};\n    this.dynamicAnchors = {};\n    \"object\" == typeof e.schema && (n = e.schema);\n    this.schema = e.schema;\n    this.schemaId = e.schemaId;\n    this.root = e.root || this;\n    this.baseId = null !== (t = e.baseId) && undefined !== t ? t : s.normalizeId(null == n ? undefined : n[e.schemaId || \"$id\"]);\n    this.schemaPath = e.schemaPath;\n    this.localRefs = e.localRefs;\n    this.meta = e.meta;\n    this.$async = null == n ? undefined : n.$async;\n    this.refs = {};\n  }\n}\nfunction compileSchema(e) {\n  const t = getCompilingSchema.call(this, e);\n  if (t) return t;\n  const n = s.getFullPath(e.root.baseId),\n    {\n      es5: a,\n      lines: l\n    } = this.opts.code,\n    {\n      ownProperties: u\n    } = this.opts,\n    d = new r.CodeGen(this.scope, {\n      es5: a,\n      lines: l,\n      ownProperties: u\n    });\n  let p;\n  e.$async && (p = d.scopeValue(\"Error\", {\n    ref: o.default,\n    code: r._`require(\"ajv/dist/runtime/validation_error\").default`\n  }));\n  const f = d.scopeName(\"validate\");\n  e.validateName = f;\n  const m = {\n    gen: d,\n    allErrors: this.opts.allErrors,\n    data: i.default.data,\n    parentData: i.default.parentData,\n    parentDataProperty: i.default.parentDataProperty,\n    dataNames: [i.default.data],\n    dataPathArr: [r.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: d.scopeValue(\"schema\", !0 === this.opts.code.source ? {\n      ref: e.schema,\n      code: r.stringify(e.schema)\n    } : {\n      ref: e.schema\n    }),\n    validateName: f,\n    ValidationError: p,\n    schema: e.schema,\n    schemaEnv: e,\n    rootId: n,\n    baseId: e.baseId || n,\n    schemaPath: r.nil,\n    errSchemaPath: e.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: r._`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let g;\n  try {\n    this._compilations.add(e);\n    c.validateFunctionCode(m);\n    d.optimize(this.opts.code.optimize);\n    const t = d.toString();\n    g = `${d.scopeRefs(i.default.scope)}return ${t}`;\n    this.opts.code.process && (g = this.opts.code.process(g, e));\n    const n = new Function(`${i.default.self}`, `${i.default.scope}`, g)(this, this.scope.get());\n    this.scope.value(f, {\n      ref: n\n    });\n    n.errors = null;\n    n.schema = e.schema;\n    n.schemaEnv = e;\n    e.$async && (n.$async = !0);\n    !0 === this.opts.code.source && (n.source = {\n      validateName: f,\n      validateCode: t,\n      scopeValues: d._values\n    });\n    if (this.opts.unevaluated) {\n      const {\n        props: e,\n        items: t\n      } = m;\n      n.evaluated = {\n        props: e instanceof r.Name ? void 0 : e,\n        items: t instanceof r.Name ? void 0 : t,\n        dynamicProps: e instanceof r.Name,\n        dynamicItems: t instanceof r.Name\n      }, n.source && (n.source.evaluated = (0, r.stringify)(n.evaluated));\n    }\n    e.validate = n;\n    return e;\n  } catch (t) {\n    throw delete e.validate, delete e.validateName, g && this.logger.error(\"Error compiling schema, function code:\", g), t;\n  } finally {\n    this._compilations.delete(e);\n  }\n}\nfunction p(e) {\n  return s.inlineRef(e.schema, this.opts.inlineRefs) ? e.schema : e.validate ? e : compileSchema.call(this, e);\n}\nfunction getCompilingSchema(e) {\n  for (const r of this._compilations) {\n    n = e;\n    if ((t = r).schema === n.schema && t.root === n.root && t.baseId === n.baseId) return r;\n  }\n  var t, n;\n}\nfunction f(e, t) {\n  let n;\n  for (; \"string\" == typeof (n = this.refs[t]);) t = n;\n  return n || this.schemas[t] || resolveSchema.call(this, e, t);\n}\nfunction resolveSchema(e, t) {\n  const n = l.parse(t),\n    r = s._getFullPath(n);\n  let o = s.getFullPath(e.baseId);\n  if (Object.keys(e.schema).length > 0 && r === o) return _.call(this, n, e);\n  const i = s.normalizeId(r),\n    a = this.refs[i] || this.schemas[i];\n  if (\"string\" == typeof a) {\n    const t = resolveSchema.call(this, e, a);\n    if (\"object\" != typeof (null == t ? undefined : t.schema)) return;\n    return _.call(this, n, t);\n  }\n  if (\"object\" == typeof (null == a ? undefined : a.schema)) {\n    a.validate || compileSchema.call(this, a);\n    if (i === (0, s.normalizeId)(t)) {\n      const {\n          schema: t\n        } = a,\n        {\n          schemaId: n\n        } = this.opts,\n        r = t[n];\n      return r && (o = (0, s.resolveUrl)(o, r)), new SchemaEnv({\n        schema: t,\n        schemaId: n,\n        root: e,\n        baseId: o\n      });\n    }\n    return _.call(this, n, a);\n  }\n}\nexports.SchemaEnv = SchemaEnv;\nexports.compileSchema = compileSchema;\nexports.resolveRef = function (e, t, n) {\n  var r;\n  n = s.resolveUrl(t, n);\n  const o = e.refs[n];\n  if (o) return o;\n  let i = f.call(this, e, n);\n  if (undefined === i) {\n    const o = null === (r = e.localRefs) || undefined === r ? undefined : r[n],\n      {\n        schemaId: s\n      } = this.opts;\n    o && (i = new SchemaEnv({\n      schema: o,\n      schemaId: s,\n      root: e,\n      baseId: t\n    }));\n  }\n  return undefined !== i ? e.refs[n] = p.call(this, i) : undefined;\n};\nexports.getCompilingSchema = getCompilingSchema;\nexports.resolveSchema = resolveSchema;\nconst g = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\nfunction _(e, {\n  baseId: t,\n  schema: n,\n  root: r\n}) {\n  var o;\n  if (\"/\" !== (null === (o = e.fragment) || undefined === o ? undefined : o[0])) return;\n  for (const r of e.fragment.slice(1).split(\"/\")) {\n    if (\"boolean\" == typeof n) return;\n    const e = n[a.unescapeFragment(r)];\n    if (undefined === e) return;\n    const o = \"object\" == typeof (n = e) && n[this.opts.schemaId];\n    !g.has(r) && o && (t = s.resolveUrl(t, o));\n  }\n  let i;\n  if (\"boolean\" != typeof n && n.$ref && !a.schemaHasRulesButRef(n, this.RULES)) {\n    const e = s.resolveUrl(t, n.$ref);\n    i = resolveSchema.call(this, r, e);\n  }\n  const {\n    schemaId: c\n  } = this.opts;\n  i = i || new SchemaEnv({\n    schema: n,\n    schemaId: c,\n    root: r,\n    baseId: t\n  });\n  return i.schema !== i.root.schema ? i : undefined;\n}",
  "5258": "module.exports = JSON.parse('{\"name\":\"@adobe/helix-fetch\",\"version\":\"3.1.1\",\"description\":\"Light-weight Fetch implementation transparently supporting both HTTP/1(.1) and HTTP/2\",\"main\":\"src/index.js\",\"scripts\":{\"test\":\"nyc mocha\",\"lint\":\"./node_modules/.bin/eslint .\",\"semantic-release\":\"semantic-release\"},\"mocha\":{\"timeout\":\"5000\",\"recursive\":\"true\",\"reporter\":\"mocha-multi-reporters\",\"reporter-options\":\"configFile=.mocha-multi.json\"},\"engines\":{\"node\":\">=12.0\"},\"types\":\"src/index.d.ts\",\"exports\":{\"import\":\"./src/index.mjs\",\"require\":\"./src/index.js\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/adobe/helix-fetch\"},\"author\":\"\",\"license\":\"Apache-2.0\",\"bugs\":{\"url\":\"https://github.com/adobe/helix-fetch/issues\"},\"homepage\":\"https://github.com/adobe/helix-fetch#readme\",\"keywords\":[\"fetch\",\"whatwg\",\"Fetch API\",\"http\",\"https\",\"http2\",\"h2\",\"promise\",\"async\",\"request\",\"RFC 7234\",\"7234\",\"caching\",\"cache\"],\"dependencies\":{\"debug\":\"4.3.4\",\"http-cache-semantics\":\"4.1.0\",\"lru-cache\":\"7.13.1\"},\"devDependencies\":{\"@adobe/eslint-config-helix\":\"1.3.2\",\"@semantic-release/changelog\":\"6.0.1\",\"@semantic-release/git\":\"10.0.1\",\"chai\":\"4.3.6\",\"chai-as-promised\":\"7.1.1\",\"chai-bytes\":\"0.1.2\",\"chai-iterator\":\"3.0.2\",\"eslint\":\"8.21.0\",\"eslint-plugin-header\":\"3.1.1\",\"eslint-plugin-import\":\"2.26.0\",\"formdata-node\":\"4.3.3\",\"lint-staged\":\"13.0.3\",\"mocha\":\"10.0.0\",\"mocha-multi-reporters\":\"1.5.1\",\"nock\":\"13.2.9\",\"nyc\":\"15.1.0\",\"parse-cache-control\":\"1.0.1\",\"pem\":\"1.14.6\",\"proxy\":\"^1.0.2\",\"semantic-release\":\"19.0.3\",\"sinon\":\"14.0.0\",\"stream-buffers\":\"3.0.2\",\"tunnel\":\"^0.0.6\"},\"lint-staged\":{\"*.js\":\"eslint\"},\"config\":{\"commitizen\":{\"path\":\"node_modules/cz-conventional-changelog\"},\"ghooks\":{\"pre-commit\":\"npx lint-staged\"}}}');",
  "5282": "var t = function () {\n  function e() {}\n  e.info = function (t) {\n    for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];\n    e.enableDebug && console.info(e.TAG + t, n);\n  };\n  e.warn = function (t) {\n    for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];\n    e.disableWarnings || console.warn(e.TAG + t, n);\n  };\n  e.enableDebug = !1;\n  e.disableWarnings = !1;\n  e.disableErrors = !1;\n  e.TAG = \"ApplicationInsights:\";\n  return e;\n}();\nmodule.exports = t;",
  "5288": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.parseTree = exports.registerLanguageSpecificParser = exports.flattenVirtual = exports.groupBlocks = exports.combineClosersAndOpeners = exports.buildLabelRules = exports.labelVirtualInherited = exports.labelLines = exports.parseRaw = undefined;\nconst r = require(9608),\n  o = require(9829);\nfunction parseRaw(e) {\n  const t = e.split(\"\\n\"),\n    n = t.map(e => e.match(/^\\s*/)[0].length),\n    o = t.map(e => e.trimLeft());\n  function i(e) {\n    const [t, i] = s(e + 1, n[e]);\n    return [r.lineNode(n[e], e, o[e], t), i];\n  }\n  function s(e, t) {\n    let s;\n    const a = [];\n    let c,\n      l = e;\n    for (; l < o.length && (\"\" === o[l] || n[l] > t);) if (\"\" === o[l]) {\n      undefined === c && (c = l);\n      l += 1;\n    } else {\n      if (undefined !== c) {\n        for (let e = c; e < l; e++) a.push(r.blankNode(e));\n        c = undefined;\n      }\n      [s, l] = i(l);\n      a.push(s);\n    }\n    undefined !== c && (l = c);\n    return [a, l];\n  }\n  const [a, c] = s(0, -1);\n  let l = c;\n  for (; l < o.length && \"\" === o[l];) {\n    a.push(r.blankNode(l));\n    l += 1;\n  }\n  if (l < o.length) throw new Error(`Parsing did not go to end of file. Ended at ${l} out of ${o.length}`);\n  return r.topNode(a);\n}\nfunction labelLines(e, t) {\n  o.visitTree(e, function (e) {\n    if (r.isLine(e)) {\n      const n = t.find(t => t.matches(e.sourceLine));\n      n && (e.label = n.label);\n    }\n  }, \"bottomUp\");\n}\nfunction buildLabelRules(e) {\n  return Object.keys(e).map(t => {\n    let n;\n    n = e[t].test ? n => e[t].test(n) : e[t];\n    return {\n      matches: n,\n      label: t\n    };\n  });\n}\nfunction combineClosersAndOpeners(e) {\n  const t = o.rebuildTree(e, function (e) {\n    if (0 === e.subs.length || -1 === e.subs.findIndex(e => \"closer\" === e.label || \"opener\" === e.label)) return e;\n    const t = [];\n    let n;\n    for (let o = 0; o < e.subs.length; o++) {\n      const i = e.subs[o],\n        s = e.subs[o - 1];\n      if (\"opener\" === i.label && undefined !== s && r.isLine(s)) {\n        s.subs.push(i);\n        i.subs.forEach(e => s.subs.push(e));\n        i.subs = [];\n      } else if (\"closer\" === i.label && undefined !== n && (r.isLine(i) || r.isVirtual(i)) && i.indentation >= n.indentation) {\n        let e = t.length - 1;\n        for (; e > 0 && r.isBlank(t[e]);) e -= 1;\n        n.subs.push(...t.splice(e + 1));\n        if (i.subs.length > 0) {\n          const e = n.subs.findIndex(e => \"newVirtual\" !== e.label),\n            t = n.subs.slice(0, e),\n            o = n.subs.slice(e),\n            s = o.length > 0 ? [(0, r.virtualNode)(i.indentation, o, \"newVirtual\")] : [];\n          n.subs = [...t, ...s, i];\n        } else n.subs.push(i);\n      } else {\n        t.push(i);\n        r.isBlank(i) || (n = i);\n      }\n    }\n    e.subs = t;\n    return e;\n  });\n  o.clearLabelsIf(e, e => \"newVirtual\" === e);\n  return t;\n}\nexports.parseRaw = parseRaw;\nexports.labelLines = labelLines;\nexports.labelVirtualInherited = function (e) {\n  o.visitTree(e, function (e) {\n    if (r.isVirtual(e) && undefined === e.label) {\n      const t = e.subs.filter(e => !r.isBlank(e));\n      1 === t.length && (e.label = t[0].label);\n    }\n  }, \"bottomUp\");\n};\nexports.buildLabelRules = buildLabelRules;\nexports.combineClosersAndOpeners = combineClosersAndOpeners;\nexports.groupBlocks = function (e, t = r.isBlank, n) {\n  return o.rebuildTree(e, function (e) {\n    if (e.subs.length <= 1) return e;\n    const o = [];\n    let i,\n      s = [],\n      a = !1;\n    function c(e = !1) {\n      if (undefined !== i && (o.length > 0 || !e)) {\n        const e = r.virtualNode(i, s, n);\n        o.push(e);\n      } else s.forEach(e => o.push(e));\n    }\n    for (let n = 0; n < e.subs.length; n++) {\n      const o = e.subs[n],\n        l = t(o);\n      !l && a && (c(), s = []);\n      a = l;\n      s.push(o);\n      r.isBlank(o) || (i = null != i ? i : o.indentation);\n    }\n    c(!0);\n    e.subs = o;\n    return e;\n  });\n};\nexports.flattenVirtual = function (e) {\n  return o.rebuildTree(e, function (e) {\n    return r.isVirtual(e) && undefined === e.label && e.subs.length <= 1 ? 0 === e.subs.length ? undefined : e.subs[0] : (1 === e.subs.length && r.isVirtual(e.subs[0]) && undefined === e.subs[0].label && (e.subs = e.subs[0].subs), e);\n  });\n};\nconst l = buildLabelRules({\n    opener: /^[\\[({]/,\n    closer: /^[\\])}]/\n  }),\n  u = {};\nexports.registerLanguageSpecificParser = function (e, t) {\n  u[e] = t;\n};\nexports.parseTree = function (e, t) {\n  const n = parseRaw(e),\n    r = u[null != t ? t : \"\"];\n  return r ? r(n) : (labelLines(n, l), combineClosersAndOpeners(n));\n};",
  "5290": "function r(e) {\n  for (var n in e) exports.hasOwnProperty(n) || (exports[n] = e[n]);\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nr(require(9382));\nr(require(9958));\nr(require(2626));",
  "5413": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getDebounceLimit = exports.GhostTextDebounceManager = undefined;\nconst r = require(9189);\nclass GhostTextDebounceManager {\n  constructor(e) {\n    this.forceDelayMs = e;\n    this.extraDebounceMs = 0;\n  }\n}\nexports.GhostTextDebounceManager = GhostTextDebounceManager;\nexports.getDebounceLimit = async function (e, t) {\n  let n;\n  if ((await e.get(r.Features).debouncePredict()) && t.measurements.contextualFilterScore) {\n    const e = t.measurements.contextualFilterScore,\n      r = .275,\n      o = 6;\n    n = 25 + 250 / (1 + Math.pow(e / r, o));\n  } else n = await e.get(r.Features).debounceMs();\n  return (n > 0 ? n : 75) + e.get(GhostTextDebounceManager).extraDebounceMs;\n};",
  "5420": "var t = Object.prototype.toString,\n  n = \"function\" == typeof Buffer.alloc && \"function\" == typeof Buffer.allocUnsafe && \"function\" == typeof Buffer.from;\nmodule.exports = function (e, r, o) {\n  if (\"number\" == typeof e) throw new TypeError('\"value\" argument must not be a number');\n  i = e;\n  return \"ArrayBuffer\" === t.call(i).slice(8, -1) ? function (e, t, r) {\n    t >>>= 0;\n    var o = e.byteLength - t;\n    if (o < 0) throw new RangeError(\"'offset' is out of bounds\");\n    if (undefined === r) r = o;else if ((r >>>= 0) > o) throw new RangeError(\"'length' is out of bounds\");\n    return n ? Buffer.from(e.slice(t, t + r)) : new Buffer(new Uint8Array(e.slice(t, t + r)));\n  }(e, r, o) : \"string\" == typeof e ? function (e, t) {\n    \"string\" == typeof t && \"\" !== t || (t = \"utf8\");\n    if (!Buffer.isEncoding(t)) throw new TypeError('\"encoding\" must be a valid string encoding');\n    return n ? Buffer.from(e, t) : new Buffer(e, t);\n  }(e, r) : n ? Buffer.from(e) : new Buffer(e);\n  var i;\n};",
  "5468": "require(1808);\nvar debug,\n  o = require(4404),\n  i = require(3685),\n  s = require(5687),\n  a = require(2361),\n  c = (require(9491), require(3837));\nfunction l(e) {\n  var t = this;\n  t.options = e || {};\n  t.proxyOptions = t.options.proxy || {};\n  t.maxSockets = t.options.maxSockets || i.Agent.defaultMaxSockets;\n  t.requests = [];\n  t.sockets = [];\n  t.on(\"free\", function (e, n, r, o) {\n    for (var i = d(n, r, o), s = 0, a = t.requests.length; s < a; ++s) {\n      var c = t.requests[s];\n      if (c.host === i.host && c.port === i.port) {\n        t.requests.splice(s, 1);\n        return void c.request.onSocket(e);\n      }\n    }\n    e.destroy();\n    t.removeSocket(e);\n  });\n}\nfunction u(e, t) {\n  var n = this;\n  l.prototype.createSocket.call(n, e, function (r) {\n    var i = e.request.getHeader(\"host\"),\n      s = p({}, n.options, {\n        socket: r,\n        servername: i ? i.replace(/:.*$/, \"\") : e.host\n      }),\n      a = o.connect(0, s);\n    n.sockets[n.sockets.indexOf(r)] = a;\n    t(a);\n  });\n}\nfunction d(e, t, n) {\n  return \"string\" == typeof e ? {\n    host: e,\n    port: t,\n    localAddress: n\n  } : e;\n}\nfunction p(e) {\n  for (var t = 1, n = arguments.length; t < n; ++t) {\n    var r = arguments[t];\n    if (\"object\" == typeof r) for (var o = Object.keys(r), i = 0, s = o.length; i < s; ++i) {\n      var a = o[i];\n      undefined !== r[a] && (e[a] = r[a]);\n    }\n  }\n  return e;\n}\nexports.httpOverHttp = function (e) {\n  var t = new l(e);\n  t.request = i.request;\n  return t;\n};\nexports.httpsOverHttp = function (e) {\n  var t = new l(e);\n  t.request = i.request;\n  t.createSocket = u;\n  t.defaultPort = 443;\n  return t;\n};\nexports.httpOverHttps = function (e) {\n  var t = new l(e);\n  t.request = s.request;\n  return t;\n};\nexports.httpsOverHttps = function (e) {\n  var t = new l(e);\n  t.request = s.request;\n  t.createSocket = u;\n  t.defaultPort = 443;\n  return t;\n};\nc.inherits(l, a.EventEmitter);\nl.prototype.addRequest = function (e, t, n, r) {\n  var o = this,\n    i = p({\n      request: e\n    }, o.options, d(t, n, r));\n  o.sockets.length >= this.maxSockets ? o.requests.push(i) : o.createSocket(i, function (t) {\n    function n() {\n      o.emit(\"free\", t, i);\n    }\n    function r(e) {\n      o.removeSocket(t);\n      t.removeListener(\"free\", n);\n      t.removeListener(\"close\", r);\n      t.removeListener(\"agentRemove\", r);\n    }\n    t.on(\"free\", n);\n    t.on(\"close\", r);\n    t.on(\"agentRemove\", r);\n    e.onSocket(t);\n  });\n};\nl.prototype.createSocket = function (e, t) {\n  var n = this,\n    o = {};\n  n.sockets.push(o);\n  var i = p({}, n.proxyOptions, {\n    method: \"CONNECT\",\n    path: e.host + \":\" + e.port,\n    agent: !1,\n    headers: {\n      host: e.host + \":\" + e.port\n    }\n  });\n  e.localAddress && (i.localAddress = e.localAddress);\n  i.proxyAuth && (i.headers = i.headers || {}, i.headers[\"Proxy-Authorization\"] = \"Basic \" + new Buffer(i.proxyAuth).toString(\"base64\"));\n  debug(\"making CONNECT request\");\n  var s = n.request(i);\n  function a(i, a, c) {\n    var l;\n    s.removeAllListeners();\n    a.removeAllListeners();\n    return 200 !== i.statusCode ? (debug(\"tunneling socket could not be established, statusCode=%d\", i.statusCode), a.destroy(), (l = new Error(\"tunneling socket could not be established, statusCode=\" + i.statusCode)).code = \"ECONNRESET\", e.request.emit(\"error\", l), void n.removeSocket(o)) : c.length > 0 ? (debug(\"got illegal response body from proxy\"), a.destroy(), (l = new Error(\"got illegal response body from proxy\")).code = \"ECONNRESET\", e.request.emit(\"error\", l), void n.removeSocket(o)) : (debug(\"tunneling connection has established\"), n.sockets[n.sockets.indexOf(o)] = a, t(a));\n  }\n  s.useChunkedEncodingByDefault = !1;\n  s.once(\"response\", function (e) {\n    e.upgrade = !0;\n  });\n  s.once(\"upgrade\", function (e, t, n) {\n    process.nextTick(function () {\n      a(e, t, n);\n    });\n  });\n  s.once(\"connect\", a);\n  s.once(\"error\", function (t) {\n    s.removeAllListeners();\n    debug(\"tunneling socket could not be established, cause=%s\\n\", t.message, t.stack);\n    var i = new Error(\"tunneling socket could not be established, cause=\" + t.message);\n    i.code = \"ECONNRESET\";\n    e.request.emit(\"error\", i);\n    n.removeSocket(o);\n  });\n  s.end();\n};\nl.prototype.removeSocket = function (e) {\n  var t = this.sockets.indexOf(e);\n  if (-1 !== t) {\n    this.sockets.splice(t, 1);\n    var n = this.requests.shift();\n    n && this.createSocket(n, function (e) {\n      n.request.onSocket(e);\n    });\n  }\n};\ndebug = process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG) ? function () {\n  var e = Array.prototype.slice.call(arguments);\n  \"string\" == typeof e[0] ? e[0] = \"TUNNEL: \" + e[0] : e.unshift(\"TUNNEL:\");\n  console.error.apply(console, e);\n} : function () {};\nexports.debug = debug;",
  "5481": "var n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.telemetryTypeToBaseType = function (e) {\n  switch (e) {\n    case n.Event:\n      return \"EventData\";\n    case n.Exception:\n      return \"ExceptionData\";\n    case n.Trace:\n      return \"MessageData\";\n    case n.Metric:\n      return \"MetricData\";\n    case n.Request:\n      return \"RequestData\";\n    case n.Dependency:\n      return \"RemoteDependencyData\";\n    case n.Availability:\n      return \"AvailabilityData\";\n  }\n};\nexports.baseTypeToTelemetryType = function (e) {\n  switch (e) {\n    case \"EventData\":\n      return n.Event;\n    case \"ExceptionData\":\n      return n.Exception;\n    case \"MessageData\":\n      return n.Trace;\n    case \"MetricData\":\n      return n.Metric;\n    case \"RequestData\":\n      return n.Request;\n    case \"RemoteDependencyData\":\n      return n.Dependency;\n    case \"AvailabilityData\":\n      return n.Availability;\n  }\n};\nexports.TelemetryTypeString = {\n  Event: \"EventData\",\n  Exception: \"ExceptionData\",\n  Trace: \"MessageData\",\n  Metric: \"MetricData\",\n  Request: \"RequestData\",\n  Dependency: \"RemoteDependencyData\",\n  Availability: \"AvailabilityData\"\n};\n(function (e) {\n  e[e.Event = 0] = \"Event\";\n  e[e.Exception = 1] = \"Exception\";\n  e[e.Trace = 2] = \"Trace\";\n  e[e.Metric = 3] = \"Metric\";\n  e[e.Request = 4] = \"Request\";\n  e[e.Dependency = 5] = \"Dependency\";\n  e[e.Availability = 6] = \"Availability\";\n})(n = exports.TelemetryType || (exports.TelemetryType = {}));",
  "5600": "const {\n    PassThrough: r,\n    Readable: o\n  } = require(2781),\n  {\n    types: {\n      isAnyArrayBuffer: i\n    }\n  } = require(3837),\n  {\n    FetchError: s,\n    FetchBaseError: a\n  } = require(3683),\n  {\n    streamToBuffer: c\n  } = require(4544),\n  l = Buffer.alloc(0),\n  u = Symbol(\"Body internals\"),\n  d = async e => {\n    if (e[u].disturbed) throw new TypeError(\"Already read\");\n    if (e[u].error) throw new TypeError(`Stream had error: ${e[u].error.message}`);\n    e[u].disturbed = !0;\n    const {\n      stream: t\n    } = e[u];\n    return null === t ? l : c(t);\n  };\nclass p {\n  constructor(e) {\n    let t;\n    t = null == e ? null : e instanceof URLSearchParams ? o.from(e.toString()) : e instanceof o ? e : Buffer.isBuffer(e) ? o.from(e) : i(e) ? o.from(Buffer.from(e)) : \"string\" == typeof e || e instanceof String ? o.from(e) : o.from(String(e));\n    this[u] = {\n      stream: t,\n      disturbed: !1,\n      error: null\n    };\n    e instanceof o && t.on(\"error\", e => {\n      const t = e instanceof a ? e : new s(`Invalid response body while trying to fetch ${this.url}: ${e.message}`, \"system\", e);\n      this[u].error = t;\n    });\n  }\n  get body() {\n    return this[u].stream;\n  }\n  get bodyUsed() {\n    return this[u].disturbed;\n  }\n  async buffer() {\n    return d(this);\n  }\n  async arrayBuffer() {\n    return (e = await this.buffer()).buffer.slice(e.byteOffset, e.byteOffset + e.byteLength);\n    var e;\n  }\n  async text() {\n    return (await d(this)).toString();\n  }\n  async json() {\n    return JSON.parse(await this.text());\n  }\n}\nObject.defineProperties(p.prototype, {\n  body: {\n    enumerable: !0\n  },\n  bodyUsed: {\n    enumerable: !0\n  },\n  arrayBuffer: {\n    enumerable: !0\n  },\n  json: {\n    enumerable: !0\n  },\n  text: {\n    enumerable: !0\n  }\n});\nmodule.exports = {\n  Body: p,\n  cloneStream: e => {\n    if (e[u].disturbed) throw new TypeError(\"Cannot clone: already read\");\n    const {\n      stream: t\n    } = e[u];\n    let n = t;\n    if (t instanceof o) {\n      n = new r();\n      const o = new r();\n      t.pipe(n);\n      t.pipe(o);\n      e[u].stream = o;\n    }\n    return n;\n  },\n  guessContentType: e => null === e ? null : \"string\" == typeof e ? \"text/plain; charset=utf-8\" : e instanceof URLSearchParams ? \"application/x-www-form-urlencoded; charset=utf-8\" : Buffer.isBuffer(e) || i(e) || e instanceof o ? null : \"text/plain; charset=utf-8\"\n};",
  "5667": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = undefined;\nconst r = require(4181),\n  o = require(3487),\n  i = require(2141),\n  s = {\n    message: \"boolean schema is false\"\n  };\nfunction a(e, t) {\n  const {\n      gen: n,\n      data: o\n    } = e,\n    i = {\n      gen: n,\n      keyword: \"false schema\",\n      data: o,\n      schema: !1,\n      schemaCode: !1,\n      schemaValue: !1,\n      params: {},\n      it: e\n    };\n  r.reportError(i, s, undefined, t);\n}\nexports.topBoolOrEmptySchema = function (e) {\n  const {\n    gen: t,\n    schema: n,\n    validateName: r\n  } = e;\n  !1 === n ? a(e, !1) : \"object\" == typeof n && !0 === n.$async ? t.return(i.default.data) : (t.assign(o._`${r}.errors`, null), t.return(!0));\n};\nexports.boolOrEmptySchema = function (e, t) {\n  const {\n    gen: n,\n    schema: r\n  } = e;\n  !1 === r ? (n.var(t, !1), a(e)) : n.var(t, !0);\n};",
  "5684": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(8386),\n  o = require(8280),\n  i = [\"$schema\", \"$id\", \"$defs\", \"$vocabulary\", {\n    keyword: \"$comment\"\n  }, \"definitions\", r.default, o.default];\nexports.default = i;",
  "5687": "module.exports = require(\"https\");",
  "5697": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(6776),\n  o = {\n    keyword: \"not\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: !0,\n    code(e) {\n      const {\n        gen: t,\n        schema: n,\n        it: o\n      } = e;\n      if (r.alwaysValidSchema(o, n)) return void e.fail();\n      const i = t.name(\"valid\");\n      e.subschema({\n        keyword: \"not\",\n        compositeRule: !0,\n        createErrors: !1,\n        allErrors: !1\n      }, i);\n      e.failResult(i, () => e.reset(), () => e.error());\n    },\n    error: {\n      message: \"must NOT be valid\"\n    }\n  };\nexports.default = o;",
  "5740": "var r = this && this.__assign || Object.assign || function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n    return e;\n  },\n  o = require(3685),\n  i = require(5687),\n  s = require(7310),\n  a = require(2057),\n  c = require(5282),\n  l = require(9036),\n  u = function () {\n    function e() {}\n    e.getCookie = function (t, n) {\n      var r = \"\";\n      if (t && t.length && \"string\" == typeof n) for (var o = t + \"=\", i = n.split(\";\"), s = 0; s < i.length; s++) {\n        n = i[s];\n        if ((n = e.trim(n)) && 0 === n.indexOf(o)) {\n          r = n.substring(o.length, i[s].length);\n          break;\n        }\n      }\n      return r;\n    };\n    e.trim = function (e) {\n      return \"string\" == typeof e ? e.replace(/^\\s+|\\s+$/g, \"\") : \"\";\n    };\n    e.int32ArrayToBase64 = function (e) {\n      var t = function (e, t) {\n          return String.fromCharCode(e >> t & 255);\n        },\n        n = e.map(function (e) {\n          return t(e, 24) + t(e, 16) + t(e, 8) + t(e, 0);\n        }).join(\"\"),\n        r = (Buffer.from ? Buffer.from(n, \"binary\") : new Buffer(n, \"binary\")).toString(\"base64\");\n      return r.substr(0, r.indexOf(\"=\"));\n    };\n    e.random32 = function () {\n      return 4294967296 * Math.random() | 0;\n    };\n    e.randomu32 = function () {\n      return e.random32() + 2147483648;\n    };\n    e.w3cTraceId = function () {\n      for (var t, n = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"], r = \"\", o = 0; o < 4; o++) r += n[15 & (t = e.random32())] + n[t >> 4 & 15] + n[t >> 8 & 15] + n[t >> 12 & 15] + n[t >> 16 & 15] + n[t >> 20 & 15] + n[t >> 24 & 15] + n[t >> 28 & 15];\n      var i = n[8 + 4 * Math.random() | 0];\n      return r.substr(0, 8) + r.substr(9, 4) + \"4\" + r.substr(13, 3) + i + r.substr(16, 3) + r.substr(19, 12);\n    };\n    e.isValidW3CId = function (e) {\n      return 32 === e.length && \"00000000000000000000000000000000\" !== e;\n    };\n    e.isArray = function (e) {\n      return \"[object Array]\" === Object.prototype.toString.call(e);\n    };\n    e.isError = function (e) {\n      return e instanceof Error;\n    };\n    e.isPrimitive = function (e) {\n      var t = typeof e;\n      return \"string\" === t || \"number\" === t || \"boolean\" === t;\n    };\n    e.isDate = function (e) {\n      return \"[object Date]\" === Object.prototype.toString.call(e);\n    };\n    e.msToTimeSpan = function (e) {\n      (isNaN(e) || e < 0) && (e = 0);\n      var t = (e / 1e3 % 60).toFixed(7).replace(/0{0,4}$/, \"\"),\n        n = \"\" + Math.floor(e / 6e4) % 60,\n        r = \"\" + Math.floor(e / 36e5) % 24,\n        o = Math.floor(e / 864e5);\n      t = t.indexOf(\".\") < 2 ? \"0\" + t : t;\n      n = n.length < 2 ? \"0\" + n : n;\n      return (o > 0 ? o + \".\" : \"\") + (r = r.length < 2 ? \"0\" + r : r) + \":\" + n + \":\" + t;\n    };\n    e.extractError = function (e) {\n      var t = e;\n      return {\n        message: e.message,\n        code: t.code || t.id || \"\"\n      };\n    };\n    e.extractObject = function (t) {\n      return t instanceof Error ? e.extractError(t) : \"function\" == typeof t.toJSON ? t.toJSON() : t;\n    };\n    e.validateStringMap = function (t) {\n      if (\"object\" == typeof t) {\n        var n = {};\n        for (var r in t) {\n          var o = \"\",\n            i = t[r],\n            s = typeof i;\n          if (e.isPrimitive(i)) o = i.toString();else if (null === i || \"undefined\" === s) o = \"\";else {\n            if (\"function\" === s) {\n              c.info(\"key: \" + r + \" was function; will not serialize\");\n              continue;\n            }\n            var a = e.isArray(i) ? i : e.extractObject(i);\n            try {\n              o = e.isPrimitive(a) ? a : JSON.stringify(a);\n            } catch (e) {\n              o = i.constructor.name.toString() + \" (Error: \" + e.message + \")\";\n              c.info(\"key: \" + r + \", could not be serialized\");\n            }\n          }\n          n[r] = o.substring(0, e.MAX_PROPERTY_LENGTH);\n        }\n        return n;\n      }\n      c.info(\"Invalid properties dropped from payload\");\n    };\n    e.canIncludeCorrelationHeader = function (e, t) {\n      var n = e && e.config && e.config.correlationHeaderExcludedDomains;\n      if (!n || 0 == n.length || !t) return !0;\n      for (var r = 0; r < n.length; r++) if (new RegExp(n[r].replace(/\\./g, \".\").replace(/\\*/g, \".*\")).test(s.parse(t).hostname)) return !1;\n      return !0;\n    };\n    e.getCorrelationContextTarget = function (e, t) {\n      var n = e.headers && e.headers[l.requestContextHeader];\n      if (n) for (var r = n.split(\",\"), o = 0; o < r.length; ++o) {\n        var i = r[o].split(\"=\");\n        if (2 == i.length && i[0] == t) return i[1];\n      }\n    };\n    e.makeRequest = function (t, n, a, l) {\n      n && 0 === n.indexOf(\"//\") && (n = \"https:\" + n);\n      var u = s.parse(n),\n        d = r({}, a, {\n          host: u.hostname,\n          port: u.port,\n          path: u.pathname\n        }),\n        p = undefined;\n      \"https:\" === u.protocol && (p = t.proxyHttpsUrl || undefined);\n      \"http:\" === u.protocol && (p = t.proxyHttpUrl || undefined);\n      if (p) {\n        0 === p.indexOf(\"//\") && (p = \"http:\" + p);\n        var h = s.parse(p);\n        \"https:\" === h.protocol ? (c.info(\"Proxies that use HTTPS are not supported\"), p = void 0) : d = r({}, d, {\n          host: h.hostname,\n          port: h.port || \"80\",\n          path: n,\n          headers: r({}, d.headers, {\n            Host: u.hostname\n          })\n        });\n      }\n      var f = \"https:\" === u.protocol && !p;\n      f && undefined !== t.httpsAgent ? d.agent = t.httpsAgent : f || undefined === t.httpAgent ? f && (d.agent = e.tlsRestrictedAgent) : d.agent = t.httpAgent;\n      return f ? i.request(d, l) : o.request(d, l);\n    };\n    e.safeIncludeCorrelationHeader = function (t, n, r) {\n      var o;\n      if (\"string\" == typeof r) o = r;else if (r instanceof Array) o = r.join(\",\");else if (r && \"function\" == typeof r.toString) try {\n        o = r.toString();\n      } catch (e) {\n        c.warn(\"Outgoing request-context header could not be read. Correlation of requests may be lost.\", e, r);\n      }\n      o ? e.addCorrelationIdHeaderFromString(t, n, o) : n.setHeader(l.requestContextHeader, l.requestContextSourceKey + \"=\" + t.config.correlationId);\n    };\n    e.addCorrelationIdHeaderFromString = function (e, t, n) {\n      var r = n.split(\",\"),\n        o = l.requestContextSourceKey + \"=\";\n      r.some(function (e) {\n        return e.substring(0, o.length) === o;\n      }) || t.setHeader(l.requestContextHeader, n + \",\" + l.requestContextSourceKey + \"=\" + e.config.correlationId);\n    };\n    e.MAX_PROPERTY_LENGTH = 8192;\n    e.tlsRestrictedAgent = new i.Agent({\n      secureOptions: a.SSL_OP_NO_SSLv2 | a.SSL_OP_NO_SSLv3 | a.SSL_OP_NO_TLSv1 | a.SSL_OP_NO_TLSv1_1\n    });\n    return e;\n  }();\nmodule.exports = u;",
  "5823": "var r = require(5290),\n  o = require(4953),\n  i = [],\n  s = {\n    10: r.SeverityLevel.Verbose,\n    20: r.SeverityLevel.Verbose,\n    30: r.SeverityLevel.Information,\n    40: r.SeverityLevel.Warning,\n    50: r.SeverityLevel.Error,\n    60: r.SeverityLevel.Critical\n  },\n  a = function (e) {\n    var t = e.data.result;\n    i.forEach(function (n) {\n      var r = s[e.data.level];\n      t instanceof Error ? n.trackException({\n        exception: t\n      }) : n.trackTrace({\n        message: t,\n        severity: r\n      });\n    });\n  };\nexports.wp = function (e, t) {\n  e ? (0 === i.length && o.channel.subscribe(\"bunyan\", a), i.push(t)) : 0 === (i = i.filter(function (e) {\n    return e != t;\n  })).length && o.channel.unsubscribe(\"bunyan\", a);\n};",
  "6008": "var r = require(2337);\nmodule.exports = function (e) {\n  var t = {\n    protocols: [],\n    protocol: null,\n    port: null,\n    resource: \"\",\n    host: \"\",\n    user: \"\",\n    password: \"\",\n    pathname: \"\",\n    hash: \"\",\n    search: \"\",\n    href: e,\n    query: {},\n    parse_failed: !1\n  };\n  try {\n    var n = new URL(e);\n    t.protocols = r(n);\n    t.protocol = t.protocols[0];\n    t.port = n.port;\n    t.resource = n.hostname;\n    t.host = n.host;\n    t.user = n.username || \"\";\n    t.password = n.password || \"\";\n    t.pathname = n.pathname;\n    t.hash = n.hash.slice(1);\n    t.search = n.search.slice(1);\n    t.href = n.href;\n    t.query = Object.fromEntries(n.searchParams);\n  } catch (n) {\n    t.protocols = [\"file\"];\n    t.protocol = t.protocols[0];\n    t.port = \"\";\n    t.resource = \"\";\n    t.user = \"\";\n    t.pathname = \"\";\n    t.hash = \"\";\n    t.search = \"\";\n    t.href = e;\n    t.query = {};\n    t.parse_failed = !0;\n  }\n  return t;\n};",
  "6113": "module.exports = require(\"crypto\");",
  "6143": "const {\n    EventEmitter: r\n  } = require(2361),\n  {\n    Readable: o\n  } = require(2781),\n  i = require(8104)(\"helix-fetch\"),\n  s = require(8348),\n  {\n    Body: a\n  } = require(5600),\n  {\n    Headers: c\n  } = require(9872),\n  {\n    Request: l\n  } = require(8359),\n  {\n    Response: u\n  } = require(2981),\n  {\n    FetchBaseError: d,\n    FetchError: p,\n    AbortError: h\n  } = require(3683),\n  {\n    AbortController: f,\n    AbortSignal: m,\n    TimeoutSignal: g\n  } = require(6829),\n  _ = require(4193),\n  {\n    cacheableResponse: y\n  } = require(2500),\n  {\n    sizeof: v\n  } = require(4544),\n  {\n    isFormData: b\n  } = require(9407),\n  {\n    context: w,\n    RequestAbortedError: x\n  } = require(3100),\n  E = [\"GET\", \"HEAD\"],\n  C = \"push\",\n  S = async (e, t, n) => {\n    const {\n        request: r\n      } = e.context,\n      i = t instanceof l && undefined === n ? t : new l(t, n),\n      {\n        method: s,\n        body: a,\n        signal: d,\n        compress: f,\n        decode: m,\n        follow: g,\n        redirect: _,\n        init: {\n          body: y\n        }\n      } = i;\n    let v;\n    if (d && d.aborted) {\n      const e = new h(\"The operation was aborted.\");\n      throw i.init.body instanceof o && i.init.body.destroy(e), e;\n    }\n    try {\n      v = await r(i.url, {\n        ...n,\n        method: s,\n        headers: i.headers.plain(),\n        body: !y || y instanceof o || b(y) ? a : y,\n        compress: f,\n        decode: m,\n        follow: g,\n        redirect: _,\n        signal: d\n      });\n    } catch (e) {\n      y instanceof o && y.destroy(e);\n      if (e instanceof TypeError) throw e;\n      if (e instanceof x) throw new h(\"The operation was aborted.\");\n      throw new p(e.message, \"system\", e);\n    }\n    const w = () => {\n      d.removeEventListener(\"abort\", w);\n      const e = new h(\"The operation was aborted.\");\n      i.init.body instanceof o && i.init.body.destroy(e);\n      v.readable.emit(\"error\", e);\n    };\n    d && d.addEventListener(\"abort\", w);\n    const {\n      statusCode: E,\n      statusText: C,\n      httpVersion: T,\n      headers: k,\n      readable: I,\n      decoded: P\n    } = v;\n    if ([301, 302, 303, 307, 308].includes(E)) {\n      const {\n          location: t\n        } = k,\n        n = null == t ? null : new URL(t, i.url);\n      switch (i.redirect) {\n        case \"manual\":\n          break;\n        case \"error\":\n          throw d && d.removeEventListener(\"abort\", w), new p(`uri requested responds with a redirect, redirect mode is set to 'error': ${i.url}`, \"no-redirect\");\n        case \"follow\":\n          {\n            if (null === n) break;\n            if (i.counter >= i.follow) throw d && d.removeEventListener(\"abort\", w), new p(`maximum redirect reached at: ${i.url}`, \"max-redirect\");\n            const t = {\n              headers: new c(i.headers),\n              follow: i.follow,\n              compress: i.compress,\n              decode: i.decode,\n              counter: i.counter + 1,\n              method: i.method,\n              body: i.body,\n              signal: i.signal\n            };\n            if (303 !== E && i.body && i.init.body instanceof o) throw d && d.removeEventListener(\"abort\", w), new p(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\");\n            303 !== E && (301 !== E && 302 !== E || \"POST\" !== i.method) || (t.method = \"GET\", t.body = undefined, t.headers.delete(\"content-length\"));\n            d && d.removeEventListener(\"abort\", w);\n            return S(e, new l(n, t));\n          }\n      }\n    }\n    d && (I.once(\"end\", () => {\n      d.removeEventListener(\"abort\", w);\n    }), I.once(\"error\", () => {\n      d.removeEventListener(\"abort\", w);\n    }));\n    return new u(I, {\n      url: i.url,\n      status: E,\n      statusText: C,\n      headers: k,\n      httpVersion: T,\n      decoded: P,\n      counter: i.counter\n    });\n  },\n  T = async (e, t, n) => {\n    if (0 === e.options.maxCacheSize) return n;\n    if (!E.includes(t.method)) return n;\n    const r = new _(t, n, {\n      shared: !1\n    });\n    if (r.storable()) {\n      const o = await y(n);\n      e.cache.set(t.url, {\n        policy: r,\n        response: o\n      }, r.timeToLive());\n      return o;\n    }\n    return n;\n  },\n  k = (e, t = {}) => {\n    const n = new URL(e);\n    if (\"object\" != typeof t || Array.isArray(t)) throw new TypeError(\"qs: object expected\");\n    Object.entries(t).forEach(([e, t]) => {\n      Array.isArray(t) ? t.forEach(t => n.searchParams.append(e, t)) : n.searchParams.append(e, t);\n    });\n    return n.href;\n  },\n  I = e => new g(e);\nclass P {\n  constructor(e) {\n    this.options = {\n      ...e\n    };\n    const {\n      maxCacheSize: t\n    } = this.options;\n    let n = \"number\" == typeof t && t >= 0 ? t : 104857600,\n      o = 500;\n    0 === n && (n = 1, o = 1);\n    this.cache = new s({\n      max: o,\n      maxSize: n,\n      sizeCalculation: ({\n        response: e\n      }, t) => v(e)\n    });\n    this.eventEmitter = new r();\n    this.options.h2 = this.options.h2 || {};\n    undefined === this.options.h2.enablePush && (this.options.h2.enablePush = !0);\n    const {\n      enablePush: i\n    } = this.options.h2;\n    i && (this.options.h2.pushPromiseHandler = (e, t, n) => {\n      const r = {\n        ...t\n      };\n      Object.keys(r).filter(e => e.startsWith(\":\")).forEach(e => delete r[e]);\n      this.pushPromiseHandler(e, r, n);\n    }, this.options.h2.pushHandler = (e, t, n) => {\n      const r = {\n        ...t\n      };\n      Object.keys(r).filter(e => e.startsWith(\":\")).forEach(e => delete r[e]);\n      const {\n        statusCode: o,\n        statusText: i,\n        httpVersion: s,\n        headers: a,\n        readable: c,\n        decoded: l\n      } = n;\n      this.pushHandler(e, r, new u(c, {\n        url: e,\n        status: o,\n        statusText: i,\n        headers: a,\n        httpVersion: s,\n        decoded: l\n      }));\n    });\n    this.context = w(this.options);\n  }\n  api() {\n    return {\n      fetch: async (e, t) => this.fetch(e, t),\n      Body: a,\n      Headers: c,\n      Request: l,\n      Response: u,\n      AbortController: f,\n      AbortSignal: m,\n      FetchBaseError: d,\n      FetchError: p,\n      AbortError: h,\n      context: (e = {}) => new P(e).api(),\n      noCache: (e = {}) => new P({\n        ...e,\n        maxCacheSize: 0\n      }).api(),\n      h1: (e = {}) => new P({\n        ...e,\n        alpnProtocols: [this.context.ALPN_HTTP1_1]\n      }).api(),\n      keepAlive: (e = {}) => new P({\n        ...e,\n        alpnProtocols: [this.context.ALPN_HTTP1_1],\n        h1: {\n          keepAlive: !0\n        }\n      }).api(),\n      h1NoCache: (e = {}) => new P({\n        ...e,\n        maxCacheSize: 0,\n        alpnProtocols: [this.context.ALPN_HTTP1_1]\n      }).api(),\n      keepAliveNoCache: (e = {}) => new P({\n        ...e,\n        maxCacheSize: 0,\n        alpnProtocols: [this.context.ALPN_HTTP1_1],\n        h1: {\n          keepAlive: !0\n        }\n      }).api(),\n      reset: async () => this.context.reset(),\n      onPush: e => this.onPush(e),\n      offPush: e => this.offPush(e),\n      createUrl: k,\n      timeoutSignal: I,\n      clearCache: () => this.clearCache(),\n      cacheStats: () => this.cacheStats(),\n      ALPN_HTTP2: this.context.ALPN_HTTP2,\n      ALPN_HTTP2C: this.context.ALPN_HTTP2C,\n      ALPN_HTTP1_1: this.context.ALPN_HTTP1_1,\n      ALPN_HTTP1_0: this.context.ALPN_HTTP1_0\n    };\n  }\n  async fetch(e, t) {\n    return (async (e, t, n) => {\n      const r = new l(t, n);\n      if (0 !== e.options.maxCacheSize && E.includes(r.method) && ![\"no-store\", \"reload\"].includes(r.cache)) {\n        const {\n          policy: t,\n          response: n\n        } = e.cache.get(r.url) || {};\n        if (t && t.satisfiesWithoutRevalidation(r)) {\n          n.headers = new c(t.responseHeaders(n));\n          const e = n.clone();\n          e.fromCache = !0;\n          return e;\n        }\n      }\n      const o = await S(e, r);\n      return \"no-store\" !== r.cache ? T(e, r, o) : o;\n    })(this, e, t);\n  }\n  onPush(e) {\n    return this.eventEmitter.on(C, e);\n  }\n  offPush(e) {\n    return this.eventEmitter.off(C, e);\n  }\n  clearCache() {\n    this.cache.clear();\n  }\n  cacheStats() {\n    return {\n      size: this.cache.calculatedSize,\n      count: this.cache.size\n    };\n  }\n  pushPromiseHandler(e, t, n) {\n    i(`received server push promise: ${e}, headers: ${JSON.stringify(t)}`);\n    const r = new l(e, {\n        headers: t\n      }),\n      {\n        policy: o\n      } = this.cache.get(e) || {};\n    o && o.satisfiesWithoutRevalidation(r) && (i(`already cached, reject push promise: ${e}, headers: ${JSON.stringify(t)}`), n());\n  }\n  async pushHandler(e, t, n) {\n    i(`caching resource pushed by server: ${e}, reqHeaders: ${JSON.stringify(t)}, status: ${n.status}, respHeaders: ${JSON.stringify(n.headers)}`);\n    const r = await T(this, new l(e, {\n      headers: t\n    }), n);\n    this.eventEmitter.emit(C, e, r);\n  }\n}\nmodule.exports = new P().api();",
  "6149": "module.exports = require(5468);",
  "6157": "module.exports = {\n  i8: \"1.7.6\"\n};",
  "6167": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.contentVocabulary = exports.metadataVocabulary = undefined;\nexports.metadataVocabulary = [\"title\", \"description\", \"default\", \"deprecated\", \"readOnly\", \"writeOnly\", \"examples\"];\nexports.contentVocabulary = [\"contentMediaType\", \"contentEncoding\", \"contentSchema\"];",
  "6206": "module.exports = require(\"console\");",
  "6214": "const t = new Set([200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501]),\n  n = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]),\n  r = new Set([500, 502, 503, 504]),\n  o = {\n    date: !0,\n    connection: !0,\n    \"keep-alive\": !0,\n    \"proxy-authenticate\": !0,\n    \"proxy-authorization\": !0,\n    te: !0,\n    trailer: !0,\n    \"transfer-encoding\": !0,\n    upgrade: !0\n  },\n  i = {\n    \"content-length\": !0,\n    \"content-encoding\": !0,\n    \"transfer-encoding\": !0,\n    \"content-range\": !0\n  };\nfunction s(e) {\n  const t = parseInt(e, 10);\n  return isFinite(t) ? t : 0;\n}\nfunction a(e) {\n  const t = {};\n  if (!e) return t;\n  const n = e.trim().split(/\\s*,\\s*/);\n  for (const e of n) {\n    const [n, r] = e.split(/\\s*=\\s*/, 2);\n    t[n] = undefined === r || r.replace(/^\"|\"$/g, \"\");\n  }\n  return t;\n}\nfunction c(e) {\n  let t = [];\n  for (const n in e) {\n    const r = e[n];\n    t.push(!0 === r ? n : n + \"=\" + r);\n  }\n  if (t.length) return t.join(\", \");\n}\nmodule.exports = class {\n  constructor(e, t, {\n    shared: n,\n    cacheHeuristic: r,\n    immutableMinTimeToLive: o,\n    ignoreCargoCult: i,\n    _fromObject: s\n  } = {}) {\n    if (s) this._fromObject(s);else {\n      if (!t || !t.headers) throw Error(\"Response headers missing\");\n      this._assertRequestHasHeaders(e);\n      this._responseTime = this.now();\n      this._isShared = !1 !== n;\n      this._cacheHeuristic = undefined !== r ? r : .1;\n      this._immutableMinTtl = undefined !== o ? o : 864e5;\n      this._status = \"status\" in t ? t.status : 200;\n      this._resHeaders = t.headers;\n      this._rescc = a(t.headers[\"cache-control\"]);\n      this._method = \"method\" in e ? e.method : \"GET\";\n      this._url = e.url;\n      this._host = e.headers.host;\n      this._noAuthorization = !e.headers.authorization;\n      this._reqHeaders = t.headers.vary ? e.headers : null;\n      this._reqcc = a(e.headers[\"cache-control\"]);\n      i && \"pre-check\" in this._rescc && \"post-check\" in this._rescc && (delete this._rescc[\"pre-check\"], delete this._rescc[\"post-check\"], delete this._rescc[\"no-cache\"], delete this._rescc[\"no-store\"], delete this._rescc[\"must-revalidate\"], this._resHeaders = Object.assign({}, this._resHeaders, {\n        \"cache-control\": c(this._rescc)\n      }), delete this._resHeaders.expires, delete this._resHeaders.pragma);\n      null == t.headers[\"cache-control\"] && /no-cache/.test(t.headers.pragma) && (this._rescc[\"no-cache\"] = !0);\n    }\n  }\n  now() {\n    return Date.now();\n  }\n  storable() {\n    return !(this._reqcc[\"no-store\"] || !(\"GET\" === this._method || \"HEAD\" === this._method || \"POST\" === this._method && this._hasExplicitExpiration()) || !n.has(this._status) || this._rescc[\"no-store\"] || this._isShared && this._rescc.private || this._isShared && !this._noAuthorization && !this._allowsStoringAuthenticated() || !(this._resHeaders.expires || this._rescc[\"max-age\"] || this._isShared && this._rescc[\"s-maxage\"] || this._rescc.public || t.has(this._status)));\n  }\n  _hasExplicitExpiration() {\n    return this._isShared && this._rescc[\"s-maxage\"] || this._rescc[\"max-age\"] || this._resHeaders.expires;\n  }\n  _assertRequestHasHeaders(e) {\n    if (!e || !e.headers) throw Error(\"Request headers missing\");\n  }\n  satisfiesWithoutRevalidation(e) {\n    this._assertRequestHasHeaders(e);\n    const t = a(e.headers[\"cache-control\"]);\n    return !t[\"no-cache\"] && !/no-cache/.test(e.headers.pragma) && !(t[\"max-age\"] && this.age() > t[\"max-age\"]) && !(t[\"min-fresh\"] && this.timeToLive() < 1e3 * t[\"min-fresh\"]) && !(this.stale() && (!t[\"max-stale\"] || this._rescc[\"must-revalidate\"] || !(!0 === t[\"max-stale\"] || t[\"max-stale\"] > this.age() - this.maxAge()))) && this._requestMatches(e, !1);\n  }\n  _requestMatches(e, t) {\n    return (!this._url || this._url === e.url) && this._host === e.headers.host && (!e.method || this._method === e.method || t && \"HEAD\" === e.method) && this._varyMatches(e);\n  }\n  _allowsStoringAuthenticated() {\n    return this._rescc[\"must-revalidate\"] || this._rescc.public || this._rescc[\"s-maxage\"];\n  }\n  _varyMatches(e) {\n    if (!this._resHeaders.vary) return !0;\n    if (\"*\" === this._resHeaders.vary) return !1;\n    const t = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n    for (const n of t) if (e.headers[n] !== this._reqHeaders[n]) return !1;\n    return !0;\n  }\n  _copyWithoutHopByHopHeaders(e) {\n    const t = {};\n    for (const n in e) o[n] || (t[n] = e[n]);\n    if (e.connection) {\n      const n = e.connection.trim().split(/\\s*,\\s*/);\n      for (const e of n) delete t[e];\n    }\n    if (t.warning) {\n      const e = t.warning.split(/,/).filter(e => !/^\\s*1[0-9][0-9]/.test(e));\n      e.length ? t.warning = e.join(\",\").trim() : delete t.warning;\n    }\n    return t;\n  }\n  responseHeaders() {\n    const e = this._copyWithoutHopByHopHeaders(this._resHeaders),\n      t = this.age();\n    t > 86400 && !this._hasExplicitExpiration() && this.maxAge() > 86400 && (e.warning = (e.warning ? `${e.warning}, ` : \"\") + '113 - \"rfc7234 5.5.4\"');\n    e.age = `${Math.round(t)}`;\n    e.date = new Date(this.now()).toUTCString();\n    return e;\n  }\n  date() {\n    const e = Date.parse(this._resHeaders.date);\n    return isFinite(e) ? e : this._responseTime;\n  }\n  age() {\n    return this._ageValue() + (this.now() - this._responseTime) / 1e3;\n  }\n  _ageValue() {\n    return s(this._resHeaders.age);\n  }\n  maxAge() {\n    if (!this.storable() || this._rescc[\"no-cache\"]) return 0;\n    if (this._isShared && this._resHeaders[\"set-cookie\"] && !this._rescc.public && !this._rescc.immutable) return 0;\n    if (\"*\" === this._resHeaders.vary) return 0;\n    if (this._isShared) {\n      if (this._rescc[\"proxy-revalidate\"]) return 0;\n      if (this._rescc[\"s-maxage\"]) return s(this._rescc[\"s-maxage\"]);\n    }\n    if (this._rescc[\"max-age\"]) return s(this._rescc[\"max-age\"]);\n    const e = this._rescc.immutable ? this._immutableMinTtl : 0,\n      t = this.date();\n    if (this._resHeaders.expires) {\n      const n = Date.parse(this._resHeaders.expires);\n      return Number.isNaN(n) || n < t ? 0 : Math.max(e, (n - t) / 1e3);\n    }\n    if (this._resHeaders[\"last-modified\"]) {\n      const n = Date.parse(this._resHeaders[\"last-modified\"]);\n      if (isFinite(n) && t > n) return Math.max(e, (t - n) / 1e3 * this._cacheHeuristic);\n    }\n    return e;\n  }\n  timeToLive() {\n    const e = this.maxAge() - this.age(),\n      t = e + s(this._rescc[\"stale-if-error\"]),\n      n = e + s(this._rescc[\"stale-while-revalidate\"]);\n    return 1e3 * Math.max(0, e, t, n);\n  }\n  stale() {\n    return this.maxAge() <= this.age();\n  }\n  _useStaleIfError() {\n    return this.maxAge() + s(this._rescc[\"stale-if-error\"]) > this.age();\n  }\n  useStaleWhileRevalidate() {\n    return this.maxAge() + s(this._rescc[\"stale-while-revalidate\"]) > this.age();\n  }\n  static fromObject(e) {\n    return new this(undefined, undefined, {\n      _fromObject: e\n    });\n  }\n  _fromObject(e) {\n    if (this._responseTime) throw Error(\"Reinitialized\");\n    if (!e || 1 !== e.v) throw Error(\"Invalid serialization\");\n    this._responseTime = e.t;\n    this._isShared = e.sh;\n    this._cacheHeuristic = e.ch;\n    this._immutableMinTtl = undefined !== e.imm ? e.imm : 864e5;\n    this._status = e.st;\n    this._resHeaders = e.resh;\n    this._rescc = e.rescc;\n    this._method = e.m;\n    this._url = e.u;\n    this._host = e.h;\n    this._noAuthorization = e.a;\n    this._reqHeaders = e.reqh;\n    this._reqcc = e.reqcc;\n  }\n  toObject() {\n    return {\n      v: 1,\n      t: this._responseTime,\n      sh: this._isShared,\n      ch: this._cacheHeuristic,\n      imm: this._immutableMinTtl,\n      st: this._status,\n      resh: this._resHeaders,\n      rescc: this._rescc,\n      m: this._method,\n      u: this._url,\n      h: this._host,\n      a: this._noAuthorization,\n      reqh: this._reqHeaders,\n      reqcc: this._reqcc\n    };\n  }\n  revalidationHeaders(e) {\n    this._assertRequestHasHeaders(e);\n    const t = this._copyWithoutHopByHopHeaders(e.headers);\n    delete t[\"if-range\"];\n    if (!this._requestMatches(e, !0) || !this.storable()) return delete t[\"if-none-match\"], delete t[\"if-modified-since\"], t;\n    this._resHeaders.etag && (t[\"if-none-match\"] = t[\"if-none-match\"] ? `${t[\"if-none-match\"]}, ${this._resHeaders.etag}` : this._resHeaders.etag);\n    if (t[\"accept-ranges\"] || t[\"if-match\"] || t[\"if-unmodified-since\"] || this._method && \"GET\" != this._method) {\n      if (delete t[\"if-modified-since\"], t[\"if-none-match\"]) {\n        const e = t[\"if-none-match\"].split(/,/).filter(e => !/^\\s*W\\//.test(e));\n        e.length ? t[\"if-none-match\"] = e.join(\",\").trim() : delete t[\"if-none-match\"];\n      }\n    } else this._resHeaders[\"last-modified\"] && !t[\"if-modified-since\"] && (t[\"if-modified-since\"] = this._resHeaders[\"last-modified\"]);\n    return t;\n  }\n  revalidatedPolicy(e, t) {\n    this._assertRequestHasHeaders(e);\n    if (this._useStaleIfError() && function (e) {\n      return !e || r.has(e.status);\n    }(t)) return {\n      modified: !1,\n      matches: !1,\n      policy: this\n    };\n    if (!t || !t.headers) throw Error(\"Response headers missing\");\n    let n = !1;\n    undefined !== t.status && 304 != t.status ? n = !1 : t.headers.etag && !/^\\s*W\\//.test(t.headers.etag) ? n = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, \"\") === t.headers.etag : this._resHeaders.etag && t.headers.etag ? n = this._resHeaders.etag.replace(/^\\s*W\\//, \"\") === t.headers.etag.replace(/^\\s*W\\//, \"\") : this._resHeaders[\"last-modified\"] ? n = this._resHeaders[\"last-modified\"] === t.headers[\"last-modified\"] : this._resHeaders.etag || this._resHeaders[\"last-modified\"] || t.headers.etag || t.headers[\"last-modified\"] || (n = !0);\n    if (!n) return {\n      policy: new this.constructor(e, t),\n      modified: 304 != t.status,\n      matches: !1\n    };\n    const o = {};\n    for (const e in this._resHeaders) o[e] = e in t.headers && !i[e] ? t.headers[e] : this._resHeaders[e];\n    const s = Object.assign({}, t, {\n      status: this._status,\n      method: this._method,\n      headers: o\n    });\n    return {\n      policy: new this.constructor(e, s, {\n        shared: this._isShared,\n        cacheHeuristic: this._cacheHeuristic,\n        immutableMinTimeToLive: this._immutableMinTtl\n      }),\n      modified: !1,\n      matches: !0\n    };\n  }\n};",
  "6224": "module.exports = require(\"tty\");",
  "6239": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(4815),\n  o = require(412),\n  i = require(6776),\n  s = require(9351),\n  a = {\n    keyword: \"properties\",\n    type: \"object\",\n    schemaType: \"object\",\n    code(e) {\n      const {\n        gen: t,\n        schema: n,\n        parentSchema: a,\n        data: c,\n        it: l\n      } = e;\n      \"all\" === l.opts.removeAdditional && undefined === a.additionalProperties && s.default.code(new r.KeywordCxt(l, s.default, \"additionalProperties\"));\n      const u = o.allSchemaProperties(n);\n      for (const e of u) l.definedProperties.add(e);\n      l.opts.unevaluated && u.length && !0 !== l.props && (l.props = i.mergeEvaluated.props(t, i.toHash(u), l.props));\n      const d = u.filter(e => !i.alwaysValidSchema(l, n[e]));\n      if (0 === d.length) return;\n      const p = t.name(\"valid\");\n      for (const n of d) {\n        h(n) ? f(n) : (t.if(o.propertyInData(t, c, n, l.opts.ownProperties)), f(n), l.allErrors || t.else().var(p, !0), t.endIf());\n        e.it.definedProperties.add(n);\n        e.ok(p);\n      }\n      function h(e) {\n        return l.opts.useDefaults && !l.compositeRule && undefined !== n[e].default;\n      }\n      function f(t) {\n        e.subschema({\n          keyword: \"properties\",\n          schemaProp: t,\n          dataProp: t\n        }, p);\n      }\n    }\n  };\nexports.default = a;",
  "6252": "module = require.nmd(module);\nvar r,\n  o = require(9125).SourceMapConsumer,\n  i = require(1017);\ntry {\n  (r = require(7147)).existsSync && r.readFileSync || (r = null);\n} catch (e) {}\nvar s = require(5420);\nfunction a(e, t) {\n  return e.require(t);\n}\nvar c = !1,\n  l = !1,\n  u = !1,\n  d = \"auto\",\n  p = {},\n  h = {},\n  f = /^data:application\\/json[^,]+base64,/,\n  m = [],\n  g = [];\nfunction _() {\n  return \"browser\" === d || \"node\" !== d && \"undefined\" != typeof window && \"function\" == typeof XMLHttpRequest && !(window.require && window.module && window.process && \"renderer\" === window.process.type);\n}\nfunction y(e) {\n  return function (t) {\n    for (var n = 0; n < e.length; n++) {\n      var r = e[n](t);\n      if (r) return r;\n    }\n    return null;\n  };\n}\nvar v = y(m);\nfunction b(e, t) {\n  if (!e) return t;\n  var n = i.dirname(e),\n    r = /^\\w+:\\/\\/[^\\/]*/.exec(n),\n    o = r ? r[0] : \"\",\n    s = n.slice(o.length);\n  return o && /^\\/\\w\\:/.test(s) ? (o += \"/\") + i.resolve(n.slice(o.length), t).replace(/\\\\/g, \"/\") : o + i.resolve(n.slice(o.length), t);\n}\nm.push(function (e) {\n  e = e.trim();\n  /^file:/.test(e) && (e = e.replace(/file:\\/\\/\\/(\\w:)?/, function (e, t) {\n    return t ? \"\" : \"/\";\n  }));\n  if (e in p) return p[e];\n  var t = \"\";\n  try {\n    if (r) r.existsSync(e) && (t = r.readFileSync(e, \"utf8\"));else {\n      var n = new XMLHttpRequest();\n      n.open(\"GET\", e, !1);\n      n.send(null);\n      4 === n.readyState && 200 === n.status && (t = n.responseText);\n    }\n  } catch (e) {}\n  return p[e] = t;\n});\nvar retrieveSourceMap = y(g);\nfunction mapSourcePosition(e) {\n  var t = h[e.source];\n  if (!t) {\n    var n = retrieveSourceMap(e.source);\n    n ? (t = h[e.source] = {\n      url: n.url,\n      map: new o(n.map)\n    }).map.sourcesContent && t.map.sources.forEach(function (e, n) {\n      var r = t.map.sourcesContent[n];\n      if (r) {\n        var o = b(t.url, e);\n        p[o] = r;\n      }\n    }) : t = h[e.source] = {\n      url: null,\n      map: null\n    };\n  }\n  if (t && t.map && \"function\" == typeof t.map.originalPositionFor) {\n    var r = t.map.originalPositionFor(e);\n    if (null !== r.source) {\n      r.source = b(t.url, r.source);\n      return r;\n    }\n  }\n  return e;\n}\nfunction E(e) {\n  var t = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(e);\n  if (t) {\n    var n = mapSourcePosition({\n      source: t[2],\n      line: +t[3],\n      column: t[4] - 1\n    });\n    return \"eval at \" + t[1] + \" (\" + n.source + \":\" + n.line + \":\" + (n.column + 1) + \")\";\n  }\n  return (t = /^eval at ([^(]+) \\((.+)\\)$/.exec(e)) ? \"eval at \" + t[1] + \" (\" + E(t[2]) + \")\" : e;\n}\nfunction C() {\n  var e,\n    t = \"\";\n  if (this.isNative()) t = \"native\";else {\n    !(e = this.getScriptNameOrSourceURL()) && this.isEval() && (t = this.getEvalOrigin(), t += \", \");\n    t += e || \"<anonymous>\";\n    var n = this.getLineNumber();\n    if (null != n) {\n      t += \":\" + n;\n      var r = this.getColumnNumber();\n      r && (t += \":\" + r);\n    }\n  }\n  var o = \"\",\n    i = this.getFunctionName(),\n    s = !0,\n    a = this.isConstructor();\n  if (this.isToplevel() || a) a ? o += \"new \" + (i || \"<anonymous>\") : i ? o += i : (o += t, s = !1);else {\n    var c = this.getTypeName();\n    \"[object Object]\" === c && (c = \"null\");\n    var l = this.getMethodName();\n    i ? (c && 0 != i.indexOf(c) && (o += c + \".\"), o += i, l && i.indexOf(\".\" + l) != i.length - l.length - 1 && (o += \" [as \" + l + \"]\")) : o += c + \".\" + (l || \"<anonymous>\");\n  }\n  s && (o += \" (\" + t + \")\");\n  return o;\n}\nfunction S(e) {\n  var t = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach(function (n) {\n    t[n] = /^(?:is|get)/.test(n) ? function () {\n      return e[n].call(e);\n    } : e[n];\n  });\n  t.toString = C;\n  return t;\n}\nfunction wrapCallSite(e, t) {\n  undefined === t && (t = {\n    nextPosition: null,\n    curPosition: null\n  });\n  if (e.isNative()) return t.curPosition = null, e;\n  var n = e.getFileName() || e.getScriptNameOrSourceURL();\n  if (n) {\n    var r = e.getLineNumber(),\n      o = e.getColumnNumber() - 1,\n      i = /^v(10\\.1[6-9]|10\\.[2-9][0-9]|10\\.[0-9]{3,}|1[2-9]\\d*|[2-9]\\d|\\d{3,}|11\\.11)/.test(\"object\" == typeof process && null !== process ? process.version : \"\") ? 0 : 62;\n    1 === r && o > i && !_() && !e.isEval() && (o -= i);\n    var s = mapSourcePosition({\n      source: n,\n      line: r,\n      column: o\n    });\n    t.curPosition = s;\n    var a = (e = S(e)).getFunctionName;\n    e.getFunctionName = function () {\n      return null == t.nextPosition ? a() : t.nextPosition.name || a();\n    };\n    e.getFileName = function () {\n      return s.source;\n    };\n    e.getLineNumber = function () {\n      return s.line;\n    };\n    e.getColumnNumber = function () {\n      return s.column + 1;\n    };\n    e.getScriptNameOrSourceURL = function () {\n      return s.source;\n    };\n    return e;\n  }\n  var c = e.isEval() && e.getEvalOrigin();\n  return c ? (c = E(c), (e = S(e)).getEvalOrigin = function () {\n    return c;\n  }, e) : e;\n}\nfunction k(e, t) {\n  u && (p = {}, h = {});\n  for (var n = (e.name || \"Error\") + \": \" + (e.message || \"\"), r = {\n      nextPosition: null,\n      curPosition: null\n    }, o = [], i = t.length - 1; i >= 0; i--) {\n    o.push(\"\\n    at \" + wrapCallSite(t[i], r));\n    r.nextPosition = r.curPosition;\n  }\n  r.curPosition = r.nextPosition = null;\n  return n + o.reverse().join(\"\");\n}\nfunction getErrorSource(e) {\n  var t = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(e.stack);\n  if (t) {\n    var n = t[1],\n      o = +t[2],\n      i = +t[3],\n      s = p[n];\n    if (!s && r && r.existsSync(n)) try {\n      s = r.readFileSync(n, \"utf8\");\n    } catch (e) {\n      s = \"\";\n    }\n    if (s) {\n      var a = s.split(/(?:\\r\\n|\\r|\\n)/)[o - 1];\n      if (a) return n + \":\" + o + \"\\n\" + a + \"\\n\" + new Array(i).join(\" \") + \"^\";\n    }\n  }\n  return null;\n}\nfunction P(e) {\n  var t = getErrorSource(e),\n    n = function () {\n      if (\"object\" == typeof process && null !== process) return process.stderr;\n    }();\n  n && n._handle && n._handle.setBlocking && n._handle.setBlocking(!0);\n  t && (console.error(), console.error(t));\n  console.error(e.stack);\n  \"object\" == typeof process && null !== process && \"function\" == typeof process.exit && process.exit(1);\n}\ng.push(function (e) {\n  var t,\n    n = function (e) {\n      var t;\n      if (_()) try {\n        var n = new XMLHttpRequest();\n        n.open(\"GET\", e, !1);\n        n.send(null);\n        t = 4 === n.readyState ? n.responseText : null;\n        var r = n.getResponseHeader(\"SourceMap\") || n.getResponseHeader(\"X-SourceMap\");\n        if (r) return r;\n      } catch (e) {}\n      t = v(e);\n      for (var o, i, s = /(?:\\/\\/[@#][\\s]*sourceMappingURL=([^\\s'\"]+)[\\s]*$)|(?:\\/\\*[@#][\\s]*sourceMappingURL=([^\\s*'\"]+)[\\s]*(?:\\*\\/)[\\s]*$)/gm; i = s.exec(t);) o = i;\n      return o ? o[1] : null;\n    }(e);\n  if (!n) return null;\n  if (f.test(n)) {\n    var r = n.slice(n.indexOf(\",\") + 1);\n    t = s(r, \"base64\").toString();\n    n = e;\n  } else {\n    n = b(e, n);\n    t = v(n);\n  }\n  return t ? {\n    url: n,\n    map: t\n  } : null;\n});\nvar A = m.slice(0),\n  O = g.slice(0);\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\nexports.install = function (t) {\n  if ((t = t || {}).environment && (d = t.environment, -1 === [\"node\", \"browser\", \"auto\"].indexOf(d))) throw new Error(\"environment \" + d + \" was unknown. Available options are {auto, browser, node}\");\n  t.retrieveFile && (t.overrideRetrieveFile && (m.length = 0), m.unshift(t.retrieveFile));\n  t.retrieveSourceMap && (t.overrideRetrieveSourceMap && (g.length = 0), g.unshift(t.retrieveSourceMap));\n  if (t.hookRequire && !_()) {\n    var n = a(module, \"module\"),\n      r = n.prototype._compile;\n    r.__sourceMapSupport || (n.prototype._compile = function (e, t) {\n      return p[t] = e, h[t] = void 0, r.call(this, e, t);\n    }, n.prototype._compile.__sourceMapSupport = !0);\n  }\n  u || (u = \"emptyCacheBetweenOperations\" in t && t.emptyCacheBetweenOperations);\n  c || (c = !0, Error.prepareStackTrace = k);\n  if (!l) {\n    var o = !(\"handleUncaughtExceptions\" in t) || t.handleUncaughtExceptions;\n    try {\n      !1 === a(module, \"worker_threads\").isMainThread && (o = !1);\n    } catch (e) {}\n    o && \"object\" == typeof process && null !== process && \"function\" == typeof process.on && (l = !0, i = process.emit, process.emit = function (e) {\n      if (\"uncaughtException\" === e) {\n        var t = arguments[1] && arguments[1].stack,\n          n = this.listeners(e).length > 0;\n        if (t && !n) return P(arguments[1]);\n      }\n      return i.apply(this, arguments);\n    });\n  }\n  var i;\n};\nexports.resetRetrieveHandlers = function () {\n  m.length = 0;\n  g.length = 0;\n  m = A.slice(0);\n  g = O.slice(0);\n  retrieveSourceMap = y(g);\n  v = y(m);\n};",
  "6267": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.commandOpenPanel = exports.completionContextForEditor = undefined;\nconst r = require(9496),\n  o = require(256);\nfunction completionContextForEditor(e, t, n) {\n  return n || o.completionContextForDocument(e, t.document, t.selection.active);\n}\nexports.completionContextForEditor = completionContextForEditor;\nexports.commandOpenPanel = function (e, t) {\n  const n = r.window.activeTextEditor;\n  if (!n) return;\n  if (!r.workspace.getConfiguration(\"editor\", n.document.uri).get(\"codeLens\")) return void r.window.showInformationMessage(\"GitHub Copilot Panel requires having Code Lens enabled. Please update your settings and then try again.\", \"Open Settings\").then(e => {\n    \"Open Settings\" === e && r.commands.executeCommand(\"workbench.action.openSettings\", \"editor.codeLens\");\n  });\n  t = completionContextForEditor(e, n, t);\n  const s = o.encodeLocation(n.document.uri, t),\n    a = n.document.languageId;\n  r.workspace.openTextDocument(s).then(e => {\n    r.languages.setTextDocumentLanguage(e, a);\n    r.window.showTextDocument(e, r.ViewColumn.Beside);\n  });\n};",
  "6279": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  }(require(4526));\nmodule.exports = i;",
  "6281": "var r = require(7396),\n  o = function () {\n    function e(t) {\n      if (e.INSTANCE) throw new Error(\"Console logging adapter tracking should be configured from the applicationInsights object\");\n      this._client = t;\n      e.INSTANCE = this;\n    }\n    e.prototype.enable = function (e, t) {\n      r.IsInitialized && (require(4309).wp(e && t, this._client), require(5823).wp(e, this._client), require(454).wp(e, this._client));\n    };\n    e.prototype.isInitialized = function () {\n      return this._isInitialized;\n    };\n    e.prototype.dispose = function () {\n      e.INSTANCE = null;\n      this.enable(!1, !1);\n    };\n    e._methodNames = [\"debug\", \"info\", \"log\", \"warn\", \"error\"];\n    return e;\n  }();\nmodule.exports = o;",
  "6290": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.success = !0;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  }(require(8934));\nmodule.exports = i;",
  "6333": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.forceSendingTelemetry = exports.dropTelemetryConfig = exports.setTelemetryConfig = exports.logEnginePrompt = exports.logEngineCompletion = exports.telemetryError = exports.telemetryException = exports.telemetryRaw = exports.telemetryExpProblem = exports.telemetry = exports.configureReporter = exports.TelemetryEndpointUrl = exports.now = exports.telemetrizePromptLength = exports.TelemetryData = exports.setupEmptyReporters = exports.setupStandardReporters = exports.TelemetryReporters = exports.APP_INSIGHTS_KEY_SECURE = exports.APP_INSIGHTS_KEY = undefined;\nconst r = require(1581),\n  o = require(4398),\n  i = require(1133),\n  s = require(9189),\n  a = require(6500),\n  c = require(70),\n  l = require(2499);\nexports.APP_INSIGHTS_KEY = \"7d7048df-6dd0-4048-bb23-b716c1461f8f\";\nexports.APP_INSIGHTS_KEY_SECURE = \"3fdd7f28-937a-48c8-9a21-ba337db23bd1\";\nclass TelemetryReporters {\n  constructor(e, t) {\n    this.reporter = e;\n    this.reporterSecure = t;\n  }\n  getReporter(e) {\n    return this.reporter;\n  }\n  getSecureReporter(e) {\n    if (y()) return this.reporterSecure;\n    if (c.shouldFailForDebugPurposes(e)) throw new Error(\"Internal error: telemetry opt-out\");\n  }\n  setReporter(e) {\n    this.reporter = e;\n  }\n  setSecureReporter(e) {\n    this.reporterSecure = e;\n  }\n  async deactivate() {\n    let e = Promise.resolve();\n    this.reporter && (e = this.reporter.dispose(), this.reporter = undefined);\n    let t = Promise.resolve();\n    this.reporterSecure && (t = this.reporterSecure.dispose(), this.reporterSecure = undefined);\n    await Promise.all([e, t]);\n  }\n  hackOptOutListener() {\n    this.reporter.optOutListener = {\n      dispose() {}\n    };\n    this.reporterSecure.optOutListener = {\n      dispose() {}\n    };\n  }\n  setToken(e) {\n    this.reporter && this.configureToken(this.reporter, e);\n    this.reporterSecure && this.configureToken(this.reporterSecure, e);\n  }\n  configureToken(e, t) {\n    const n = e;\n    n && n.appInsightsClient && (n.appInsightsClient.context.tags.github_telemetry_token = t.token);\n  }\n}\nlet d;\nfunction p(e, t, n, r) {\n  const i = new o.default(t, n, r);\n  configureReporter(e, i);\n  return i;\n}\nexports.TelemetryReporters = TelemetryReporters;\nexports.setupStandardReporters = function (e, n) {\n  const r = i.getVersion(e),\n    o = p(e, n, r, exports.APP_INSIGHTS_KEY),\n    s = p(e, n, r, exports.APP_INSIGHTS_KEY_SECURE),\n    a = e.get(TelemetryReporters);\n  a.setReporter(o);\n  a.setSecureReporter(s);\n  return a;\n};\nexports.setupEmptyReporters = function () {\n  return new TelemetryReporters();\n};\nclass TelemetryData {\n  constructor(e, t, n) {\n    this.properties = e;\n    this.measurements = t;\n    this.issuedTime = n;\n  }\n  static createAndMarkAsIssued(e, t) {\n    return new TelemetryData(e || {}, t || {}, now());\n  }\n  extendedBy(e, t) {\n    const n = {\n        ...this.properties,\n        ...e\n      },\n      r = {\n        ...this.measurements,\n        ...t\n      },\n      o = new TelemetryData(n, r, this.issuedTime);\n    o.displayedTime = this.displayedTime;\n    o.filtersAndExp = this.filtersAndExp;\n    return o;\n  }\n  markAsDisplayed() {\n    undefined === this.displayedTime && (this.displayedTime = now());\n  }\n  async extendWithExpTelemetry(e) {\n    this.filtersAndExp || (await e.get(s.Features).addExpAndFilterToTelemetry(this));\n    this.filtersAndExp.exp.addToTelemetry(this);\n    this.filtersAndExp.filters.addToTelemetry(this);\n  }\n  extendWithEditorAgnosticFields(e) {\n    this.properties.editor_version = i.formatNameAndVersion(e.get(i.EditorAndPluginInfo).getEditorInfo(e));\n    this.properties.editor_plugin_version = i.formatNameAndVersion(e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e));\n    const t = e.get(i.VscInfo);\n    this.properties.client_machineid = t.machineId;\n    this.properties.client_sessionid = t.sessionId;\n    this.properties.copilot_version = `copilot/${i.getVersion(e)}`;\n    this.properties.common_extname = e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e).name;\n    this.properties.common_extversion = e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e).version;\n  }\n  extendWithConfigProperties(e) {\n    const t = i.dumpConfig(e);\n    try {\n      t[\"copilot.build\"] = i.getBuild(e);\n      t[\"copilot.buildType\"] = i.getBuildType(e);\n    } catch (e) {}\n    d && (t[\"copilot.trackingId\"] = d.trackingId);\n    this.properties = {\n      ...this.properties,\n      ...t\n    };\n  }\n  extendWithRequestId(e) {\n    const t = {\n      completionId: e.completionId,\n      created: e.created.toString(),\n      headerRequestId: e.headerRequestId,\n      serverExperiments: e.serverExperiments,\n      deploymentId: e.deploymentId\n    };\n    this.properties = {\n      ...this.properties,\n      ...t\n    };\n  }\n  static maybeRemoveRepoInfoFromPropertiesHack(e, t) {\n    if (e) return t;\n    const n = {};\n    for (const e in t) TelemetryData.keysToRemoveFromStandardTelemetryHack.includes(e) || (n[e] = t[e]);\n    return n;\n  }\n  sanitizeKeys() {\n    this.properties = TelemetryData.sanitizeKeys(this.properties);\n    this.measurements = TelemetryData.sanitizeKeys(this.measurements);\n  }\n  static sanitizeKeys(e) {\n    e = e || {};\n    const t = {};\n    for (const n in e) t[TelemetryData.keysExemptedFromSanitization.includes(n) ? n : n.replace(/\\./g, \"_\")] = e[n];\n    return t;\n  }\n  updateTimeSinceIssuedAndDisplayed() {\n    const e = now() - this.issuedTime;\n    this.measurements.timeSinceIssuedMs = e;\n    if (void 0 !== this.displayedTime) {\n      const e = now() - this.displayedTime;\n      this.measurements.timeSinceDisplayedMs = e;\n    }\n  }\n  validateData(e, t) {\n    var n;\n    let r;\n    TelemetryData.validateTelemetryProperties(this.properties) || (r = {\n      problem: \"properties\",\n      error: JSON.stringify(TelemetryData.validateTelemetryProperties.errors)\n    });\n    if (!TelemetryData.validateTelemetryMeasurements(this.measurements)) {\n      const e = JSON.stringify(TelemetryData.validateTelemetryMeasurements.errors);\n      void 0 === r ? r = {\n        problem: \"measurements\",\n        error: e\n      } : (r.problem = \"both\", r.error += `; ${e}`);\n    }\n    if (undefined === r) return !0;\n    if (c.shouldFailForDebugPurposes(e)) throw new Error(`Invalid telemetry data: ${r.problem} ${r.error} properties=${JSON.stringify(this.properties)} measurements=${JSON.stringify(this.measurements)}`);\n    telemetryError(e, \"invalidTelemetryData\", TelemetryData.createAndMarkAsIssued({\n      properties: JSON.stringify(this.properties),\n      measurements: JSON.stringify(this.measurements),\n      problem: r.problem,\n      validationError: r.error\n    }), t);\n    t && telemetryError(e, \"invalidTelemetryData_in_secure\", TelemetryData.createAndMarkAsIssued({\n      problem: r.problem,\n      requestId: null !== (n = this.properties.requestId) && undefined !== n ? n : \"unknown\"\n    }), !1);\n    return !1;\n  }\n  async makeReadyForSending(e, t, n) {\n    this.extendWithConfigProperties(e);\n    this.extendWithEditorAgnosticFields(e);\n    this.sanitizeKeys();\n    \"IncludeExp\" === n && (await this.extendWithExpTelemetry(e));\n    this.updateTimeSinceIssuedAndDisplayed();\n    this.validateData(e, t) || (this.properties.telemetry_failed_validation = \"true\");\n  }\n}\nfunction f(e, t, n, r) {\n  const o = t ? e.get(TelemetryReporters).getSecureReporter(e) : e.get(TelemetryReporters).getReporter(e);\n  o && o.sendTelemetryEvent(n, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(t, r.properties), r.measurements);\n}\nfunction now() {\n  return new Date().getTime();\n}\nexports.TelemetryData = TelemetryData;\nTelemetryData.ajv = new r.default({\n  strictNumbers: !1\n});\nTelemetryData.validateTelemetryProperties = TelemetryData.ajv.compile({\n  type: \"object\",\n  additionalProperties: {\n    type: \"string\"\n  },\n  required: []\n});\nTelemetryData.validateTelemetryMeasurements = TelemetryData.ajv.compile({\n  type: \"object\",\n  properties: {\n    meanLogProb: {\n      type: \"number\",\n      nullable: !0\n    },\n    meanAlternativeLogProb: {\n      type: \"number\",\n      nullable: !0\n    }\n  },\n  additionalProperties: {\n    type: \"number\"\n  },\n  required: []\n});\nTelemetryData.keysExemptedFromSanitization = [a.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName, a.ExpServiceTelemetryNames.featuresTelemetryPropertyName];\nTelemetryData.keysToRemoveFromStandardTelemetryHack = [\"gitRepoHost\", \"gitRepoName\", \"gitRepoOwner\", \"gitRepoUrl\", \"gitRepoPath\", \"repo\", \"request_option_nwo\"];\nexports.telemetrizePromptLength = function (e) {\n  return e.isFimEnabled ? {\n    promptPrefixCharLen: e.prefix.length,\n    promptSuffixCharLen: e.suffix.length\n  } : {\n    promptCharLen: e.prefix.length\n  };\n};\nexports.now = now;\nclass TelemetryEndpointUrl {\n  constructor(e = \"https://copilot-telemetry.githubusercontent.com/telemetry\") {\n    this.url = e;\n  }\n  getUrl() {\n    return this.url;\n  }\n  setUrlForTesting(e) {\n    this.url = e;\n  }\n}\nfunction configureReporter(e, t) {\n  const n = t;\n  if (n.appInsightsClient) {\n    const t = n.appInsightsClient.commonProperties,\n      r = TelemetryData.sanitizeKeys(t);\n    n.appInsightsClient.commonProperties = r;\n    n.appInsightsClient.context.tags[n.appInsightsClient.context.keys.cloudRoleInstance] = \"REDACTED\";\n    const o = e.get(TelemetryEndpointUrl).getUrl();\n    n.appInsightsClient.config.endpointUrl = o;\n  }\n}\nfunction y() {\n  var e;\n  return null !== (e = null == d ? undefined : d.optedIn) && undefined !== e && e;\n}\nasync function telemetry(e, t, n, r) {\n  if (r && !y()) return;\n  const o = n || TelemetryData.createAndMarkAsIssued({}, {});\n  await o.makeReadyForSending(e, null != r && r, \"IncludeExp\");\n  f(e, null != r && r, t, o);\n}\nasync function telemetryError(e, t, n, r) {\n  if (r && !y()) return;\n  const o = n || TelemetryData.createAndMarkAsIssued({}, {});\n  await o.makeReadyForSending(e, null != r && r, \"IncludeExp\");\n  (function (e, t, n, r) {\n    const o = t ? e.get(TelemetryReporters).getSecureReporter(e) : e.get(TelemetryReporters).getReporter(e);\n    o && o.sendTelemetryErrorEvent(n, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(t, r.properties), r.measurements);\n  })(e, null != r && r, t, o);\n}\nexports.TelemetryEndpointUrl = TelemetryEndpointUrl;\nexports.configureReporter = configureReporter;\nexports.telemetry = telemetry;\nexports.telemetryExpProblem = async function (e, t) {\n  const n = TelemetryData.createAndMarkAsIssued(t, {});\n  await n.makeReadyForSending(e, !1, \"SkipExp\");\n  f(e, !1, \"expProblem\", n);\n};\nexports.telemetryRaw = async function (e, t, n, r) {\n  f(e, !1, t, {\n    properties: n,\n    measurements: r\n  });\n};\nexports.telemetryException = async function (e, t, n, r) {\n  const o = t instanceof Error ? t : new Error(\"Non-error thrown: \" + t),\n    i = y(),\n    s = TelemetryData.createAndMarkAsIssued({\n      origin: l.redactPaths(n),\n      reason: i ? \"Exception logged to restricted telemetry\" : \"Exception, not logged due to opt-out\",\n      ...r\n    });\n  await s.makeReadyForSending(e, !1, \"IncludeExp\");\n  f(e, !1, \"exception\", s);\n  if (!i) return;\n  const a = TelemetryData.createAndMarkAsIssued({\n    origin: n,\n    ...r\n  });\n  await a.makeReadyForSending(e, !0, \"IncludeExp\");\n  (function (e, t, n, r) {\n    const o = e.get(TelemetryReporters).getSecureReporter(e);\n    o && o.sendTelemetryException(n, TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(true, r.properties), r.measurements);\n  })(e, 0, o, a);\n};\nexports.telemetryError = telemetryError;\nexports.logEngineCompletion = async function (e, t, n, r, o) {\n  var i;\n  const s = TelemetryData.createAndMarkAsIssued({\n    completionTextJson: JSON.stringify(t),\n    choiceIndex: o.toString()\n  });\n  if (n.logprobs) for (const [e, t] of Object.entries(n.logprobs)) s.properties[\"logprobs_\" + e] = null !== (i = JSON.stringify(t)) && undefined !== i ? i : \"unset\";\n  s.extendWithRequestId(r);\n  await telemetry(e, \"engine.completion\", s, !0);\n};\nexports.logEnginePrompt = async function (e, t, n) {\n  let r;\n  r = t.isFimEnabled ? {\n    promptPrefixJson: JSON.stringify(t.prefix),\n    promptSuffixJson: JSON.stringify(t.suffix),\n    promptElementRanges: JSON.stringify(t.promptElementRanges)\n  } : {\n    promptJson: JSON.stringify(t.prefix),\n    promptElementRanges: JSON.stringify(t.promptElementRanges)\n  };\n  const o = n.extendedBy(r);\n  await telemetry(e, \"engine.prompt\", o, !0);\n};\nexports.setTelemetryConfig = function (e) {\n  d = e;\n};\nexports.dropTelemetryConfig = function () {\n  d = undefined;\n};\nexports.forceSendingTelemetry = function (e, n) {\n  const r = n.getReporter(e);\n  if (r) {\n    const n = r;\n    n.userOptIn = !0;\n    n.createAppInsightsClient(exports.APP_INSIGHTS_KEY);\n    configureReporter(e, r);\n  }\n  try {\n    const r = n.getSecureReporter(e);\n    if (r) {\n      const n = r;\n      n.userOptIn = !0;\n      n.createAppInsightsClient(exports.APP_INSIGHTS_KEY_SECURE);\n      configureReporter(e, r);\n    }\n  } catch (e) {}\n};",
  "6372": "function t(e) {\n  return \"function\" == typeof e;\n}\nvar n = console.error.bind(console);\nfunction r(e, t, n) {\n  var r = !!e[t] && e.propertyIsEnumerable(t);\n  Object.defineProperty(e, t, {\n    configurable: !0,\n    enumerable: r,\n    writable: !0,\n    value: n\n  });\n}\nfunction o(e) {\n  e && e.logger && (t(e.logger) ? n = e.logger : n(\"new logger isn't a function, not replacing\"));\n}\nfunction i(e, o, i) {\n  if (e && e[o]) {\n    if (!i) {\n      n(\"no wrapper function\");\n      return void n(new Error().stack);\n    }\n    if (t(e[o]) && t(i)) {\n      var s = e[o],\n        a = i(s, o);\n      r(a, \"__original\", s);\n      r(a, \"__unwrap\", function () {\n        e[o] === a && r(e, o, s);\n      });\n      r(a, \"__wrapped\", !0);\n      r(e, o, a);\n      return a;\n    }\n    n(\"original object and wrapper must be functions\");\n  } else n(\"no original function \" + o + \" to wrap\");\n}\nfunction s(e, t) {\n  return e && e[t] ? e[t].__unwrap ? e[t].__unwrap() : void n(\"no original to unwrap to -- has \" + t + \" already been unwrapped?\") : (n(\"no function to unwrap.\"), void n(new Error().stack));\n}\no.wrap = i;\no.massWrap = function (e, t, r) {\n  if (!e) {\n    n(\"must provide one or more modules to patch\");\n    return void n(new Error().stack);\n  }\n  Array.isArray(e) || (e = [e]);\n  t && Array.isArray(t) ? e.forEach(function (e) {\n    t.forEach(function (t) {\n      i(e, t, r);\n    });\n  }) : n(\"must provide one or more functions to wrap on modules\");\n};\no.unwrap = s;\no.massUnwrap = function (e, t) {\n  if (!e) {\n    n(\"must provide one or more modules to patch\");\n    return void n(new Error().stack);\n  }\n  Array.isArray(e) || (e = [e]);\n  t && Array.isArray(t) ? e.forEach(function (e) {\n    t.forEach(function (t) {\n      s(e, t);\n    });\n  }) : n(\"must provide one or more functions to unwrap on modules\");\n};\nmodule.exports = o;",
  "6376": "module.exports = function () {};",
  "6400": "var r = require(7923);\nexports.encode = function (e) {\n  var t,\n    n = \"\",\n    o = function (e) {\n      return e < 0 ? 1 + (-e << 1) : 0 + (e << 1);\n    }(e);\n  do {\n    t = 31 & o;\n    (o >>>= 5) > 0 && (t |= 32);\n    n += r.encode(t);\n  } while (o > 0);\n  return n;\n};\nexports.decode = function (e, t, n) {\n  var o,\n    i,\n    s,\n    a,\n    c = e.length,\n    l = 0,\n    u = 0;\n  do {\n    if (t >= c) throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    if (-1 === (i = r.decode(e.charCodeAt(t++)))) throw new Error(\"Invalid base64 digit: \" + e.charAt(t - 1));\n    o = !!(32 & i);\n    l += (i &= 31) << u;\n    u += 5;\n  } while (o);\n  a = (s = l) >> 1;\n  n.value = 1 == (1 & s) ? -a : a;\n  n.rest = t;\n};",
  "6403": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.LocationFactory = undefined;\nexports.LocationFactory = class {};",
  "6475": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.ZeroPadding = {\n  pad: function (e, t) {\n    var n = 4 * t;\n    e.clamp();\n    e.sigBytes += n - (e.sigBytes % n || n);\n  },\n  unpad: function (e) {\n    var t = e.words,\n      n = e.sigBytes - 1;\n    for (n = e.sigBytes - 1; n >= 0; n--) if (t[n >>> 2] >>> 24 - n % 4 * 8 & 255) {\n      e.sigBytes = n + 1;\n      break;\n    }\n  }\n};\nmodule.exports = r.pad.ZeroPadding;",
  "6500": "var n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ExpServiceTelemetryNames = undefined;\n(n = exports.ExpServiceTelemetryNames || (exports.ExpServiceTelemetryNames = {})).featuresTelemetryPropertyName = \"VSCode.ABExp.Features\";\nn.assignmentContextTelemetryPropertyName = \"abexp.assignmentcontext\";",
  "6552": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(6776),\n  o = {\n    keyword: [\"then\", \"else\"],\n    schemaType: [\"object\", \"boolean\"],\n    code({\n      keyword: e,\n      parentSchema: t,\n      it: n\n    }) {\n      undefined === t.if && r.checkStrictMode(n, `\"${e}\" without \"if\" is ignored`);\n    }\n  };\nexports.default = o;",
  "6560": "module.exports = (e, t) => {\n  t = t || process.argv;\n  const n = e.startsWith(\"-\") ? \"\" : 1 === e.length ? \"-\" : \"--\",\n    r = t.indexOf(n + e),\n    o = t.indexOf(\"--\");\n  return -1 !== r && (-1 === o || r < o);\n};",
  "6639": "var t = function () {\n  function e(t) {\n    if (e.INSTANCE) throw new Error(\"Exception tracking should be configured from the applicationInsights object\");\n    e.INSTANCE = this;\n    this._client = t;\n    var n = process.versions.node.split(\".\");\n    e._canUseUncaughtExceptionMonitor = parseInt(n[0]) > 13 || 13 === parseInt(n[0]) && parseInt(n[1]) >= 7;\n  }\n  e.prototype.isInitialized = function () {\n    return this._isInitialized;\n  };\n  e.prototype.enable = function (t) {\n    var n = this;\n    if (t) {\n      this._isInitialized = !0;\n      if (!this._exceptionListenerHandle) {\n        var r = function (t, r, o) {\n          void 0 === o && (o = new Error(e._FALLBACK_ERROR_MESSAGE)), n._client.trackException({\n            exception: o\n          }), n._client.flush({\n            isAppCrashing: !0\n          }), t && r && 1 === process.listeners(r).length && (console.error(o), process.exit(1));\n        };\n        e._canUseUncaughtExceptionMonitor ? (this._exceptionListenerHandle = r.bind(this, !1), process.on(e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle)) : (this._exceptionListenerHandle = r.bind(this, !0, e.UNCAUGHT_EXCEPTION_HANDLER_NAME), this._rejectionListenerHandle = r.bind(this, !1), process.on(e.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle), process.on(e.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle));\n      }\n    } else this._exceptionListenerHandle && (e._canUseUncaughtExceptionMonitor ? process.removeListener(e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME, this._exceptionListenerHandle) : (process.removeListener(e.UNCAUGHT_EXCEPTION_HANDLER_NAME, this._exceptionListenerHandle), process.removeListener(e.UNHANDLED_REJECTION_HANDLER_NAME, this._rejectionListenerHandle)), this._exceptionListenerHandle = undefined, this._rejectionListenerHandle = undefined, delete this._exceptionListenerHandle, delete this._rejectionListenerHandle);\n  };\n  e.prototype.dispose = function () {\n    e.INSTANCE = null;\n    this.enable(!1);\n    this._isInitialized = !1;\n  };\n  e.INSTANCE = null;\n  e.UNCAUGHT_EXCEPTION_MONITOR_HANDLER_NAME = \"uncaughtExceptionMonitor\";\n  e.UNCAUGHT_EXCEPTION_HANDLER_NAME = \"uncaughtException\";\n  e.UNHANDLED_REJECTION_HANDLER_NAME = \"unhandledRejection\";\n  e._RETHROW_EXIT_MESSAGE = \"Application Insights Rethrow Exception Handler\";\n  e._FALLBACK_ERROR_MESSAGE = \"A promise was rejected without providing an error. Application Insights generated this error stack for you.\";\n  e._canUseUncaughtExceptionMonitor = !1;\n  return e;\n}();\nmodule.exports = t;",
  "6646": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(2531);\nclass o extends Error {\n  constructor(e, t, n) {\n    super(n || `can't resolve reference ${t} from id ${e}`);\n    this.missingRef = r.resolveUrl(e, t);\n    this.missingSchema = r.normalizeId(r.getFullPath(this.missingRef));\n  }\n}\nexports.default = o;",
  "6661": "var r = this && this.__assign || Object.assign || function (e) {\n  for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n  return e;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar o = require(4953);\nexports.tedious = {\n  versionSpecifier: \">= 6.0.0 < 9.0.0\",\n  patch: function (e) {\n    var t = e.Connection.prototype.makeRequest;\n    e.Connection.prototype.makeRequest = function () {\n      function e(e) {\n        var t = process.hrtime(),\n          n = {\n            query: {},\n            database: {\n              host: null,\n              port: null\n            },\n            result: null,\n            error: null,\n            duration: 0\n          };\n        return o.channel.bindToContext(function (i, s, a) {\n          var c = process.hrtime(t);\n          n = r({}, n, {\n            database: {\n              host: this.connection.config.server,\n              port: this.connection.config.options.port\n            },\n            result: !i && {\n              rowCount: s,\n              rows: a\n            },\n            query: {\n              text: this.parametersByName.statement.value\n            },\n            error: i,\n            duration: Math.ceil(1e3 * c[0] + c[1] / 1e6)\n          });\n          o.channel.publish(\"tedious\", n);\n          e.call(this, i, s, a);\n        });\n      }\n      var n = arguments[0];\n      arguments[0].callback = e(n.callback);\n      t.apply(this, arguments);\n    };\n    return e;\n  }\n};\nexports.enable = function () {\n  o.channel.registerMonkeyPatch(\"tedious\", exports.tedious);\n};",
  "6694": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = require(7310),\n  s = require(5290),\n  a = require(5740),\n  c = require(9036),\n  l = require(3054),\n  u = require(9962),\n  d = require(1974),\n  p = require(8090),\n  h = function (e) {\n    function t(t, n) {\n      var r = e.call(this) || this;\n      t && (r.method = t.method, r.url = r._getAbsoluteUrl(t), r.startTime = +new Date(), r.socketRemoteAddress = t.socket && t.socket.remoteAddress, r.parseHeaders(t, n), t.connection && (r.connectionRemoteAddress = t.connection.remoteAddress, r.legacySocketRemoteAddress = t.connection.socket && t.connection.socket.remoteAddress));\n      return r;\n    }\n    o(t, e);\n    t.prototype.onError = function (e, t) {\n      this._setStatus(undefined, e);\n      t && (this.duration = t);\n    };\n    t.prototype.onResponse = function (e, t) {\n      this._setStatus(e.statusCode, undefined);\n      t && (this.duration = t);\n    };\n    t.prototype.getRequestTelemetry = function (e) {\n      var t = {\n        id: this.requestId,\n        name: this.method + \" \" + i.parse(this.url).pathname,\n        url: this.url,\n        source: this.sourceCorrelationId,\n        duration: this.duration,\n        resultCode: this.statusCode ? this.statusCode.toString() : null,\n        success: this._isSuccess(),\n        properties: this.properties\n      };\n      if (e) {\n        for (var n in e) t[n] || (t[n] = e[n]);\n        if (e.properties) for (var n in e.properties) t.properties[n] = e.properties[n];\n      }\n      return t;\n    };\n    t.prototype.getRequestTags = function (e) {\n      var n = {};\n      for (var r in e) n[r] = e[r];\n      n[t.keys.locationIp] = e[t.keys.locationIp] || this._getIp();\n      n[t.keys.sessionId] = e[t.keys.sessionId] || this._getId(\"ai_session\");\n      n[t.keys.userId] = e[t.keys.userId] || this._getId(\"ai_user\");\n      n[t.keys.userAuthUserId] = e[t.keys.userAuthUserId] || this._getId(\"ai_authUser\");\n      n[t.keys.operationName] = this.getOperationName(e);\n      n[t.keys.operationParentId] = this.getOperationParentId(e);\n      n[t.keys.operationId] = this.getOperationId(e);\n      return n;\n    };\n    t.prototype.getOperationId = function (e) {\n      return e[t.keys.operationId] || this.operationId;\n    };\n    t.prototype.getOperationParentId = function (e) {\n      return e[t.keys.operationParentId] || this.parentId || this.getOperationId(e);\n    };\n    t.prototype.getOperationName = function (e) {\n      return e[t.keys.operationName] || this.method + \" \" + i.parse(this.url).pathname;\n    };\n    t.prototype.getRequestId = function () {\n      return this.requestId;\n    };\n    t.prototype.getCorrelationContextHeader = function () {\n      return this.correlationContextHeader;\n    };\n    t.prototype.getTraceparent = function () {\n      return this.traceparent;\n    };\n    t.prototype.getTracestate = function () {\n      return this.tracestate;\n    };\n    t.prototype.getLegacyRootId = function () {\n      return this.legacyRootId;\n    };\n    t.prototype._getAbsoluteUrl = function (e) {\n      if (!e.headers) return e.url;\n      var t = e.connection ? e.connection.encrypted : null,\n        n = i.parse(e.url),\n        r = n.pathname,\n        o = n.search;\n      return i.format({\n        protocol: t ? \"https\" : \"http\",\n        host: e.headers.host,\n        pathname: r,\n        search: o\n      });\n    };\n    t.prototype._getIp = function () {\n      var e = /[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}/,\n        t = function (t) {\n          var n = e.exec(t);\n          if (n) return n[0];\n        },\n        n = t(this.rawHeaders[\"x-forwarded-for\"]) || t(this.rawHeaders[\"x-client-ip\"]) || t(this.rawHeaders[\"x-real-ip\"]) || t(this.connectionRemoteAddress) || t(this.socketRemoteAddress) || t(this.legacySocketRemoteAddress);\n      !n && this.connectionRemoteAddress && this.connectionRemoteAddress.substr && \"::\" === this.connectionRemoteAddress.substr(0, 2) && (n = \"127.0.0.1\");\n      return n;\n    };\n    t.prototype._getId = function (e) {\n      var n = this.rawHeaders && this.rawHeaders.cookie && \"string\" == typeof this.rawHeaders.cookie && this.rawHeaders.cookie || \"\";\n      return t.parseId(a.getCookie(e, n));\n    };\n    t.prototype.setBackCompatFromThisTraceContext = function () {\n      this.operationId = this.traceparent.traceId;\n      this.traceparent.legacyRootId && (this.legacyRootId = this.traceparent.legacyRootId);\n      this.parentId = this.traceparent.parentId;\n      this.traceparent.updateSpanId();\n      this.requestId = this.traceparent.getBackCompatRequestId();\n    };\n    t.prototype.parseHeaders = function (e, t) {\n      this.rawHeaders = e.headers || e.rawHeaders;\n      this.userAgent = e.headers && e.headers[\"user-agent\"];\n      this.sourceCorrelationId = a.getCorrelationContextTarget(e, c.requestContextSourceKey);\n      if (e.headers) {\n        var n = e.headers[c.traceStateHeader],\n          r = e.headers[c.traceparentHeader],\n          o = e.headers[c.requestIdHeader],\n          i = e.headers[c.parentIdHeader],\n          s = e.headers[c.rootIdHeader];\n        this.correlationContextHeader = e.headers[c.correlationContextHeader], u.w3cEnabled && (r || n) ? (this.traceparent = new p(r), this.tracestate = r && n && new d(n), this.setBackCompatFromThisTraceContext()) : o ? u.w3cEnabled ? (this.traceparent = new p(null, o), this.setBackCompatFromThisTraceContext()) : (this.parentId = o, this.requestId = u.generateRequestId(this.parentId), this.operationId = u.getRootId(this.requestId)) : u.w3cEnabled ? (this.traceparent = new p(), this.traceparent.parentId = i, this.traceparent.legacyRootId = s || i, this.setBackCompatFromThisTraceContext()) : (this.parentId = i, this.requestId = u.generateRequestId(s || this.parentId), this.correlationContextHeader = null, this.operationId = u.getRootId(this.requestId)), t && (this.requestId = t, this.operationId = u.getRootId(this.requestId));\n      }\n    };\n    t.parseId = function (e) {\n      var t = e.split(\"|\");\n      return t.length > 0 ? t[0] : \"\";\n    };\n    t.keys = new s.ContextTagKeys();\n    return t;\n  }(l);\nmodule.exports = h;",
  "6722": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.NoOpStatusReporter = exports.StatusReporter = undefined;\nclass StatusReporter {}\nexports.StatusReporter = StatusReporter;\nexports.NoOpStatusReporter = class extends StatusReporter {\n  setProgress() {}\n  removeProgress() {}\n  setWarning() {}\n  setError(e) {}\n  forceNormal() {}\n};",
  "6771": "var r = require(2728),\n  o = require(9216),\n  i = require(8213).I,\n  s = require(6400),\n  a = require(2826).U;\nfunction SourceMapConsumer(e, t) {\n  var n = e;\n  \"string\" == typeof e && (n = r.parseSourceMapInput(e));\n  return null != n.sections ? new d(n, t) : new l(n, t);\n}\nfunction l(e, t) {\n  var n = e;\n  \"string\" == typeof e && (n = r.parseSourceMapInput(e));\n  var o = r.getArg(n, \"version\"),\n    s = r.getArg(n, \"sources\"),\n    a = r.getArg(n, \"names\", []),\n    c = r.getArg(n, \"sourceRoot\", null),\n    l = r.getArg(n, \"sourcesContent\", null),\n    u = r.getArg(n, \"mappings\"),\n    d = r.getArg(n, \"file\", null);\n  if (o != this._version) throw new Error(\"Unsupported version: \" + o);\n  c && (c = r.normalize(c));\n  s = s.map(String).map(r.normalize).map(function (e) {\n    return c && r.isAbsolute(c) && r.isAbsolute(e) ? r.relative(c, e) : e;\n  });\n  this._names = i.fromArray(a.map(String), !0);\n  this._sources = i.fromArray(s, !0);\n  this._absoluteSources = this._sources.toArray().map(function (e) {\n    return r.computeSourceURL(c, e, t);\n  });\n  this.sourceRoot = c;\n  this.sourcesContent = l;\n  this._mappings = u;\n  this._sourceMapURL = t;\n  this.file = d;\n}\nfunction u() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\nfunction d(e, t) {\n  var n = e;\n  \"string\" == typeof e && (n = r.parseSourceMapInput(e));\n  var o = r.getArg(n, \"version\"),\n    s = r.getArg(n, \"sections\");\n  if (o != this._version) throw new Error(\"Unsupported version: \" + o);\n  this._sources = new i();\n  this._names = new i();\n  var a = {\n    line: -1,\n    column: 0\n  };\n  this._sections = s.map(function (e) {\n    if (e.url) throw new Error(\"Support for url field in sections not implemented.\");\n    var n = r.getArg(e, \"offset\"),\n      o = r.getArg(n, \"line\"),\n      i = r.getArg(n, \"column\");\n    if (o < a.line || o === a.line && i < a.column) throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n    a = n;\n    return {\n      generatedOffset: {\n        generatedLine: o + 1,\n        generatedColumn: i + 1\n      },\n      consumer: new SourceMapConsumer(r.getArg(e, \"map\"), t)\n    };\n  });\n}\nSourceMapConsumer.fromSourceMap = function (e, t) {\n  return l.fromSourceMap(e, t);\n};\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_generatedMappings\", {\n  configurable: !0,\n  enumerable: !0,\n  get: function () {\n    this.__generatedMappings || this._parseMappings(this._mappings, this.sourceRoot);\n    return this.__generatedMappings;\n  }\n});\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, \"_originalMappings\", {\n  configurable: !0,\n  enumerable: !0,\n  get: function () {\n    this.__originalMappings || this._parseMappings(this._mappings, this.sourceRoot);\n    return this.__originalMappings;\n  }\n});\nSourceMapConsumer.prototype._charIsMappingSeparator = function (e, t) {\n  var n = e.charAt(t);\n  return \";\" === n || \",\" === n;\n};\nSourceMapConsumer.prototype._parseMappings = function (e, t) {\n  throw new Error(\"Subclasses must implement _parseMappings\");\n};\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\nSourceMapConsumer.prototype.eachMapping = function (e, t, n) {\n  var o,\n    i = t || null;\n  switch (n || SourceMapConsumer.GENERATED_ORDER) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      o = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      o = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n  }\n  var s = this.sourceRoot;\n  o.map(function (e) {\n    var t = null === e.source ? null : this._sources.at(e.source);\n    return {\n      source: t = r.computeSourceURL(s, t, this._sourceMapURL),\n      generatedLine: e.generatedLine,\n      generatedColumn: e.generatedColumn,\n      originalLine: e.originalLine,\n      originalColumn: e.originalColumn,\n      name: null === e.name ? null : this._names.at(e.name)\n    };\n  }, this).forEach(e, i);\n};\nSourceMapConsumer.prototype.allGeneratedPositionsFor = function (e) {\n  var t = r.getArg(e, \"line\"),\n    n = {\n      source: r.getArg(e, \"source\"),\n      originalLine: t,\n      originalColumn: r.getArg(e, \"column\", 0)\n    };\n  n.source = this._findSourceIndex(n.source);\n  if (n.source < 0) return [];\n  var i = [],\n    s = this._findMapping(n, this._originalMappings, \"originalLine\", \"originalColumn\", r.compareByOriginalPositions, o.LEAST_UPPER_BOUND);\n  if (s >= 0) {\n    var a = this._originalMappings[s];\n    if (undefined === e.column) for (var c = a.originalLine; a && a.originalLine === c;) {\n      i.push({\n        line: r.getArg(a, \"generatedLine\", null),\n        column: r.getArg(a, \"generatedColumn\", null),\n        lastColumn: r.getArg(a, \"lastGeneratedColumn\", null)\n      });\n      a = this._originalMappings[++s];\n    } else for (var l = a.originalColumn; a && a.originalLine === t && a.originalColumn == l;) {\n      i.push({\n        line: r.getArg(a, \"generatedLine\", null),\n        column: r.getArg(a, \"generatedColumn\", null),\n        lastColumn: r.getArg(a, \"lastGeneratedColumn\", null)\n      });\n      a = this._originalMappings[++s];\n    }\n  }\n  return i;\n};\nexports.SourceMapConsumer = SourceMapConsumer;\nl.prototype = Object.create(SourceMapConsumer.prototype);\nl.prototype.consumer = SourceMapConsumer;\nl.prototype._findSourceIndex = function (e) {\n  var t,\n    n = e;\n  null != this.sourceRoot && (n = r.relative(this.sourceRoot, n));\n  if (this._sources.has(n)) return this._sources.indexOf(n);\n  for (t = 0; t < this._absoluteSources.length; ++t) if (this._absoluteSources[t] == e) return t;\n  return -1;\n};\nl.fromSourceMap = function (e, t) {\n  var n = Object.create(l.prototype),\n    o = n._names = i.fromArray(e._names.toArray(), !0),\n    s = n._sources = i.fromArray(e._sources.toArray(), !0);\n  n.sourceRoot = e._sourceRoot;\n  n.sourcesContent = e._generateSourcesContent(n._sources.toArray(), n.sourceRoot);\n  n.file = e._file;\n  n._sourceMapURL = t;\n  n._absoluteSources = n._sources.toArray().map(function (e) {\n    return r.computeSourceURL(n.sourceRoot, e, t);\n  });\n  for (var c = e._mappings.toArray().slice(), d = n.__generatedMappings = [], p = n.__originalMappings = [], h = 0, f = c.length; h < f; h++) {\n    var m = c[h],\n      g = new u();\n    g.generatedLine = m.generatedLine;\n    g.generatedColumn = m.generatedColumn;\n    m.source && (g.source = s.indexOf(m.source), g.originalLine = m.originalLine, g.originalColumn = m.originalColumn, m.name && (g.name = o.indexOf(m.name)), p.push(g));\n    d.push(g);\n  }\n  a(n.__originalMappings, r.compareByOriginalPositions);\n  return n;\n};\nl.prototype._version = 3;\nObject.defineProperty(l.prototype, \"sources\", {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\nl.prototype._parseMappings = function (e, t) {\n  for (var n, o, i, c, l, d = 1, p = 0, h = 0, f = 0, m = 0, g = 0, _ = e.length, y = 0, v = {}, b = {}, w = [], x = []; y < _;) if (\";\" === e.charAt(y)) {\n    d++;\n    y++;\n    p = 0;\n  } else if (\",\" === e.charAt(y)) y++;else {\n    for ((n = new u()).generatedLine = d, c = y; c < _ && !this._charIsMappingSeparator(e, c); c++);\n    if (i = v[o = e.slice(y, c)]) y += o.length;else {\n      for (i = []; y < c;) {\n        s.decode(e, y, b);\n        l = b.value;\n        y = b.rest;\n        i.push(l);\n      }\n      if (2 === i.length) throw new Error(\"Found a source, but no line and column\");\n      if (3 === i.length) throw new Error(\"Found a source and line, but no column\");\n      v[o] = i;\n    }\n    n.generatedColumn = p + i[0];\n    p = n.generatedColumn;\n    i.length > 1 && (n.source = m + i[1], m += i[1], n.originalLine = h + i[2], h = n.originalLine, n.originalLine += 1, n.originalColumn = f + i[3], f = n.originalColumn, i.length > 4 && (n.name = g + i[4], g += i[4]));\n    x.push(n);\n    \"number\" == typeof n.originalLine && w.push(n);\n  }\n  a(x, r.compareByGeneratedPositionsDeflated);\n  this.__generatedMappings = x;\n  a(w, r.compareByOriginalPositions);\n  this.__originalMappings = w;\n};\nl.prototype._findMapping = function (e, t, n, r, i, s) {\n  if (e[n] <= 0) throw new TypeError(\"Line must be greater than or equal to 1, got \" + e[n]);\n  if (e[r] < 0) throw new TypeError(\"Column must be greater than or equal to 0, got \" + e[r]);\n  return o.search(e, t, i, s);\n};\nl.prototype.computeColumnSpans = function () {\n  for (var e = 0; e < this._generatedMappings.length; ++e) {\n    var t = this._generatedMappings[e];\n    if (e + 1 < this._generatedMappings.length) {\n      var n = this._generatedMappings[e + 1];\n      if (t.generatedLine === n.generatedLine) {\n        t.lastGeneratedColumn = n.generatedColumn - 1;\n        continue;\n      }\n    }\n    t.lastGeneratedColumn = 1 / 0;\n  }\n};\nl.prototype.originalPositionFor = function (e) {\n  var t = {\n      generatedLine: r.getArg(e, \"line\"),\n      generatedColumn: r.getArg(e, \"column\")\n    },\n    n = this._findMapping(t, this._generatedMappings, \"generatedLine\", \"generatedColumn\", r.compareByGeneratedPositionsDeflated, r.getArg(e, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND));\n  if (n >= 0) {\n    var o = this._generatedMappings[n];\n    if (o.generatedLine === t.generatedLine) {\n      var i = r.getArg(o, \"source\", null);\n      null !== i && (i = this._sources.at(i), i = r.computeSourceURL(this.sourceRoot, i, this._sourceMapURL));\n      var s = r.getArg(o, \"name\", null);\n      null !== s && (s = this._names.at(s));\n      return {\n        source: i,\n        line: r.getArg(o, \"originalLine\", null),\n        column: r.getArg(o, \"originalColumn\", null),\n        name: s\n      };\n    }\n  }\n  return {\n    source: null,\n    line: null,\n    column: null,\n    name: null\n  };\n};\nl.prototype.hasContentsOfAllSources = function () {\n  return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (e) {\n    return null == e;\n  });\n};\nl.prototype.sourceContentFor = function (e, t) {\n  if (!this.sourcesContent) return null;\n  var n = this._findSourceIndex(e);\n  if (n >= 0) return this.sourcesContent[n];\n  var o,\n    i = e;\n  null != this.sourceRoot && (i = r.relative(this.sourceRoot, i));\n  if (null != this.sourceRoot && (o = r.urlParse(this.sourceRoot))) {\n    var s = i.replace(/^file:\\/\\//, \"\");\n    if (\"file\" == o.scheme && this._sources.has(s)) return this.sourcesContent[this._sources.indexOf(s)];\n    if ((!o.path || \"/\" == o.path) && this._sources.has(\"/\" + i)) return this.sourcesContent[this._sources.indexOf(\"/\" + i)];\n  }\n  if (t) return null;\n  throw new Error('\"' + i + '\" is not in the SourceMap.');\n};\nl.prototype.generatedPositionFor = function (e) {\n  var t = r.getArg(e, \"source\");\n  if ((t = this._findSourceIndex(t)) < 0) return {\n    line: null,\n    column: null,\n    lastColumn: null\n  };\n  var n = {\n      source: t,\n      originalLine: r.getArg(e, \"line\"),\n      originalColumn: r.getArg(e, \"column\")\n    },\n    o = this._findMapping(n, this._originalMappings, \"originalLine\", \"originalColumn\", r.compareByOriginalPositions, r.getArg(e, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND));\n  if (o >= 0) {\n    var i = this._originalMappings[o];\n    if (i.source === n.source) return {\n      line: r.getArg(i, \"generatedLine\", null),\n      column: r.getArg(i, \"generatedColumn\", null),\n      lastColumn: r.getArg(i, \"lastGeneratedColumn\", null)\n    };\n  }\n  return {\n    line: null,\n    column: null,\n    lastColumn: null\n  };\n};\nd.prototype = Object.create(SourceMapConsumer.prototype);\nd.prototype.constructor = SourceMapConsumer;\nd.prototype._version = 3;\nObject.defineProperty(d.prototype, \"sources\", {\n  get: function () {\n    for (var e = [], t = 0; t < this._sections.length; t++) for (var n = 0; n < this._sections[t].consumer.sources.length; n++) e.push(this._sections[t].consumer.sources[n]);\n    return e;\n  }\n});\nd.prototype.originalPositionFor = function (e) {\n  var t = {\n      generatedLine: r.getArg(e, \"line\"),\n      generatedColumn: r.getArg(e, \"column\")\n    },\n    n = o.search(t, this._sections, function (e, t) {\n      return e.generatedLine - t.generatedOffset.generatedLine || e.generatedColumn - t.generatedOffset.generatedColumn;\n    }),\n    i = this._sections[n];\n  return i ? i.consumer.originalPositionFor({\n    line: t.generatedLine - (i.generatedOffset.generatedLine - 1),\n    column: t.generatedColumn - (i.generatedOffset.generatedLine === t.generatedLine ? i.generatedOffset.generatedColumn - 1 : 0),\n    bias: e.bias\n  }) : {\n    source: null,\n    line: null,\n    column: null,\n    name: null\n  };\n};\nd.prototype.hasContentsOfAllSources = function () {\n  return this._sections.every(function (e) {\n    return e.consumer.hasContentsOfAllSources();\n  });\n};\nd.prototype.sourceContentFor = function (e, t) {\n  for (var n = 0; n < this._sections.length; n++) {\n    var r = this._sections[n].consumer.sourceContentFor(e, !0);\n    if (r) return r;\n  }\n  if (t) return null;\n  throw new Error('\"' + e + '\" is not in the SourceMap.');\n};\nd.prototype.generatedPositionFor = function (e) {\n  for (var t = 0; t < this._sections.length; t++) {\n    var n = this._sections[t];\n    if (-1 !== n.consumer._findSourceIndex(r.getArg(e, \"source\"))) {\n      var o = n.consumer.generatedPositionFor(e);\n      if (o) return {\n        line: o.line + (n.generatedOffset.generatedLine - 1),\n        column: o.column + (n.generatedOffset.generatedLine === o.line ? n.generatedOffset.generatedColumn - 1 : 0)\n      };\n    }\n  }\n  return {\n    line: null,\n    column: null\n  };\n};\nd.prototype._parseMappings = function (e, t) {\n  this.__generatedMappings = [];\n  this.__originalMappings = [];\n  for (var n = 0; n < this._sections.length; n++) for (var o = this._sections[n], i = o.consumer._generatedMappings, s = 0; s < i.length; s++) {\n    var c = i[s],\n      l = o.consumer._sources.at(c.source);\n    l = r.computeSourceURL(o.consumer.sourceRoot, l, this._sourceMapURL);\n    this._sources.add(l);\n    l = this._sources.indexOf(l);\n    var u = null;\n    c.name && (u = o.consumer._names.at(c.name), this._names.add(u), u = this._names.indexOf(u));\n    var d = {\n      source: l,\n      generatedLine: c.generatedLine + (o.generatedOffset.generatedLine - 1),\n      generatedColumn: c.generatedColumn + (o.generatedOffset.generatedLine === c.generatedLine ? o.generatedOffset.generatedColumn - 1 : 0),\n      originalLine: c.originalLine,\n      originalColumn: c.originalColumn,\n      name: u\n    };\n    this.__generatedMappings.push(d);\n    \"number\" == typeof d.originalLine && this.__originalMappings.push(d);\n  }\n  a(this.__generatedMappings, r.compareByGeneratedPositionsDeflated);\n  a(this.__originalMappings, r.compareByOriginalPositions);\n};",
  "6776": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = undefined;\nconst r = require(3487),\n  o = require(7023);\nfunction checkUnknownRules(e, t = e.schema) {\n  const {\n    opts: n,\n    self: r\n  } = e;\n  if (!n.strictSchema) return;\n  if (\"boolean\" == typeof t) return;\n  const o = r.RULES.keywords;\n  for (const n in t) o[n] || checkStrictMode(e, `unknown keyword: \"${n}\"`);\n}\nfunction schemaHasRules(e, t) {\n  if (\"boolean\" == typeof e) return !e;\n  for (const n in e) if (t[n]) return !0;\n  return !1;\n}\nfunction escapeJsonPointer(e) {\n  return \"number\" == typeof e ? `${e}` : e.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nfunction unescapeJsonPointer(e) {\n  return e.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\nfunction l({\n  mergeNames: e,\n  mergeToName: t,\n  mergeValues: n,\n  resultToName: o\n}) {\n  return (i, s, a, c) => {\n    const l = undefined === a ? s : a instanceof r.Name ? (s instanceof r.Name ? e(i, s, a) : t(i, s, a), a) : s instanceof r.Name ? (t(i, a, s), s) : n(s, a);\n    return c !== r.Name || l instanceof r.Name ? l : o(i, l);\n  };\n}\nfunction evaluatedPropsToName(e, t) {\n  if (!0 === t) return e.var(\"props\", !0);\n  const n = e.var(\"props\", r._`{}`);\n  undefined !== t && setEvaluated(e, n, t);\n  return n;\n}\nfunction setEvaluated(e, t, n) {\n  Object.keys(n).forEach(n => e.assign(r._`${t}${r.getProperty(n)}`, !0));\n}\nexports.toHash = function (e) {\n  const t = {};\n  for (const n of e) t[n] = !0;\n  return t;\n};\nexports.alwaysValidSchema = function (e, t) {\n  return \"boolean\" == typeof t ? t : 0 === Object.keys(t).length || (checkUnknownRules(e, t), !schemaHasRules(t, e.self.RULES.all));\n};\nexports.checkUnknownRules = checkUnknownRules;\nexports.schemaHasRules = schemaHasRules;\nexports.schemaHasRulesButRef = function (e, t) {\n  if (\"boolean\" == typeof e) return !e;\n  for (const n in e) if (\"$ref\" !== n && t.all[n]) return !0;\n  return !1;\n};\nexports.schemaRefOrVal = function ({\n  topSchemaRef: e,\n  schemaPath: t\n}, n, o, i) {\n  if (!i) {\n    if (\"number\" == typeof n || \"boolean\" == typeof n) return n;\n    if (\"string\" == typeof n) return r._`${n}`;\n  }\n  return r._`${e}${t}${r.getProperty(o)}`;\n};\nexports.unescapeFragment = function (e) {\n  return unescapeJsonPointer(decodeURIComponent(e));\n};\nexports.escapeFragment = function (e) {\n  return encodeURIComponent(escapeJsonPointer(e));\n};\nexports.escapeJsonPointer = escapeJsonPointer;\nexports.unescapeJsonPointer = unescapeJsonPointer;\nexports.eachItem = function (e, t) {\n  if (Array.isArray(e)) for (const n of e) t(n);else t(e);\n};\nexports.mergeEvaluated = {\n  props: l({\n    mergeNames: (e, t, n) => e.if(r._`${n} !== true && ${t} !== undefined`, () => {\n      e.if(r._`${t} === true`, () => e.assign(n, !0), () => e.assign(n, r._`${n} || {}`).code(r._`Object.assign(${n}, ${t})`));\n    }),\n    mergeToName: (e, t, n) => e.if(r._`${n} !== true`, () => {\n      !0 === t ? e.assign(n, !0) : (e.assign(n, r._`${n} || {}`), setEvaluated(e, n, t));\n    }),\n    mergeValues: (e, t) => !0 === e || {\n      ...e,\n      ...t\n    },\n    resultToName: evaluatedPropsToName\n  }),\n  items: l({\n    mergeNames: (e, t, n) => e.if(r._`${n} !== true && ${t} !== undefined`, () => e.assign(n, r._`${t} === true ? true : ${n} > ${t} ? ${n} : ${t}`)),\n    mergeToName: (e, t, n) => e.if(r._`${n} !== true`, () => e.assign(n, !0 === t || r._`${n} > ${t} ? ${n} : ${t}`)),\n    mergeValues: (e, t) => !0 === e || Math.max(e, t),\n    resultToName: (e, t) => e.var(\"items\", t)\n  })\n};\nexports.evaluatedPropsToName = evaluatedPropsToName;\nexports.setEvaluated = setEvaluated;\nconst p = {};\nvar h;\nfunction checkStrictMode(e, t, n = e.opts.strictSchema) {\n  if (n) {\n    t = `strict mode: ${t}`;\n    if (!0 === n) throw new Error(t);\n    e.self.logger.warn(t);\n  }\n}\nexports.useFunc = function (e, t) {\n  return e.scopeValue(\"func\", {\n    ref: t,\n    code: p[t.code] || (p[t.code] = new o._Code(t.code))\n  });\n};\n(function (e) {\n  e[e.Num = 0] = \"Num\";\n  e[e.Str = 1] = \"Str\";\n})(h = exports.Type || (exports.Type = {}));\nexports.getErrorPath = function (e, t, n) {\n  if (e instanceof r.Name) {\n    const o = t === h.Num;\n    return n ? o ? r._`\"[\" + ${e} + \"]\"` : r._`\"['\" + ${e} + \"']\"` : o ? r._`\"/\" + ${e}` : r._`\"/\" + ${e}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")`;\n  }\n  return n ? r.getProperty(e).toString() : \"/\" + escapeJsonPointer(e);\n};\nexports.checkStrictMode = checkStrictMode;",
  "6794": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.TELEMETRY_TERMS_URL = exports.LAST_TELEMETRY_TERMS_UPDATE = undefined;\nexports.LAST_TELEMETRY_TERMS_UPDATE = \"2021-10-14\";\nexports.TELEMETRY_TERMS_URL = \"https://github.co/copilot-telemetry-terms\";",
  "6829": "const {\n    EventEmitter: r\n  } = require(2361),\n  o = Symbol(\"AbortSignal internals\");\nclass i {\n  constructor() {\n    this[o] = {\n      eventEmitter: new r(),\n      onabort: null,\n      aborted: !1\n    };\n  }\n  get aborted() {\n    return this[o].aborted;\n  }\n  get onabort() {\n    return this[o].onabort;\n  }\n  set onabort(e) {\n    this[o].onabort = e;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n  removeEventListener(e, t) {\n    this[o].eventEmitter.removeListener(e, t);\n  }\n  addEventListener(e, t) {\n    this[o].eventEmitter.on(e, t);\n  }\n  dispatchEvent(e) {\n    const t = {\n        type: e,\n        target: this\n      },\n      n = `on${e}`;\n    \"function\" == typeof this[o][n] && this[n](t);\n    this[o].eventEmitter.emit(e, t);\n  }\n  fire() {\n    this[o].aborted = !0;\n    this.dispatchEvent(\"abort\");\n  }\n}\nObject.defineProperties(i.prototype, {\n  addEventListener: {\n    enumerable: !0\n  },\n  removeEventListener: {\n    enumerable: !0\n  },\n  dispatchEvent: {\n    enumerable: !0\n  },\n  aborted: {\n    enumerable: !0\n  },\n  onabort: {\n    enumerable: !0\n  }\n});\nclass s extends i {\n  constructor(e) {\n    if (!Number.isInteger(e)) throw new TypeError(\"Expected an integer, got \" + typeof e);\n    super();\n    this[o].timerId = setTimeout(() => {\n      this.fire();\n    }, e);\n  }\n  clear() {\n    clearTimeout(this[o].timerId);\n  }\n}\nObject.defineProperties(s.prototype, {\n  clear: {\n    enumerable: !0\n  }\n});\nconst a = Symbol(\"AbortController internals\");\nclass c {\n  constructor() {\n    this[a] = {\n      signal: new i()\n    };\n  }\n  get signal() {\n    return this[a].signal;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n  abort() {\n    this[a].signal.aborted || this[a].signal.fire();\n  }\n}\nObject.defineProperties(c.prototype, {\n  signal: {\n    enumerable: !0\n  },\n  abort: {\n    enumerable: !0\n  }\n});\nmodule.exports = {\n  AbortController: c,\n  AbortSignal: i,\n  TimeoutSignal: s\n};",
  "6857": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.extensionFileSystem = undefined;\nconst r = require(9496);\nexports.extensionFileSystem = {\n  readFile: async function (e) {\n    return await r.workspace.fs.readFile(r.Uri.file(e));\n  },\n  mtime: async function (e) {\n    return (await r.workspace.fs.stat(r.Uri.file(e))).mtime;\n  },\n  stat: async function (e) {\n    return await r.workspace.fs.stat(r.Uri.file(e));\n  }\n};",
  "6881": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ChangeTracker = undefined;\nconst r = require(3136);\nexports.ChangeTracker = class {\n  constructor(e, t, n) {\n    this._referenceCount = 0;\n    this._isDisposed = !1;\n    this._offset = n;\n    const o = e.get(r.TextDocumentManager);\n    this._tracker = o.onDidChangeTextDocument(async e => {\n      if (e.document.uri === t) for (const t of e.contentChanges) if (t.rangeOffset + t.rangeLength <= this.offset) {\n        const e = t.text.length - t.rangeLength;\n        this._offset = this._offset + e;\n      }\n    });\n  }\n  get offset() {\n    return this._offset;\n  }\n  push(e, t) {\n    if (this._isDisposed) throw new Error(\"Unable to push new actions to a disposed ChangeTracker\");\n    this._referenceCount++;\n    setTimeout(() => {\n      e();\n      this._referenceCount--;\n      0 === this._referenceCount && (this._tracker.dispose(), this._isDisposed = !0);\n    }, t);\n  }\n};",
  "6932": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.asyncIterableFromArray = exports.asyncIterableMapFilter = exports.asyncIterableFilter = exports.asyncIterableMap = undefined;\nexports.asyncIterableMap = async function* (e, t) {\n  for await (const n of e) yield t(n);\n};\nexports.asyncIterableFilter = async function* (e, t) {\n  for await (const n of e) (await t(n)) && (yield n);\n};\nexports.asyncIterableMapFilter = async function* (e, t) {\n  for await (const n of e) {\n    const e = await t(n);\n    undefined !== e && (yield e);\n  }\n};\nexports.asyncIterableFromArray = async function* (e) {\n  for (const t of e) yield t;\n};",
  "6991": "var r;\nr = require(8249);\nrequire(5109);\nr.pad.NoPadding = {\n  pad: function () {},\n  unpad: function () {}\n};\nmodule.exports = r.pad.NoPadding;",
  "7017": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.postInsertionTasks = exports.postRejectionTasks = exports.captureCode = undefined;\nconst r = require(6881),\n  o = require(750),\n  i = require(9899),\n  s = require(7727),\n  a = require(4969),\n  c = require(5120),\n  l = require(6333),\n  u = require(3136),\n  d = new i.Logger(i.LogLevel.INFO, \"post-insertion\"),\n  p = [{\n    seconds: 15,\n    captureCode: !1,\n    captureRejection: !1\n  }, {\n    seconds: 30,\n    captureCode: !0,\n    captureRejection: !0\n  }, {\n    seconds: 120,\n    captureCode: !1,\n    captureRejection: !1\n  }, {\n    seconds: 300,\n    captureCode: !1,\n    captureRejection: !1\n  }, {\n    seconds: 600,\n    captureCode: !1,\n    captureRejection: !1\n  }];\nasync function captureCode(e, t, n) {\n  const r = await e.get(u.TextDocumentManager).getTextDocument(t);\n  if (!r) {\n    d.info(e, `Could not get document for ${t.fsPath}. Maybe it was closed by the editor.`);\n    return {\n      prompt: {\n        prefix: \"\",\n        suffix: \"\",\n        isFimEnabled: !1,\n        promptElementRanges: []\n      },\n      capturedCode: \"\",\n      terminationOffset: 0\n    };\n  }\n  const o = r.getText(),\n    i = o.substring(0, n),\n    c = r.positionAt(n),\n    l = await a.extractPrompt(e, r, c),\n    p = \"prompt\" === l.type ? l.prompt : {\n      prefix: i,\n      suffix: \"\",\n      isFimEnabled: !1,\n      promptElementRanges: []\n    },\n    h = o.substring(n),\n    f = s.contextIndentationFromText(i, n, r.languageId),\n    m = s.indentationBlockFinished(f, undefined),\n    g = await m(h),\n    _ = Math.min(o.length, n + (g ? 2 * g : 500));\n  return {\n    prompt: p,\n    capturedCode: o.substring(n, _),\n    terminationOffset: null != g ? g : -1\n  };\n}\nfunction f(e, t, n, r) {\n  const o = e.substring(Math.max(0, r - n), Math.min(e.length, r + t.length + n)),\n    i = c.lexEditDistance(o, t),\n    s = i.lexDistance / i.needleLexLength,\n    {\n      distance: a\n    } = c.editDistance(o.substring(i.startOffset, i.endOffset), t);\n  return {\n    relativeLexEditDistance: s,\n    charEditDistance: a,\n    completionLexLength: i.needleLexLength,\n    foundOffset: i.startOffset + Math.max(0, r - n),\n    lexEditDistance: i.lexDistance,\n    stillInCodeHeuristic: s <= .5 ? 1 : 0\n  };\n}\nexports.captureCode = captureCode;\nexports.postRejectionTasks = function (e, t, n, i, s) {\n  s.forEach(({\n    completionText: n,\n    completionTelemetryData: r\n  }) => {\n    d.debug(e, `${t}.rejected choiceIndex: ${r.properties.choiceIndex}`);\n    o.telemetryRejected(e, t, r);\n  });\n  const a = new r.ChangeTracker(e, i, n);\n  p.filter(e => e.captureRejection).map(r => {\n    a.push(async () => {\n      d.debug(e, `Original offset: ${n}, Tracked offset: ${a.offset}`);\n      const {\n          completionTelemetryData: o\n        } = s[0],\n        {\n          prompt: c,\n          capturedCode: u,\n          terminationOffset: p\n        } = await captureCode(e, i, a.offset);\n      let f;\n      f = c.isFimEnabled ? {\n        hypotheticalPromptPrefixJson: JSON.stringify(c.prefix),\n        hypotheticalPromptSuffixJson: JSON.stringify(c.suffix)\n      } : {\n        hypotheticalPromptJson: JSON.stringify(c.prefix)\n      };\n      const m = o.extendedBy({\n        ...f,\n        capturedCodeJson: JSON.stringify(u)\n      }, {\n        timeout: r.seconds,\n        insertionOffset: n,\n        trackedOffset: a.offset,\n        terminationOffsetInCapturedCode: p\n      });\n      d.debug(e, `${t}.capturedAfterRejected choiceIndex: ${o.properties.choiceIndex}`, m);\n      l.telemetry(e, t + \".capturedAfterRejected\", m, !0);\n    }, 1e3 * r.seconds);\n  });\n};\nexports.postInsertionTasks = async function (e, t, n, i, s, a) {\n  d.debug(e, `${t}.accepted choiceIndex: ${a.properties.choiceIndex}`);\n  o.telemetryAccepted(e, t, a);\n  const c = new r.ChangeTracker(e, s, i),\n    m = n.trim();\n  p.map(n => c.push(() => async function (e, t, n, r, o, i, s, a) {\n    const c = await e.get(u.TextDocumentManager).getTextDocument(o);\n    if (c) {\n      const u = c.getText();\n      let p = f(u, n, 50, a.offset);\n      p.stillInCodeHeuristic || (p = f(u, n, 1500, a.offset));\n      d.debug(e, `stillInCode: ${p.stillInCodeHeuristic ? \"Found\" : \"Not found\"}! Completion '${n}' in file ${o.fsPath}. lexEditDistance fraction was ${p.relativeLexEditDistance}. Char edit distance was ${p.charEditDistance}. Inserted at ${r}, tracked at ${a.offset}, found at ${p.foundOffset}. choiceIndex: ${s.properties.choiceIndex}`);\n      const m = s.extendedBy({}, {\n        timeout: i.seconds,\n        insertionOffset: r,\n        trackedOffset: a.offset\n      }).extendedBy({}, p);\n      l.telemetry(e, t + \".stillInCode\", m);\n      if (i.captureCode) {\n        const {\n          prompt: n,\n          capturedCode: c,\n          terminationOffset: u\n        } = await captureCode(e, o, a.offset);\n        let p;\n        p = n.isFimEnabled ? {\n          hypotheticalPromptPrefixJson: JSON.stringify(n.prefix),\n          hypotheticalPromptSuffixJson: JSON.stringify(n.suffix)\n        } : {\n          hypotheticalPromptJson: JSON.stringify(n.prefix)\n        };\n        const f = s.extendedBy({\n          ...p,\n          capturedCodeJson: JSON.stringify(c)\n        }, {\n          timeout: i.seconds,\n          insertionOffset: r,\n          trackedOffset: a.offset,\n          terminationOffsetInCapturedCode: u\n        });\n        d.debug(e, `${t}.capturedAfterAccepted choiceIndex: ${s.properties.choiceIndex}`, m), (0, l.telemetry)(e, t + \".capturedAfterAccepted\", f, !0);\n      }\n    }\n  }(e, t, m, i, s, n, a, c), 1e3 * n.seconds));\n};",
  "7023": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.regexpCode = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = undefined;\nclass _CodeOrName {}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n  constructor(e) {\n    super();\n    if (!exports.IDENTIFIER.test(e)) throw new Error(\"CodeGen: name must be a valid identifier\");\n    this.str = e;\n  }\n  toString() {\n    return this.str;\n  }\n  emptyStr() {\n    return !1;\n  }\n  get names() {\n    return {\n      [this.str]: 1\n    };\n  }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n  constructor(e) {\n    super();\n    this._items = \"string\" == typeof e ? [e] : e;\n  }\n  toString() {\n    return this.str;\n  }\n  emptyStr() {\n    if (this._items.length > 1) return !1;\n    const e = this._items[0];\n    return \"\" === e || '\"\"' === e;\n  }\n  get str() {\n    var e;\n    return null !== (e = this._str) && undefined !== e ? e : this._str = this._items.reduce((e, t) => `${e}${t}`, \"\");\n  }\n  get names() {\n    var e;\n    return null !== (e = this._names) && undefined !== e ? e : this._names = this._items.reduce((e, t) => (t instanceof Name && (e[t.str] = (e[t.str] || 0) + 1), e), {});\n  }\n}\nfunction _(e, ...t) {\n  const n = [e[0]];\n  let r = 0;\n  for (; r < t.length;) {\n    addCodeArg(n, t[r]);\n    n.push(e[++r]);\n  }\n  return new _Code(n);\n}\nexports._Code = _Code;\nexports.nil = new _Code(\"\");\nexports._ = _;\nconst s = new _Code(\"+\");\nfunction str(e, ...t) {\n  const n = [safeStringify(e[0])];\n  let r = 0;\n  for (; r < t.length;) {\n    n.push(s);\n    addCodeArg(n, t[r]);\n    n.push(s, safeStringify(e[++r]));\n  }\n  (function (e) {\n    let t = 1;\n    for (; t < e.length - 1;) {\n      if (e[t] === s) {\n        const n = l(e[t - 1], e[t + 1]);\n        if (undefined !== n) {\n          e.splice(t - 1, 3, n);\n          continue;\n        }\n        e[t++] = \"+\";\n      }\n      t++;\n    }\n  })(n);\n  return new _Code(n);\n}\nfunction addCodeArg(e, t) {\n  var n;\n  t instanceof _Code ? e.push(...t._items) : t instanceof Name ? e.push(t) : e.push(\"number\" == typeof (n = t) || \"boolean\" == typeof n || null === n ? n : safeStringify(Array.isArray(n) ? n.join(\",\") : n));\n}\nfunction l(e, t) {\n  if ('\"\"' === t) return e;\n  if ('\"\"' === e) return t;\n  if (\"string\" == typeof e) {\n    if (t instanceof Name || '\"' !== e[e.length - 1]) return;\n    return \"string\" != typeof t ? `${e.slice(0, -1)}${t}\"` : '\"' === t[0] ? e.slice(0, -1) + t.slice(1) : undefined;\n  }\n  return \"string\" != typeof t || '\"' !== t[0] || e instanceof Name ? undefined : `\"${e}${t.slice(1)}`;\n}\nfunction safeStringify(e) {\n  return JSON.stringify(e).replace(/\\u2028/g, \"\\\\u2028\").replace(/\\u2029/g, \"\\\\u2029\");\n}\nexports.str = str;\nexports.addCodeArg = addCodeArg;\nexports.strConcat = function (e, t) {\n  return t.emptyStr() ? e : e.emptyStr() ? t : str`${e}${t}`;\n};\nexports.stringify = function (e) {\n  return new _Code(safeStringify(e));\n};\nexports.safeStringify = safeStringify;\nexports.getProperty = function (e) {\n  return \"string\" == typeof e && exports.IDENTIFIER.test(e) ? new _Code(`.${e}`) : _`[${e}]`;\n};\nexports.regexpCode = function (e) {\n  return new _Code(e.toString());\n};",
  "7057": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.RealUrlOpener = exports.UrlOpener = undefined;\nconst r = require(8318);\nexports.UrlOpener = class {};\nexports.RealUrlOpener = class {\n  async open(e) {\n    await r(e);\n  }\n};",
  "7085": "var r = require(4433).h,\n  o = require(2728),\n  i = /(\\r?\\n)/,\n  s = \"$$$isSourceNode$$$\";\nfunction a(e, t, n, r, o) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = null == e ? null : e;\n  this.column = null == t ? null : t;\n  this.source = null == n ? null : n;\n  this.name = null == o ? null : o;\n  this[s] = !0;\n  null != r && this.add(r);\n}\na.fromStringWithSourceMap = function (e, t, n) {\n  var r = new a(),\n    s = e.split(i),\n    c = 0,\n    l = function () {\n      return e() + (e() || \"\");\n      function e() {\n        return c < s.length ? s[c++] : undefined;\n      }\n    },\n    u = 1,\n    d = 0,\n    p = null;\n  t.eachMapping(function (e) {\n    if (null !== p) {\n      if (!(u < e.generatedLine)) {\n        var t = (n = s[c] || \"\").substr(0, e.generatedColumn - d);\n        s[c] = n.substr(e.generatedColumn - d);\n        d = e.generatedColumn;\n        h(p, t);\n        return void (p = e);\n      }\n      h(p, l());\n      u++;\n      d = 0;\n    }\n    for (; u < e.generatedLine;) {\n      r.add(l());\n      u++;\n    }\n    if (d < e.generatedColumn) {\n      var n = s[c] || \"\";\n      r.add(n.substr(0, e.generatedColumn));\n      s[c] = n.substr(e.generatedColumn);\n      d = e.generatedColumn;\n    }\n    p = e;\n  }, this);\n  c < s.length && (p && h(p, l()), r.add(s.splice(c).join(\"\")));\n  t.sources.forEach(function (e) {\n    var i = t.sourceContentFor(e);\n    null != i && (null != n && (e = o.join(n, e)), r.setSourceContent(e, i));\n  });\n  return r;\n  function h(e, t) {\n    if (null === e || undefined === e.source) r.add(t);else {\n      var i = n ? o.join(n, e.source) : e.source;\n      r.add(new a(e.originalLine, e.originalColumn, i, t, e.name));\n    }\n  }\n};\na.prototype.add = function (e) {\n  if (Array.isArray(e)) e.forEach(function (e) {\n    this.add(e);\n  }, this);else {\n    if (!e[s] && \"string\" != typeof e) throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + e);\n    e && this.children.push(e);\n  }\n  return this;\n};\na.prototype.prepend = function (e) {\n  if (Array.isArray(e)) for (var t = e.length - 1; t >= 0; t--) this.prepend(e[t]);else {\n    if (!e[s] && \"string\" != typeof e) throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + e);\n    this.children.unshift(e);\n  }\n  return this;\n};\na.prototype.walk = function (e) {\n  for (var t, n = 0, r = this.children.length; n < r; n++) (t = this.children[n])[s] ? t.walk(e) : \"\" !== t && e(t, {\n    source: this.source,\n    line: this.line,\n    column: this.column,\n    name: this.name\n  });\n};\na.prototype.join = function (e) {\n  var t,\n    n,\n    r = this.children.length;\n  if (r > 0) {\n    for (t = [], n = 0; n < r - 1; n++) {\n      t.push(this.children[n]);\n      t.push(e);\n    }\n    t.push(this.children[n]);\n    this.children = t;\n  }\n  return this;\n};\na.prototype.replaceRight = function (e, t) {\n  var n = this.children[this.children.length - 1];\n  n[s] ? n.replaceRight(e, t) : \"string\" == typeof n ? this.children[this.children.length - 1] = n.replace(e, t) : this.children.push(\"\".replace(e, t));\n  return this;\n};\na.prototype.setSourceContent = function (e, t) {\n  this.sourceContents[o.toSetString(e)] = t;\n};\na.prototype.walkSourceContents = function (e) {\n  for (var t = 0, n = this.children.length; t < n; t++) this.children[t][s] && this.children[t].walkSourceContents(e);\n  var r = Object.keys(this.sourceContents);\n  for (t = 0, n = r.length; t < n; t++) e(o.fromSetString(r[t]), this.sourceContents[r[t]]);\n};\na.prototype.toString = function () {\n  var e = \"\";\n  this.walk(function (t) {\n    e += t;\n  });\n  return e;\n};\na.prototype.toStringWithSourceMap = function (e) {\n  var t = {\n      code: \"\",\n      line: 1,\n      column: 0\n    },\n    n = new r(e),\n    o = !1,\n    i = null,\n    s = null,\n    a = null,\n    c = null;\n  this.walk(function (e, r) {\n    t.code += e;\n    null !== r.source && null !== r.line && null !== r.column ? (i === r.source && s === r.line && a === r.column && c === r.name || n.addMapping({\n      source: r.source,\n      original: {\n        line: r.line,\n        column: r.column\n      },\n      generated: {\n        line: t.line,\n        column: t.column\n      },\n      name: r.name\n    }), i = r.source, s = r.line, a = r.column, c = r.name, o = !0) : o && (n.addMapping({\n      generated: {\n        line: t.line,\n        column: t.column\n      }\n    }), i = null, o = !1);\n    for (var l = 0, u = e.length; l < u; l++) 10 === e.charCodeAt(l) ? (t.line++, t.column = 0, l + 1 === u ? (i = null, o = !1) : o && n.addMapping({\n      source: r.source,\n      original: {\n        line: r.line,\n        column: r.column\n      },\n      generated: {\n        line: t.line,\n        column: t.column\n      },\n      name: r.name\n    })) : t.column++;\n  });\n  this.walkSourceContents(function (e, t) {\n    n.setSourceContent(e, t);\n  });\n  return {\n    code: t.code,\n    map: n\n  };\n};",
  "7147": "module.exports = require(\"fs\");",
  "7148": "var r = this && this.__assign || Object.assign || function (e) {\n    for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n    return e;\n  },\n  o = require(2037),\n  i = require(5290),\n  s = require(3580),\n  a = require(5740),\n  c = require(5282),\n  l = a.w3cTraceId(),\n  u = function () {\n    function e() {}\n    e.createQuickPulseEnvelope = function (e, t, n, r) {\n      var i = o && \"function\" == typeof o.hostname && o.hostname() || \"Unknown\",\n        s = r.tags && r.keys && r.keys.cloudRoleInstance && r.tags[r.keys.cloudRoleInstance] || i;\n      return {\n        Documents: t.length > 0 ? t : null,\n        InstrumentationKey: n.instrumentationKey || \"\",\n        Metrics: e.length > 0 ? e : null,\n        InvariantVersion: 1,\n        Timestamp: \"/Date(\" + Date.now() + \")/\",\n        Version: r.tags[r.keys.internalSdkVersion],\n        StreamId: l,\n        MachineName: i,\n        Instance: s\n      };\n    };\n    e.createQuickPulseMetric = function (e) {\n      return {\n        Name: e.name,\n        Value: e.value,\n        Weight: e.count || 1\n      };\n    };\n    e.telemetryEnvelopeToQuickPulseDocument = function (t) {\n      switch (t.data.baseType) {\n        case i.TelemetryTypeString.Event:\n          return e.createQuickPulseEventDocument(t);\n        case i.TelemetryTypeString.Exception:\n          return e.createQuickPulseExceptionDocument(t);\n        case i.TelemetryTypeString.Trace:\n          return e.createQuickPulseTraceDocument(t);\n        case i.TelemetryTypeString.Dependency:\n          return e.createQuickPulseDependencyDocument(t);\n        case i.TelemetryTypeString.Request:\n          return e.createQuickPulseRequestDocument(t);\n      }\n      return null;\n    };\n    e.createQuickPulseEventDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData.name;\n      return r({}, n, {\n        Name: o\n      });\n    };\n    e.createQuickPulseTraceDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData.severityLevel || 0;\n      return r({}, n, {\n        Message: t.data.baseData.message,\n        SeverityLevel: i.SeverityLevel[o]\n      });\n    };\n    e.createQuickPulseExceptionDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData.exceptions,\n        i = \"\",\n        s = \"\",\n        a = \"\";\n      o && o.length > 0 && (o[0].parsedStack && o[0].parsedStack.length > 0 ? o[0].parsedStack.forEach(function (e) {\n        i += e.assembly + \"\\n\";\n      }) : o[0].stack && o[0].stack.length > 0 && (i = o[0].stack), s = o[0].message, a = o[0].typeName);\n      return r({}, n, {\n        Exception: i,\n        ExceptionMessage: s,\n        ExceptionType: a\n      });\n    };\n    e.createQuickPulseRequestDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData;\n      return r({}, n, {\n        Name: o.name,\n        Success: o.success,\n        Duration: o.duration,\n        ResponseCode: o.responseCode,\n        OperationName: o.name\n      });\n    };\n    e.createQuickPulseDependencyDocument = function (t) {\n      var n = e.createQuickPulseDocument(t),\n        o = t.data.baseData;\n      return r({}, n, {\n        Name: o.name,\n        Target: o.target,\n        Success: o.success,\n        Duration: o.duration,\n        ResultCode: o.resultCode,\n        CommandName: o.data,\n        OperationName: n.OperationId,\n        DependencyTypeName: o.type\n      });\n    };\n    e.createQuickPulseDocument = function (t) {\n      var n, r;\n      t.data.baseType ? (r = s.TelemetryTypeStringToQuickPulseType[t.data.baseType], n = s.TelemetryTypeStringToQuickPulseDocumentType[t.data.baseType]) : c.warn(\"Document type invalid; not sending live metric document\", t.data.baseType);\n      return {\n        DocumentType: n,\n        __type: r,\n        OperationId: t.tags[e.keys.operationId],\n        Version: \"1.0\",\n        Properties: e.aggregateProperties(t)\n      };\n    };\n    e.aggregateProperties = function (e) {\n      var t = [],\n        n = e.data.baseData.measurements || {};\n      for (var r in n) if (n.hasOwnProperty(r)) {\n        var o = {\n          key: r,\n          value: n[r]\n        };\n        t.push(o);\n      }\n      var i = e.data.baseData.properties || {};\n      for (var r in i) i.hasOwnProperty(r) && (o = {\n        key: r,\n        value: i[r]\n      }, t.push(o));\n      return t;\n    };\n    e.keys = new i.ContextTagKeys();\n    return e;\n  }();\nmodule.exports = u;",
  "7159": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;\nvar r = require(4815);\nexports.KeywordCxt = r.KeywordCxt;\nvar o = require(3487);\nexports._ = o._;\nexports.str = o.str;\nexports.stringify = o.stringify;\nexports.nil = o.nil;\nexports.Name = o.Name;\nexports.CodeGen = o.CodeGen;\nconst i = require(7426),\n  s = require(6646),\n  a = require(3141),\n  c = require(5173),\n  l = require(3487),\n  u = require(2531),\n  d = require(453),\n  p = require(6776),\n  h = require(4775),\n  f = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"],\n  m = new Set([\"validate\", \"serialize\", \"parse\", \"wrapper\", \"root\", \"schema\", \"keyword\", \"pattern\", \"formats\", \"validate$data\", \"func\", \"obj\", \"Error\"]),\n  g = {\n    errorDataPath: \"\",\n    format: \"`validateFormats: false` can be used instead.\",\n    nullable: '\"nullable\" keyword is supported by default.',\n    jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n    extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n    missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n    processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n    sourceCode: \"Use option `code: {source: true}`\",\n    strictDefaults: \"It is default now, see option `strict`.\",\n    strictKeywords: \"It is default now, see option `strict`.\",\n    uniqueItems: '\"uniqueItems\" keyword is always validated.',\n    unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n    cache: \"Map is used as cache, schema object as key.\",\n    serialize: \"Map is used as cache, schema object as key.\",\n    ajvErrors: \"It is default now.\"\n  },\n  _ = {\n    ignoreKeywordsWithRef: \"\",\n    jsPropertySyntax: \"\",\n    unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.'\n  };\nfunction y(e) {\n  var t, n, r, o, i, s, a, c, l, u, d, p, h, f, m, g, _, y, v, b, w, x;\n  const E = e.strict,\n    C = null === (t = e.code) || undefined === t ? undefined : t.optimize,\n    S = !0 === C || undefined === C ? 1 : C || 0;\n  return {\n    strictSchema: null === (r = null !== (n = e.strictSchema) && undefined !== n ? n : E) || undefined === r || r,\n    strictNumbers: null === (i = null !== (o = e.strictNumbers) && undefined !== o ? o : E) || undefined === i || i,\n    strictTypes: null !== (a = null !== (s = e.strictTypes) && undefined !== s ? s : E) && undefined !== a ? a : \"log\",\n    strictTuples: null !== (l = null !== (c = e.strictTuples) && undefined !== c ? c : E) && undefined !== l ? l : \"log\",\n    strictRequired: null !== (d = null !== (u = e.strictRequired) && undefined !== u ? u : E) && undefined !== d && d,\n    code: e.code ? {\n      ...e.code,\n      optimize: S\n    } : {\n      optimize: S\n    },\n    loopRequired: null !== (p = e.loopRequired) && undefined !== p ? p : 200,\n    loopEnum: null !== (h = e.loopEnum) && undefined !== h ? h : 200,\n    meta: null === (f = e.meta) || undefined === f || f,\n    messages: null === (m = e.messages) || undefined === m || m,\n    inlineRefs: null === (g = e.inlineRefs) || undefined === g || g,\n    schemaId: null !== (_ = e.schemaId) && undefined !== _ ? _ : \"$id\",\n    addUsedSchema: null === (y = e.addUsedSchema) || undefined === y || y,\n    validateSchema: null === (v = e.validateSchema) || undefined === v || v,\n    validateFormats: null === (b = e.validateFormats) || undefined === b || b,\n    unicodeRegExp: null === (w = e.unicodeRegExp) || undefined === w || w,\n    int32range: null === (x = e.int32range) || undefined === x || x\n  };\n}\nclass v {\n  constructor(e = {}) {\n    this.schemas = {};\n    this.refs = {};\n    this.formats = {};\n    this._compilations = new Set();\n    this._loading = {};\n    this._cache = new Map();\n    e = this.opts = {\n      ...e,\n      ...y(e)\n    };\n    const {\n      es5: t,\n      lines: n\n    } = this.opts.code;\n    this.scope = new l.ValueScope({\n      scope: {},\n      prefixes: m,\n      es5: t,\n      lines: n\n    });\n    this.logger = function (e) {\n      if (!1 === e) return T;\n      if (undefined === e) return console;\n      if (e.log && e.warn && e.error) return e;\n      throw new Error(\"logger must implement log, warn and error methods\");\n    }(e.logger);\n    const r = e.validateFormats;\n    e.validateFormats = !1;\n    this.RULES = a.getRules();\n    b.call(this, g, e, \"NOT SUPPORTED\");\n    b.call(this, _, e, \"DEPRECATED\", \"warn\");\n    this._metaOpts = S.call(this);\n    e.formats && E.call(this);\n    this._addVocabularies();\n    this._addDefaultMetaSchema();\n    e.keywords && C.call(this, e.keywords);\n    \"object\" == typeof e.meta && this.addMetaSchema(e.meta);\n    x.call(this);\n    e.validateFormats = r;\n  }\n  _addVocabularies() {\n    this.addKeyword(\"$async\");\n  }\n  _addDefaultMetaSchema() {\n    const {\n      $data: e,\n      meta: t,\n      schemaId: n\n    } = this.opts;\n    let r = h;\n    \"id\" === n && (r = {\n      ...h\n    }, r.id = r.$id, delete r.$id);\n    t && e && this.addMetaSchema(r, r[n], !1);\n  }\n  defaultMeta() {\n    const {\n      meta: e,\n      schemaId: t\n    } = this.opts;\n    return this.opts.defaultMeta = \"object\" == typeof e ? e[t] || e : undefined;\n  }\n  validate(e, t) {\n    let n;\n    if (\"string\" == typeof e) {\n      n = this.getSchema(e);\n      if (!n) throw new Error(`no schema with key or ref \"${e}\"`);\n    } else n = this.compile(e);\n    const r = n(t);\n    \"$async\" in n || (this.errors = n.errors);\n    return r;\n  }\n  compile(e, t) {\n    const n = this._addSchema(e, t);\n    return n.validate || this._compileSchemaEnv(n);\n  }\n  compileAsync(e, t) {\n    if (\"function\" != typeof this.opts.loadSchema) throw new Error(\"options.loadSchema should be a function\");\n    const {\n      loadSchema: n\n    } = this.opts;\n    return r.call(this, e, t);\n    async function r(e, t) {\n      await o.call(this, e.$schema);\n      const n = this._addSchema(e, t);\n      return n.validate || i.call(this, n);\n    }\n    async function o(e) {\n      e && !this.getSchema(e) && (await r.call(this, {\n        $ref: e\n      }, !0));\n    }\n    async function i(e) {\n      try {\n        return this._compileSchemaEnv(e);\n      } catch (t) {\n        if (!(t instanceof s.default)) throw t;\n        a.call(this, t);\n        await c.call(this, t.missingSchema);\n        return i.call(this, e);\n      }\n    }\n    function a({\n      missingSchema: e,\n      missingRef: t\n    }) {\n      if (this.refs[e]) throw new Error(`AnySchema ${e} is loaded but ${t} cannot be resolved`);\n    }\n    async function c(e) {\n      const n = await l.call(this, e);\n      this.refs[e] || (await o.call(this, n.$schema));\n      this.refs[e] || this.addSchema(n, e, t);\n    }\n    async function l(e) {\n      const t = this._loading[e];\n      if (t) return t;\n      try {\n        return await (this._loading[e] = n(e));\n      } finally {\n        delete this._loading[e];\n      }\n    }\n  }\n  addSchema(e, t, n, r = this.opts.validateSchema) {\n    if (Array.isArray(e)) {\n      for (const t of e) this.addSchema(t, undefined, n, r);\n      return this;\n    }\n    let o;\n    if (\"object\" == typeof e) {\n      const {\n        schemaId: t\n      } = this.opts;\n      o = e[t];\n      if (void 0 !== o && \"string\" != typeof o) throw new Error(`schema ${t} must be string`);\n    }\n    t = u.normalizeId(t || o);\n    this._checkUnique(t);\n    this.schemas[t] = this._addSchema(e, n, t, r, !0);\n    return this;\n  }\n  addMetaSchema(e, t, n = this.opts.validateSchema) {\n    this.addSchema(e, t, !0, n);\n    return this;\n  }\n  validateSchema(e, t) {\n    if (\"boolean\" == typeof e) return !0;\n    let n;\n    n = e.$schema;\n    if (void 0 !== n && \"string\" != typeof n) throw new Error(\"$schema must be a string\");\n    n = n || this.opts.defaultMeta || this.defaultMeta();\n    if (!n) return this.logger.warn(\"meta-schema not available\"), this.errors = null, !0;\n    const r = this.validate(n, e);\n    if (!r && t) {\n      const e = \"schema is invalid: \" + this.errorsText();\n      if (\"log\" !== this.opts.validateSchema) throw new Error(e);\n      this.logger.error(e);\n    }\n    return r;\n  }\n  getSchema(e) {\n    let t;\n    for (; \"string\" == typeof (t = w.call(this, e));) e = t;\n    if (undefined === t) {\n      const {\n          schemaId: n\n        } = this.opts,\n        r = new c.SchemaEnv({\n          schema: {},\n          schemaId: n\n        });\n      t = c.resolveSchema.call(this, r, e);\n      if (!t) return;\n      this.refs[e] = t;\n    }\n    return t.validate || this._compileSchemaEnv(t);\n  }\n  removeSchema(e) {\n    if (e instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, e);\n      this._removeAllSchemas(this.refs, e);\n      return this;\n    }\n    switch (typeof e) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas);\n        this._removeAllSchemas(this.refs);\n        this._cache.clear();\n        return this;\n      case \"string\":\n        {\n          const t = w.call(this, e);\n          \"object\" == typeof t && this._cache.delete(t.schema);\n          delete this.schemas[e];\n          delete this.refs[e];\n          return this;\n        }\n      case \"object\":\n        {\n          const t = e;\n          this._cache.delete(t);\n          let n = e[this.opts.schemaId];\n          n && (n = u.normalizeId(n), delete this.schemas[n], delete this.refs[n]);\n          return this;\n        }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\");\n    }\n  }\n  addVocabulary(e) {\n    for (const t of e) this.addKeyword(t);\n    return this;\n  }\n  addKeyword(e, t) {\n    let n;\n    if (\"string\" == typeof e) {\n      n = e;\n      \"object\" == typeof t && (this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\"), t.keyword = n);\n    } else {\n      if (\"object\" != typeof e || undefined !== t) throw new Error(\"invalid addKeywords parameters\");\n      n = (t = e).keyword;\n      if (Array.isArray(n) && !n.length) throw new Error(\"addKeywords: keyword must be string or non-empty array\");\n    }\n    I.call(this, n, t);\n    if (!t) return (0, p.eachItem)(n, e => P.call(this, e)), this;\n    O.call(this, t);\n    const r = {\n      ...t,\n      type: d.getJSONTypes(t.type),\n      schemaType: d.getJSONTypes(t.schemaType)\n    };\n    p.eachItem(n, 0 === r.type.length ? e => P.call(this, e, r) : e => r.type.forEach(t => P.call(this, e, r, t)));\n    return this;\n  }\n  getKeyword(e) {\n    const t = this.RULES.all[e];\n    return \"object\" == typeof t ? t.definition : !!t;\n  }\n  removeKeyword(e) {\n    const {\n      RULES: t\n    } = this;\n    delete t.keywords[e];\n    delete t.all[e];\n    for (const n of t.rules) {\n      const t = n.rules.findIndex(t => t.keyword === e);\n      t >= 0 && n.rules.splice(t, 1);\n    }\n    return this;\n  }\n  addFormat(e, t) {\n    \"string\" == typeof t && (t = new RegExp(t));\n    this.formats[e] = t;\n    return this;\n  }\n  errorsText(e = this.errors, {\n    separator: t = \", \",\n    dataVar: n = \"data\"\n  } = {}) {\n    return e && 0 !== e.length ? e.map(e => `${n}${e.instancePath} ${e.message}`).reduce((e, n) => e + t + n) : \"No errors\";\n  }\n  $dataMetaSchema(e, t) {\n    const n = this.RULES.all;\n    e = JSON.parse(JSON.stringify(e));\n    for (const r of t) {\n      const t = r.split(\"/\").slice(1);\n      let o = e;\n      for (const e of t) o = o[e];\n      for (const e in n) {\n        const t = n[e];\n        if (\"object\" != typeof t) continue;\n        const {\n            $data: r\n          } = t.definition,\n          i = o[e];\n        r && i && (o[e] = R(i));\n      }\n    }\n    return e;\n  }\n  _removeAllSchemas(e, t) {\n    for (const n in e) {\n      const r = e[n];\n      t && !t.test(n) || (\"string\" == typeof r ? delete e[n] : r && !r.meta && (this._cache.delete(r.schema), delete e[n]));\n    }\n  }\n  _addSchema(e, t, n, r = this.opts.validateSchema, o = this.opts.addUsedSchema) {\n    let i;\n    const {\n      schemaId: s\n    } = this.opts;\n    if (\"object\" == typeof e) i = e[s];else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\");\n      if (\"boolean\" != typeof e) throw new Error(\"schema must be object or boolean\");\n    }\n    let a = this._cache.get(e);\n    if (undefined !== a) return a;\n    n = u.normalizeId(i || n);\n    const l = u.getSchemaRefs.call(this, e, n);\n    a = new c.SchemaEnv({\n      schema: e,\n      schemaId: s,\n      meta: t,\n      baseId: n,\n      localRefs: l\n    });\n    this._cache.set(a.schema, a);\n    o && !n.startsWith(\"#\") && (n && this._checkUnique(n), this.refs[n] = a);\n    r && this.validateSchema(e, !0);\n    return a;\n  }\n  _checkUnique(e) {\n    if (this.schemas[e] || this.refs[e]) throw new Error(`schema with key or id \"${e}\" already exists`);\n  }\n  _compileSchemaEnv(e) {\n    e.meta ? this._compileMetaSchema(e) : c.compileSchema.call(this, e);\n    if (!e.validate) throw new Error(\"ajv implementation error\");\n    return e.validate;\n  }\n  _compileMetaSchema(e) {\n    const t = this.opts;\n    this.opts = this._metaOpts;\n    try {\n      c.compileSchema.call(this, e);\n    } finally {\n      this.opts = t;\n    }\n  }\n}\nfunction b(e, t, n, r = \"error\") {\n  for (const o in e) {\n    const i = o;\n    i in t && this.logger[r](`${n}: option ${o}. ${e[i]}`);\n  }\n}\nfunction w(e) {\n  e = u.normalizeId(e);\n  return this.schemas[e] || this.refs[e];\n}\nfunction x() {\n  const e = this.opts.schemas;\n  if (e) if (Array.isArray(e)) this.addSchema(e);else for (const t in e) this.addSchema(e[t], t);\n}\nfunction E() {\n  for (const e in this.opts.formats) {\n    const t = this.opts.formats[e];\n    t && this.addFormat(e, t);\n  }\n}\nfunction C(e) {\n  if (Array.isArray(e)) this.addVocabulary(e);else {\n    this.logger.warn(\"keywords option as map is deprecated, pass array\");\n    for (const t in e) {\n      const n = e[t];\n      n.keyword || (n.keyword = t);\n      this.addKeyword(n);\n    }\n  }\n}\nfunction S() {\n  const e = {\n    ...this.opts\n  };\n  for (const t of f) delete e[t];\n  return e;\n}\nexports.default = v;\nv.ValidationError = i.default;\nv.MissingRefError = s.default;\nconst T = {\n    log() {},\n    warn() {},\n    error() {}\n  },\n  k = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction I(e, t) {\n  const {\n    RULES: n\n  } = this;\n  p.eachItem(e, e => {\n    if (n.keywords[e]) throw new Error(`Keyword ${e} is already defined`);\n    if (!k.test(e)) throw new Error(`Keyword ${e} has invalid name`);\n  });\n  if (t && t.$data && !(\"code\" in t) && !(\"validate\" in t)) throw new Error('$data keyword must have \"code\" or \"validate\" function');\n}\nfunction P(e, t, n) {\n  var r;\n  const o = null == t ? undefined : t.post;\n  if (n && o) throw new Error('keyword with \"post\" flag cannot have \"type\"');\n  const {\n    RULES: i\n  } = this;\n  let s = o ? i.post : i.rules.find(({\n    type: e\n  }) => e === n);\n  s || (s = {\n    type: n,\n    rules: []\n  }, i.rules.push(s));\n  i.keywords[e] = !0;\n  if (!t) return;\n  const a = {\n    keyword: e,\n    definition: {\n      ...t,\n      type: d.getJSONTypes(t.type),\n      schemaType: d.getJSONTypes(t.schemaType)\n    }\n  };\n  t.before ? A.call(this, s, a, t.before) : s.rules.push(a);\n  i.all[e] = a;\n  null === (r = t.implements) || undefined === r || r.forEach(e => this.addKeyword(e));\n}\nfunction A(e, t, n) {\n  const r = e.rules.findIndex(e => e.keyword === n);\n  r >= 0 ? e.rules.splice(r, 0, t) : (e.rules.push(t), this.logger.warn(`rule ${n} is not defined`));\n}\nfunction O(e) {\n  let {\n    metaSchema: t\n  } = e;\n  undefined !== t && (e.$data && this.opts.$data && (t = R(t)), e.validateSchema = this.compile(t, !0));\n}\nconst N = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\"\n};\nfunction R(e) {\n  return {\n    anyOf: [e, N]\n  };\n}",
  "7190": "const r = require(9512);\nfunction o() {}\nfunction i() {}\nfunction s() {}\nconst a = new Map(),\n  c = new Map(),\n  l = new Map();\nlet u = null,\n  d = !1;\nfunction p(e, t, n, o, i, s, a) {\n  const c = r[n],\n    l = r[o];\n  r[n] = function () {\n    if (!t.enabled) return c.apply(r, arguments);\n    const n = new Array(arguments.length);\n    for (let e = 0; e < arguments.length; e++) n[e] = arguments[e];\n    const o = n[0];\n    if (\"function\" != typeof o) throw new TypeError('\"callback\" argument must be a function');\n    const l = new i(),\n      p = --t.counter;\n    let h;\n    e.init.call(l, p, 0, null, null);\n    n[0] = function () {\n      u = h;\n      e.pre.call(l, p);\n      let t = !0;\n      try {\n        o.apply(this, arguments);\n        t = !1;\n      } finally {\n        t && process.listenerCount(\"uncaughtException\") > 0 && process.once(\"uncaughtException\", function () {\n          e.post.call(l, p, !0);\n          s.delete(h);\n          e.destroy.call(null, p);\n        });\n      }\n      e.post.call(l, p, !1);\n      u = null;\n      (a || d) && (d = !1, s.delete(h), e.destroy.call(null, p));\n    };\n    h = c.apply(r, n);\n    s.set(h, p);\n    return h;\n  };\n  r[o] = function (t) {\n    if (u === t && null !== t) d = !0;else if (s.has(t)) {\n      const n = s.get(t);\n      s.delete(t);\n      e.destroy.call(null, n);\n    }\n    l.apply(r, arguments);\n  };\n}\nmodule.exports = function () {\n  p(this._hooks, this._state, \"setTimeout\", \"clearTimeout\", o, a, !0);\n  p(this._hooks, this._state, \"setInterval\", \"clearInterval\", i, c, !1);\n  p(this._hooks, this._state, \"setImmediate\", \"clearImmediate\", s, l, !0);\n  global.setTimeout = r.setTimeout;\n  global.setInterval = r.setInterval;\n  global.setImmediate = r.setImmediate;\n  global.clearTimeout = r.clearTimeout;\n  global.clearInterval = r.clearInterval;\n  global.clearImmediate = r.clearImmediate;\n};",
  "7220": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  }(require(8934));\nmodule.exports = i;",
  "7254": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.CopilotStatusBar = undefined;\nconst r = require(9496),\n  o = require(106),\n  i = require(1133),\n  s = require(6333),\n  a = require(3060);\nexports.CopilotStatusBar = class {\n  constructor(e) {\n    this.ctx = e;\n    this.showingMessage = !1;\n    this.status = \"Normal\";\n    this.errorMessage = \"\";\n    this.disabledColor = new r.ThemeColor(\"statusBarItem.warningBackground\");\n    this.delayedUpdateDisplay = o.debounce(100, () => {\n      this.updateDisplay();\n    });\n    this.enabled = this.checkEnabledForLanguage();\n    this.item = r.window.createStatusBarItem(r.StatusBarAlignment.Right, 0);\n    this.updateDisplay();\n    this.item.show();\n    r.window.onDidChangeActiveTextEditor(() => {\n      this.updateStatusBarIndicator();\n    });\n    r.workspace.onDidCloseTextDocument(() => {\n      this.updateStatusBarIndicator();\n    });\n    r.workspace.onDidOpenTextDocument(() => {\n      this.updateStatusBarIndicator();\n    });\n  }\n  updateStatusBarIndicator() {\n    this.enabled = this.checkEnabledForLanguage();\n    this.updateDisplay();\n  }\n  checkEnabledForLanguage() {\n    return i.getEnabledConfig(this.ctx) || !1;\n  }\n  updateDisplay() {\n    switch (this.status) {\n      case \"Error\":\n        this.item.text = \"$(copilot-notconnected)\";\n        this.item.command = a.CMDShowActivationErrors;\n        this.item.tooltip = \"Copilot activation failed\";\n        break;\n      case \"Warning\":\n        this.item.text = \"$(copilot-warning)\";\n        this.item.command = undefined;\n        this.item.tooltip = \"Copilot is encountering temporary issues\";\n        break;\n      case \"InProgress\":\n        this.item.text = \"$(loading~spin)\";\n        break;\n      case \"Normal\":\n        this.item.text = \"$(copilot-logo)\";\n        this.item.command = a.CMDToggleCopilot;\n        this.item.tooltip = this.enabled ? \"Deactivate Copilot\" : \"Activate Copilot\";\n        this.item.backgroundColor = this.enabled ? undefined : this.disabledColor;\n    }\n  }\n  getStatusBarItem() {\n    return this.item;\n  }\n  setProgress() {\n    \"Error\" !== this.status && (this.status = \"InProgress\", this.delayedUpdateDisplay());\n  }\n  removeProgress() {\n    \"Error\" !== this.status && \"Warning\" !== this.status && (this.status = \"Normal\", this.delayedUpdateDisplay());\n  }\n  setWarning() {\n    \"Error\" !== this.status && (this.status = \"Warning\", this.updateDisplay());\n  }\n  setError(e, t) {\n    this.status = \"Error\";\n    this.errorMessage = e;\n    this.errorRetry = t;\n    this.updateDisplay();\n  }\n  forceNormal() {\n    this.status = \"Normal\";\n    this.errorMessage = \"\";\n    this.errorRetry = undefined;\n    this.updateDisplay();\n  }\n  toggleStatusBar() {\n    var e;\n    const t = this.ctx.get(i.ConfigProvider),\n      n = this.enabled,\n      o = null === (e = r.window.activeTextEditor) || undefined === e ? undefined : e.document.languageId,\n      a = \"editor.action.inlineSuggest.hide\";\n    if (this.showingMessage) return;\n    const c = s.TelemetryData.createAndMarkAsIssued({\n      languageId: o || \"*\"\n    });\n    if (i.getEnabledConfig(this.ctx, \"*\") == i.getEnabledConfig(this.ctx, o)) {\n      this.showingMessage = !0;\n      setTimeout(() => {\n        this.showingMessage = !1;\n      }, 15e3);\n      const e = n ? \"Disable\" : \"Enable\",\n        i = `${e} Globally`,\n        l = `${e} for ${o}`,\n        u = o ? [i, l] : [i];\n      r.window.showInformationMessage(`Would you like to ${n ? \"disable\" : \"enable\"} Copilot?`, ...u).then(e => {\n        const l = e === i;\n        this.showingMessage = !1;\n        if (void 0 === e) return void (0, s.telemetry)(this.ctx, \"statusBar.cancelToggle\");\n        s.telemetry(this.ctx, \"statusBar\" + (l ? \".global\" : \".language\") + (n ? \"Off\" : \"On\"), c);\n        n && r.commands.executeCommand(a);\n        const u = l ? \"*\" : o;\n        t.updateEnabledConfig(this.ctx, u, !n).then(() => {\n          this.enabled = !n;\n          this.updateDisplay();\n        });\n      });\n    } else {\n      s.telemetry(this.ctx, \"statusBar.language\" + (n ? \"Off\" : \"On\"), c);\n      n && r.commands.executeCommand(a);\n      t.updateEnabledConfig(this.ctx, o || \"*\", !n).then(() => {\n        this.enabled = !n;\n        this.updateDisplay();\n      });\n    }\n    this.updateDisplay();\n  }\n  showActivationErrors(e) {\n    if (this.showingMessage) return;\n    this.showingMessage = !0;\n    const t = [\"Show output log\"];\n    this.errorRetry && t.push(\"Retry\");\n    r.window.showWarningMessage(this.errorMessage, ...t).then(t => {\n      this.showingMessage = !1;\n      \"Show Output log\" === t && e.show();\n      \"Retry\" === t && this.errorRetry && this.errorRetry();\n    });\n  }\n};",
  "7262": "const {\n    connect: r,\n    constants: o\n  } = require(1995),\n  {\n    Readable: i\n  } = require(2781),\n  s = require(8104)(\"helix-fetch:h2\"),\n  {\n    RequestAbortedError: a\n  } = require(1787),\n  {\n    decodeStream: c\n  } = require(4544),\n  {\n    NGHTTP2_CANCEL: l\n  } = o,\n  u = 3e5,\n  d = 5e3,\n  p = (e, t, n, r = () => {}) => {\n    const o = {\n        ...e\n      },\n      i = o[\":status\"];\n    delete o[\":status\"];\n    const s = n ? c(i, e, t, r) : t;\n    return {\n      statusCode: i,\n      statusText: \"\",\n      httpVersion: \"2.0\",\n      httpVersionMajor: 2,\n      httpVersionMinor: 0,\n      headers: o,\n      readable: s,\n      decoded: !(!n || s === t)\n    };\n  };\nmodule.exports = {\n  request: async (e, t, n) => {\n    const {\n        origin: o,\n        pathname: c,\n        search: h,\n        hash: f\n      } = t,\n      m = `${c}${h}${f}`,\n      {\n        options: {\n          h2: g = {}\n        },\n        h2: {\n          sessionCache: _\n        }\n      } = e,\n      {\n        idleSessionTimeout: y = u,\n        pushPromiseHandler: v,\n        pushHandler: b\n      } = g,\n      w = {\n        ...n\n      },\n      {\n        method: x,\n        headers: E,\n        socket: C,\n        body: S,\n        decode: T\n      } = w;\n    C && delete w.socket;\n    E.host && (E[\":authority\"] = E.host, delete E.host);\n    return new Promise((n, c) => {\n      let u,\n        h = _[o];\n      if (!h || h.closed || h.destroyed) {\n        const t = !(!1 === e.options.rejectUnauthorized || !1 === g.rejectUnauthorized),\n          n = {\n            ...g,\n            rejectUnauthorized: t\n          };\n        C && !C.inUse && (n.createConnection = () => (s(`reusing socket #${C.id} (${C.servername})`), C.inUse = !0, C));\n        const i = !(!v && !b);\n        h = r(o, {\n          ...n,\n          settings: {\n            enablePush: i\n          }\n        });\n        h.setMaxListeners(1e3);\n        h.setTimeout(y, () => {\n          s(`closing session ${o} after ${y} ms of inactivity`);\n          h.close();\n        });\n        h.once(\"connect\", () => {\n          s(`session ${o} established`);\n          s(`caching session ${o}`);\n          _[o] = h;\n        });\n        h.on(\"localSettings\", e => {\n          s(`session ${o} localSettings: ${JSON.stringify(e)}`);\n        });\n        h.on(\"remoteSettings\", e => {\n          s(`session ${o} remoteSettings: ${JSON.stringify(e)}`);\n        });\n        h.once(\"close\", () => {\n          s(`session ${o} closed`);\n          _[o] === h && (s(`discarding cached session ${o}`), delete _[o]);\n        });\n        h.once(\"error\", e => {\n          s(`session ${o} encountered error: ${e}`);\n          _[o] === h && (s(`discarding cached session ${o}`), delete _[o]);\n        });\n        h.on(\"frameError\", (e, t, n) => {\n          s(`session ${o} encountered frameError: type: ${e}, code: ${t}, id: ${n}`);\n        });\n        h.once(\"goaway\", (e, t, n) => {\n          s(`session ${o} received GOAWAY frame: errorCode: ${e}, lastStreamID: ${t}, opaqueData: ${n ? n.toString() : undefined}`);\n        });\n        h.on(\"stream\", (t, n, r) => {\n          ((e, t, n, r, o, i) => {\n            const {\n                options: {\n                  h2: {\n                    pushPromiseHandler: a,\n                    pushHandler: c,\n                    pushedStreamIdleTimeout: u = d\n                  }\n                }\n              } = e,\n              h = o[\":path\"],\n              f = `${t}${h}`;\n            s(`received PUSH_PROMISE: ${f}, stream #${r.id}, headers: ${JSON.stringify(o)}, flags: ${i}`);\n            a && a(f, o, () => {\n              r.close(l);\n            });\n            r.on(\"push\", (e, i) => {\n              s(`received push headers for ${t}${h}, stream #${r.id}, headers: ${JSON.stringify(e)}, flags: ${i}`);\n              r.setTimeout(u, () => {\n                s(`closing pushed stream #${r.id} after ${u} ms of inactivity`);\n                r.close(l);\n              });\n              c && c(f, o, p(e, r, n));\n            });\n            r.on(\"aborted\", () => {\n              s(`pushed stream #${r.id} aborted`);\n            });\n            r.on(\"error\", e => {\n              s(`pushed stream #${r.id} encountered error: ${e}`);\n            });\n            r.on(\"frameError\", (e, t, n) => {\n              s(`pushed stream #${r.id} encountered frameError: type: ${e}, code: ${t}, id: ${n}`);\n            });\n          })(e, o, T, t, n, r);\n        });\n      } else C && C.id !== h.socket.id && !C.inUse && (s(`discarding redundant socket used for ALPN: #${C.id} ${C.servername}`), C.destroy());\n      s(`${x} ${t.host}${m}`);\n      const {\n          signal: f\n        } = w,\n        k = () => {\n          f.removeEventListener(\"abort\", k);\n          c(new a());\n          u && u.close(l);\n        };\n      if (f) {\n        if (f.aborted) return void c(new a());\n        f.addEventListener(\"abort\", k);\n      }\n      const I = e => {\n        s(`session ${o} encountered error during ${w.method} ${t.href}: ${e}`);\n        c(e);\n      };\n      h.once(\"error\", I);\n      u = h.request({\n        \":method\": x,\n        \":path\": m,\n        ...E\n      });\n      u.once(\"response\", e => {\n        h.off(\"error\", I);\n        f && f.removeEventListener(\"abort\", k);\n        n(p(e, u, w.decode, c));\n      });\n      u.once(\"error\", e => {\n        h.off(\"error\", I);\n        f && f.removeEventListener(\"abort\", k);\n        u.rstCode !== l && (s(`${w.method} ${t.href} failed with: ${e.message}`), u.close(l), c(e));\n      });\n      u.once(\"frameError\", (e, n, r) => {\n        h.off(\"error\", I);\n        s(`encountered frameError during ${w.method} ${t.href}: type: ${e}, code: ${n}, id: ${r}`);\n      });\n      u.on(\"push\", (e, t) => {\n        s(`received 'push' event: headers: ${JSON.stringify(e)}, flags: ${t}`);\n      });\n      S instanceof i ? S.pipe(u) : (S && u.write(S), u.end());\n    });\n  },\n  setupContext: e => {\n    e.h2 = {\n      sessionCache: {}\n    };\n  },\n  resetContext: async ({\n    h2: e\n  }) => Promise.all(Object.values(e.sessionCache).map(e => new Promise(t => {\n    e.on(\"close\", t);\n    s(`resetContext: destroying session (socket #${e.socket && e.socket.id}, ${e.socket && e.socket.servername})`);\n    e.destroy();\n  })))\n};",
  "7300": "module.exports = function () {\n  this.ver = 1;\n  this.sampleRate = 100;\n  this.tags = {};\n};",
  "7310": "module.exports = require(\"url\");",
  "7339": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = function (e) {\n    function t() {\n      var t = e.call(this) || this;\n      t.ver = 2;\n      t.properties = {};\n      t.measurements = {};\n      return t;\n    }\n    o(t, e);\n    return t;\n  }(require(8934));\nmodule.exports = i;",
  "7373": "var r;\nrequire.r(exports);\nrequire.d(exports, {\n  URI: () => o,\n  Utils: () => i\n});\nr = (() => {\n  var e = {\n      470: e => {\n        function t(e) {\n          if (\"string\" != typeof e) throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(e));\n        }\n        function n(e, t) {\n          for (var n, r = \"\", o = 0, i = -1, s = 0, a = 0; a <= e.length; ++a) {\n            if (a < e.length) n = e.charCodeAt(a);else {\n              if (47 === n) break;\n              n = 47;\n            }\n            if (47 === n) {\n              if (i === a - 1 || 1 === s) ;else if (i !== a - 1 && 2 === s) {\n                if (r.length < 2 || 2 !== o || 46 !== r.charCodeAt(r.length - 1) || 46 !== r.charCodeAt(r.length - 2)) if (r.length > 2) {\n                  var c = r.lastIndexOf(\"/\");\n                  if (c !== r.length - 1) {\n                    -1 === c ? (r = \"\", o = 0) : o = (r = r.slice(0, c)).length - 1 - r.lastIndexOf(\"/\");\n                    i = a;\n                    s = 0;\n                    continue;\n                  }\n                } else if (2 === r.length || 1 === r.length) {\n                  r = \"\";\n                  o = 0;\n                  i = a;\n                  s = 0;\n                  continue;\n                }\n                t && (r.length > 0 ? r += \"/..\" : r = \"..\", o = 2);\n              } else {\n                r.length > 0 ? r += \"/\" + e.slice(i + 1, a) : r = e.slice(i + 1, a);\n                o = a - i - 1;\n              }\n              i = a;\n              s = 0;\n            } else 46 === n && -1 !== s ? ++s : s = -1;\n          }\n          return r;\n        }\n        var r = {\n          resolve: function () {\n            for (var e, r = \"\", o = !1, i = arguments.length - 1; i >= -1 && !o; i--) {\n              var s;\n              i >= 0 ? s = arguments[i] : (undefined === e && (e = process.cwd()), s = e);\n              t(s);\n              0 !== s.length && (r = s + \"/\" + r, o = 47 === s.charCodeAt(0));\n            }\n            r = n(r, !o);\n            return o ? r.length > 0 ? \"/\" + r : \"/\" : r.length > 0 ? r : \".\";\n          },\n          normalize: function (e) {\n            t(e);\n            if (0 === e.length) return \".\";\n            var r = 47 === e.charCodeAt(0),\n              o = 47 === e.charCodeAt(e.length - 1);\n            0 !== (e = n(e, !r)).length || r || (e = \".\");\n            e.length > 0 && o && (e += \"/\");\n            return r ? \"/\" + e : e;\n          },\n          isAbsolute: function (e) {\n            t(e);\n            return e.length > 0 && 47 === e.charCodeAt(0);\n          },\n          join: function () {\n            if (0 === arguments.length) return \".\";\n            for (var e, n = 0; n < arguments.length; ++n) {\n              var o = arguments[n];\n              t(o);\n              o.length > 0 && (undefined === e ? e = o : e += \"/\" + o);\n            }\n            return undefined === e ? \".\" : r.normalize(e);\n          },\n          relative: function (e, n) {\n            t(e);\n            t(n);\n            if (e === n) return \"\";\n            if ((e = r.resolve(e)) === (n = r.resolve(n))) return \"\";\n            for (var o = 1; o < e.length && 47 === e.charCodeAt(o); ++o);\n            for (var i = e.length, s = i - o, a = 1; a < n.length && 47 === n.charCodeAt(a); ++a);\n            for (var c = n.length - a, l = s < c ? s : c, u = -1, d = 0; d <= l; ++d) {\n              if (d === l) {\n                if (c > l) {\n                  if (47 === n.charCodeAt(a + d)) return n.slice(a + d + 1);\n                  if (0 === d) return n.slice(a + d);\n                } else s > l && (47 === e.charCodeAt(o + d) ? u = d : 0 === d && (u = 0));\n                break;\n              }\n              var p = e.charCodeAt(o + d);\n              if (p !== n.charCodeAt(a + d)) break;\n              47 === p && (u = d);\n            }\n            var h = \"\";\n            for (d = o + u + 1; d <= i; ++d) d !== i && 47 !== e.charCodeAt(d) || (0 === h.length ? h += \"..\" : h += \"/..\");\n            return h.length > 0 ? h + n.slice(a + u) : (a += u, 47 === n.charCodeAt(a) && ++a, n.slice(a));\n          },\n          _makeLong: function (e) {\n            return e;\n          },\n          dirname: function (e) {\n            t(e);\n            if (0 === e.length) return \".\";\n            for (var n = e.charCodeAt(0), r = 47 === n, o = -1, i = !0, s = e.length - 1; s >= 1; --s) if (47 === (n = e.charCodeAt(s))) {\n              if (!i) {\n                o = s;\n                break;\n              }\n            } else i = !1;\n            return -1 === o ? r ? \"/\" : \".\" : r && 1 === o ? \"//\" : e.slice(0, o);\n          },\n          basename: function (e, n) {\n            if (undefined !== n && \"string\" != typeof n) throw new TypeError('\"ext\" argument must be a string');\n            t(e);\n            var r,\n              o = 0,\n              i = -1,\n              s = !0;\n            if (undefined !== n && n.length > 0 && n.length <= e.length) {\n              if (n.length === e.length && n === e) return \"\";\n              var a = n.length - 1,\n                c = -1;\n              for (r = e.length - 1; r >= 0; --r) {\n                var l = e.charCodeAt(r);\n                if (47 === l) {\n                  if (!s) {\n                    o = r + 1;\n                    break;\n                  }\n                } else {\n                  -1 === c && (s = !1, c = r + 1);\n                  a >= 0 && (l === n.charCodeAt(a) ? -1 == --a && (i = r) : (a = -1, i = c));\n                }\n              }\n              o === i ? i = c : -1 === i && (i = e.length);\n              return e.slice(o, i);\n            }\n            for (r = e.length - 1; r >= 0; --r) if (47 === e.charCodeAt(r)) {\n              if (!s) {\n                o = r + 1;\n                break;\n              }\n            } else -1 === i && (s = !1, i = r + 1);\n            return -1 === i ? \"\" : e.slice(o, i);\n          },\n          extname: function (e) {\n            t(e);\n            for (var n = -1, r = 0, o = -1, i = !0, s = 0, a = e.length - 1; a >= 0; --a) {\n              var c = e.charCodeAt(a);\n              if (47 !== c) {\n                -1 === o && (i = !1, o = a + 1);\n                46 === c ? -1 === n ? n = a : 1 !== s && (s = 1) : -1 !== n && (s = -1);\n              } else if (!i) {\n                r = a + 1;\n                break;\n              }\n            }\n            return -1 === n || -1 === o || 0 === s || 1 === s && n === o - 1 && n === r + 1 ? \"\" : e.slice(n, o);\n          },\n          format: function (e) {\n            if (null === e || \"object\" != typeof e) throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof e);\n            return function (e, t) {\n              var n = t.dir || t.root,\n                r = t.base || (t.name || \"\") + (t.ext || \"\");\n              return n ? n === t.root ? n + r : n + \"/\" + r : r;\n            }(0, e);\n          },\n          parse: function (e) {\n            t(e);\n            var n = {\n              root: \"\",\n              dir: \"\",\n              base: \"\",\n              ext: \"\",\n              name: \"\"\n            };\n            if (0 === e.length) return n;\n            var r,\n              o = e.charCodeAt(0),\n              i = 47 === o;\n            i ? (n.root = \"/\", r = 1) : r = 0;\n            for (var s = -1, a = 0, c = -1, l = !0, u = e.length - 1, d = 0; u >= r; --u) if (47 !== (o = e.charCodeAt(u))) {\n              -1 === c && (l = !1, c = u + 1);\n              46 === o ? -1 === s ? s = u : 1 !== d && (d = 1) : -1 !== s && (d = -1);\n            } else if (!l) {\n              a = u + 1;\n              break;\n            }\n            -1 === s || -1 === c || 0 === d || 1 === d && s === c - 1 && s === a + 1 ? -1 !== c && (n.base = n.name = 0 === a && i ? e.slice(1, c) : e.slice(a, c)) : (0 === a && i ? (n.name = e.slice(1, s), n.base = e.slice(1, c)) : (n.name = e.slice(a, s), n.base = e.slice(a, c)), n.ext = e.slice(s, c));\n            a > 0 ? n.dir = e.slice(0, a - 1) : i && (n.dir = \"/\");\n            return n;\n          },\n          sep: \"/\",\n          delimiter: \":\",\n          win32: null,\n          posix: null\n        };\n        r.posix = r;\n        e.exports = r;\n      },\n      447: (e, t, n) => {\n        var r;\n        n.r(t);\n        n.d(t, {\n          URI: () => f,\n          Utils: () => S\n        });\n        if (\"object\" == typeof process) r = \"win32\" === process.platform;else if (\"object\" == typeof navigator) {\n          var o = navigator.userAgent;\n          r = o.indexOf(\"Windows\") >= 0;\n        }\n        var i,\n          s,\n          a = (i = function (e, t) {\n            return (i = Object.setPrototypeOf || {\n              __proto__: []\n            } instanceof Array && function (e, t) {\n              e.__proto__ = t;\n            } || function (e, t) {\n              for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);\n            })(e, t);\n          }, function (e, t) {\n            function n() {\n              this.constructor = e;\n            }\n            i(e, t);\n            e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n          }),\n          c = /^\\w[\\w\\d+.-]*$/,\n          l = /^\\//,\n          u = /^\\/\\//,\n          d = \"\",\n          p = \"/\",\n          h = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/,\n          f = function () {\n            function e(e, t, n, r, o, i) {\n              undefined === i && (i = !1);\n              \"object\" == typeof e ? (this.scheme = e.scheme || d, this.authority = e.authority || d, this.path = e.path || d, this.query = e.query || d, this.fragment = e.fragment || d) : (this.scheme = function (e, t) {\n                return e || t ? e : \"file\";\n              }(e, i), this.authority = t || d, this.path = function (e, t) {\n                switch (e) {\n                  case \"https\":\n                  case \"http\":\n                  case \"file\":\n                    t ? t[0] !== p && (t = p + t) : t = p;\n                }\n                return t;\n              }(this.scheme, n || d), this.query = r || d, this.fragment = o || d, function (e, t) {\n                if (!e.scheme && t) throw new Error('[UriError]: Scheme is missing: {scheme: \"\", authority: \"' + e.authority + '\", path: \"' + e.path + '\", query: \"' + e.query + '\", fragment: \"' + e.fragment + '\"}');\n                if (e.scheme && !c.test(e.scheme)) throw new Error(\"[UriError]: Scheme contains illegal characters.\");\n                if (e.path) if (e.authority) {\n                  if (!l.test(e.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n                } else if (u.test(e.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n              }(this, i));\n            }\n            e.isUri = function (t) {\n              return t instanceof e || !!t && \"string\" == typeof t.authority && \"string\" == typeof t.fragment && \"string\" == typeof t.path && \"string\" == typeof t.query && \"string\" == typeof t.scheme && \"function\" == typeof t.fsPath && \"function\" == typeof t.with && \"function\" == typeof t.toString;\n            };\n            Object.defineProperty(e.prototype, \"fsPath\", {\n              get: function () {\n                return b(this, !1);\n              },\n              enumerable: !1,\n              configurable: !0\n            });\n            e.prototype.with = function (e) {\n              if (!e) return this;\n              var t = e.scheme,\n                n = e.authority,\n                r = e.path,\n                o = e.query,\n                i = e.fragment;\n              undefined === t ? t = this.scheme : null === t && (t = d);\n              undefined === n ? n = this.authority : null === n && (n = d);\n              undefined === r ? r = this.path : null === r && (r = d);\n              undefined === o ? o = this.query : null === o && (o = d);\n              undefined === i ? i = this.fragment : null === i && (i = d);\n              return t === this.scheme && n === this.authority && r === this.path && o === this.query && i === this.fragment ? this : new g(t, n, r, o, i);\n            };\n            e.parse = function (e, t) {\n              undefined === t && (t = !1);\n              var n = h.exec(e);\n              return n ? new g(n[2] || d, C(n[4] || d), C(n[5] || d), C(n[7] || d), C(n[9] || d), t) : new g(d, d, d, d, d);\n            };\n            e.file = function (e) {\n              var t = d;\n              r && (e = e.replace(/\\\\/g, p));\n              if (e[0] === p && e[1] === p) {\n                var n = e.indexOf(p, 2);\n                -1 === n ? (t = e.substring(2), e = p) : (t = e.substring(2, n), e = e.substring(n) || p);\n              }\n              return new g(\"file\", t, e, d, d);\n            };\n            e.from = function (e) {\n              return new g(e.scheme, e.authority, e.path, e.query, e.fragment);\n            };\n            e.prototype.toString = function (e) {\n              undefined === e && (e = !1);\n              return w(this, e);\n            };\n            e.prototype.toJSON = function () {\n              return this;\n            };\n            e.revive = function (t) {\n              if (t) {\n                if (t instanceof e) return t;\n                var n = new g(t);\n                n._formatted = t.external;\n                n._fsPath = t._sep === m ? t.fsPath : null;\n                return n;\n              }\n              return t;\n            };\n            return e;\n          }(),\n          m = r ? 1 : undefined,\n          g = function (e) {\n            function t() {\n              var t = null !== e && e.apply(this, arguments) || this;\n              t._formatted = null;\n              t._fsPath = null;\n              return t;\n            }\n            a(t, e);\n            Object.defineProperty(t.prototype, \"fsPath\", {\n              get: function () {\n                this._fsPath || (this._fsPath = b(this, !1));\n                return this._fsPath;\n              },\n              enumerable: !1,\n              configurable: !0\n            });\n            t.prototype.toString = function (e) {\n              undefined === e && (e = !1);\n              return e ? w(this, !0) : (this._formatted || (this._formatted = w(this, !1)), this._formatted);\n            };\n            t.prototype.toJSON = function () {\n              var e = {\n                $mid: 1\n              };\n              this._fsPath && (e.fsPath = this._fsPath, e._sep = m);\n              this._formatted && (e.external = this._formatted);\n              this.path && (e.path = this.path);\n              this.scheme && (e.scheme = this.scheme);\n              this.authority && (e.authority = this.authority);\n              this.query && (e.query = this.query);\n              this.fragment && (e.fragment = this.fragment);\n              return e;\n            };\n            return t;\n          }(f),\n          _ = ((s = {})[58] = \"%3A\", s[47] = \"%2F\", s[63] = \"%3F\", s[35] = \"%23\", s[91] = \"%5B\", s[93] = \"%5D\", s[64] = \"%40\", s[33] = \"%21\", s[36] = \"%24\", s[38] = \"%26\", s[39] = \"%27\", s[40] = \"%28\", s[41] = \"%29\", s[42] = \"%2A\", s[43] = \"%2B\", s[44] = \"%2C\", s[59] = \"%3B\", s[61] = \"%3D\", s[32] = \"%20\", s);\n        function y(e, t) {\n          for (var n = undefined, r = -1, o = 0; o < e.length; o++) {\n            var i = e.charCodeAt(o);\n            if (i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || 45 === i || 46 === i || 95 === i || 126 === i || t && 47 === i) {\n              -1 !== r && (n += encodeURIComponent(e.substring(r, o)), r = -1);\n              undefined !== n && (n += e.charAt(o));\n            } else {\n              undefined === n && (n = e.substr(0, o));\n              var s = _[i];\n              undefined !== s ? (-1 !== r && (n += encodeURIComponent(e.substring(r, o)), r = -1), n += s) : -1 === r && (r = o);\n            }\n          }\n          -1 !== r && (n += encodeURIComponent(e.substring(r)));\n          return undefined !== n ? n : e;\n        }\n        function v(e) {\n          for (var t = undefined, n = 0; n < e.length; n++) {\n            var r = e.charCodeAt(n);\n            35 === r || 63 === r ? (undefined === t && (t = e.substr(0, n)), t += _[r]) : undefined !== t && (t += e[n]);\n          }\n          return undefined !== t ? t : e;\n        }\n        function b(e, t) {\n          var n;\n          n = e.authority && e.path.length > 1 && \"file\" === e.scheme ? \"//\" + e.authority + e.path : 47 === e.path.charCodeAt(0) && (e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90 || e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122) && 58 === e.path.charCodeAt(2) ? t ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path;\n          r && (n = n.replace(/\\//g, \"\\\\\"));\n          return n;\n        }\n        function w(e, t) {\n          var n = t ? v : y,\n            r = \"\",\n            o = e.scheme,\n            i = e.authority,\n            s = e.path,\n            a = e.query,\n            c = e.fragment;\n          o && (r += o, r += \":\");\n          (i || \"file\" === o) && (r += p, r += p);\n          if (i) {\n            var l = i.indexOf(\"@\");\n            if (-1 !== l) {\n              var u = i.substr(0, l);\n              i = i.substr(l + 1), -1 === (l = u.indexOf(\":\")) ? r += n(u, !1) : (r += n(u.substr(0, l), !1), r += \":\", r += n(u.substr(l + 1), !1)), r += \"@\";\n            }\n            -1 === (l = (i = i.toLowerCase()).indexOf(\":\")) ? r += n(i, !1) : (r += n(i.substr(0, l), !1), r += i.substr(l));\n          }\n          if (s) {\n            if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2)) (d = s.charCodeAt(1)) >= 65 && d <= 90 && (s = \"/\" + String.fromCharCode(d + 32) + \":\" + s.substr(3));else if (s.length >= 2 && 58 === s.charCodeAt(1)) {\n              var d;\n              (d = s.charCodeAt(0)) >= 65 && d <= 90 && (s = String.fromCharCode(d + 32) + \":\" + s.substr(2));\n            }\n            r += n(s, !0);\n          }\n          a && (r += \"?\", r += n(a, !1));\n          c && (r += \"#\", r += t ? c : y(c, !1));\n          return r;\n        }\n        function x(e) {\n          try {\n            return decodeURIComponent(e);\n          } catch (t) {\n            return e.length > 3 ? e.substr(0, 3) + x(e.substr(3)) : e;\n          }\n        }\n        var E = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n        function C(e) {\n          return e.match(E) ? e.replace(E, function (e) {\n            return x(e);\n          }) : e;\n        }\n        var S,\n          T = n(470),\n          k = function () {\n            for (var e = 0, t = 0, n = arguments.length; t < n; t++) e += arguments[t].length;\n            var r = Array(e),\n              o = 0;\n            for (t = 0; t < n; t++) for (var i = arguments[t], s = 0, a = i.length; s < a; s++, o++) r[o] = i[s];\n            return r;\n          },\n          I = T.posix || T;\n        !function (e) {\n          e.joinPath = function (e) {\n            for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];\n            return e.with({\n              path: I.join.apply(I, k([e.path], t))\n            });\n          };\n          e.resolvePath = function (e) {\n            for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];\n            var r = e.path || \"/\";\n            return e.with({\n              path: I.resolve.apply(I, k([r], t))\n            });\n          };\n          e.dirname = function (e) {\n            var t = I.dirname(e.path);\n            return 1 === t.length && 46 === t.charCodeAt(0) ? e : e.with({\n              path: t\n            });\n          };\n          e.basename = function (e) {\n            return I.basename(e.path);\n          };\n          e.extname = function (e) {\n            return I.extname(e.path);\n          };\n        }(S || (S = {}));\n      }\n    },\n    t = {};\n  function n(r) {\n    if (t[r]) return t[r].exports;\n    var o = t[r] = {\n      exports: {}\n    };\n    e[r](o, o.exports, n);\n    return o.exports;\n  }\n  n.d = (e, t) => {\n    for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {\n      enumerable: !0,\n      get: t[r]\n    });\n  };\n  n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t);\n  n.r = e => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n      value: \"Module\"\n    });\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n  };\n  return n(447);\n})();\nconst {\n  URI: o,\n  Utils: i\n} = r;",
  "7396": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(5282);\nexports.IsInitialized = !process.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL;\nvar o = \"DiagnosticChannel\";\nif (exports.IsInitialized) {\n  var i = require(4106),\n    s = (process.env.APPLICATION_INSIGHTS_NO_PATCH_MODULES || \"\").split(\",\"),\n    a = {\n      bunyan: i.bunyan,\n      console: i.console,\n      mongodb: i.mongodb,\n      mongodbCore: i.mongodbCore,\n      mysql: i.mysql,\n      redis: i.redis,\n      pg: i.pg,\n      pgPool: i.pgPool,\n      winston: i.winston\n    };\n  for (var c in a) -1 === s.indexOf(c) && (a[c].enable(), r.info(o, \"Subscribed to \" + c + \" events\"));\n  s.length > 0 && r.info(o, \"Some modules will not be patched\", s);\n} else r.info(o, \"Not subscribing to dependency autocollection because APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL was set\");\nexports.registerContextPreservation = function (e) {\n  exports.IsInitialized && require(4953).channel.addContextPreservation(e);\n};",
  "7408": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.Priorities = exports.PromptWishlist = exports.PromptElementRanges = exports.PromptChoices = exports.PromptBackground = exports.PromptElementKind = undefined;\nconst r = require(1747),\n  o = require(9852);\nvar i;\n!function (e) {\n  e.BeforeCursor = \"BeforeCursor\";\n  e.AfterCursor = \"AfterCursor\";\n  e.SimilarFile = \"SimilarFile\";\n  e.ImportedFile = \"ImportedFile\";\n  e.LanguageMarker = \"LanguageMarker\";\n  e.PathMarker = \"PathMarker\";\n}(i = exports.PromptElementKind || (exports.PromptElementKind = {}));\nclass PromptBackground {\n  constructor() {\n    this.used = new Map();\n    this.unused = new Map();\n  }\n  markUsed(e) {\n    this.IsNeighboringTab(e) && this.used.set(e.id, this.convert(e));\n  }\n  undoMarkUsed(e) {\n    this.IsNeighboringTab(e) && this.used.delete(e.id);\n  }\n  markUnused(e) {\n    this.IsNeighboringTab(e) && this.unused.set(e.id, this.convert(e));\n  }\n  convert(e) {\n    return {\n      score: e.score.toFixed(4),\n      length: e.text.length\n    };\n  }\n  IsNeighboringTab(e) {\n    return e.kind == i.SimilarFile;\n  }\n}\nexports.PromptBackground = PromptBackground;\nclass PromptChoices {\n  constructor() {\n    this.used = new Map();\n    this.unused = new Map();\n  }\n  markUsed(e) {\n    this.used.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\n  }\n  undoMarkUsed(e) {\n    this.used.set(e.kind, (this.used.get(e.kind) || 0) - e.tokens);\n  }\n  markUnused(e) {\n    this.unused.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\n  }\n}\nexports.PromptChoices = PromptChoices;\nclass PromptElementRanges {\n  constructor(e) {\n    this.ranges = new Array();\n    let t,\n      n = 0;\n    for (const {\n      element: r\n    } of e) 0 !== r.text.length && (t === i.BeforeCursor && r.kind === i.BeforeCursor ? this.ranges[this.ranges.length - 1].end += r.text.length : this.ranges.push({\n      kind: r.kind,\n      start: n,\n      end: n + r.text.length\n    }), t = r.kind, n += r.text.length);\n  }\n}\nexports.PromptElementRanges = PromptElementRanges;\nexports.PromptWishlist = class {\n  constructor(e) {\n    this.content = [];\n    this.lineEndingOption = e;\n  }\n  getContent() {\n    return [...this.content];\n  }\n  convertLineEndings(e) {\n    this.lineEndingOption === r.LineEndingOptions.ConvertToUnix && (e = e.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\"));\n    return e;\n  }\n  append(e, t, n, r = o.tokenLength(e), i = NaN) {\n    e = this.convertLineEndings(e);\n    const s = this.content.length;\n    this.content.push({\n      id: s,\n      text: e,\n      kind: t,\n      priority: n,\n      tokens: r,\n      requires: [],\n      excludes: [],\n      score: i\n    });\n    return s;\n  }\n  appendLineForLine(e, t, n) {\n    const r = (e = this.convertLineEndings(e)).split(\"\\n\");\n    for (let e = 0; e < r.length - 1; e++) r[e] += \"\\n\";\n    const o = [];\n    r.forEach((e, t) => {\n      \"\\n\" === e && o.length > 0 && !o[o.length - 1].endsWith(\"\\n\\n\") ? o[o.length - 1] += \"\\n\" : o.push(e);\n    });\n    const i = [];\n    o.forEach((e, r) => {\n      \"\" !== e && (i.push(this.append(e, t, n)), r > 0 && (this.content[this.content.length - 2].requires = [this.content[this.content.length - 1]]));\n    });\n    return i;\n  }\n  require(e, t) {\n    const n = this.content.find(t => t.id === e),\n      r = this.content.find(e => e.id === t);\n    n && r && n.requires.push(r);\n  }\n  exclude(e, t) {\n    const n = this.content.find(t => t.id === e),\n      r = this.content.find(e => e.id === t);\n    n && r && n.excludes.push(r);\n  }\n  fulfill(e) {\n    const t = new PromptChoices(),\n      n = new PromptBackground(),\n      r = this.content.map((e, t) => ({\n        element: e,\n        index: t\n      }));\n    r.sort((e, t) => e.element.priority === t.element.priority ? t.index - e.index : t.element.priority - e.element.priority);\n    const i = new Set(),\n      l = new Set();\n    let u;\n    const d = [];\n    let p = e;\n    r.forEach(e => {\n      var r;\n      const o = e.element,\n        s = e.index;\n      if (p >= 0 && (p > 0 || undefined === u) && o.requires.every(e => i.has(e.id)) && !l.has(o.id)) {\n        let a = o.tokens;\n        const c = null === (r = function (e, t) {\n          let n,\n            r = 1 / 0;\n          for (const o of e) o.index > t && o.index < r && (n = o, r = o.index);\n          return n;\n        }(d, s)) || undefined === r ? undefined : r.element;\n        o.text.endsWith(\"\\n\\n\") && c && !c.text.match(/^\\s/) && a++;\n        p >= a ? (p -= a, i.add(o.id), o.excludes.forEach(e => l.add(e.id)), t.markUsed(o), n.markUsed(o), d.push(e)) : u = null != u ? u : e;\n      } else {\n        t.markUnused(o);\n        n.markUnused(o);\n      }\n    });\n    d.sort((e, t) => e.index - t.index);\n    let h = d.reduce((e, t) => e + t.element.text, \"\"),\n      f = o.tokenLength(h);\n    for (; f > e;) {\n      d.sort((e, t) => t.element.priority === e.element.priority ? t.index - e.index : t.element.priority - e.element.priority);\n      const e = d.pop();\n      e && (t.undoMarkUsed(e.element), t.markUnused(e.element), n.undoMarkUsed(e.element), n.markUnused(e.element), u = undefined);\n      d.sort((e, t) => e.index - t.index);\n      h = d.reduce((e, t) => e + t.element.text, \"\");\n      f = o.tokenLength(h);\n    }\n    const m = [...d];\n    if (undefined !== u) {\n      m.push(u);\n      m.sort((e, t) => e.index - t.index);\n      const r = m.reduce((e, t) => e + t.element.text, \"\"),\n        i = o.tokenLength(r);\n      if (i <= e) {\n        t.markUsed(u.element);\n        n.markUsed(u.element);\n        const e = new PromptElementRanges(m);\n        return {\n          prefix: r,\n          suffix: \"\",\n          prefixLength: i,\n          suffixLength: 0,\n          promptChoices: t,\n          promptBackground: n,\n          promptElementRanges: e\n        };\n      }\n      t.markUnused(u.element);\n      n.markUnused(u.element);\n    }\n    const g = new PromptElementRanges(d);\n    return {\n      prefix: h,\n      suffix: \"\",\n      prefixLength: f,\n      suffixLength: 0,\n      promptChoices: t,\n      promptBackground: n,\n      promptElementRanges: g\n    };\n  }\n};\nclass Priorities {\n  constructor() {\n    this.registeredPriorities = [0, 1];\n  }\n  register(e) {\n    if (e > Priorities.TOP || e < Priorities.BOTTOM) throw new Error(\"Priority must be between 0 and 1\");\n    this.registeredPriorities.push(e);\n    return e;\n  }\n  justAbove(...e) {\n    const t = Math.max(...e),\n      n = Math.min(...this.registeredPriorities.filter(e => e > t));\n    return this.register((n + t) / 2);\n  }\n  justBelow(...e) {\n    const t = Math.min(...e),\n      n = Math.max(...this.registeredPriorities.filter(e => e < t));\n    return this.register((n + t) / 2);\n  }\n  between(e, t) {\n    if (this.registeredPriorities.some(n => n > e && n < t) || !this.registeredPriorities.includes(e) || !this.registeredPriorities.includes(t)) throw new Error(\"Priorities must be adjacent in the list of priorities\");\n    return this.register((e + t) / 2);\n  }\n}\nexports.Priorities = Priorities;\nPriorities.TOP = 1;\nPriorities.BOTTOM = 0;",
  "7424": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(1017),\n  o = require(4014),\n  i = require(8188),\n  s = Object.keys(process.binding(\"natives\")),\n  a = i.prototype.require;\nexports.makePatchingRequire = function (e) {\n  var t = {};\n  return function (n) {\n    var c = a.apply(this, arguments);\n    if (e[n]) {\n      var l = i._resolveFilename(n, this);\n      if (t.hasOwnProperty(l)) return t[l];\n      var u = undefined;\n      if (s.indexOf(n) < 0) try {\n        u = a.call(this, r.join(n, \"package.json\")).version;\n      } catch (e) {\n        return c;\n      } else u = process.version.substring(1);\n      var d = u.indexOf(\"-\");\n      d >= 0 && (u = u.substring(0, d));\n      for (var p = c, h = 0, f = e[n]; h < f.length; h++) {\n        var m = f[h];\n        o.satisfies(u, m.versionSpecifier) && (p = m.patch(p, l));\n      }\n      return t[l] = p;\n    }\n    return c;\n  };\n};",
  "7426": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nclass n extends Error {\n  constructor(e) {\n    super(\"validation failed\");\n    this.errors = e;\n    this.ajv = this.validation = !0;\n  }\n}\nexports.default = n;",
  "7460": "var r, o, i, s, a, c, l, u;\nu = require(8249);\nrequire(4938);\nrequire(34);\no = (r = u).x64;\ni = o.Word;\ns = o.WordArray;\na = r.algo;\nc = a.SHA512;\nl = a.SHA384 = c.extend({\n  _doReset: function () {\n    this._hash = new s.init([new i.init(3418070365, 3238371032), new i.init(1654270250, 914150663), new i.init(2438529370, 812702999), new i.init(355462360, 4144912697), new i.init(1731405415, 4290775857), new i.init(2394180231, 1750603025), new i.init(3675008525, 1694076839), new i.init(1203062813, 3204075428)]);\n  },\n  _doFinalize: function () {\n    var e = c._doFinalize.call(this);\n    e.sigBytes -= 16;\n    return e;\n  }\n});\nr.SHA384 = c._createHelper(l);\nr.HmacSHA384 = c._createHmacHelper(l);\nmodule.exports = u.SHA384;",
  "7481": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ghostTextDisplayQuantiles = exports.ghostTextDisplayLanguageParameters = exports.ghostTextDisplayMeanAlternativeLogProbParameter = exports.ghostTextDisplayMeanLogProbParameter = exports.ghostTextDisplayLog1pcompCharLenParameter = exports.ghostTextDisplayInterceptParameter = undefined;\nexports.ghostTextDisplayInterceptParameter = 2.98410452738298;\nexports.ghostTextDisplayLog1pcompCharLenParameter = -.838732736843507;\nexports.ghostTextDisplayMeanLogProbParameter = 1.50314646255716;\nexports.ghostTextDisplayMeanAlternativeLogProbParameter = -.237798634012662;\nexports.ghostTextDisplayLanguageParameters = {\n  python: .314368072478742\n};\nexports.ghostTextDisplayQuantiles = {\n  .01: .225800751784931,\n  .02: .290204307767402,\n  .03: .333153496466045,\n  .05: .404516749849559,\n  .1: .513216040545626,\n  .2: .626904979128674,\n  .3: .694880719658273,\n  .4: .743100684947291,\n  .5: .782524520571946,\n  .6: .816856186092243,\n  .7: .84922977716585,\n  .8: .883694877241999,\n  .9: .921859050950077,\n  .95: .944571268106974,\n  .99: .969535563141733\n};",
  "7625": "var r = require(7310),\n  o = require(9253),\n  i = require(4470),\n  s = require(5290),\n  a = require(3504),\n  c = require(9428),\n  l = require(894),\n  u = require(2588),\n  d = require(5740),\n  p = require(5282),\n  h = require(9813),\n  f = function () {\n    function e(e) {\n      this._telemetryProcessors = [];\n      var t = new o(e);\n      this.config = t;\n      this.context = new i();\n      this.commonProperties = {};\n      var n = new u(this.config);\n      this.channel = new a(function () {\n        return t.disableAppInsights;\n      }, function () {\n        return t.maxBatchSize;\n      }, function () {\n        return t.maxBatchIntervalMs;\n      }, n);\n    }\n    e.prototype.trackAvailability = function (e) {\n      this.track(e, s.TelemetryType.Availability);\n    };\n    e.prototype.trackTrace = function (e) {\n      this.track(e, s.TelemetryType.Trace);\n    };\n    e.prototype.trackMetric = function (e) {\n      this.track(e, s.TelemetryType.Metric);\n    };\n    e.prototype.trackException = function (e) {\n      e && e.exception && !d.isError(e.exception) && (e.exception = new Error(e.exception.toString()));\n      this.track(e, s.TelemetryType.Exception);\n    };\n    e.prototype.trackEvent = function (e) {\n      this.track(e, s.TelemetryType.Event);\n    };\n    e.prototype.trackRequest = function (e) {\n      this.track(e, s.TelemetryType.Request);\n    };\n    e.prototype.trackDependency = function (e) {\n      e && !e.target && e.data && (e.target = r.parse(e.data).host);\n      this.track(e, s.TelemetryType.Dependency);\n    };\n    e.prototype.flush = function (e) {\n      this.channel.triggerSend(!!e && !!e.isAppCrashing, e ? e.callback : undefined);\n    };\n    e.prototype.track = function (e, t) {\n      if (e && s.telemetryTypeToBaseType(t)) {\n        var n = h.createEnvelope(e, t, this.commonProperties, this.context, this.config);\n        e.time && (n.time = e.time.toISOString());\n        var r = this.runTelemetryProcessors(n, e.contextObjects);\n        r = r && c.samplingTelemetryProcessor(n, {\n          correlationContext: l.CorrelationContextManager.getCurrentContext()\n        });\n        c.performanceMetricsTelemetryProcessor(n, this.quickPulseClient);\n        r && this.channel.send(n);\n      } else p.warn(\"track() requires telemetry object and telemetryType to be specified.\");\n    };\n    e.prototype.addTelemetryProcessor = function (e) {\n      this._telemetryProcessors.push(e);\n    };\n    e.prototype.clearTelemetryProcessors = function () {\n      this._telemetryProcessors = [];\n    };\n    e.prototype.runTelemetryProcessors = function (e, t) {\n      var n = !0,\n        r = this._telemetryProcessors.length;\n      if (0 === r) return n;\n      (t = t || {}).correlationContext = l.CorrelationContextManager.getCurrentContext();\n      for (var o = 0; o < r; ++o) try {\n        var i = this._telemetryProcessors[o];\n        if (i && !1 === i.apply(null, [e, t])) {\n          n = !1;\n          break;\n        }\n      } catch (t) {\n        n = !0;\n        p.warn(\"One of telemetry processors failed, telemetry item will be sent.\", t, e);\n      }\n      return n;\n    };\n    return e;\n  }();\nmodule.exports = f;",
  "7645": "if (process.addAsyncListener) throw new Error(\"Don't require polyfill unless needed\");\nvar r = require(6372),\n  o = require(2249),\n  i = r.wrap,\n  s = r.massWrap,\n  a = require(9090),\n  c = require(3837),\n  l = o.gte(process.version, \"6.0.0\"),\n  u = o.gte(process.version, \"7.0.0\"),\n  d = o.gte(process.version, \"8.0.0\"),\n  p = o.gte(process.version, \"11.0.0\"),\n  h = require(1808);\nfunction f(e) {\n  return function () {\n    this.on(\"connection\", function (e) {\n      e._handle && (e._handle.onread = a(e._handle.onread));\n    });\n    try {\n      return e.apply(this, arguments);\n    } finally {\n      this._handle && this._handle.onconnection && (this._handle.onconnection = a(this._handle.onconnection));\n    }\n  };\n}\nfunction m(e) {\n  if (e && e._handle) {\n    var t = e._handle;\n    t._originalOnread || (t._originalOnread = t.onread);\n    t.onread = a(t._originalOnread);\n  }\n}\nu && !h._normalizeArgs ? h._normalizeArgs = function (e) {\n  if (0 === e.length) return [{}, null];\n  var t,\n    n,\n    r = e[0],\n    o = {};\n  \"object\" == typeof r && null !== r ? o = r : \"string\" == typeof (t = r) && !1 === (n = t, (n = Number(n)) >= 0 && n) ? o.path = r : (o.port = r, e.length > 1 && \"string\" == typeof e[1] && (o.host = e[1]));\n  var i = e[e.length - 1];\n  return \"function\" != typeof i ? [o, null] : [o, i];\n} : u || h._normalizeConnectArgs || (h._normalizeConnectArgs = function (e) {\n  var t,\n    n = {};\n  \"object\" == typeof e[0] && null !== e[0] ? n = e[0] : \"string\" == typeof e[0] && !1 === (t = e[0], (t = Number(t)) >= 0 && t) ? n.path = e[0] : (n.port = e[0], \"string\" == typeof e[1] && (n.host = e[1]));\n  var r = e[e.length - 1];\n  return \"function\" == typeof r ? [n, r] : [n];\n});\n\"_setUpListenHandle\" in h.Server.prototype ? i(h.Server.prototype, \"_setUpListenHandle\", f) : i(h.Server.prototype, \"_listen2\", f);\ni(h.Socket.prototype, \"connect\", function (e) {\n  return function () {\n    var t;\n    (t = d && Array.isArray(arguments[0]) && Object.getOwnPropertySymbols(arguments[0]).length > 0 ? arguments[0] : u ? h._normalizeArgs(arguments) : h._normalizeConnectArgs(arguments))[1] && (t[1] = a(t[1]));\n    var n = e.apply(this, t);\n    m(this);\n    return n;\n  };\n});\nvar g = require(3685);\ni(g.Agent.prototype, \"addRequest\", function (e) {\n  return function (t) {\n    var n = t.onSocket;\n    t.onSocket = a(function (e) {\n      m(e);\n      return n.apply(this, arguments);\n    });\n    return e.apply(this, arguments);\n  };\n});\nvar _ = require(2081);\nfunction y(e) {\n  Array.isArray(e.stdio) && e.stdio.forEach(function (e) {\n    e && e._handle && (e._handle.onread = a(e._handle.onread), i(e._handle, \"close\", N));\n  });\n  e._handle && (e._handle.onexit = a(e._handle.onexit));\n}\n_.ChildProcess ? i(_.ChildProcess.prototype, \"spawn\", function (e) {\n  return function () {\n    var t = e.apply(this, arguments);\n    y(this);\n    return t;\n  };\n}) : s(_, [\"execFile\", \"fork\", \"spawn\"], function (e) {\n  return function () {\n    var t = e.apply(this, arguments);\n    y(t);\n    return t;\n  };\n});\nprocess._fatalException || (process._originalNextTick = process.nextTick);\nvar v = [];\nprocess._nextDomainTick && v.push(\"_nextDomainTick\");\nprocess._tickDomainCallback && v.push(\"_tickDomainCallback\");\ns(process, v, O);\ni(process, \"nextTick\", N);\nvar b = [\"setTimeout\", \"setInterval\"];\nglobal.setImmediate && b.push(\"setImmediate\");\nvar w = require(9512),\n  x = global.setTimeout === w.setTimeout;\ns(w, b, N);\nx && s(global, b, N);\nvar E = require(9523);\ns(E, [\"lookup\", \"resolve\", \"resolve4\", \"resolve6\", \"resolveCname\", \"resolveMx\", \"resolveNs\", \"resolveTxt\", \"resolveSrv\", \"reverse\"], O);\nE.resolveNaptr && i(E, \"resolveNaptr\", O);\nvar C,\n  S,\n  T = require(7147);\ns(T, [\"watch\", \"rename\", \"truncate\", \"chown\", \"fchown\", \"chmod\", \"fchmod\", \"stat\", \"lstat\", \"fstat\", \"link\", \"symlink\", \"readlink\", \"realpath\", \"unlink\", \"rmdir\", \"mkdir\", \"readdir\", \"close\", \"open\", \"utimes\", \"futimes\", \"fsync\", \"write\", \"read\", \"readFile\", \"writeFile\", \"appendFile\", \"watchFile\", \"unwatchFile\", \"exists\"], O);\nT.lchown && i(T, \"lchown\", O);\nT.lchmod && i(T, \"lchmod\", O);\nT.ftruncate && i(T, \"ftruncate\", O);\ntry {\n  C = require(9796);\n} catch (e) {}\nif (C && C.Deflate && C.Deflate.prototype) {\n  var k = Object.getPrototypeOf(C.Deflate.prototype);\n  k._transform ? i(k, \"_transform\", O) : k.write && k.flush && k.end && s(k, [\"write\", \"flush\", \"end\"], O);\n}\ntry {\n  S = require(6113);\n} catch (e) {}\nif (S) {\n  var I = [\"pbkdf2\", \"randomBytes\"];\n  p || I.push(\"pseudoRandomBytes\");\n  s(S, I, O);\n}\nvar P = !!global.Promise && \"function Promise() { [native code] }\" === Promise.toString() && \"function toString() { [native code] }\" === Promise.toString.toString();\nif (P) {\n  var A = process.addAsyncListener({\n    create: function () {\n      P = !1;\n    }\n  });\n  global.Promise.resolve(!0).then(function () {\n    P = !1;\n  });\n  process.removeAsyncListener(A);\n}\nfunction O(e) {\n  var t = function () {\n    var t,\n      n = arguments.length - 1;\n    if (\"function\" == typeof arguments[n]) {\n      t = Array(arguments.length);\n      for (var r = 0; r < arguments.length - 1; r++) t[r] = arguments[r];\n      t[n] = a(arguments[n]);\n    }\n    return e.apply(this, t || arguments);\n  };\n  switch (e.length) {\n    case 1:\n      return function (n) {\n        return 1 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof n && (n = a(n)), e.call(this, n));\n      };\n    case 2:\n      return function (n, r) {\n        return 2 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof r && (r = a(r)), e.call(this, n, r));\n      };\n    case 3:\n      return function (n, r, o) {\n        return 3 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof o && (o = a(o)), e.call(this, n, r, o));\n      };\n    case 4:\n      return function (n, r, o, i) {\n        return 4 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof i && (i = a(i)), e.call(this, n, r, o, i));\n      };\n    case 5:\n      return function (n, r, o, i, s) {\n        return 5 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof s && (s = a(s)), e.call(this, n, r, o, i, s));\n      };\n    case 6:\n      return function (n, r, o, i, s, c) {\n        return 6 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof c && (c = a(c)), e.call(this, n, r, o, i, s, c));\n      };\n    default:\n      return t;\n  }\n}\nfunction N(e) {\n  var t = function () {\n    var t;\n    if (\"function\" == typeof arguments[0]) {\n      (t = Array(arguments.length))[0] = a(arguments[0]);\n      for (var n = 1; n < arguments.length; n++) t[n] = arguments[n];\n    }\n    return e.apply(this, t || arguments);\n  };\n  switch (e.length) {\n    case 1:\n      return function (n) {\n        return 1 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof n && (n = a(n)), e.call(this, n));\n      };\n    case 2:\n      return function (n, r) {\n        return 2 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r));\n      };\n    case 3:\n      return function (n, r, o) {\n        return 3 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r, o));\n      };\n    case 4:\n      return function (n, r, o, i) {\n        return 4 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r, o, i));\n      };\n    case 5:\n      return function (n, r, o, i, s) {\n        return 5 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r, o, i, s));\n      };\n    case 6:\n      return function (n, r, o, i, s, c) {\n        return 6 !== arguments.length ? t.apply(this, arguments) : (\"function\" == typeof n && (n = a(n)), e.call(this, n, r, o, i, s, c));\n      };\n    default:\n      return t;\n  }\n}\nP && function () {\n  var e = global.Promise;\n  function t(n) {\n    if (!(this instanceof t)) return e(n);\n    if (\"function\" != typeof n) return new e(n);\n    var o,\n      i,\n      s = new e(function (e, t) {\n        o = this;\n        i = [function (t) {\n          r(s, !1);\n          return e(t);\n        }, function (e) {\n          r(s, !1);\n          return t(e);\n        }];\n      });\n    s.__proto__ = t.prototype;\n    try {\n      n.apply(o, i);\n    } catch (e) {\n      i[1](e);\n    }\n    return s;\n  }\n  function r(e, t) {\n    e.__asl_wrapper && !t || (e.__asl_wrapper = a(o));\n  }\n  function o(t, n, i, s) {\n    var a;\n    try {\n      return {\n        returnVal: a = n.call(t, i),\n        error: !1\n      };\n    } catch (e) {\n      return {\n        errorVal: e,\n        error: !0\n      };\n    } finally {\n      a instanceof e ? s.__asl_wrapper = function () {\n        return (a.__asl_wrapper || o).apply(this, arguments);\n      } : r(s, !0);\n    }\n  }\n  function s(e) {\n    return function () {\n      var t = this,\n        n = e.apply(t, Array.prototype.map.call(arguments, r));\n      n.__asl_wrapper = function (e, r, i, s) {\n        return t.__asl_wrapper ? (t.__asl_wrapper(e, function () {}, null, n), n.__asl_wrapper(e, r, i, s)) : o(e, r, i, s);\n      };\n      return n;\n      function r(e) {\n        return \"function\" != typeof e ? e : a(function (r) {\n          var i = (t.__asl_wrapper || o)(this, e, r, n);\n          if (i.error) throw i.errorVal;\n          return i.returnVal;\n        });\n      }\n    };\n  }\n  c.inherits(t, e);\n  i(e.prototype, \"then\", s);\n  e.prototype.chain && i(e.prototype, \"chain\", s);\n  l ? global.Promise = require(8286)(e, r) : ([\"all\", \"race\", \"reject\", \"resolve\", \"accept\", \"defer\"].forEach(function (n) {\n    \"function\" == typeof e[n] && (t[n] = e[n]);\n  }), global.Promise = t);\n}();",
  "7660": "var r, o, i;\ni = require(8249);\nrequire(5109);\no = (r = i.lib.BlockCipherMode.extend()).Encryptor = r.extend({\n  processBlock: function (e, t) {\n    var n = this._cipher,\n      r = n.blockSize,\n      o = this._iv,\n      i = this._keystream;\n    o && (i = this._keystream = o.slice(0), this._iv = undefined);\n    n.encryptBlock(i, 0);\n    for (var s = 0; s < r; s++) e[t + s] ^= i[s];\n  }\n});\nr.Decryptor = o;\ni.mode.OFB = r;\nmodule.exports = i.mode.OFB;",
  "7727": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.indentationBlockFinished = exports.completionCutOrContinue = exports.contextIndentationFromText = exports.contextIndentation = exports.getNodeStart = exports.isBlockBodyFinishedWithPrefix = exports.isBlockBodyFinished = exports.isEmptyBlockStart = undefined;\nconst r = require(6403),\n  o = require(2533);\nexports.isEmptyBlockStart = function (e, t) {\n  return o.isEmptyBlockStart(e.languageId, e.getText(), e.offsetAt(t));\n};\nexports.isBlockBodyFinished = function (e, t, n, i) {\n  const s = e.get(r.LocationFactory),\n    a = t.getText(s.range(s.position(0, 0), n)),\n    c = t.offsetAt(n);\n  return o.isBlockBodyFinished(t.languageId, a, i, c);\n};\nexports.isBlockBodyFinishedWithPrefix = function (e, t, n, i, s) {\n  const a = e.get(r.LocationFactory),\n    c = t.getText(a.range(a.position(0, 0), n)),\n    l = t.offsetAt(n);\n  return o.isBlockBodyFinished(t.languageId, c + s, i, l + s.length);\n};\nexports.getNodeStart = async function (e, t, n, i) {\n  const s = e.get(r.LocationFactory),\n    a = t.getText(s.range(s.position(0, 0), n)) + i,\n    c = await o.getNodeStart(t.languageId, a, t.offsetAt(n));\n  if (c) return t.positionAt(c);\n};\nconst i = [\"\\\\{\", \"\\\\}\", \"\\\\[\", \"\\\\]\", \"\\\\(\", \"\\\\)\"].concat([\"then\", \"else\", \"elseif\", \"elif\", \"catch\", \"finally\", \"fi\", \"done\", \"end\", \"loop\", \"until\", \"where\", \"when\"].map(e => e + \"\\\\b\")),\n  s = new RegExp(`^(${i.join(\"|\")})`);\nfunction a(e) {\n  return s.test(e.trimLeft().toLowerCase());\n}\nfunction c(e) {\n  const t = /^(\\s*)([^]*)$/.exec(e);\n  return t && t[2] && t[2].length > 0 ? t[1].length : undefined;\n}\nfunction contextIndentationFromText(e, t, n) {\n  const r = e.slice(0, t).split(\"\\n\"),\n    o = e.slice(t).split(\"\\n\");\n  function i(e, t, r) {\n    let o,\n      i,\n      s = t;\n    for (; undefined === o && s >= 0 && s < e.length;) {\n      o = c(e[s]);\n      i = s;\n      s += r;\n    }\n    if (\"python\" === n && -1 === r) {\n      s++;\n      const t = e[s].trim();\n      if (t.endsWith('\"\"\"')) {\n        if (!t.startsWith('\"\"\"') || '\"\"\"' === t) for (s--; s >= 0 && !e[s].trim().startsWith('\"\"\"');) s--;\n        if (s >= 0) for (o = undefined, s--; undefined === o && s >= 0;) {\n          o = c(e[s]);\n          i = s;\n          s--;\n        }\n      }\n    }\n    return [o, i];\n  }\n  const [s, a] = i(r, r.length - 1, -1),\n    l = (() => {\n      if (undefined !== s && undefined !== a) for (let e = a - 1; e >= 0; e--) {\n        const t = c(r[e]);\n        if (undefined !== t && t < s) return t;\n      }\n    })(),\n    [u] = i(o, 1, 1);\n  return {\n    prev: l,\n    current: null != s ? s : 0,\n    next: u\n  };\n}\nfunction completionCutOrContinue(e, t, n) {\n  var r;\n  const o = e.split(\"\\n\"),\n    i = undefined !== n,\n    s = null == n ? undefined : n.split(\"\\n\").pop();\n  let l = 0;\n  i && \"\" != (null == s ? undefined : s.trim()) && \"\" !== o[0].trim() && l++;\n  i || l++;\n  if (o.length === l) return \"continue\";\n  const u = Math.max(t.current, null !== (r = t.next) && undefined !== r ? r : 0);\n  for (let e = l; e < o.length; e++) {\n    let t = o[e];\n    0 == e && undefined !== s && (t = s + t);\n    const n = c(t);\n    if (undefined !== n && (n < u || n === u && !a(t))) return o.slice(0, e).join(\"\\n\").length;\n  }\n  return \"continue\";\n}\nexports.contextIndentation = function (e, t) {\n  return contextIndentationFromText(e.getText(), e.offsetAt(t), e.languageId);\n};\nexports.contextIndentationFromText = contextIndentationFromText;\nexports.completionCutOrContinue = completionCutOrContinue;\nexports.indentationBlockFinished = function (e, t) {\n  return async n => {\n    const r = completionCutOrContinue(n, e, t);\n    return \"continue\" === r ? undefined : r;\n  };\n};",
  "7744": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.contextualFilterCharacterMap = exports.contextualFilterLanguageMap = exports.contextualFilterWeights = exports.contextualFilterIntercept = exports.contextualFilterAcceptThreshold = undefined;\nexports.contextualFilterAcceptThreshold = 15;\nexports.contextualFilterIntercept = -.3043572714994554;\nexports.contextualFilterWeights = [.9978708359643611, .7001905605239328, -.1736749244124868, -.22994157947320112, .13406692641682572, -.007751370662011853, .0057783222035240715, .41910878254476003, -.1621657125711092, .13770814958908187, -.06036011308184006, -.07351180985800129, 0, -.05584878151248109, .30618794079412015, -.1282197982598485, .10951859303997555, .1700461782788777, -.3346057842644757, .22497985923128136, 0, -.44038101825774356, -.6540115939236782, .16595600081341702, .20733910722385135, -.1337033766105696, -.06923072125290894, -.05806684191976292, .3583334671633344, -.47357732824944315, .17810871365594377, .42268219963946685, 0, 0, -.16379620467004602, -.43893868831061167, 0, .11570094006709251, .9326431262654882, -.9990110509203912, -.44125275652726503, -.15840786997162004, -.4600396256644451, -.018814811994044403, .09230944537175266, .025814790934742798, -1.0940162204190154, -.9407503631235489, -.9854303778694269, -1.1045822488262245, -1.1417299456573262, -1.5623704405345513, -.4157473855795939, -1.0244257735561713, -.7477401944601753, -1.1275109699068402, -.0714715633552533, -1.1408628006786907, -1.0409898655074672, -.2288889836518878, -.5469549893760344, -.181946611106845, .1264329316374918, 0, 0, .312206968554707, -.3656436392517924, .23655650686038968, .1014912419901576, 0, .06287549221765308, 0, 0, .19027065218932154, -.8519502045974378, 0, .23753599905971923, .2488809322489166, .019969251907983224, 0, .06916505526229488, .29053356359188204, -.14484456555431657, .014768129429370188, -.15051464926341374, .07614835502776021, -.3317489901313935, 0, 0, .04921938684669103, -.28248576768353445, -.9708816204525345, -1.3560464522265527, .014165375212383239, -.23924166472544983, .10006595730248855, .09867233147279562, .32330430333220644, -.058625706114180595, .17149853105783947, .4436484054395367, .047189049576707255, .16832520944790552, .1117259900942179, -.35469010329927253, 0, -.1528189124465582, -.3804848349564939, .07278077320753953, .13263786480064088, .22920682659292527, 1.1512955314336537, 0, .016939862282340023, .4242994650403408, .12759835577444986, -.5577261135825583, -.19764560943067672, -.4042102444736004, .12063461617733708, -.2933966817484834, .2715683893968593, 0, -.7138548251238751, 0, -.023066228703035277, 0, -.06383043976746139, .09683723720709651, -.7337151424080791, 0, -.27191370124625525, .2819781269656171, -.08711496549050252, .11048604909969338, -.0934849550450534, .0721001250772912, .2589126797890794, .6729582659532254, -.21921032738244908, -.21535277468651456, -.45474006124091354, -.05861820126419139, -.007875306207720204, -.056661261678809284, .17727881404222662, .23603713348534658, .17485861412377932, -.5737483768696752, -.38220029570342745, -.5202722985519168, -.37187947527657256, .47155277792990113, -.12077912346691123, .47825628981545326, .4736704404000214, -.1615218651546898, .18362447973513005, 0, 0, -.18183417425866824, 0, 0, -.2538532305733833, -.1303692690676528, -.4073577969188216, .04172985870928789, -.1704527388573901, 0, 0, .7536858953385828, -.44703159588787644, 0, -.7246484085580873, -.21378128540782063, 0, .037461090552656146, -.16205852364367032, -.10973952064404884, .017468043407647377, -.1288980387397392, 0, 0, 0, -1.218692715379445, .05536949662193305, -.3763799844799116, -.1845001725624579, -.1615576298149558, 0, -.15373262203249874, -.04603412604270418, 0, -.3068149681460828, .09412352468269412, 0, .09116543650609721, .06065865264082559, .05688267379386188, -.05873945477722306, 0, .14532465133322153, .1870857769705463, .36304258043185555, .1411392422180405, .0630388629716367, 0, -1.1170522012450395, .16133697772771127, .15908534390781448, -.23485453704002232, -.1419980841417892, .21909510179526218, .39948420260153766, .40802294284289187, .15403767653746853, 0, .19764784115096676, .584914157527457, 0, -.4573883817015294];\nexports.contextualFilterLanguageMap = {\n  javascript: 1,\n  typescript: 2,\n  typescriptreact: 3,\n  python: 4,\n  vue: 5,\n  php: 6,\n  dart: 7,\n  javascriptreact: 8,\n  go: 9,\n  css: 10,\n  cpp: 11,\n  html: 12,\n  scss: 13,\n  markdown: 14,\n  csharp: 15,\n  java: 16,\n  json: 17,\n  rust: 18,\n  ruby: 19,\n  c: 20\n};\nexports.contextualFilterCharacterMap = {\n  \" \": 1,\n  \"!\": 2,\n  '\"': 3,\n  \"#\": 4,\n  $: 5,\n  \"%\": 6,\n  \"&\": 7,\n  \"'\": 8,\n  \"(\": 9,\n  \")\": 10,\n  \"*\": 11,\n  \"+\": 12,\n  \",\": 13,\n  \"-\": 14,\n  \".\": 15,\n  \"/\": 16,\n  0: 17,\n  1: 18,\n  2: 19,\n  3: 20,\n  4: 21,\n  5: 22,\n  6: 23,\n  7: 24,\n  8: 25,\n  9: 26,\n  \":\": 27,\n  \";\": 28,\n  \"<\": 29,\n  \"=\": 30,\n  \">\": 31,\n  \"?\": 32,\n  \"@\": 33,\n  A: 34,\n  B: 35,\n  C: 36,\n  D: 37,\n  E: 38,\n  F: 39,\n  G: 40,\n  H: 41,\n  I: 42,\n  J: 43,\n  K: 44,\n  L: 45,\n  M: 46,\n  N: 47,\n  O: 48,\n  P: 49,\n  Q: 50,\n  R: 51,\n  S: 52,\n  T: 53,\n  U: 54,\n  V: 55,\n  W: 56,\n  X: 57,\n  Y: 58,\n  Z: 59,\n  \"[\": 60,\n  \"\\\\\": 61,\n  \"]\": 62,\n  \"^\": 63,\n  _: 64,\n  \"`\": 65,\n  a: 66,\n  b: 67,\n  c: 68,\n  d: 69,\n  e: 70,\n  f: 71,\n  g: 72,\n  h: 73,\n  i: 74,\n  j: 75,\n  k: 76,\n  l: 77,\n  m: 78,\n  n: 79,\n  o: 80,\n  p: 81,\n  q: 82,\n  r: 83,\n  s: 84,\n  t: 85,\n  u: 86,\n  v: 87,\n  w: 88,\n  x: 89,\n  y: 90,\n  z: 91,\n  \"{\": 92,\n  \"|\": 93,\n  \"}\": 94,\n  \"~\": 95\n};",
  "7772": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = undefined;\nconst r = require(3487),\n  o = require(6776),\n  i = require(412);\nexports.error = {\n  message: ({\n    params: {\n      property: e,\n      depsCount: t,\n      deps: n\n    }\n  }) => {\n    const o = 1 === t ? \"property\" : \"properties\";\n    return r.str`must have ${o} ${n} when property ${e} is present`;\n  },\n  params: ({\n    params: {\n      property: e,\n      depsCount: t,\n      deps: n,\n      missingProperty: o\n    }\n  }) => r._`{property: ${e},\n    missingProperty: ${o},\n    depsCount: ${t},\n    deps: ${n}}`\n};\nconst s = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: exports.error,\n  code(e) {\n    const [t, n] = function ({\n      schema: e\n    }) {\n      const t = {},\n        n = {};\n      for (const r in e) \"__proto__\" !== r && ((Array.isArray(e[r]) ? t : n)[r] = e[r]);\n      return [t, n];\n    }(e);\n    validatePropertyDeps(e, t);\n    validateSchemaDeps(e, n);\n  }\n};\nfunction validatePropertyDeps(e, t = e.schema) {\n  const {\n    gen: n,\n    data: o,\n    it: s\n  } = e;\n  if (0 === Object.keys(t).length) return;\n  const a = n.let(\"missing\");\n  for (const c in t) {\n    const l = t[c];\n    if (0 === l.length) continue;\n    const u = i.propertyInData(n, o, c, s.opts.ownProperties);\n    e.setParams({\n      property: c,\n      depsCount: l.length,\n      deps: l.join(\", \")\n    });\n    s.allErrors ? n.if(u, () => {\n      for (const t of l) i.checkReportMissingProp(e, t);\n    }) : (n.if(r._`${u} && (${i.checkMissingProp(e, l, a)})`), i.reportMissingProp(e, a), n.else());\n  }\n}\nfunction validateSchemaDeps(e, t = e.schema) {\n  const {\n      gen: n,\n      data: r,\n      keyword: s,\n      it: a\n    } = e,\n    c = n.name(\"valid\");\n  for (const l in t) o.alwaysValidSchema(a, t[l]) || (n.if(i.propertyInData(n, r, l, a.opts.ownProperties), () => {\n    const t = e.subschema({\n      keyword: s,\n      schemaProp: l\n    }, c);\n    e.mergeValidEvaluated(t, c);\n  }, () => n.var(c, !0)), e.ok(c));\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = s;",
  "7792": "var r, o, i, s, a, c;\nc = require(8249);\nrequire(2153);\no = (r = c).lib.WordArray;\ni = r.algo;\ns = i.SHA256;\na = i.SHA224 = s.extend({\n  _doReset: function () {\n    this._hash = new o.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);\n  },\n  _doFinalize: function () {\n    var e = s._doFinalize.call(this);\n    e.sigBytes -= 4;\n    return e;\n  }\n});\nr.SHA224 = s._createHelper(a);\nr.HmacSHA224 = s._createHmacHelper(a);\nmodule.exports = c.SHA224;",
  "7824": "var t = 1e3,\n  n = 60 * t,\n  r = 60 * n,\n  o = 24 * r;\nfunction i(e, t, n, r) {\n  var o = t >= 1.5 * n;\n  return Math.round(e / n) + \" \" + r + (o ? \"s\" : \"\");\n}\nmodule.exports = function (e, s) {\n  s = s || {};\n  var a,\n    c,\n    l = typeof e;\n  if (\"string\" === l && e.length > 0) return function (e) {\n    if (!((e = String(e)).length > 100)) {\n      var i = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);\n      if (i) {\n        var s = parseFloat(i[1]);\n        switch ((i[2] || \"ms\").toLowerCase()) {\n          case \"years\":\n          case \"year\":\n          case \"yrs\":\n          case \"yr\":\n          case \"y\":\n            return 315576e5 * s;\n          case \"weeks\":\n          case \"week\":\n          case \"w\":\n            return 6048e5 * s;\n          case \"days\":\n          case \"day\":\n          case \"d\":\n            return s * o;\n          case \"hours\":\n          case \"hour\":\n          case \"hrs\":\n          case \"hr\":\n          case \"h\":\n            return s * r;\n          case \"minutes\":\n          case \"minute\":\n          case \"mins\":\n          case \"min\":\n          case \"m\":\n            return s * n;\n          case \"seconds\":\n          case \"second\":\n          case \"secs\":\n          case \"sec\":\n          case \"s\":\n            return s * t;\n          case \"milliseconds\":\n          case \"millisecond\":\n          case \"msecs\":\n          case \"msec\":\n          case \"ms\":\n            return s;\n          default:\n            return;\n        }\n      }\n    }\n  }(e);\n  if (\"number\" === l && isFinite(e)) return s.long ? (a = e, (c = Math.abs(a)) >= o ? i(a, c, o, \"day\") : c >= r ? i(a, c, r, \"hour\") : c >= n ? i(a, c, n, \"minute\") : c >= t ? i(a, c, t, \"second\") : a + \" ms\") : function (e) {\n    var i = Math.abs(e);\n    return i >= o ? Math.round(e / o) + \"d\" : i >= r ? Math.round(e / r) + \"h\" : i >= n ? Math.round(e / n) + \"m\" : i >= t ? Math.round(e / t) + \"s\" : e + \"ms\";\n  }(e);\n  throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(e));\n};",
  "7870": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.Context = undefined;\nexports.Context = class {\n  constructor(e) {\n    var t;\n    this.baseContext = e;\n    this.constructionStack = [];\n    this.instances = new Map();\n    const n = null === (t = new Error().stack) || undefined === t ? undefined : t.split(\"\\n\");\n    n && this.constructionStack.push(...n.slice(1));\n  }\n  get(e) {\n    const t = this.tryGet(e);\n    if (t) return t;\n    throw new Error(`No instance of ${e.name} has been registered.\\n${this}`);\n  }\n  tryGet(e) {\n    return this.instances.get(e) || (this.baseContext ? this.baseContext.tryGet(e) : undefined);\n  }\n  set(e, t) {\n    if (this.tryGet(e)) throw new Error(`An instance of ${e.name} has already been registered. Use forceSet() if you're sure it's a good idea.`);\n    this.instances.set(e, t);\n  }\n  forceSet(e, t) {\n    this.instances.set(e, t);\n  }\n  toString() {\n    var e, t;\n    let n = \"    Context created at:\\n\";\n    for (const e of this.constructionStack || []) n += `    ${e}\\n`;\n    n += null !== (t = null === (e = this.baseContext) || undefined === e ? undefined : e.toString()) && undefined !== t ? t : \"\";\n    return n;\n  }\n  get debug() {\n    const e = {};\n    for (const [t, n] of this.instances) e[t.name] = n;\n    return e;\n  }\n};",
  "7886": "var r = require(4953),\n  o = [];\nexports.qP = function (e) {\n  e.data.event.commandName;\n  o.forEach(function (t) {\n    var n = e.data.startedData && e.data.startedData.databaseName || \"Unknown database\";\n    t.trackDependency({\n      target: n,\n      data: e.data.event.commandName,\n      name: e.data.event.commandName,\n      duration: e.data.event.duration,\n      success: e.data.succeeded,\n      resultCode: e.data.succeeded ? \"0\" : \"1\",\n      dependencyTypeName: \"mongodb\"\n    });\n  });\n};\nexports.wp = function (e, n) {\n  e ? (0 === o.length && r.channel.subscribe(\"mongodb\", exports.qP), o.push(n)) : 0 === (o = o.filter(function (e) {\n    return e != n;\n  })).length && r.channel.unsubscribe(\"mongodb\", exports.qP);\n};",
  "7898": "var r = require(465);\nfunction o() {\n  this.extend = new a();\n  this.filter = new a();\n  this.format = new c();\n  this.version = require(2301).i8;\n}\nvar i = !1;\no.prototype.callSite = function e(t) {\n  t || (t = {});\n  i = !0;\n  var n = {};\n  Error.captureStackTrace(n, e);\n  var r = n.stack;\n  i = !1;\n  r = r.slice(t.slice || 0);\n  t.extend && (r = this.extend._modify(n, r));\n  t.filter && (r = this.filter._modify(n, r));\n  return r;\n};\nvar s = new o();\nfunction a() {\n  this._modifiers = [];\n}\nfunction c() {\n  this._formater = r;\n  this._previous = undefined;\n}\na.prototype._modify = function (e, t) {\n  for (var n = 0, r = this._modifiers.length; n < r; n++) t = this._modifiers[n](e, t);\n  return t;\n};\na.prototype.attach = function (e) {\n  this._modifiers.push(e);\n};\na.prototype.deattach = function (e) {\n  var t = this._modifiers.indexOf(e);\n  return -1 !== t && (this._modifiers.splice(t, 1), !0);\n};\nc.prototype.replace = function (e) {\n  e ? this._formater = e : this.restore();\n};\nc.prototype.restore = function () {\n  this._formater = r;\n  this._previous = undefined;\n};\nc.prototype._backup = function () {\n  this._previous = this._formater;\n};\nc.prototype._roolback = function () {\n  this._previous === r ? this.replace(undefined) : this.replace(this._previous);\n  this._previous = undefined;\n};\nError.prepareStackTrace && s.format.replace(Error.prepareStackTrace);\nvar l = !1;\nfunction u(e, t) {\n  if (i) return t;\n  if (l) return r(e, t);\n  var n = t.concat();\n  n = s.extend._modify(e, n);\n  n = (n = s.filter._modify(e, n)).slice(0, Error.stackTraceLimit);\n  Object.isExtensible(e) && undefined === Object.getOwnPropertyDescriptor(e, \"callSite\") && (e.callSite = {\n    original: t,\n    mutated: n\n  });\n  l = !0;\n  var o = s.format._formater(e, n);\n  l = !1;\n  return o;\n}\nObject.defineProperty(Error, \"prepareStackTrace\", {\n  get: function () {\n    return u;\n  },\n  set: function (e) {\n    e === u ? s.format._roolback() : (s.format._backup(), s.format.replace(e));\n  }\n});\nObject.defineProperty(Error.prototype, \"callSite\", {\n  get: function () {\n    this.stack;\n    return this.callSite;\n  },\n  set: function (e) {\n    Object.defineProperty(this, \"callSite\", {\n      value: e,\n      writable: !0,\n      configurable: !0\n    });\n  },\n  configurable: !0\n});\nmodule.exports = s;",
  "7923": "var n = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\nexports.encode = function (e) {\n  if (0 <= e && e < n.length) return n[e];\n  throw new TypeError(\"Must be between 0 and 63: \" + e);\n};\nexports.decode = function (e) {\n  return 65 <= e && e <= 90 ? e - 65 : 97 <= e && e <= 122 ? e - 97 + 26 : 48 <= e && e <= 57 ? e - 48 + 52 : 43 == e ? 62 : 47 == e ? 63 : -1;\n};",
  "8002": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(4953),\n  o = require(1017);\nexports.mysql = {\n  versionSpecifier: \">= 2.0.0 < 3.0.0\",\n  patch: function (e, t) {\n    var i = function (e, t) {\n        return function (t, n) {\n          var o = e[t];\n          o && (e[t] = function () {\n            for (var e = arguments.length - 1, t = arguments.length - 1; t >= 0; --t) {\n              if (\"function\" == typeof arguments[t]) {\n                e = t;\n                break;\n              }\n              if (undefined !== arguments[t]) break;\n            }\n            var i = arguments[e],\n              s = {\n                result: null,\n                startTime: null,\n                startDate: null\n              };\n            \"function\" == typeof i && (n ? (s.startTime = process.hrtime(), s.startDate = new Date(), arguments[e] = r.channel.bindToContext(n(s, i))) : arguments[e] = r.channel.bindToContext(i));\n            var a = o.apply(this, arguments);\n            s.result = a;\n            return a;\n          });\n        };\n      },\n      s = function (e, t) {\n        return i(e.prototype);\n      },\n      a = require(4694)(o.dirname(t) + \"/lib/Connection\");\n    [\"connect\", \"changeUser\", \"ping\", \"statistics\", \"end\"].forEach(function (e) {\n      return s(a)(e);\n    });\n    i(a)(\"createQuery\", function (e, t) {\n      return function (n) {\n        var o = process.hrtime(e.startTime),\n          i = 1e3 * o[0] + o[1] / 1e6 | 0;\n        r.channel.publish(\"mysql\", {\n          query: e.result,\n          callbackArgs: arguments,\n          err: n,\n          duration: i,\n          time: e.startDate\n        });\n        t.apply(this, arguments);\n      };\n    });\n    var c = require(420)(o.dirname(t) + \"/lib/Pool\");\n    [\"_enqueueCallback\"].forEach(function (e) {\n      return s(c)(e);\n    });\n    return e;\n  }\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"mysql\", exports.mysql);\n};",
  "8028": "module.exports = require(\"@opentelemetry/tracing\");",
  "8060": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(4953),\n  o = require(2361);\nexports.postgres6 = {\n  versionSpecifier: \"6.*\",\n  patch: function (e, t) {\n    var n = e.Client.prototype.query,\n      i = \"__diagnosticOriginalFunc\";\n    e.Client.prototype.query = function (e, t, s) {\n      var a,\n        c = {\n          query: {},\n          database: {\n            host: this.connectionParameters.host,\n            port: this.connectionParameters.port\n          },\n          result: null,\n          error: null,\n          duration: 0,\n          time: new Date()\n        },\n        l = process.hrtime();\n      function u(e) {\n        e && e[i] && (e = e[i]);\n        var t = r.channel.bindToContext(function (t, n) {\n          var i = process.hrtime(l);\n          c.result = n && {\n            rowCount: n.rowCount,\n            command: n.command\n          };\n          c.error = t;\n          c.duration = Math.ceil(1e3 * i[0] + i[1] / 1e6);\n          r.channel.publish(\"postgres\", c);\n          if (t) {\n            if (e) return e.apply(this, arguments);\n            a && a instanceof o.EventEmitter && a.emit(\"error\", t);\n          } else e && e.apply(this, arguments);\n        });\n        try {\n          Object.defineProperty(t, i, {\n            value: e\n          });\n          return t;\n        } catch (t) {\n          return e;\n        }\n      }\n      try {\n        \"string\" == typeof e ? t instanceof Array ? (c.query.preparable = {\n          text: e,\n          args: t\n        }, s = u(s)) : (c.query.text = e, s ? s = u(s) : t = u(t)) : (\"string\" == typeof e.name ? c.query.plan = e.name : e.values instanceof Array ? c.query.preparable = {\n          text: e.text,\n          args: e.values\n        } : c.query.text = e.text, s ? s = u(s) : t ? t = u(t) : e.callback = u(e.callback));\n      } catch (e) {\n        return n.apply(this, arguments);\n      }\n      arguments[0] = e;\n      arguments[1] = t;\n      arguments[2] = s;\n      arguments.length = arguments.length > 3 ? arguments.length : 3;\n      return a = n.apply(this, arguments);\n    };\n    return e;\n  }\n};\nexports.postgres7 = {\n  versionSpecifier: \">=7.* <=8.*\",\n  patch: function (e, t) {\n    var n = e.Client.prototype.query,\n      i = \"__diagnosticOriginalFunc\";\n    e.Client.prototype.query = function (e, t, s) {\n      var a,\n        c = this,\n        l = !!s,\n        u = {\n          query: {},\n          database: {\n            host: this.connectionParameters.host,\n            port: this.connectionParameters.port\n          },\n          result: null,\n          error: null,\n          duration: 0,\n          time: new Date()\n        },\n        d = process.hrtime();\n      function p(e) {\n        e && e[i] && (e = e[i]);\n        var t = r.channel.bindToContext(function (t, n) {\n          var i = process.hrtime(d);\n          u.result = n && {\n            rowCount: n.rowCount,\n            command: n.command\n          };\n          u.error = t;\n          u.duration = Math.ceil(1e3 * i[0] + i[1] / 1e6);\n          r.channel.publish(\"postgres\", u);\n          if (t) {\n            if (e) return e.apply(this, arguments);\n            a && a instanceof o.EventEmitter && a.emit(\"error\", t);\n          } else e && e.apply(this, arguments);\n        });\n        try {\n          Object.defineProperty(t, i, {\n            value: e\n          });\n          return t;\n        } catch (t) {\n          return e;\n        }\n      }\n      try {\n        \"string\" == typeof e ? t instanceof Array ? (u.query.preparable = {\n          text: e,\n          args: t\n        }, s = (l = \"function\" == typeof s) ? p(s) : s) : (u.query.text = e, s ? s = (l = \"function\" == typeof s) ? p(s) : s : t = (l = \"function\" == typeof t) ? p(t) : t) : (\"string\" == typeof e.name ? u.query.plan = e.name : e.values instanceof Array ? u.query.preparable = {\n          text: e.text,\n          args: e.values\n        } : u.query.text = e.text, s ? (l = \"function\" == typeof s, s = p(s)) : t ? t = (l = \"function\" == typeof t) ? p(t) : t : (l = \"function\" == typeof e.callback, e.callback = l ? p(e.callback) : e.callback));\n      } catch (e) {\n        return n.apply(this, arguments);\n      }\n      arguments[0] = e;\n      arguments[1] = t;\n      arguments[2] = s;\n      arguments.length = arguments.length > 3 ? arguments.length : 3;\n      a = n.apply(this, arguments);\n      return l ? a : a.then(function (e) {\n        p()(undefined, e);\n        return new c._Promise(function (t, n) {\n          t(e);\n        });\n      }).catch(function (e) {\n        p()(e, undefined);\n        return new c._Promise(function (t, n) {\n          n(e);\n        });\n      });\n    };\n    return e;\n  }\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"pg\", exports.postgres6);\n  r.channel.registerMonkeyPatch(\"pg\", exports.postgres7);\n};",
  "8082": "module.exports = function () {\n  this.hasFullStack = !0;\n  this.parsedStack = [];\n};",
  "8090": "var r = require(5740),\n  o = require(9962),\n  i = function () {\n    function e(t, n) {\n      this.traceFlag = e.DEFAULT_TRACE_FLAG;\n      this.version = e.DEFAULT_VERSION;\n      if (t && \"string\" == typeof t) {\n        if (t.split(\",\").length > 1) this.traceId = r.w3cTraceId(), this.spanId = r.w3cTraceId().substr(0, 16);else {\n          var i = t.trim().split(\"-\"),\n            s = i.length;\n          s >= 4 ? (this.version = i[0], this.traceId = i[1], this.spanId = i[2], this.traceFlag = i[3]) : (this.traceId = r.w3cTraceId(), this.spanId = r.w3cTraceId().substr(0, 16)), this.version.match(/^[0-9a-f]{2}$/g) || (this.version = e.DEFAULT_VERSION, this.traceId = r.w3cTraceId()), \"00\" === this.version && 4 !== s && (this.traceId = r.w3cTraceId(), this.spanId = r.w3cTraceId().substr(0, 16)), \"ff\" === this.version && (this.version = e.DEFAULT_VERSION, this.traceId = r.w3cTraceId(), this.spanId = r.w3cTraceId().substr(0, 16)), this.version.match(/^0[0-9a-f]$/g) || (this.version = e.DEFAULT_VERSION), this.traceFlag.match(/^[0-9a-f]{2}$/g) || (this.traceFlag = e.DEFAULT_TRACE_FLAG, this.traceId = r.w3cTraceId()), e.isValidTraceId(this.traceId) || (this.traceId = r.w3cTraceId()), e.isValidSpanId(this.spanId) || (this.spanId = r.w3cTraceId().substr(0, 16), this.traceId = r.w3cTraceId()), this.parentId = this.getBackCompatRequestId();\n        }\n      } else if (n) {\n        this.parentId = n.slice();\n        var a = o.getRootId(n);\n        e.isValidTraceId(a) || (this.legacyRootId = a, a = r.w3cTraceId()), -1 !== n.indexOf(\"|\") && (n = n.substring(1 + n.substring(0, n.length - 1).lastIndexOf(\".\"), n.length - 1)), this.traceId = a, this.spanId = n;\n      } else this.traceId = r.w3cTraceId(), this.spanId = r.w3cTraceId().substr(0, 16);\n    }\n    e.isValidTraceId = function (e) {\n      return e.match(/^[0-9a-f]{32}$/) && \"00000000000000000000000000000000\" !== e;\n    };\n    e.isValidSpanId = function (e) {\n      return e.match(/^[0-9a-f]{16}$/) && \"0000000000000000\" !== e;\n    };\n    e.prototype.getBackCompatRequestId = function () {\n      return \"|\" + this.traceId + \".\" + this.spanId + \".\";\n    };\n    e.prototype.toString = function () {\n      return this.version + \"-\" + this.traceId + \"-\" + this.spanId + \"-\" + this.traceFlag;\n    };\n    e.prototype.updateSpanId = function () {\n      this.spanId = r.w3cTraceId().substr(0, 16);\n    };\n    e.DEFAULT_TRACE_FLAG = \"01\";\n    e.DEFAULT_VERSION = \"00\";\n    return e;\n  }();\nmodule.exports = i;",
  "8104": "\"undefined\" == typeof process || \"renderer\" === process.type || !0 === process.browser || process.__nwjs ? module.exports = require(1758) : module.exports = require(39);",
  "8129": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ExtensionLocationFactory = undefined;\nconst r = require(9496),\n  o = require(6403);\nclass ExtensionLocationFactory extends o.LocationFactory {\n  range(e, t, n, o) {\n    return undefined !== n && undefined !== o ? new r.Range(e, t, n, o) : new r.Range(e, t);\n  }\n  position(e, t) {\n    return new r.Position(e, t);\n  }\n}\nexports.ExtensionLocationFactory = ExtensionLocationFactory;",
  "8142": "var n, r;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.FilterSettings = exports.telmetryNames = exports.TargetPopulation = exports.Filter = undefined;\n(function (e) {\n  e.Market = \"X-MSEdge-Market\";\n  e.CorpNet = \"X-FD-Corpnet\";\n  e.ApplicationVersion = \"X-VSCode-AppVersion\";\n  e.Build = \"X-VSCode-Build\";\n  e.ClientId = \"X-MSEdge-ClientId\";\n  e.ExtensionName = \"X-VSCode-ExtensionName\";\n  e.ExtensionVersion = \"X-VSCode-ExtensionVersion\";\n  e.Language = \"X-VSCode-Language\";\n  e.TargetPopulation = \"X-VSCode-TargetPopulation\";\n  e.CopilotClientTimeBucket = \"X-Copilot-ClientTimeBucket\";\n  e.CopilotOverrideEngine = \"X-Copilot-OverrideEngine\";\n  e.CopilotRepository = \"X-Copilot-Repository\";\n  e.CopilotFileType = \"X-Copilot-FileType\";\n  e.CopilotUserKind = \"X-Copilot-UserKind\";\n  e.CopilotDogfood = \"X-Copilot-Dogfood\";\n})(n = exports.Filter || (exports.Filter = {}));\n(r = exports.TargetPopulation || (exports.TargetPopulation = {})).Team = \"team\";\nr.Internal = \"internal\";\nr.Insiders = \"insider\";\nr.Public = \"public\";\nexports.telmetryNames = {\n  [n.CopilotClientTimeBucket]: \"timeBucket\",\n  [n.CopilotOverrideEngine]: \"engine\",\n  [n.CopilotRepository]: \"repo\",\n  [n.CopilotFileType]: \"fileType\",\n  [n.CopilotUserKind]: \"userKind\"\n};\nclass FilterSettings {\n  constructor(e) {\n    this.filters = e;\n    for (const [e, t] of Object.entries(this.filters)) \"\" === t && delete this.filters[e];\n  }\n  extends(e) {\n    for (const [t, n] of Object.entries(e.filters)) if (this.filters[t] !== n) return !1;\n    return !0;\n  }\n  addToTelemetry(e) {\n    for (const [n, r] of Object.entries(this.filters)) {\n      const o = exports.telmetryNames[n];\n      undefined !== o && (e.properties[o] = r);\n    }\n  }\n  stringify() {\n    const e = Object.keys(this.filters);\n    e.sort();\n    return e.map(e => `${e}:${this.filters[e]}`).join(\";\");\n  }\n  toHeaders() {\n    return {\n      ...this.filters\n    };\n  }\n  withChange(e, t) {\n    return new FilterSettings({\n      ...this.filters,\n      [e]: t\n    });\n  }\n}\nexports.FilterSettings = FilterSettings;",
  "8188": "module.exports = require(\"module\");",
  "8200": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(4783),\n  o = require(2924),\n  i = require(4665),\n  s = require(1119),\n  a = require(9864),\n  c = require(7772),\n  l = require(3708),\n  u = require(9351),\n  d = require(6239),\n  p = require(2296),\n  h = require(5697),\n  f = require(19),\n  m = require(4200),\n  g = require(1125),\n  _ = require(9434),\n  y = require(6552);\nexports.default = function (e = !1) {\n  const t = [h.default, f.default, m.default, g.default, _.default, y.default, l.default, u.default, c.default, d.default, p.default];\n  e ? t.push(o.default, s.default) : t.push(r.default, i.default);\n  t.push(a.default);\n  return t;\n};",
  "8213": "var r = require(2728),\n  o = Object.prototype.hasOwnProperty,\n  i = \"undefined\" != typeof Map;\nfunction I() {\n  this._array = [];\n  this._set = i ? new Map() : Object.create(null);\n}\nI.fromArray = function (e, t) {\n  for (var n = new I(), r = 0, o = e.length; r < o; r++) n.add(e[r], t);\n  return n;\n};\nI.prototype.size = function () {\n  return i ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\nI.prototype.add = function (e, t) {\n  var n = i ? e : r.toSetString(e),\n    s = i ? this.has(e) : o.call(this._set, n),\n    a = this._array.length;\n  s && !t || this._array.push(e);\n  s || (i ? this._set.set(e, a) : this._set[n] = a);\n};\nI.prototype.has = function (e) {\n  if (i) return this._set.has(e);\n  var t = r.toSetString(e);\n  return o.call(this._set, t);\n};\nI.prototype.indexOf = function (e) {\n  if (i) {\n    var t = this._set.get(e);\n    if (t >= 0) return t;\n  } else {\n    var n = r.toSetString(e);\n    if (o.call(this._set, n)) return this._set[n];\n  }\n  throw new Error('\"' + e + '\" is not in the set.');\n};\nI.prototype.at = function (e) {\n  if (e >= 0 && e < this._array.length) return this._array[e];\n  throw new Error(\"No element indexed by \" + e);\n};\nI.prototype.toArray = function () {\n  return this._array.slice();\n};\nexports.I = I;",
  "8214": "var r;\nr = require(8249);\n(function (e) {\n  var t = r,\n    n = t.lib,\n    o = n.WordArray,\n    i = n.Hasher,\n    s = t.algo,\n    a = [];\n  !function () {\n    for (var t = 0; t < 64; t++) a[t] = 4294967296 * e.abs(e.sin(t + 1)) | 0;\n  }();\n  var c = s.MD5 = i.extend({\n    _doReset: function () {\n      this._hash = new o.init([1732584193, 4023233417, 2562383102, 271733878]);\n    },\n    _doProcessBlock: function (e, t) {\n      for (var n = 0; n < 16; n++) {\n        var r = t + n,\n          o = e[r];\n        e[r] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8);\n      }\n      var i = this._hash.words,\n        s = e[t + 0],\n        c = e[t + 1],\n        h = e[t + 2],\n        f = e[t + 3],\n        m = e[t + 4],\n        g = e[t + 5],\n        _ = e[t + 6],\n        y = e[t + 7],\n        v = e[t + 8],\n        b = e[t + 9],\n        w = e[t + 10],\n        x = e[t + 11],\n        E = e[t + 12],\n        C = e[t + 13],\n        S = e[t + 14],\n        T = e[t + 15],\n        k = i[0],\n        I = i[1],\n        P = i[2],\n        A = i[3];\n      k = l(k, I, P, A, s, 7, a[0]);\n      A = l(A, k, I, P, c, 12, a[1]);\n      P = l(P, A, k, I, h, 17, a[2]);\n      I = l(I, P, A, k, f, 22, a[3]);\n      k = l(k, I, P, A, m, 7, a[4]);\n      A = l(A, k, I, P, g, 12, a[5]);\n      P = l(P, A, k, I, _, 17, a[6]);\n      I = l(I, P, A, k, y, 22, a[7]);\n      k = l(k, I, P, A, v, 7, a[8]);\n      A = l(A, k, I, P, b, 12, a[9]);\n      P = l(P, A, k, I, w, 17, a[10]);\n      I = l(I, P, A, k, x, 22, a[11]);\n      k = l(k, I, P, A, E, 7, a[12]);\n      A = l(A, k, I, P, C, 12, a[13]);\n      P = l(P, A, k, I, S, 17, a[14]);\n      k = u(k, I = l(I, P, A, k, T, 22, a[15]), P, A, c, 5, a[16]);\n      A = u(A, k, I, P, _, 9, a[17]);\n      P = u(P, A, k, I, x, 14, a[18]);\n      I = u(I, P, A, k, s, 20, a[19]);\n      k = u(k, I, P, A, g, 5, a[20]);\n      A = u(A, k, I, P, w, 9, a[21]);\n      P = u(P, A, k, I, T, 14, a[22]);\n      I = u(I, P, A, k, m, 20, a[23]);\n      k = u(k, I, P, A, b, 5, a[24]);\n      A = u(A, k, I, P, S, 9, a[25]);\n      P = u(P, A, k, I, f, 14, a[26]);\n      I = u(I, P, A, k, v, 20, a[27]);\n      k = u(k, I, P, A, C, 5, a[28]);\n      A = u(A, k, I, P, h, 9, a[29]);\n      P = u(P, A, k, I, y, 14, a[30]);\n      k = d(k, I = u(I, P, A, k, E, 20, a[31]), P, A, g, 4, a[32]);\n      A = d(A, k, I, P, v, 11, a[33]);\n      P = d(P, A, k, I, x, 16, a[34]);\n      I = d(I, P, A, k, S, 23, a[35]);\n      k = d(k, I, P, A, c, 4, a[36]);\n      A = d(A, k, I, P, m, 11, a[37]);\n      P = d(P, A, k, I, y, 16, a[38]);\n      I = d(I, P, A, k, w, 23, a[39]);\n      k = d(k, I, P, A, C, 4, a[40]);\n      A = d(A, k, I, P, s, 11, a[41]);\n      P = d(P, A, k, I, f, 16, a[42]);\n      I = d(I, P, A, k, _, 23, a[43]);\n      k = d(k, I, P, A, b, 4, a[44]);\n      A = d(A, k, I, P, E, 11, a[45]);\n      P = d(P, A, k, I, T, 16, a[46]);\n      k = p(k, I = d(I, P, A, k, h, 23, a[47]), P, A, s, 6, a[48]);\n      A = p(A, k, I, P, y, 10, a[49]);\n      P = p(P, A, k, I, S, 15, a[50]);\n      I = p(I, P, A, k, g, 21, a[51]);\n      k = p(k, I, P, A, E, 6, a[52]);\n      A = p(A, k, I, P, f, 10, a[53]);\n      P = p(P, A, k, I, w, 15, a[54]);\n      I = p(I, P, A, k, c, 21, a[55]);\n      k = p(k, I, P, A, v, 6, a[56]);\n      A = p(A, k, I, P, T, 10, a[57]);\n      P = p(P, A, k, I, _, 15, a[58]);\n      I = p(I, P, A, k, C, 21, a[59]);\n      k = p(k, I, P, A, m, 6, a[60]);\n      A = p(A, k, I, P, x, 10, a[61]);\n      P = p(P, A, k, I, h, 15, a[62]);\n      I = p(I, P, A, k, b, 21, a[63]);\n      i[0] = i[0] + k | 0;\n      i[1] = i[1] + I | 0;\n      i[2] = i[2] + P | 0;\n      i[3] = i[3] + A | 0;\n    },\n    _doFinalize: function () {\n      var t = this._data,\n        n = t.words,\n        r = 8 * this._nDataBytes,\n        o = 8 * t.sigBytes;\n      n[o >>> 5] |= 128 << 24 - o % 32;\n      var i = e.floor(r / 4294967296),\n        s = r;\n      n[15 + (o + 64 >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8);\n      n[14 + (o + 64 >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8);\n      t.sigBytes = 4 * (n.length + 1);\n      this._process();\n      for (var a = this._hash, c = a.words, l = 0; l < 4; l++) {\n        var u = c[l];\n        c[l] = 16711935 & (u << 8 | u >>> 24) | 4278255360 & (u << 24 | u >>> 8);\n      }\n      return a;\n    },\n    clone: function () {\n      var e = i.clone.call(this);\n      e._hash = this._hash.clone();\n      return e;\n    }\n  });\n  function l(e, t, n, r, o, i, s) {\n    var a = e + (t & n | ~t & r) + o + s;\n    return (a << i | a >>> 32 - i) + t;\n  }\n  function u(e, t, n, r, o, i, s) {\n    var a = e + (t & r | n & ~r) + o + s;\n    return (a << i | a >>> 32 - i) + t;\n  }\n  function d(e, t, n, r, o, i, s) {\n    var a = e + (t ^ n ^ r) + o + s;\n    return (a << i | a >>> 32 - i) + t;\n  }\n  function p(e, t, n, r, o, i, s) {\n    var a = e + (n ^ (t | ~r)) + o + s;\n    return (a << i | a >>> 32 - i) + t;\n  }\n  t.MD5 = i._createHelper(c);\n  t.HmacMD5 = i._createHmacHelper(c);\n})(Math);\nmodule.exports = r.MD5;",
  "8249": "var r;\nr = r || function (e, t) {\n  var r;\n  \"undefined\" != typeof window && window.crypto && (r = window.crypto);\n  !r && \"undefined\" != typeof window && window.msCrypto && (r = window.msCrypto);\n  !r && \"undefined\" != typeof global && global.crypto && (r = global.crypto);\n  if (!r) try {\n    r = require(6113);\n  } catch (e) {}\n  var o = function () {\n      if (r) {\n        if (\"function\" == typeof r.getRandomValues) try {\n          return r.getRandomValues(new Uint32Array(1))[0];\n        } catch (e) {}\n        if (\"function\" == typeof r.randomBytes) try {\n          return r.randomBytes(4).readInt32LE();\n        } catch (e) {}\n      }\n      throw new Error(\"Native crypto module could not be used to get secure random number.\");\n    },\n    i = Object.create || function () {\n      function e() {}\n      return function (t) {\n        var n;\n        e.prototype = t;\n        n = new e();\n        e.prototype = null;\n        return n;\n      };\n    }(),\n    s = {},\n    a = s.lib = {},\n    c = a.Base = {\n      extend: function (e) {\n        var t = i(this);\n        e && t.mixIn(e);\n        t.hasOwnProperty(\"init\") && this.init !== t.init || (t.init = function () {\n          t.$super.init.apply(this, arguments);\n        });\n        t.init.prototype = t;\n        t.$super = this;\n        return t;\n      },\n      create: function () {\n        var e = this.extend();\n        e.init.apply(e, arguments);\n        return e;\n      },\n      init: function () {},\n      mixIn: function (e) {\n        for (var t in e) e.hasOwnProperty(t) && (this[t] = e[t]);\n        e.hasOwnProperty(\"toString\") && (this.toString = e.toString);\n      },\n      clone: function () {\n        return this.init.prototype.extend(this);\n      }\n    },\n    l = a.WordArray = c.extend({\n      init: function (e, t) {\n        e = this.words = e || [];\n        this.sigBytes = null != t ? t : 4 * e.length;\n      },\n      toString: function (e) {\n        return (e || d).stringify(this);\n      },\n      concat: function (e) {\n        var t = this.words,\n          n = e.words,\n          r = this.sigBytes,\n          o = e.sigBytes;\n        this.clamp();\n        if (r % 4) for (var i = 0; i < o; i++) {\n          var s = n[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n          t[r + i >>> 2] |= s << 24 - (r + i) % 4 * 8;\n        } else for (i = 0; i < o; i += 4) t[r + i >>> 2] = n[i >>> 2];\n        this.sigBytes += o;\n        return this;\n      },\n      clamp: function () {\n        var t = this.words,\n          n = this.sigBytes;\n        t[n >>> 2] &= 4294967295 << 32 - n % 4 * 8;\n        t.length = e.ceil(n / 4);\n      },\n      clone: function () {\n        var e = c.clone.call(this);\n        e.words = this.words.slice(0);\n        return e;\n      },\n      random: function (e) {\n        for (var t = [], n = 0; n < e; n += 4) t.push(o());\n        return new l.init(t, e);\n      }\n    }),\n    u = s.enc = {},\n    d = u.Hex = {\n      stringify: function (e) {\n        for (var t = e.words, n = e.sigBytes, r = [], o = 0; o < n; o++) {\n          var i = t[o >>> 2] >>> 24 - o % 4 * 8 & 255;\n          r.push((i >>> 4).toString(16));\n          r.push((15 & i).toString(16));\n        }\n        return r.join(\"\");\n      },\n      parse: function (e) {\n        for (var t = e.length, n = [], r = 0; r < t; r += 2) n[r >>> 3] |= parseInt(e.substr(r, 2), 16) << 24 - r % 8 * 4;\n        return new l.init(n, t / 2);\n      }\n    },\n    p = u.Latin1 = {\n      stringify: function (e) {\n        for (var t = e.words, n = e.sigBytes, r = [], o = 0; o < n; o++) {\n          var i = t[o >>> 2] >>> 24 - o % 4 * 8 & 255;\n          r.push(String.fromCharCode(i));\n        }\n        return r.join(\"\");\n      },\n      parse: function (e) {\n        for (var t = e.length, n = [], r = 0; r < t; r++) n[r >>> 2] |= (255 & e.charCodeAt(r)) << 24 - r % 4 * 8;\n        return new l.init(n, t);\n      }\n    },\n    h = u.Utf8 = {\n      stringify: function (e) {\n        try {\n          return decodeURIComponent(escape(p.stringify(e)));\n        } catch (e) {\n          throw new Error(\"Malformed UTF-8 data\");\n        }\n      },\n      parse: function (e) {\n        return p.parse(unescape(encodeURIComponent(e)));\n      }\n    },\n    f = a.BufferedBlockAlgorithm = c.extend({\n      reset: function () {\n        this._data = new l.init();\n        this._nDataBytes = 0;\n      },\n      _append: function (e) {\n        \"string\" == typeof e && (e = h.parse(e));\n        this._data.concat(e);\n        this._nDataBytes += e.sigBytes;\n      },\n      _process: function (t) {\n        var n,\n          r = this._data,\n          o = r.words,\n          i = r.sigBytes,\n          s = this.blockSize,\n          a = i / (4 * s),\n          c = (a = t ? e.ceil(a) : e.max((0 | a) - this._minBufferSize, 0)) * s,\n          u = e.min(4 * c, i);\n        if (c) {\n          for (var d = 0; d < c; d += s) this._doProcessBlock(o, d);\n          n = o.splice(0, c);\n          r.sigBytes -= u;\n        }\n        return new l.init(n, u);\n      },\n      clone: function () {\n        var e = c.clone.call(this);\n        e._data = this._data.clone();\n        return e;\n      },\n      _minBufferSize: 0\n    }),\n    m = (a.Hasher = f.extend({\n      cfg: c.extend(),\n      init: function (e) {\n        this.cfg = this.cfg.extend(e);\n        this.reset();\n      },\n      reset: function () {\n        f.reset.call(this);\n        this._doReset();\n      },\n      update: function (e) {\n        this._append(e);\n        this._process();\n        return this;\n      },\n      finalize: function (e) {\n        e && this._append(e);\n        return this._doFinalize();\n      },\n      blockSize: 16,\n      _createHelper: function (e) {\n        return function (t, n) {\n          return new e.init(n).finalize(t);\n        };\n      },\n      _createHmacHelper: function (e) {\n        return function (t, n) {\n          return new m.HMAC.init(e, n).finalize(t);\n        };\n      }\n    }), s.algo = {});\n  return s;\n}(Math);\nmodule.exports = r;",
  "8269": "var r, o, i;\nr = require(8249);\ni = (o = r).lib.WordArray;\no.enc.Base64 = {\n  stringify: function (e) {\n    var t = e.words,\n      n = e.sigBytes,\n      r = this._map;\n    e.clamp();\n    for (var o = [], i = 0; i < n; i += 3) for (var s = (t[i >>> 2] >>> 24 - i % 4 * 8 & 255) << 16 | (t[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255) << 8 | t[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255, a = 0; a < 4 && i + .75 * a < n; a++) o.push(r.charAt(s >>> 6 * (3 - a) & 63));\n    var c = r.charAt(64);\n    if (c) for (; o.length % 4;) o.push(c);\n    return o.join(\"\");\n  },\n  parse: function (e) {\n    var t = e.length,\n      n = this._map,\n      r = this._reverseMap;\n    if (!r) {\n      r = this._reverseMap = [];\n      for (var o = 0; o < n.length; o++) r[n.charCodeAt(o)] = o;\n    }\n    var s = n.charAt(64);\n    if (s) {\n      var a = e.indexOf(s);\n      -1 !== a && (t = a);\n    }\n    return function (e, t, n) {\n      for (var r = [], o = 0, s = 0; s < t; s++) if (s % 4) {\n        var a = n[e.charCodeAt(s - 1)] << s % 4 * 2 | n[e.charCodeAt(s)] >>> 6 - s % 4 * 2;\n        r[o >>> 2] |= a << 24 - o % 4 * 8;\n        o++;\n      }\n      return i.create(r, o);\n    }(e, t, r);\n  },\n  _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n};\nmodule.exports = r.enc.Base64;",
  "8280": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.callRef = exports.getValidate = undefined;\nconst r = require(6646),\n  o = require(412),\n  i = require(3487),\n  s = require(2141),\n  a = require(5173),\n  c = require(6776),\n  l = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(e) {\n      const {\n          gen: t,\n          schema: n,\n          it: o\n        } = e,\n        {\n          baseId: s,\n          schemaEnv: c,\n          validateName: l,\n          opts: p,\n          self: h\n        } = o,\n        {\n          root: f\n        } = c;\n      if ((\"#\" === n || \"#/\" === n) && s === f.baseId) return function () {\n        if (c === f) return callRef(e, l, c, c.$async);\n        const n = t.scopeValue(\"root\", {\n          ref: f\n        });\n        return callRef(e, i._`${n}.validate`, f, f.$async);\n      }();\n      const m = a.resolveRef.call(h, f, s, n);\n      if (undefined === m) throw new r.default(s, n);\n      return m instanceof a.SchemaEnv ? function (t) {\n        const n = getValidate(e, t);\n        callRef(e, n, t, t.$async);\n      }(m) : function (r) {\n        const o = t.scopeValue(\"schema\", !0 === p.code.source ? {\n            ref: r,\n            code: i.stringify(r)\n          } : {\n            ref: r\n          }),\n          s = t.name(\"valid\"),\n          a = e.subschema({\n            schema: r,\n            dataTypes: [],\n            schemaPath: i.nil,\n            topSchemaRef: o,\n            errSchemaPath: n\n          }, s);\n        e.mergeEvaluated(a);\n        e.ok(s);\n      }(m);\n    }\n  };\nfunction getValidate(e, t) {\n  const {\n    gen: n\n  } = e;\n  return t.validate ? n.scopeValue(\"validate\", {\n    ref: t.validate\n  }) : i._`${n.scopeValue(\"wrapper\", {\n    ref: t\n  })}.validate`;\n}\nfunction callRef(e, t, n, r) {\n  const {\n      gen: a,\n      it: l\n    } = e,\n    {\n      allErrors: u,\n      schemaEnv: d,\n      opts: p\n    } = l,\n    h = p.passContext ? s.default.this : i.nil;\n  function f(e) {\n    const t = i._`${e}.errors`;\n    a.assign(s.default.vErrors, i._`${s.default.vErrors} === null ? ${t} : ${s.default.vErrors}.concat(${t})`);\n    a.assign(s.default.errors, i._`${s.default.vErrors}.length`);\n  }\n  function m(e) {\n    var t;\n    if (!l.opts.unevaluated) return;\n    const r = null === (t = null == n ? undefined : n.validate) || undefined === t ? undefined : t.evaluated;\n    if (!0 !== l.props) if (r && !r.dynamicProps) undefined !== r.props && (l.props = c.mergeEvaluated.props(a, r.props, l.props));else {\n      const t = a.var(\"props\", i._`${e}.evaluated.props`);\n      l.props = c.mergeEvaluated.props(a, t, l.props, i.Name);\n    }\n    if (!0 !== l.items) if (r && !r.dynamicItems) undefined !== r.items && (l.items = c.mergeEvaluated.items(a, r.items, l.items));else {\n      const t = a.var(\"items\", i._`${e}.evaluated.items`);\n      l.items = c.mergeEvaluated.items(a, t, l.items, i.Name);\n    }\n  }\n  r ? function () {\n    if (!d.$async) throw new Error(\"async schema referenced by sync schema\");\n    const n = a.let(\"valid\");\n    a.try(() => {\n      a.code(i._`await ${o.callValidateCode(e, t, h)}`);\n      m(t);\n      u || a.assign(n, !0);\n    }, e => {\n      a.if(i._`!(${e} instanceof ${l.ValidationError})`, () => a.throw(e));\n      f(e);\n      u || a.assign(n, !1);\n    });\n    e.ok(n);\n  }() : e.result(o.callValidateCode(e, t, h), () => m(t), () => f(t));\n}\nexports.getValidate = getValidate;\nexports.callRef = callRef;\nexports.default = l;",
  "8286": "module.exports = (e, t) => class extends e {\n  constructor(e) {\n    var n, r;\n    super(function (e, i) {\n      n = this;\n      r = [function (n) {\n        t(o, !1);\n        return e(n);\n      }, function (e) {\n        t(o, !1);\n        return i(e);\n      }];\n    });\n    var o = this;\n    try {\n      e.apply(n, r);\n    } catch (e) {\n      r[1](e);\n    }\n    return o;\n  }\n};",
  "8318": "const r = require(1017),\n  o = require(2081),\n  {\n    promises: i,\n    constants: s\n  } = require(7147),\n  a = require(2818),\n  c = require(1595),\n  l = require(1906),\n  u = r.join(__dirname, \"xdg-open\"),\n  {\n    platform: d,\n    arch: p\n  } = process,\n  h = (() => {\n    const e = \"/mnt/\";\n    let t;\n    return async function () {\n      if (t) return t;\n      const n = \"/etc/wsl.conf\";\n      let r = !1;\n      try {\n        await i.access(n, s.F_OK);\n        r = !0;\n      } catch {}\n      if (!r) return e;\n      const o = await i.readFile(n, {\n          encoding: \"utf8\"\n        }),\n        a = /(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)/g.exec(o);\n      return a ? (t = a.groups.mountPoint.trim(), t = t.endsWith(\"/\") ? t : `${t}/`, t) : e;\n    };\n  })(),\n  f = async (e, t) => {\n    let n;\n    for (const r of e) try {\n      return await t(r);\n    } catch (e) {\n      n = e;\n    }\n    throw n;\n  },\n  m = async e => {\n    e = {\n      wait: !1,\n      background: !1,\n      newInstance: !1,\n      allowNonzeroExitCode: !1,\n      ...e\n    };\n    if (Array.isArray(e.app)) return f(e.app, t => m({\n      ...e,\n      app: t\n    }));\n    let t,\n      {\n        name: n,\n        arguments: r = []\n      } = e.app || {};\n    r = [...r];\n    if (Array.isArray(n)) return f(n, t => m({\n      ...e,\n      app: {\n        name: t,\n        arguments: r\n      }\n    }));\n    const l = [],\n      p = {};\n    if (\"darwin\" === d) {\n      t = \"open\";\n      e.wait && l.push(\"--wait-apps\");\n      e.background && l.push(\"--background\");\n      e.newInstance && l.push(\"--new\");\n      n && l.push(\"-a\", n);\n    } else if (\"win32\" === d || a && !c()) {\n      const o = await h();\n      t = a ? `${o}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`;\n      l.push(\"-NoProfile\", \"-NonInteractive\", \"–ExecutionPolicy\", \"Bypass\", \"-EncodedCommand\");\n      a || (p.windowsVerbatimArguments = !0);\n      const i = [\"Start\"];\n      e.wait && i.push(\"-Wait\");\n      n ? (i.push(`\"\\`\"${n}\\`\"\"`, \"-ArgumentList\"), e.target && r.unshift(e.target)) : e.target && i.push(`\"${e.target}\"`);\n      r.length > 0 && (r = r.map(e => `\"\\`\"${e}\\`\"\"`), i.push(r.join(\",\")));\n      e.target = Buffer.from(i.join(\" \"), \"utf16le\").toString(\"base64\");\n    } else {\n      if (n) t = n;else {\n        const e = \"/\" === __dirname;\n        let n = !1;\n        try {\n          await i.access(u, s.X_OK);\n          n = !0;\n        } catch {}\n        t = process.versions.electron || \"android\" === d || e || !n ? \"xdg-open\" : u;\n      }\n      r.length > 0 && l.push(...r);\n      e.wait || (p.stdio = \"ignore\", p.detached = !0);\n    }\n    e.target && l.push(e.target);\n    \"darwin\" === d && r.length > 0 && l.push(\"--args\", ...r);\n    const g = o.spawn(t, l, p);\n    return e.wait ? new Promise((t, n) => {\n      g.once(\"error\", n);\n      g.once(\"close\", r => {\n        e.allowNonzeroExitCode && r > 0 ? n(new Error(`Exited with code ${r}`)) : t(g);\n      });\n    }) : (g.unref(), g);\n  },\n  g = (e, t) => {\n    if (\"string\" != typeof e) throw new TypeError(\"Expected a `target`\");\n    return m({\n      ...t,\n      target: e\n    });\n  };\nfunction _(e) {\n  if (\"string\" == typeof e || Array.isArray(e)) return e;\n  const {\n    [p]: t\n  } = e;\n  if (!t) throw new Error(`${p} is not supported`);\n  return t;\n}\nfunction y({\n  [d]: e\n}, {\n  wsl: t\n}) {\n  if (t && a) return _(t);\n  if (!e) throw new Error(`${d} is not supported`);\n  return _(e);\n}\nconst v = {};\nl(v, \"chrome\", () => y({\n  darwin: \"google chrome\",\n  win32: \"chrome\",\n  linux: [\"google-chrome\", \"google-chrome-stable\", \"chromium\"]\n}, {\n  wsl: {\n    ia32: \"/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe\",\n    x64: [\"/mnt/c/Program Files/Google/Chrome/Application/chrome.exe\", \"/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe\"]\n  }\n}));\nl(v, \"firefox\", () => y({\n  darwin: \"firefox\",\n  win32: \"C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe\",\n  linux: \"firefox\"\n}, {\n  wsl: \"/mnt/c/Program Files/Mozilla Firefox/firefox.exe\"\n}));\nl(v, \"edge\", () => y({\n  darwin: \"microsoft edge\",\n  win32: \"msedge\",\n  linux: [\"microsoft-edge\", \"microsoft-edge-dev\"]\n}, {\n  wsl: \"/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe\"\n}));\ng.apps = v;\ng.openApp = (e, t) => {\n  if (\"string\" != typeof e) throw new TypeError(\"Expected a `name`\");\n  const {\n    arguments: n = []\n  } = t || {};\n  if (null != n && !Array.isArray(n)) throw new TypeError(\"Expected `appArguments` as Array type\");\n  return m({\n    ...t,\n    app: {\n      name: e,\n      arguments: n\n    }\n  });\n};\nmodule.exports = g;",
  "8339": "var r,\n  o = this && this.__extends || (r = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (e, t) {\n    e.__proto__ = t;\n  } || function (e, t) {\n    for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);\n  }, function (e, t) {\n    function n() {\n      this.constructor = e;\n    }\n    r(e, t);\n    e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, new n());\n  }),\n  i = require(7310),\n  s = require(5290),\n  a = require(5740),\n  c = require(9036),\n  l = require(3054),\n  u = require(9962),\n  d = function (e) {\n    function t(n, r) {\n      var o = e.call(this) || this;\n      r && r.method && n && (o.method = r.method, o.url = t._getUrlFromRequestOptions(n, r), o.startTime = +new Date());\n      return o;\n    }\n    o(t, e);\n    t.prototype.onError = function (e) {\n      this._setStatus(undefined, e);\n    };\n    t.prototype.onResponse = function (e) {\n      this._setStatus(e.statusCode, undefined);\n      this.correlationId = a.getCorrelationContextTarget(e, c.requestContextTargetKey);\n    };\n    t.prototype.getDependencyTelemetry = function (e, t) {\n      var n = i.parse(this.url);\n      n.search = undefined;\n      n.hash = undefined;\n      var r = this.method.toUpperCase() + \" \" + n.pathname,\n        o = s.RemoteDependencyDataConstants.TYPE_HTTP,\n        a = n.hostname;\n      this.correlationId ? (o = s.RemoteDependencyDataConstants.TYPE_AI, this.correlationId !== u.correlationIdPrefix && (a = n.hostname + \" | \" + this.correlationId)) : o = s.RemoteDependencyDataConstants.TYPE_HTTP;\n      n.port && (a += \":\" + n.port);\n      var c = {\n        id: t,\n        name: r,\n        data: this.url,\n        duration: this.duration,\n        success: this._isSuccess(),\n        resultCode: this.statusCode ? this.statusCode.toString() : null,\n        properties: this.properties || {},\n        dependencyTypeName: o,\n        target: a\n      };\n      if (e) {\n        for (var l in e) c[l] || (c[l] = e[l]);\n        if (e.properties) for (var l in e.properties) c.properties[l] = e.properties[l];\n      }\n      return c;\n    };\n    t._getUrlFromRequestOptions = function (e, t) {\n      if (\"string\" == typeof e) e = i.parse(e);else {\n        var n = e;\n        e = {};\n        n && Object.keys(n).forEach(function (t) {\n          e[t] = n[t];\n        });\n      }\n      if (e.path) {\n        var r = i.parse(e.path);\n        e.pathname = r.pathname;\n        e.search = r.search;\n      }\n      e.host && e.port && !i.parse(\"http://\" + e.host).port && e.port && (e.hostname = e.host, delete e.host);\n      e.protocol = e.protocol || t.agent && t.agent.protocol || undefined;\n      e.hostname = e.hostname || \"localhost\";\n      return i.format(e);\n    };\n    return t;\n  }(l);\nmodule.exports = d;",
  "8348": "const t = \"object\" == typeof performance && performance && \"function\" == typeof performance.now ? performance : Date,\n  n = \"function\" == typeof AbortController ? AbortController : class {\n    constructor() {\n      this.signal = new i();\n    }\n    abort() {\n      this.signal.dispatchEvent(\"abort\");\n    }\n  },\n  r = \"function\" == typeof AbortSignal,\n  o = \"function\" == typeof n.AbortSignal,\n  i = r ? AbortSignal : o ? n.AbortController : class {\n    constructor() {\n      this.aborted = !1;\n      this._listeners = [];\n    }\n    dispatchEvent(e) {\n      if (\"abort\" === e) {\n        this.aborted = !0;\n        const t = {\n          type: e,\n          target: this\n        };\n        this.onabort(t);\n        this._listeners.forEach(e => e(t), this);\n      }\n    }\n    onabort() {}\n    addEventListener(e, t) {\n      \"abort\" === e && this._listeners.push(t);\n    }\n    removeEventListener(e, t) {\n      \"abort\" === e && (this._listeners = this._listeners.filter(e => e !== t));\n    }\n  },\n  s = new Set(),\n  a = (e, t) => {\n    const n = `LRU_CACHE_OPTION_${e}`;\n    u(n) && d(n, `${e} option`, `options.${t}`, g);\n  },\n  c = (e, t) => {\n    const n = `LRU_CACHE_METHOD_${e}`;\n    if (u(n)) {\n      const {\n          prototype: r\n        } = g,\n        {\n          get: o\n        } = Object.getOwnPropertyDescriptor(r, e);\n      d(n, `${e} method`, `cache.${t}()`, o);\n    }\n  },\n  l = (...e) => {\n    \"object\" == typeof process && process && \"function\" == typeof process.emitWarning ? process.emitWarning(...e) : console.error(...e);\n  },\n  u = e => !s.has(e),\n  d = (e, t, n, r) => {\n    s.add(e);\n    l(`The ${t} is deprecated. Please use ${n} instead.`, \"DeprecationWarning\", e, r);\n  },\n  p = e => e && e === Math.floor(e) && e > 0 && isFinite(e),\n  h = e => p(e) ? e <= Math.pow(2, 8) ? Uint8Array : e <= Math.pow(2, 16) ? Uint16Array : e <= Math.pow(2, 32) ? Uint32Array : e <= Number.MAX_SAFE_INTEGER ? f : null : null;\nclass f extends Array {\n  constructor(e) {\n    super(e);\n    this.fill(0);\n  }\n}\nclass m {\n  constructor(e) {\n    if (0 === e) return [];\n    const t = h(e);\n    this.heap = new t(e);\n    this.length = 0;\n  }\n  push(e) {\n    this.heap[this.length++] = e;\n  }\n  pop() {\n    return this.heap[--this.length];\n  }\n}\nclass g {\n  constructor(e = {}) {\n    const {\n        max: t = 0,\n        ttl: n,\n        ttlResolution: r = 1,\n        ttlAutopurge: o,\n        updateAgeOnGet: i,\n        updateAgeOnHas: c,\n        allowStale: d,\n        dispose: f,\n        disposeAfter: _,\n        noDisposeOnSet: y,\n        noUpdateTTL: v,\n        maxSize: b = 0,\n        sizeCalculation: w,\n        fetchMethod: x,\n        fetchContext: E,\n        noDeleteOnFetchRejection: C,\n        noDeleteOnStaleGet: S\n      } = e,\n      {\n        length: T,\n        maxAge: k,\n        stale: I\n      } = e instanceof g ? {} : e;\n    if (0 !== t && !p(t)) throw new TypeError(\"max option must be a nonnegative integer\");\n    const P = t ? h(t) : Array;\n    if (!P) throw new Error(\"invalid max value: \" + t);\n    this.max = t;\n    this.maxSize = b;\n    this.sizeCalculation = w || T;\n    if (this.sizeCalculation) {\n      if (!this.maxSize) throw new TypeError(\"cannot set sizeCalculation without setting maxSize\");\n      if (\"function\" != typeof this.sizeCalculation) throw new TypeError(\"sizeCalculation set to non-function\");\n    }\n    this.fetchMethod = x || null;\n    if (this.fetchMethod && \"function\" != typeof this.fetchMethod) throw new TypeError(\"fetchMethod must be a function if specified\");\n    this.fetchContext = E;\n    if (!this.fetchMethod && void 0 !== E) throw new TypeError(\"cannot set fetchContext without fetchMethod\");\n    this.keyMap = new Map();\n    this.keyList = new Array(t).fill(null);\n    this.valList = new Array(t).fill(null);\n    this.next = new P(t);\n    this.prev = new P(t);\n    this.head = 0;\n    this.tail = 0;\n    this.free = new m(t);\n    this.initialFill = 1;\n    this.size = 0;\n    \"function\" == typeof f && (this.dispose = f);\n    \"function\" == typeof _ ? (this.disposeAfter = _, this.disposed = []) : (this.disposeAfter = null, this.disposed = null);\n    this.noDisposeOnSet = !!y;\n    this.noUpdateTTL = !!v;\n    this.noDeleteOnFetchRejection = !!C;\n    if (0 !== this.maxSize) {\n      if (!p(this.maxSize)) throw new TypeError(\"maxSize must be a positive integer if specified\");\n      this.initializeSizeTracking();\n    }\n    this.allowStale = !!d || !!I;\n    this.noDeleteOnStaleGet = !!S;\n    this.updateAgeOnGet = !!i;\n    this.updateAgeOnHas = !!c;\n    this.ttlResolution = p(r) || 0 === r ? r : 1;\n    this.ttlAutopurge = !!o;\n    this.ttl = n || k || 0;\n    if (this.ttl) {\n      if (!p(this.ttl)) throw new TypeError(\"ttl must be a positive integer if specified\");\n      this.initializeTTLTracking();\n    }\n    if (0 === this.max && 0 === this.ttl && 0 === this.maxSize) throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n    if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n      const e = \"LRU_CACHE_UNBOUNDED\";\n      u(e) && (s.add(e), l(\"TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.\", \"UnboundedCacheWarning\", e, g));\n    }\n    I && a(\"stale\", \"allowStale\");\n    k && a(\"maxAge\", \"ttl\");\n    T && a(\"length\", \"sizeCalculation\");\n  }\n  getRemainingTTL(e) {\n    return this.has(e, {\n      updateAgeOnHas: !1\n    }) ? 1 / 0 : 0;\n  }\n  initializeTTLTracking() {\n    this.ttls = new f(this.max);\n    this.starts = new f(this.max);\n    this.setItemTTL = (e, n, r = t.now()) => {\n      this.starts[e] = 0 !== n ? r : 0;\n      this.ttls[e] = n;\n      if (0 !== n && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          this.isStale(e) && this.delete(this.keyList[e]);\n        }, n + 1);\n        t.unref && t.unref();\n      }\n    };\n    this.updateItemAge = e => {\n      this.starts[e] = 0 !== this.ttls[e] ? t.now() : 0;\n    };\n    let e = 0;\n    const n = () => {\n      const n = t.now();\n      if (this.ttlResolution > 0) {\n        e = n;\n        const t = setTimeout(() => e = 0, this.ttlResolution);\n        t.unref && t.unref();\n      }\n      return n;\n    };\n    this.getRemainingTTL = t => {\n      const r = this.keyMap.get(t);\n      return undefined === r ? 0 : 0 === this.ttls[r] || 0 === this.starts[r] ? 1 / 0 : this.starts[r] + this.ttls[r] - (e || n());\n    };\n    this.isStale = t => 0 !== this.ttls[t] && 0 !== this.starts[t] && (e || n()) - this.starts[t] > this.ttls[t];\n  }\n  updateItemAge(e) {}\n  setItemTTL(e, t, n) {}\n  isStale(e) {\n    return !1;\n  }\n  initializeSizeTracking() {\n    this.calculatedSize = 0;\n    this.sizes = new f(this.max);\n    this.removeItemSize = e => {\n      this.calculatedSize -= this.sizes[e];\n      this.sizes[e] = 0;\n    };\n    this.requireSize = (e, t, n, r) => {\n      if (!p(n)) {\n        if (!r) throw new TypeError(\"invalid size value (must be positive integer)\");\n        if (\"function\" != typeof r) throw new TypeError(\"sizeCalculation must be a function\");\n        n = r(t, e);\n        if (!p(n)) throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n      }\n      return n;\n    };\n    this.addItemSize = (e, t) => {\n      this.sizes[e] = t;\n      const n = this.maxSize - this.sizes[e];\n      for (; this.calculatedSize > n;) this.evict(!0);\n      this.calculatedSize += this.sizes[e];\n    };\n  }\n  removeItemSize(e) {}\n  addItemSize(e, t) {}\n  requireSize(e, t, n, r) {\n    if (n || r) throw new TypeError(\"cannot set size without setting maxSize on cache\");\n  }\n  *indexes({\n    allowStale: e = this.allowStale\n  } = {}) {\n    if (this.size) for (let t = this.tail; this.isValidIndex(t) && (!e && this.isStale(t) || (yield t), t !== this.head);) t = this.prev[t];\n  }\n  *rindexes({\n    allowStale: e = this.allowStale\n  } = {}) {\n    if (this.size) for (let t = this.head; this.isValidIndex(t) && (!e && this.isStale(t) || (yield t), t !== this.tail);) t = this.next[t];\n  }\n  isValidIndex(e) {\n    return this.keyMap.get(this.keyList[e]) === e;\n  }\n  *entries() {\n    for (const e of this.indexes()) yield [this.keyList[e], this.valList[e]];\n  }\n  *rentries() {\n    for (const e of this.rindexes()) yield [this.keyList[e], this.valList[e]];\n  }\n  *keys() {\n    for (const e of this.indexes()) yield this.keyList[e];\n  }\n  *rkeys() {\n    for (const e of this.rindexes()) yield this.keyList[e];\n  }\n  *values() {\n    for (const e of this.indexes()) yield this.valList[e];\n  }\n  *rvalues() {\n    for (const e of this.rindexes()) yield this.valList[e];\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  find(e, t = {}) {\n    for (const n of this.indexes()) if (e(this.valList[n], this.keyList[n], this)) return this.get(this.keyList[n], t);\n  }\n  forEach(e, t = this) {\n    for (const n of this.indexes()) e.call(t, this.valList[n], this.keyList[n], this);\n  }\n  rforEach(e, t = this) {\n    for (const n of this.rindexes()) e.call(t, this.valList[n], this.keyList[n], this);\n  }\n  get prune() {\n    c(\"prune\", \"purgeStale\");\n    return this.purgeStale;\n  }\n  purgeStale() {\n    let e = !1;\n    for (const t of this.rindexes({\n      allowStale: !0\n    })) this.isStale(t) && (this.delete(this.keyList[t]), e = !0);\n    return e;\n  }\n  dump() {\n    const e = [];\n    for (const n of this.indexes({\n      allowStale: !0\n    })) {\n      const r = this.keyList[n],\n        o = this.valList[n],\n        i = {\n          value: this.isBackgroundFetch(o) ? o.__staleWhileFetching : o\n        };\n      if (this.ttls) {\n        i.ttl = this.ttls[n];\n        const e = t.now() - this.starts[n];\n        i.start = Math.floor(Date.now() - e);\n      }\n      this.sizes && (i.size = this.sizes[n]);\n      e.unshift([r, i]);\n    }\n    return e;\n  }\n  load(e) {\n    this.clear();\n    for (const [n, r] of e) {\n      if (r.start) {\n        const e = Date.now() - r.start;\n        r.start = t.now() - e;\n      }\n      this.set(n, r.value, r);\n    }\n  }\n  dispose(e, t, n) {}\n  set(e, t, {\n    ttl: n = this.ttl,\n    start: r,\n    noDisposeOnSet: o = this.noDisposeOnSet,\n    size: i = 0,\n    sizeCalculation: s = this.sizeCalculation,\n    noUpdateTTL: a = this.noUpdateTTL\n  } = {}) {\n    i = this.requireSize(e, t, i, s);\n    if (this.maxSize && i > this.maxSize) return this;\n    let c = 0 === this.size ? undefined : this.keyMap.get(e);\n    if (undefined === c) {\n      c = this.newIndex();\n      this.keyList[c] = e;\n      this.valList[c] = t;\n      this.keyMap.set(e, c);\n      this.next[this.tail] = c;\n      this.prev[c] = this.tail;\n      this.tail = c;\n      this.size++;\n      this.addItemSize(c, i);\n      a = !1;\n    } else {\n      const n = this.valList[c];\n      t !== n && (this.isBackgroundFetch(n) ? n.__abortController.abort() : o || (this.dispose(n, e, \"set\"), this.disposeAfter && this.disposed.push([n, e, \"set\"])), this.removeItemSize(c), this.valList[c] = t, this.addItemSize(c, i));\n      this.moveToTail(c);\n    }\n    0 === n || 0 !== this.ttl || this.ttls || this.initializeTTLTracking();\n    a || this.setItemTTL(c, n, r);\n    if (this.disposeAfter) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());\n    return this;\n  }\n  newIndex() {\n    return 0 === this.size ? this.tail : this.size === this.max && 0 !== this.max ? this.evict(!1) : 0 !== this.free.length ? this.free.pop() : this.initialFill++;\n  }\n  pop() {\n    if (this.size) {\n      const e = this.valList[this.head];\n      this.evict(!0);\n      return e;\n    }\n  }\n  evict(e) {\n    const t = this.head,\n      n = this.keyList[t],\n      r = this.valList[t];\n    this.isBackgroundFetch(r) ? r.__abortController.abort() : (this.dispose(r, n, \"evict\"), this.disposeAfter && this.disposed.push([r, n, \"evict\"]));\n    this.removeItemSize(t);\n    e && (this.keyList[t] = null, this.valList[t] = null, this.free.push(t));\n    this.head = this.next[t];\n    this.keyMap.delete(n);\n    this.size--;\n    return t;\n  }\n  has(e, {\n    updateAgeOnHas: t = this.updateAgeOnHas\n  } = {}) {\n    const n = this.keyMap.get(e);\n    return undefined !== n && !this.isStale(n) && (t && this.updateItemAge(n), !0);\n  }\n  peek(e, {\n    allowStale: t = this.allowStale\n  } = {}) {\n    const n = this.keyMap.get(e);\n    if (undefined !== n && (t || !this.isStale(n))) {\n      const e = this.valList[n];\n      return this.isBackgroundFetch(e) ? e.__staleWhileFetching : e;\n    }\n  }\n  backgroundFetch(e, t, r, o) {\n    const i = undefined === t ? undefined : this.valList[t];\n    if (this.isBackgroundFetch(i)) return i;\n    const s = new n(),\n      a = {\n        signal: s.signal,\n        options: r,\n        context: o\n      },\n      c = new Promise(t => t(this.fetchMethod(e, i, a))).then(t => (s.signal.aborted || this.set(e, t, a.options), t), n => {\n        this.valList[t] === c && (r.noDeleteOnFetchRejection && undefined !== c.__staleWhileFetching ? this.valList[t] = c.__staleWhileFetching : this.delete(e));\n        if (c.__returned === c) throw n;\n      });\n    c.__abortController = s;\n    c.__staleWhileFetching = i;\n    c.__returned = null;\n    undefined === t ? (this.set(e, c, a.options), t = this.keyMap.get(e)) : this.valList[t] = c;\n    return c;\n  }\n  isBackgroundFetch(e) {\n    return e && \"object\" == typeof e && \"function\" == typeof e.then && Object.prototype.hasOwnProperty.call(e, \"__staleWhileFetching\") && Object.prototype.hasOwnProperty.call(e, \"__returned\") && (e.__returned === e || null === e.__returned);\n  }\n  async fetch(e, {\n    allowStale: t = this.allowStale,\n    updateAgeOnGet: n = this.updateAgeOnGet,\n    noDeleteOnStaleGet: r = this.noDeleteOnStaleGet,\n    ttl: o = this.ttl,\n    noDisposeOnSet: i = this.noDisposeOnSet,\n    size: s = 0,\n    sizeCalculation: a = this.sizeCalculation,\n    noUpdateTTL: c = this.noUpdateTTL,\n    noDeleteOnFetchRejection: l = this.noDeleteOnFetchRejection,\n    fetchContext: u = this.fetchContext,\n    forceRefresh: d = !1\n  } = {}) {\n    if (!this.fetchMethod) return this.get(e, {\n      allowStale: t,\n      updateAgeOnGet: n,\n      noDeleteOnStaleGet: r\n    });\n    const p = {\n      allowStale: t,\n      updateAgeOnGet: n,\n      noDeleteOnStaleGet: r,\n      ttl: o,\n      noDisposeOnSet: i,\n      size: s,\n      sizeCalculation: a,\n      noUpdateTTL: c,\n      noDeleteOnFetchRejection: l\n    };\n    let h = this.keyMap.get(e);\n    if (undefined === h) {\n      const t = this.backgroundFetch(e, h, p, u);\n      return t.__returned = t;\n    }\n    {\n      const r = this.valList[h];\n      if (this.isBackgroundFetch(r)) return t && undefined !== r.__staleWhileFetching ? r.__staleWhileFetching : r.__returned = r;\n      if (!d && !this.isStale(h)) {\n        this.moveToTail(h);\n        n && this.updateItemAge(h);\n        return r;\n      }\n      const o = this.backgroundFetch(e, h, p, u);\n      return t && undefined !== o.__staleWhileFetching ? o.__staleWhileFetching : o.__returned = o;\n    }\n  }\n  get(e, {\n    allowStale: t = this.allowStale,\n    updateAgeOnGet: n = this.updateAgeOnGet,\n    noDeleteOnStaleGet: r = this.noDeleteOnStaleGet\n  } = {}) {\n    const o = this.keyMap.get(e);\n    if (undefined !== o) {\n      const i = this.valList[o],\n        s = this.isBackgroundFetch(i);\n      if (this.isStale(o)) return s ? t ? i.__staleWhileFetching : undefined : (r || this.delete(e), t ? i : undefined);\n      if (s) return;\n      this.moveToTail(o);\n      n && this.updateItemAge(o);\n      return i;\n    }\n  }\n  connect(e, t) {\n    this.prev[t] = e;\n    this.next[e] = t;\n  }\n  moveToTail(e) {\n    e !== this.tail && (e === this.head ? this.head = this.next[e] : this.connect(this.prev[e], this.next[e]), this.connect(this.tail, e), this.tail = e);\n  }\n  get del() {\n    c(\"del\", \"delete\");\n    return this.delete;\n  }\n  delete(e) {\n    let t = !1;\n    if (0 !== this.size) {\n      const n = this.keyMap.get(e);\n      if (undefined !== n) {\n        t = !0;\n        if (1 === this.size) this.clear();else {\n          this.removeItemSize(n);\n          const t = this.valList[n];\n          this.isBackgroundFetch(t) ? t.__abortController.abort() : (this.dispose(t, e, \"delete\"), this.disposeAfter && this.disposed.push([t, e, \"delete\"]));\n          this.keyMap.delete(e);\n          this.keyList[n] = null;\n          this.valList[n] = null;\n          n === this.tail ? this.tail = this.prev[n] : n === this.head ? this.head = this.next[n] : (this.next[this.prev[n]] = this.next[n], this.prev[this.next[n]] = this.prev[n]);\n          this.size--;\n          this.free.push(n);\n        }\n      }\n    }\n    if (this.disposed) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());\n    return t;\n  }\n  clear() {\n    for (const e of this.rindexes({\n      allowStale: !0\n    })) {\n      const t = this.valList[e];\n      if (this.isBackgroundFetch(t)) t.__abortController.abort();else {\n        const n = this.keyList[e];\n        this.dispose(t, n, \"delete\");\n        this.disposeAfter && this.disposed.push([t, n, \"delete\"]);\n      }\n    }\n    this.keyMap.clear();\n    this.valList.fill(null);\n    this.keyList.fill(null);\n    this.ttls && (this.ttls.fill(0), this.starts.fill(0));\n    this.sizes && this.sizes.fill(0);\n    this.head = 0;\n    this.tail = 0;\n    this.initialFill = 1;\n    this.free.length = 0;\n    this.calculatedSize = 0;\n    this.size = 0;\n    if (this.disposed) for (; this.disposed.length;) this.disposeAfter(...this.disposed.shift());\n  }\n  get reset() {\n    c(\"reset\", \"clear\");\n    return this.clear;\n  }\n  get length() {\n    ((e, t) => {\n      const n = \"LRU_CACHE_PROPERTY_length\";\n      if (u(n)) {\n        const {\n            prototype: t\n          } = g,\n          {\n            get: r\n          } = Object.getOwnPropertyDescriptor(t, e);\n        d(n, \"length property\", \"cache.size\", r);\n      }\n    })(\"length\");\n    return this.size;\n  }\n  static get AbortController() {\n    return n;\n  }\n  static get AbortSignal() {\n    return i;\n  }\n}\nmodule.exports = g;",
  "8359": "const {\n    AbortSignal: r\n  } = require(6829),\n  {\n    Body: o,\n    cloneStream: i,\n    guessContentType: s\n  } = require(5600),\n  {\n    Headers: a\n  } = require(9872),\n  {\n    isPlainObject: c\n  } = require(4544),\n  {\n    isFormData: l,\n    FormDataSerializer: u\n  } = require(9407),\n  d = Symbol(\"Request internals\");\nclass p extends o {\n  constructor(e, t = {}) {\n    const n = e instanceof p ? e : null,\n      o = n ? new URL(n.url) : new URL(e);\n    let h = t.method || n && n.method || \"GET\";\n    h = h.toUpperCase();\n    if ((null != t.body || n && null !== n.body) && [\"GET\", \"HEAD\"].includes(h)) throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n    let f = t.body || (n && n.body ? i(n) : null);\n    const m = new a(t.headers || n && n.headers || {});\n    if (l(f) && !m.has(\"content-type\")) {\n      const e = new u(f);\n      f = e.stream();\n      m.set(\"content-type\", e.contentType());\n      m.has(\"transfer-encoding\") || m.has(\"content-length\") || m.set(\"content-length\", e.length());\n    }\n    if (!m.has(\"content-type\")) if (c(f)) {\n      f = JSON.stringify(f);\n      m.set(\"content-type\", \"application/json\");\n    } else {\n      const e = s(f);\n      e && m.set(\"content-type\", e);\n    }\n    super(f);\n    let g = n ? n.signal : null;\n    \"signal\" in t && (g = t.signal);\n    if (g && !(g instanceof r)) throw new TypeError(\"signal needs to be an instance of AbortSignal\");\n    const _ = t.redirect || n && n.redirect || \"follow\";\n    if (![\"follow\", \"error\", \"manual\"].includes(_)) throw new TypeError(`'${_}' is not a valid redirect option`);\n    const y = t.cache || n && n.cache || \"default\";\n    if (![\"default\", \"no-store\", \"reload\", \"no-cache\", \"force-cache\", \"only-if-cached\"].includes(y)) throw new TypeError(`'${y}' is not a valid cache option`);\n    this[d] = {\n      init: {\n        ...t\n      },\n      method: h,\n      redirect: _,\n      cache: y,\n      headers: m,\n      parsedURL: o,\n      signal: g\n    };\n    undefined === t.follow ? n && undefined !== n.follow ? this.follow = n.follow : this.follow = 20 : this.follow = t.follow;\n    this.counter = t.counter || n && n.counter || 0;\n    undefined === t.compress ? n && undefined !== n.compress ? this.compress = n.compress : this.compress = !0 : this.compress = t.compress;\n    undefined === t.decode ? n && undefined !== n.decode ? this.decode = n.decode : this.decode = !0 : this.decode = t.decode;\n  }\n  get method() {\n    return this[d].method;\n  }\n  get url() {\n    return this[d].parsedURL.toString();\n  }\n  get headers() {\n    return this[d].headers;\n  }\n  get redirect() {\n    return this[d].redirect;\n  }\n  get cache() {\n    return this[d].cache;\n  }\n  get signal() {\n    return this[d].signal;\n  }\n  clone() {\n    return new p(this);\n  }\n  get init() {\n    return this[d].init;\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n}\nObject.defineProperties(p.prototype, {\n  method: {\n    enumerable: !0\n  },\n  url: {\n    enumerable: !0\n  },\n  headers: {\n    enumerable: !0\n  },\n  redirect: {\n    enumerable: !0\n  },\n  cache: {\n    enumerable: !0\n  },\n  clone: {\n    enumerable: !0\n  },\n  signal: {\n    enumerable: !0\n  }\n});\nmodule.exports = {\n  Request: p\n};",
  "8386": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst n = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID');\n  }\n};\nexports.default = n;",
  "8436": "var r = this && this.__assign || Object.assign || function (e) {\n  for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n  return e;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar o = require(4953);\nexports.mongo2 = {\n  versionSpecifier: \">= 2.0.0 <= 3.0.5\",\n  patch: function (e) {\n    var t = e.instrument({\n        operationIdGenerator: {\n          next: function () {\n            return o.channel.bindToContext(function (e) {\n              return e();\n            });\n          }\n        }\n      }),\n      n = {};\n    t.on(\"started\", function (e) {\n      n[e.requestId] || (n[e.requestId] = r({}, e, {\n        time: new Date()\n      }));\n    });\n    t.on(\"succeeded\", function (e) {\n      var t = n[e.requestId];\n      t && delete n[e.requestId];\n      \"function\" == typeof e.operationId ? e.operationId(function () {\n        return o.channel.publish(\"mongodb\", {\n          startedData: t,\n          event: e,\n          succeeded: !0\n        });\n      }) : o.channel.publish(\"mongodb\", {\n        startedData: t,\n        event: e,\n        succeeded: !0\n      });\n    });\n    t.on(\"failed\", function (e) {\n      var t = n[e.requestId];\n      t && delete n[e.requestId];\n      \"function\" == typeof e.operationId ? e.operationId(function () {\n        return o.channel.publish(\"mongodb\", {\n          startedData: t,\n          event: e,\n          succeeded: !1\n        });\n      }) : o.channel.publish(\"mongodb\", {\n        startedData: t,\n        event: e,\n        succeeded: !1\n      });\n    });\n    return e;\n  }\n};\nexports.mongo3 = {\n  versionSpecifier: \"> 3.0.5 < 3.3.0\",\n  patch: function (e) {\n    var t = e.instrument(),\n      n = {},\n      i = {};\n    t.on(\"started\", function (e) {\n      n[e.requestId] || (i[e.requestId] = o.channel.bindToContext(function (e) {\n        return e();\n      }), n[e.requestId] = r({}, e, {\n        time: new Date()\n      }));\n    });\n    t.on(\"succeeded\", function (e) {\n      var t = n[e.requestId];\n      t && delete n[e.requestId];\n      \"object\" == typeof e && \"function\" == typeof i[e.requestId] && (i[e.requestId](function () {\n        return o.channel.publish(\"mongodb\", {\n          startedData: t,\n          event: e,\n          succeeded: !0\n        });\n      }), delete i[e.requestId]);\n    });\n    t.on(\"failed\", function (e) {\n      var t = n[e.requestId];\n      t && delete n[e.requestId];\n      \"object\" == typeof e && \"function\" == typeof i[e.requestId] && (i[e.requestId](function () {\n        return o.channel.publish(\"mongodb\", {\n          startedData: t,\n          event: e,\n          succeeded: !1\n        });\n      }), delete i[e.requestId]);\n    });\n    return e;\n  }\n};\nexports.mongo330 = {\n  versionSpecifier: \">= 3.3.0 < 4.0.0\",\n  patch: function (e) {\n    !function (e) {\n      var t = e.Server.prototype.connect;\n      e.Server.prototype.connect = function () {\n        var e = t.apply(this, arguments),\n          n = this.s.coreTopology.s.pool.write;\n        this.s.coreTopology.s.pool.write = function () {\n          var e = \"function\" == typeof arguments[1] ? 1 : 2;\n          \"function\" == typeof arguments[e] && (arguments[e] = o.channel.bindToContext(arguments[e]));\n          return n.apply(this, arguments);\n        };\n        var r = this.s.coreTopology.s.pool.logout;\n        this.s.coreTopology.s.pool.logout = function () {\n          \"function\" == typeof arguments[1] && (arguments[1] = o.channel.bindToContext(arguments[1]));\n          return r.apply(this, arguments);\n        };\n        return e;\n      };\n    }(e);\n    var t = e.instrument(),\n      n = {},\n      r = {};\n    t.on(\"started\", function (e) {\n      n[e.requestId] || (r[e.requestId] = o.channel.bindToContext(function (e) {\n        return e();\n      }), n[e.requestId] = e);\n    });\n    t.on(\"succeeded\", function (e) {\n      var t = n[e.requestId];\n      t && delete n[e.requestId];\n      \"object\" == typeof e && \"function\" == typeof r[e.requestId] && (r[e.requestId](function () {\n        return o.channel.publish(\"mongodb\", {\n          startedData: t,\n          event: e,\n          succeeded: !0\n        });\n      }), delete r[e.requestId]);\n    });\n    t.on(\"failed\", function (e) {\n      var t = n[e.requestId];\n      t && delete n[e.requestId];\n      \"object\" == typeof e && \"function\" == typeof r[e.requestId] && (r[e.requestId](function () {\n        return o.channel.publish(\"mongodb\", {\n          startedData: t,\n          event: e,\n          succeeded: !1\n        });\n      }), delete r[e.requestId]);\n    });\n    return e;\n  }\n};\nexports.enable = function () {\n  o.channel.registerMonkeyPatch(\"mongodb\", exports.mongo2);\n  o.channel.registerMonkeyPatch(\"mongodb\", exports.mongo3);\n  o.channel.registerMonkeyPatch(\"mongodb\", exports.mongo330);\n};",
  "8490": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = undefined;\nconst r = require(7023);\nclass o extends Error {\n  constructor(e) {\n    super(`CodeGen: \"code\" for ${e} not defined`);\n    this.value = e.value;\n  }\n}\nvar i;\n!function (e) {\n  e[e.Started = 0] = \"Started\";\n  e[e.Completed = 1] = \"Completed\";\n}(i = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n  const: new r.Name(\"const\"),\n  let: new r.Name(\"let\"),\n  var: new r.Name(\"var\")\n};\nclass Scope {\n  constructor({\n    prefixes: e,\n    parent: t\n  } = {}) {\n    this._names = {};\n    this._prefixes = e;\n    this._parent = t;\n  }\n  toName(e) {\n    return e instanceof r.Name ? e : this.name(e);\n  }\n  name(e) {\n    return new r.Name(this._newName(e));\n  }\n  _newName(e) {\n    return `${e}${(this._names[e] || this._nameGroup(e)).index++}`;\n  }\n  _nameGroup(e) {\n    var t, n;\n    if ((null === (n = null === (t = this._parent) || undefined === t ? undefined : t._prefixes) || undefined === n ? undefined : n.has(e)) || this._prefixes && !this._prefixes.has(e)) throw new Error(`CodeGen: prefix \"${e}\" is not allowed in this scope`);\n    return this._names[e] = {\n      prefix: e,\n      index: 0\n    };\n  }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends r.Name {\n  constructor(e, t) {\n    super(t);\n    this.prefix = e;\n  }\n  setValue(e, {\n    property: t,\n    itemIndex: n\n  }) {\n    this.value = e;\n    this.scopePath = r._`.${new r.Name(t)}[${n}]`;\n  }\n}\nexports.ValueScopeName = ValueScopeName;\nconst c = r._`\\n`;\nexports.ValueScope = class extends Scope {\n  constructor(e) {\n    super(e);\n    this._values = {};\n    this._scope = e.scope;\n    this.opts = {\n      ...e,\n      _n: e.lines ? c : r.nil\n    };\n  }\n  get() {\n    return this._scope;\n  }\n  name(e) {\n    return new ValueScopeName(e, this._newName(e));\n  }\n  value(e, t) {\n    var n;\n    if (undefined === t.ref) throw new Error(\"CodeGen: ref must be passed in value\");\n    const r = this.toName(e),\n      {\n        prefix: o\n      } = r,\n      i = null !== (n = t.key) && undefined !== n ? n : t.ref;\n    let s = this._values[o];\n    if (s) {\n      const e = s.get(i);\n      if (e) return e;\n    } else s = this._values[o] = new Map();\n    s.set(i, r);\n    const a = this._scope[o] || (this._scope[o] = []),\n      c = a.length;\n    a[c] = t.ref;\n    r.setValue(t, {\n      property: o,\n      itemIndex: c\n    });\n    return r;\n  }\n  getValue(e, t) {\n    const n = this._values[e];\n    if (n) return n.get(t);\n  }\n  scopeRefs(e, t = this._values) {\n    return this._reduceValues(t, t => {\n      if (undefined === t.scopePath) throw new Error(`CodeGen: name \"${t}\" has no value`);\n      return r._`${e}${t.scopePath}`;\n    });\n  }\n  scopeCode(e = this._values, t, n) {\n    return this._reduceValues(e, e => {\n      if (undefined === e.value) throw new Error(`CodeGen: name \"${e}\" has no value`);\n      return e.value.code;\n    }, t, n);\n  }\n  _reduceValues(e, n, s = {}, a) {\n    let c = r.nil;\n    for (const l in e) {\n      const u = e[l];\n      if (!u) continue;\n      const d = s[l] = s[l] || new Map();\n      u.forEach(e => {\n        if (d.has(e)) return;\n        d.set(e, i.Started);\n        let s = n(e);\n        if (s) {\n          const n = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          c = r._`${c}${n} ${e} = ${s};${this.opts._n}`;\n        } else {\n          if (!(s = null == a ? undefined : a(e))) throw new o(e);\n          c = r._`${c}${s}${this.opts._n}`;\n        }\n        d.set(e, i.Completed);\n      });\n    }\n    return c;\n  }\n};",
  "8568": "var r;\nr = require(8249);\nrequire(5109);\nr.mode.CFB = function () {\n  var e = r.lib.BlockCipherMode.extend();\n  function t(e, t, n, r) {\n    var o,\n      i = this._iv;\n    i ? (o = i.slice(0), this._iv = undefined) : o = this._prevBlock;\n    r.encryptBlock(o, 0);\n    for (var s = 0; s < n; s++) e[t + s] ^= o[s];\n  }\n  e.Encryptor = e.extend({\n    processBlock: function (e, n) {\n      var r = this._cipher,\n        o = r.blockSize;\n      t.call(this, e, n, o, r);\n      this._prevBlock = e.slice(n, n + o);\n    }\n  });\n  e.Decryptor = e.extend({\n    processBlock: function (e, n) {\n      var r = this._cipher,\n        o = r.blockSize,\n        i = e.slice(n, n + o);\n      t.call(this, e, n, o, r);\n      this._prevBlock = i;\n    }\n  });\n  return e;\n}();\nmodule.exports = r.mode.CFB;",
  "8602": "var r = require(495);\nmodule.exports = function () {\n  this.kind = r.Measurement;\n};",
  "8604": "var r = this && this.__assign || Object.assign || function (e) {\n  for (var t, n = 1, r = arguments.length; n < r; n++) for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);\n  return e;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar o = require(4953);\nexports.AzureMonitorSymbol = \"Azure_Monitor_Tracer\";\nvar i = function () {\n  function e() {}\n  e.prototype.onStart = function (e) {};\n  e.prototype.onEnd = function (e) {\n    o.channel.publish(\"azure-coretracing\", e);\n  };\n  e.prototype.shutdown = function () {};\n  return e;\n}();\nexports.azureCoreTracing = {\n  versionSpecifier: \">= 1.0.0 < 2.0.0\",\n  patch: function (e) {\n    try {\n      var s = new (0, require(8028).BasicTracer)(o.channel.spanContextPropagator ? {\n          scopeManager: o.channel.spanContextPropagator\n        } : undefined),\n        a = s.startSpan;\n      s.startSpan = function (e, t) {\n        if (!t || !t.parent) {\n          var n = s.getCurrentSpan();\n          n && n.operation && n.operation.traceparent && (t = r({}, t, {\n            parent: {\n              traceId: n.operation.traceparent.traceId,\n              spanId: n.operation.traceparent.spanId\n            }\n          }));\n        }\n        var o = a.call(this, e, t);\n        o.addEvent(\"Application Insights Integration enabled\");\n        return o;\n      };\n      s.addSpanProcessor(new i());\n      s[exports.AzureMonitorSymbol] = !0;\n      e.setTracer(s);\n    } catch (e) {}\n    return e;\n  }\n};\nexports.enable = function () {\n  o.channel.registerMonkeyPatch(\"@azure/core-tracing\", exports.azureCoreTracing);\n};",
  "8723": "var r = require(3685),\n  o = require(5687),\n  i = require(5282),\n  s = require(5740),\n  a = require(9036),\n  c = require(8339),\n  l = require(894),\n  u = require(9962),\n  d = require(8090),\n  p = require(7396),\n  h = function () {\n    function e(t) {\n      if (e.INSTANCE) throw new Error(\"Client request tracking should be configured from the applicationInsights object\");\n      e.INSTANCE = this;\n      this._client = t;\n    }\n    e.prototype.enable = function (e) {\n      this._isEnabled = e;\n      this._isEnabled && !this._isInitialized && this._initialize();\n      p.IsInitialized && (require(7886).wp(e, this._client), require(4777).wp(e, this._client), require(5071).wp(e, this._client), require(1227).wp(e, this._client));\n    };\n    e.prototype.isInitialized = function () {\n      return this._isInitialized;\n    };\n    e.prototype._initialize = function () {\n      var t = this;\n      this._isInitialized = !0;\n      r.get;\n      var n = r.request,\n        i = o.request,\n        s = function (n, r) {\n          var o = !r[e.disableCollectionRequestOption] && !n[e.alreadyAutoCollectedFlag];\n          n[e.alreadyAutoCollectedFlag] = !0;\n          n && r && o && (l.CorrelationContextManager.wrapEmitter(n), e.trackRequest(t._client, {\n            options: r,\n            request: n\n          }));\n        };\n      r.request = function (e) {\n        for (var t = [], o = 1; o < arguments.length; o++) t[o - 1] = arguments[o];\n        var i = n.call.apply(n, [r, e].concat(t));\n        s(i, e);\n        return i;\n      };\n      o.request = function (e) {\n        for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];\n        var r = i.call.apply(i, [o, e].concat(t));\n        s(r, e);\n        return r;\n      };\n      r.get = function (e) {\n        for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];\n        var o,\n          i = (o = r.request).call.apply(o, [r, e].concat(t));\n        i.end();\n        return i;\n      };\n      o.get = function (e) {\n        for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];\n        var r,\n          i = (r = o.request).call.apply(r, [o, e].concat(t));\n        i.end();\n        return i;\n      };\n    };\n    e.trackRequest = function (t, n) {\n      if (n.options && n.request && t) {\n        var r,\n          o,\n          p = new c(n.options, n.request),\n          h = l.CorrelationContextManager.getCurrentContext();\n        h && h.operation && h.operation.traceparent && d.isValidTraceId(h.operation.traceparent.traceId) ? (h.operation.traceparent.updateSpanId(), r = h.operation.traceparent.getBackCompatRequestId()) : u.w3cEnabled ? (o = (m = new d()).toString(), r = m.getBackCompatRequestId()) : r = h && h.operation && h.operation.parentId + e.requestNumber++ + \".\";\n        if (s.canIncludeCorrelationHeader(t, p.getUrl()) && n.request.getHeader && n.request.setHeader && t.config && t.config.correlationId) {\n          var f = n.request.getHeader(a.requestContextHeader);\n          try {\n            s.safeIncludeCorrelationHeader(t, n.request, f);\n          } catch (e) {\n            i.warn(\"Request-Context header could not be set. Correlation of requests may be lost\", e);\n          }\n          if (h && h.operation) try {\n            if (n.request.setHeader(a.requestIdHeader, r), n.request.setHeader(a.parentIdHeader, h.operation.id), n.request.setHeader(a.rootIdHeader, r), o || h.operation.traceparent) n.request.setHeader(a.traceparentHeader, o || h.operation.traceparent.toString());else if (u.w3cEnabled) {\n              var m = new d().toString();\n              n.request.setHeader(a.traceparentHeader, m);\n            }\n            if (h.operation.tracestate) {\n              var g = h.operation.tracestate.toString();\n              g && n.request.setHeader(a.traceStateHeader, g);\n            }\n            var _ = h.customProperties.serializeToHeader();\n            _ && n.request.setHeader(a.correlationContextHeader, _);\n          } catch (e) {\n            i.warn(\"Correlation headers could not be set. Correlation of requests may be lost.\", e);\n          }\n        }\n        n.request.on && (n.request.on(\"response\", function (e) {\n          p.onResponse(e);\n          var o = p.getDependencyTelemetry(n, r);\n          o.contextObjects = o.contextObjects || {};\n          o.contextObjects[\"http.RequestOptions\"] = n.options;\n          o.contextObjects[\"http.ClientRequest\"] = n.request;\n          o.contextObjects[\"http.ClientResponse\"] = e;\n          t.trackDependency(o);\n        }), n.request.on(\"error\", function (e) {\n          p.onError(e);\n          var o = p.getDependencyTelemetry(n, r);\n          o.contextObjects = o.contextObjects || {};\n          o.contextObjects[\"http.RequestOptions\"] = n.options;\n          o.contextObjects[\"http.ClientRequest\"] = n.request;\n          o.contextObjects.Error = e;\n          t.trackDependency(o);\n        }));\n      } else i.info(\"AutoCollectHttpDependencies.trackRequest was called with invalid parameters: \", !n.options, !n.request, !t);\n    };\n    e.prototype.dispose = function () {\n      e.INSTANCE = null;\n      this.enable(!1);\n      this._isInitialized = !1;\n    };\n    e.disableCollectionRequestOption = \"disableAppInsightsAutoCollection\";\n    e.requestNumber = 1;\n    e.alreadyAutoCollectedFlag = \"_appInsightsAutoCollected\";\n    return e;\n  }();\nmodule.exports = h;",
  "8771": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.TestNotificationSender = exports.TestUrlOpener = exports.rangeToString = exports.positionToString = undefined;\nconst r = require(1547);\nfunction positionToString(e) {\n  return `${e.line}:${e.character}`;\n}\nexports.positionToString = positionToString;\nexports.rangeToString = function (e) {\n  return `[${positionToString(e.start)}--${positionToString(e.end)}]`;\n};\nexports.TestUrlOpener = class {\n  constructor() {\n    this.openedUrls = [];\n  }\n  open(e) {\n    this.openedUrls.push(e);\n  }\n};\nclass TestNotificationSender extends r.NotificationSender {\n  constructor() {\n    super();\n    this.sentMessages = [];\n  }\n  showWarningMessage(e, ...t) {\n    this.sentMessages.push(e);\n    return t ? Promise.resolve(t[0]) : Promise.resolve(undefined);\n  }\n}\nexports.TestNotificationSender = TestNotificationSender;",
  "8859": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(4953);\nexports.bunyan = {\n  versionSpecifier: \">= 1.0.0 < 2.0.0\",\n  patch: function (e) {\n    var t = e.prototype._emit;\n    e.prototype._emit = function (e, n) {\n      var o = t.apply(this, arguments);\n      if (!n) {\n        var i = o;\n        i || (i = t.call(this, e, !0));\n        r.channel.publish(\"bunyan\", {\n          level: e.level,\n          result: i\n        });\n      }\n      return o;\n    };\n    return e;\n  }\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"bunyan\", exports.bunyan);\n};",
  "8876": "function shouldUseGroup(e, t) {\n  return t.rules.some(t => shouldUseRule(e, t));\n}\nfunction shouldUseRule(e, t) {\n  var n;\n  return undefined !== e[t.keyword] || (null === (n = t.definition.implements) || undefined === n ? undefined : n.some(t => undefined !== e[t]));\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = undefined;\nexports.schemaHasRulesForType = function ({\n  schema: e,\n  self: t\n}, r) {\n  const o = t.RULES.types[r];\n  return o && !0 !== o && shouldUseGroup(e, o);\n};\nexports.shouldUseGroup = shouldUseGroup;\nexports.shouldUseRule = shouldUseRule;",
  "8934": "module.exports = function () {};",
  "8965": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.contextualFilterScore = exports.getLastLineLength = exports.ContextualFilterManager = undefined;\nconst r = require(7744);\nclass ContextualFilterManager {\n  constructor() {\n    this.previousLabel = 0;\n    this.previousLabelTimestamp = Date.now() - 3600;\n    this.probabilityAccept = 0;\n  }\n}\nfunction getLastLineLength(e) {\n  const t = e.split(\"\\n\");\n  return t[t.length - 1].length;\n}\nexports.ContextualFilterManager = ContextualFilterManager;\nexports.getLastLineLength = getLastLineLength;\nexports.contextualFilterScore = function (e, t, n) {\n  const s = e.get(ContextualFilterManager),\n    a = s.previousLabel;\n  let c = 0;\n  \"afterCursorWhitespace\" in t.properties && \"true\" === t.properties.afterCursorWhitespace && (c = 1);\n  const l = (Date.now() - s.previousLabelTimestamp) / 1e3,\n    u = Math.log(1 + l);\n  let d = 0,\n    p = 0;\n  const h = n.prefix;\n  if (h) {\n    d = Math.log(1 + getLastLineLength(h));\n    const e = h.slice(-1);\n    undefined !== r.contextualFilterCharacterMap[e] && (p = r.contextualFilterCharacterMap[e]);\n  }\n  let f = 0,\n    m = 0;\n  const g = h.trimEnd();\n  if (g) {\n    f = Math.log(1 + getLastLineLength(g));\n    const e = g.slice(-1);\n    undefined !== r.contextualFilterCharacterMap[e] && (m = r.contextualFilterCharacterMap[e]);\n  }\n  let _ = 0;\n  if (\"documentLength\" in t.measurements) {\n    const e = t.measurements.documentLength;\n    _ = Math.log(1 + e);\n  }\n  let y = 0;\n  if (\"promptEndPos\" in t.measurements) {\n    const e = t.measurements.promptEndPos;\n    y = Math.log(1 + e);\n  }\n  let v = 0;\n  if (\"promptEndPos\" in t.measurements && \"documentLength\" in t.measurements) {\n    const e = t.measurements.documentLength;\n    v = (t.measurements.promptEndPos + .5) / (1 + e);\n  }\n  let b = 0;\n  undefined !== r.contextualFilterLanguageMap[t.properties.languageId] && (b = r.contextualFilterLanguageMap[t.properties.languageId]);\n  let w = r.contextualFilterIntercept;\n  w += r.contextualFilterWeights[0] * a;\n  w += r.contextualFilterWeights[1] * c;\n  w += r.contextualFilterWeights[2] * u;\n  w += r.contextualFilterWeights[3] * d;\n  w += r.contextualFilterWeights[4] * f;\n  w += r.contextualFilterWeights[5] * _;\n  w += r.contextualFilterWeights[6] * y;\n  w += r.contextualFilterWeights[7] * v;\n  w += r.contextualFilterWeights[8 + b];\n  w += r.contextualFilterWeights[29 + p];\n  w += r.contextualFilterWeights[125 + m];\n  const x = 1 / (1 + Math.exp(-w));\n  e.get(ContextualFilterManager).probabilityAccept = x;\n  return x;\n};",
  "9012": "var n;\nexports = module.exports = SemVer;\nn = \"object\" == typeof process && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? function () {\n  var e = Array.prototype.slice.call(arguments, 0);\n  e.unshift(\"SEMVER\");\n  console.log.apply(console, e);\n} : function () {};\nexports.SEMVER_SPEC_VERSION = \"2.0.0\";\nvar r = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  o = exports.re = [],\n  i = exports.src = [],\n  s = 0,\n  a = s++;\ni[a] = \"0|[1-9]\\\\d*\";\nvar c = s++;\ni[c] = \"[0-9]+\";\nvar l = s++;\ni[l] = \"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\";\nvar u = s++;\ni[u] = \"(\" + i[a] + \")\\\\.(\" + i[a] + \")\\\\.(\" + i[a] + \")\";\nvar d = s++;\ni[d] = \"(\" + i[c] + \")\\\\.(\" + i[c] + \")\\\\.(\" + i[c] + \")\";\nvar p = s++;\ni[p] = \"(?:\" + i[a] + \"|\" + i[l] + \")\";\nvar h = s++;\ni[h] = \"(?:\" + i[c] + \"|\" + i[l] + \")\";\nvar f = s++;\ni[f] = \"(?:-(\" + i[p] + \"(?:\\\\.\" + i[p] + \")*))\";\nvar m = s++;\ni[m] = \"(?:-?(\" + i[h] + \"(?:\\\\.\" + i[h] + \")*))\";\nvar g = s++;\ni[g] = \"[0-9A-Za-z-]+\";\nvar _ = s++;\ni[_] = \"(?:\\\\+(\" + i[g] + \"(?:\\\\.\" + i[g] + \")*))\";\nvar y = s++,\n  v = \"v?\" + i[u] + i[f] + \"?\" + i[_] + \"?\";\ni[y] = \"^\" + v + \"$\";\nvar b = \"[v=\\\\s]*\" + i[d] + i[m] + \"?\" + i[_] + \"?\",\n  w = s++;\ni[w] = \"^\" + b + \"$\";\nvar x = s++;\ni[x] = \"((?:<|>)?=?)\";\nvar E = s++;\ni[E] = i[c] + \"|x|X|\\\\*\";\nvar C = s++;\ni[C] = i[a] + \"|x|X|\\\\*\";\nvar S = s++;\ni[S] = \"[v=\\\\s]*(\" + i[C] + \")(?:\\\\.(\" + i[C] + \")(?:\\\\.(\" + i[C] + \")(?:\" + i[f] + \")?\" + i[_] + \"?)?)?\";\nvar T = s++;\ni[T] = \"[v=\\\\s]*(\" + i[E] + \")(?:\\\\.(\" + i[E] + \")(?:\\\\.(\" + i[E] + \")(?:\" + i[m] + \")?\" + i[_] + \"?)?)?\";\nvar k = s++;\ni[k] = \"^\" + i[x] + \"\\\\s*\" + i[S] + \"$\";\nvar I = s++;\ni[I] = \"^\" + i[x] + \"\\\\s*\" + i[T] + \"$\";\nvar P = s++;\ni[P] = \"(?:^|[^\\\\d])(\\\\d{1,16})(?:\\\\.(\\\\d{1,16}))?(?:\\\\.(\\\\d{1,16}))?(?:$|[^\\\\d])\";\nvar A = s++;\ni[A] = \"(?:~>?)\";\nvar O = s++;\ni[O] = \"(\\\\s*)\" + i[A] + \"\\\\s+\";\no[O] = new RegExp(i[O], \"g\");\nvar N = s++;\ni[N] = \"^\" + i[A] + i[S] + \"$\";\nvar R = s++;\ni[R] = \"^\" + i[A] + i[T] + \"$\";\nvar M = s++;\ni[M] = \"(?:\\\\^)\";\nvar L = s++;\ni[L] = \"(\\\\s*)\" + i[M] + \"\\\\s+\";\no[L] = new RegExp(i[L], \"g\");\nvar $ = s++;\ni[$] = \"^\" + i[M] + i[S] + \"$\";\nvar D = s++;\ni[D] = \"^\" + i[M] + i[T] + \"$\";\nvar F = s++;\ni[F] = \"^\" + i[x] + \"\\\\s*(\" + b + \")$|^$\";\nvar j = s++;\ni[j] = \"^\" + i[x] + \"\\\\s*(\" + v + \")$|^$\";\nvar q = s++;\ni[q] = \"(\\\\s*)\" + i[x] + \"\\\\s*(\" + b + \"|\" + i[S] + \")\";\no[q] = new RegExp(i[q], \"g\");\nvar B = s++;\ni[B] = \"^\\\\s*(\" + i[S] + \")\\\\s+-\\\\s+(\" + i[S] + \")\\\\s*$\";\nvar U = s++;\ni[U] = \"^\\\\s*(\" + i[T] + \")\\\\s+-\\\\s+(\" + i[T] + \")\\\\s*$\";\nvar H = s++;\ni[H] = \"(<|>)?=?\\\\s*\\\\*\";\nfor (var z = 0; z < 35; z++) {\n  n(z, i[z]);\n  o[z] || (o[z] = new RegExp(i[z]));\n}\nfunction parse(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  if (e.length > 256) return null;\n  if (!(t.loose ? o[w] : o[y]).test(e)) return null;\n  try {\n    return new SemVer(e, t);\n  } catch (e) {\n    return null;\n  }\n}\nfunction SemVer(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof SemVer) {\n    if (e.loose === t.loose) return e;\n    e = e.version;\n  } else if (\"string\" != typeof e) throw new TypeError(\"Invalid Version: \" + e);\n  if (e.length > 256) throw new TypeError(\"version is longer than 256 characters\");\n  if (!(this instanceof SemVer)) return new SemVer(e, t);\n  n(\"SemVer\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  var i = e.trim().match(t.loose ? o[w] : o[y]);\n  if (!i) throw new TypeError(\"Invalid Version: \" + e);\n  this.raw = e;\n  this.major = +i[1];\n  this.minor = +i[2];\n  this.patch = +i[3];\n  if (this.major > r || this.major < 0) throw new TypeError(\"Invalid major version\");\n  if (this.minor > r || this.minor < 0) throw new TypeError(\"Invalid minor version\");\n  if (this.patch > r || this.patch < 0) throw new TypeError(\"Invalid patch version\");\n  i[4] ? this.prerelease = i[4].split(\".\").map(function (e) {\n    if (/^[0-9]+$/.test(e)) {\n      var t = +e;\n      if (t >= 0 && t < r) return t;\n    }\n    return e;\n  }) : this.prerelease = [];\n  this.build = i[5] ? i[5].split(\".\") : [];\n  this.format();\n}\nexports.parse = parse;\nexports.valid = function (e, t) {\n  var n = parse(e, t);\n  return n ? n.version : null;\n};\nexports.clean = function (e, t) {\n  var n = parse(e.trim().replace(/^[=v]+/, \"\"), t);\n  return n ? n.version : null;\n};\nexports.SemVer = SemVer;\nSemVer.prototype.format = function () {\n  this.version = this.major + \".\" + this.minor + \".\" + this.patch;\n  this.prerelease.length && (this.version += \"-\" + this.prerelease.join(\".\"));\n  return this.version;\n};\nSemVer.prototype.toString = function () {\n  return this.version;\n};\nSemVer.prototype.compare = function (e) {\n  n(\"SemVer.compare\", this.version, this.options, e);\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  return this.compareMain(e) || this.comparePre(e);\n};\nSemVer.prototype.compareMain = function (e) {\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  return compareIdentifiers(this.major, e.major) || compareIdentifiers(this.minor, e.minor) || compareIdentifiers(this.patch, e.patch);\n};\nSemVer.prototype.comparePre = function (e) {\n  e instanceof SemVer || (e = new SemVer(e, this.options));\n  if (this.prerelease.length && !e.prerelease.length) return -1;\n  if (!this.prerelease.length && e.prerelease.length) return 1;\n  if (!this.prerelease.length && !e.prerelease.length) return 0;\n  var t = 0;\n  do {\n    var r = this.prerelease[t],\n      o = e.prerelease[t];\n    n(\"prerelease compare\", t, r, o);\n    if (void 0 === r && void 0 === o) return 0;\n    if (undefined === o) return 1;\n    if (undefined === r) return -1;\n    if (r !== o) return compareIdentifiers(r, o);\n  } while (++t);\n};\nSemVer.prototype.inc = function (e, t) {\n  switch (e) {\n    case \"premajor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc(\"pre\", t);\n      break;\n    case \"preminor\":\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc(\"pre\", t);\n      break;\n    case \"prepatch\":\n      this.prerelease.length = 0;\n      this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"prerelease\":\n      0 === this.prerelease.length && this.inc(\"patch\", t);\n      this.inc(\"pre\", t);\n      break;\n    case \"major\":\n      0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"minor\":\n      0 === this.patch && 0 !== this.prerelease.length || this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case \"patch\":\n      0 === this.prerelease.length && this.patch++;\n      this.prerelease = [];\n      break;\n    case \"pre\":\n      if (0 === this.prerelease.length) this.prerelease = [0];else {\n        for (var n = this.prerelease.length; --n >= 0;) \"number\" == typeof this.prerelease[n] && (this.prerelease[n]++, n = -2);\n        -1 === n && this.prerelease.push(0);\n      }\n      t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);\n      break;\n    default:\n      throw new Error(\"invalid increment argument: \" + e);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\nexports.inc = function (e, t, n, r) {\n  \"string\" == typeof n && (r = n, n = undefined);\n  try {\n    return new SemVer(e, n).inc(t, r).version;\n  } catch (e) {\n    return null;\n  }\n};\nexports.diff = function (e, t) {\n  if (eq(e, t)) return null;\n  var n = parse(e),\n    r = parse(t),\n    o = \"\";\n  if (n.prerelease.length || r.prerelease.length) {\n    o = \"pre\";\n    var i = \"prerelease\";\n  }\n  for (var s in n) if ((\"major\" === s || \"minor\" === s || \"patch\" === s) && n[s] !== r[s]) return o + s;\n  return i;\n};\nexports.compareIdentifiers = compareIdentifiers;\nvar W = /^[0-9]+$/;\nfunction compareIdentifiers(e, t) {\n  var n = W.test(e),\n    r = W.test(t);\n  n && r && (e = +e, t = +t);\n  return e === t ? 0 : n && !r ? -1 : r && !n ? 1 : e < t ? -1 : 1;\n}\nfunction compare(e, t, n) {\n  return new SemVer(e, n).compare(new SemVer(t, n));\n}\nfunction gt(e, t, n) {\n  return compare(e, t, n) > 0;\n}\nfunction lt(e, t, n) {\n  return compare(e, t, n) < 0;\n}\nfunction eq(e, t, n) {\n  return 0 === compare(e, t, n);\n}\nfunction neq(e, t, n) {\n  return 0 !== compare(e, t, n);\n}\nfunction ee(e, t, n) {\n  return compare(e, t, n) >= 0;\n}\nfunction te(e, t, n) {\n  return compare(e, t, n) <= 0;\n}\nfunction ne(e, t, n, r) {\n  switch (t) {\n    case \"===\":\n      \"object\" == typeof e && (e = e.version);\n      \"object\" == typeof n && (n = n.version);\n      return e === n;\n    case \"!==\":\n      \"object\" == typeof e && (e = e.version);\n      \"object\" == typeof n && (n = n.version);\n      return e !== n;\n    case \"\":\n    case \"=\":\n    case \"==\":\n      return eq(e, n, r);\n    case \"!=\":\n      return neq(e, n, r);\n    case \">\":\n      return gt(e, n, r);\n    case \">=\":\n      return ee(e, n, r);\n    case \"<\":\n      return lt(e, n, r);\n    case \"<=\":\n      return te(e, n, r);\n    default:\n      throw new TypeError(\"Invalid operator: \" + t);\n  }\n}\nfunction re(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof re) {\n    if (e.loose === !!t.loose) return e;\n    e = e.value;\n  }\n  if (!(this instanceof re)) return new re(e, t);\n  n(\"comparator\", e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.parse(e);\n  this.semver === oe ? this.value = \"\" : this.value = this.operator + this.semver.version;\n  n(\"comp\", this);\n}\nexports.rcompareIdentifiers = function (e, t) {\n  return compareIdentifiers(t, e);\n};\nexports.major = function (e, t) {\n  return new SemVer(e, t).major;\n};\nexports.minor = function (e, t) {\n  return new SemVer(e, t).minor;\n};\nexports.patch = function (e, t) {\n  return new SemVer(e, t).patch;\n};\nexports.compare = compare;\nexports.compareLoose = function (e, t) {\n  return compare(e, t, !0);\n};\nexports.rcompare = function (e, t, n) {\n  return compare(t, e, n);\n};\nexports.sort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.compare(e, r, n);\n  });\n};\nexports.rsort = function (e, n) {\n  return e.sort(function (e, r) {\n    return exports.rcompare(e, r, n);\n  });\n};\nexports.gt = gt;\nexports.lt = lt;\nexports.eq = eq;\nexports.neq = neq;\nexports.gte = ee;\nexports.lte = te;\nexports.cmp = ne;\nexports.Comparator = re;\nvar oe = {};\nfunction ie(e, t) {\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (e instanceof ie) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new ie(e.raw, t);\n  if (e instanceof re) return new ie(e.value, t);\n  if (!(this instanceof ie)) return new ie(e, t);\n  this.options = t;\n  this.loose = !!t.loose;\n  this.includePrerelease = !!t.includePrerelease;\n  this.raw = e;\n  this.set = e.split(/\\s*\\|\\|\\s*/).map(function (e) {\n    return this.parseRange(e.trim());\n  }, this).filter(function (e) {\n    return e.length;\n  });\n  if (!this.set.length) throw new TypeError(\"Invalid SemVer Range: \" + e);\n  this.format();\n}\nfunction se(e) {\n  return !e || \"x\" === e.toLowerCase() || \"*\" === e;\n}\nfunction ae(e, t, n, r, o, i, s, a, c, l, u, d, p) {\n  return ((t = se(n) ? \"\" : se(r) ? \">=\" + n + \".0.0\" : se(o) ? \">=\" + n + \".\" + r + \".0\" : \">=\" + t) + \" \" + (a = se(c) ? \"\" : se(l) ? \"<\" + (+c + 1) + \".0.0\" : se(u) ? \"<\" + c + \".\" + (+l + 1) + \".0\" : d ? \"<=\" + c + \".\" + l + \".\" + u + \"-\" + d : \"<=\" + a)).trim();\n}\nfunction ce(e, t, r) {\n  for (var o = 0; o < e.length; o++) if (!e[o].test(t)) return !1;\n  if (t.prerelease.length && !r.includePrerelease) {\n    for (o = 0; o < e.length; o++) {\n      n(e[o].semver);\n      if (e[o].semver !== oe && e[o].semver.prerelease.length > 0) {\n        var i = e[o].semver;\n        if (i.major === t.major && i.minor === t.minor && i.patch === t.patch) return !0;\n      }\n    }\n    return !1;\n  }\n  return !0;\n}\nfunction le(e, t, n) {\n  try {\n    t = new ie(t, n);\n  } catch (e) {\n    return !1;\n  }\n  return t.test(e);\n}\nfunction ue(e, t, n, r) {\n  var o, i, s, a, c;\n  switch (e = new SemVer(e, r), t = new ie(t, r), n) {\n    case \">\":\n      o = gt;\n      i = te;\n      s = lt;\n      a = \">\";\n      c = \">=\";\n      break;\n    case \"<\":\n      o = lt;\n      i = ee;\n      s = gt;\n      a = \"<\";\n      c = \"<=\";\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n  if (le(e, t, r)) return !1;\n  for (var l = 0; l < t.set.length; ++l) {\n    var u = t.set[l],\n      d = null,\n      p = null;\n    u.forEach(function (e) {\n      e.semver === oe && (e = new re(\">=0.0.0\"));\n      d = d || e;\n      p = p || e;\n      o(e.semver, d.semver, r) ? d = e : s(e.semver, p.semver, r) && (p = e);\n    });\n    if (d.operator === a || d.operator === c) return !1;\n    if ((!p.operator || p.operator === a) && i(e, p.semver)) return !1;\n    if (p.operator === c && s(e, p.semver)) return !1;\n  }\n  return !0;\n}\nre.prototype.parse = function (e) {\n  var t = this.options.loose ? o[F] : o[j],\n    n = e.match(t);\n  if (!n) throw new TypeError(\"Invalid comparator: \" + e);\n  this.operator = n[1];\n  \"=\" === this.operator && (this.operator = \"\");\n  n[2] ? this.semver = new SemVer(n[2], this.options.loose) : this.semver = oe;\n};\nre.prototype.toString = function () {\n  return this.value;\n};\nre.prototype.test = function (e) {\n  n(\"Comparator.test\", e, this.options.loose);\n  return this.semver === oe || (\"string\" == typeof e && (e = new SemVer(e, this.options)), ne(e, this.operator, this.semver, this.options));\n};\nre.prototype.intersects = function (e, t) {\n  if (!(e instanceof re)) throw new TypeError(\"a Comparator is required\");\n  var n;\n  t && \"object\" == typeof t || (t = {\n    loose: !!t,\n    includePrerelease: !1\n  });\n  if (\"\" === this.operator) return n = new ie(e.value, t), le(this.value, n, t);\n  if (\"\" === e.operator) {\n    n = new ie(this.value, t);\n    return le(e.semver, n, t);\n  }\n  var r = !(\">=\" !== this.operator && \">\" !== this.operator || \">=\" !== e.operator && \">\" !== e.operator),\n    o = !(\"<=\" !== this.operator && \"<\" !== this.operator || \"<=\" !== e.operator && \"<\" !== e.operator),\n    i = this.semver.version === e.semver.version,\n    s = !(\">=\" !== this.operator && \"<=\" !== this.operator || \">=\" !== e.operator && \"<=\" !== e.operator),\n    a = ne(this.semver, \"<\", e.semver, t) && (\">=\" === this.operator || \">\" === this.operator) && (\"<=\" === e.operator || \"<\" === e.operator),\n    c = ne(this.semver, \">\", e.semver, t) && (\"<=\" === this.operator || \"<\" === this.operator) && (\">=\" === e.operator || \">\" === e.operator);\n  return r || o || i && s || a || c;\n};\nexports.Range = ie;\nie.prototype.format = function () {\n  this.range = this.set.map(function (e) {\n    return e.join(\" \").trim();\n  }).join(\"||\").trim();\n  return this.range;\n};\nie.prototype.toString = function () {\n  return this.range;\n};\nie.prototype.parseRange = function (e) {\n  var t = this.options.loose;\n  e = e.trim();\n  var r = t ? o[U] : o[B];\n  e = e.replace(r, ae);\n  n(\"hyphen replace\", e);\n  e = e.replace(o[q], \"$1$2$3\");\n  n(\"comparator trim\", e, o[q]);\n  e = (e = (e = e.replace(o[O], \"$1~\")).replace(o[L], \"$1^\")).split(/\\s+/).join(\" \");\n  var i = t ? o[F] : o[j],\n    s = e.split(\" \").map(function (e) {\n      return function (e, t) {\n        n(\"comp\", e, t);\n        e = function (e, t) {\n          return e.trim().split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              n(\"caret\", e, t);\n              var r = t.loose ? o[D] : o[$];\n              return e.replace(r, function (t, r, o, i, s) {\n                var a;\n                n(\"caret\", e, t, r, o, i, s);\n                se(r) ? a = \"\" : se(o) ? a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\" : se(i) ? a = \"0\" === r ? \">=\" + r + \".\" + o + \".0 <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".0 <\" + (+r + 1) + \".0.0\" : s ? (n(\"replaceCaret pr\", s), a = \"0\" === r ? \"0\" === o ? \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + o + \".\" + (+i + 1) : \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + (+r + 1) + \".0.0\") : (n(\"no pr\"), a = \"0\" === r ? \"0\" === o ? \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + o + \".\" + (+i + 1) : \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + (+o + 1) + \".0\" : \">=\" + r + \".\" + o + \".\" + i + \" <\" + (+r + 1) + \".0.0\");\n                n(\"caret return\", a);\n                return a;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"caret\", e);\n        e = function (e, t) {\n          return e.trim().split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              var r = t.loose ? o[R] : o[N];\n              return e.replace(r, function (t, r, o, i, s) {\n                var a;\n                n(\"tilde\", e, t, r, o, i, s);\n                se(r) ? a = \"\" : se(o) ? a = \">=\" + r + \".0.0 <\" + (+r + 1) + \".0.0\" : se(i) ? a = \">=\" + r + \".\" + o + \".0 <\" + r + \".\" + (+o + 1) + \".0\" : s ? (n(\"replaceTilde pr\", s), a = \">=\" + r + \".\" + o + \".\" + i + \"-\" + s + \" <\" + r + \".\" + (+o + 1) + \".0\") : a = \">=\" + r + \".\" + o + \".\" + i + \" <\" + r + \".\" + (+o + 1) + \".0\";\n                n(\"tilde return\", a);\n                return a;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"tildes\", e);\n        e = function (e, t) {\n          n(\"replaceXRanges\", e, t);\n          return e.split(/\\s+/).map(function (e) {\n            return function (e, t) {\n              e = e.trim();\n              var r = t.loose ? o[I] : o[k];\n              return e.replace(r, function (t, r, o, i, s, a) {\n                n(\"xRange\", e, t, r, o, i, s, a);\n                var c = se(o),\n                  l = c || se(i),\n                  u = l || se(s);\n                \"=\" === r && u && (r = \"\");\n                c ? t = \">\" === r || \"<\" === r ? \"<0.0.0\" : \"*\" : r && u ? (l && (i = 0), s = 0, \">\" === r ? (r = \">=\", l ? (o = +o + 1, i = 0, s = 0) : (i = +i + 1, s = 0)) : \"<=\" === r && (r = \"<\", l ? o = +o + 1 : i = +i + 1), t = r + o + \".\" + i + \".\" + s) : l ? t = \">=\" + o + \".0.0 <\" + (+o + 1) + \".0.0\" : u && (t = \">=\" + o + \".\" + i + \".0 <\" + o + \".\" + (+i + 1) + \".0\");\n                n(\"xRange return\", t);\n                return t;\n              });\n            }(e, t);\n          }).join(\" \");\n        }(e, t);\n        n(\"xrange\", e);\n        e = function (e, t) {\n          n(\"replaceStars\", e, t);\n          return e.trim().replace(o[H], \"\");\n        }(e, t);\n        n(\"stars\", e);\n        return e;\n      }(e, this.options);\n    }, this).join(\" \").split(/\\s+/);\n  this.options.loose && (s = s.filter(function (e) {\n    return !!e.match(i);\n  }));\n  return s.map(function (e) {\n    return new re(e, this.options);\n  }, this);\n};\nie.prototype.intersects = function (e, t) {\n  if (!(e instanceof ie)) throw new TypeError(\"a Range is required\");\n  return this.set.some(function (n) {\n    return n.every(function (n) {\n      return e.set.some(function (e) {\n        return e.every(function (e) {\n          return n.intersects(e, t);\n        });\n      });\n    });\n  });\n};\nexports.toComparators = function (e, t) {\n  return new ie(e, t).set.map(function (e) {\n    return e.map(function (e) {\n      return e.value;\n    }).join(\" \").trim().split(\" \");\n  });\n};\nie.prototype.test = function (e) {\n  if (!e) return !1;\n  \"string\" == typeof e && (e = new SemVer(e, this.options));\n  for (var t = 0; t < this.set.length; t++) if (ce(this.set[t], e, this.options)) return !0;\n  return !1;\n};\nexports.satisfies = le;\nexports.maxSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    i.test(e) && (r && -1 !== o.compare(e) || (o = new SemVer(r = e, n)));\n  });\n  return r;\n};\nexports.minSatisfying = function (e, t, n) {\n  var r = null,\n    o = null;\n  try {\n    var i = new ie(t, n);\n  } catch (e) {\n    return null;\n  }\n  e.forEach(function (e) {\n    i.test(e) && (r && 1 !== o.compare(e) || (o = new SemVer(r = e, n)));\n  });\n  return r;\n};\nexports.minVersion = function (e, t) {\n  e = new ie(e, t);\n  var n = new SemVer(\"0.0.0\");\n  if (e.test(n)) return n;\n  n = new SemVer(\"0.0.0-0\");\n  if (e.test(n)) return n;\n  n = null;\n  for (var r = 0; r < e.set.length; ++r) e.set[r].forEach(function (e) {\n    var t = new SemVer(e.semver.version);\n    switch (e.operator) {\n      case \">\":\n        0 === t.prerelease.length ? t.patch++ : t.prerelease.push(0);\n        t.raw = t.format();\n      case \"\":\n      case \">=\":\n        n && !gt(n, t) || (n = t);\n        break;\n      case \"<\":\n      case \"<=\":\n        break;\n      default:\n        throw new Error(\"Unexpected operation: \" + e.operator);\n    }\n  });\n  return n && e.test(n) ? n : null;\n};\nexports.validRange = function (e, t) {\n  try {\n    return new ie(e, t).range || \"*\";\n  } catch (e) {\n    return null;\n  }\n};\nexports.ltr = function (e, t, n) {\n  return ue(e, t, \"<\", n);\n};\nexports.gtr = function (e, t, n) {\n  return ue(e, t, \">\", n);\n};\nexports.outside = ue;\nexports.prerelease = function (e, t) {\n  var n = parse(e, t);\n  return n && n.prerelease.length ? n.prerelease : null;\n};\nexports.intersects = function (e, t, n) {\n  e = new ie(e, n);\n  t = new ie(t, n);\n  return e.intersects(t);\n};\nexports.coerce = function (e) {\n  if (e instanceof SemVer) return e;\n  if (\"string\" != typeof e) return null;\n  var t = e.match(o[P]);\n  return null == t ? null : parse(t[1] + \".\" + (t[2] || \"0\") + \".\" + (t[3] || \"0\"));\n};",
  "9024": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(4953);\nexports.postgresPool1 = {\n  versionSpecifier: \">= 1.0.0 < 3.0.0\",\n  patch: function (e) {\n    var t = e.prototype.connect;\n    e.prototype.connect = function (e) {\n      e && (arguments[0] = r.channel.bindToContext(e));\n      return t.apply(this, arguments);\n    };\n    return e;\n  }\n};\nexports.enable = function () {\n  r.channel.registerMonkeyPatch(\"pg-pool\", exports.postgresPool1);\n};",
  "9030": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.GranularityDirectory = undefined;\nconst r = require(8142),\n  o = require(862),\n  i = r.Filter.CopilotClientTimeBucket;\nexports.GranularityDirectory = class {\n  constructor(e, t) {\n    this.specs = new Map();\n    this.prefix = e;\n    this.clock = t;\n    this.defaultGranularity = o.DEFAULT_GRANULARITY(e);\n  }\n  selectGranularity(e) {\n    for (const [t, n] of this.specs.entries()) if (e.extends(t)) return n;\n    return this.defaultGranularity;\n  }\n  update(e, t, n) {\n    t = t > 1 ? t : NaN;\n    n = n > 0 ? n : NaN;\n    if (isNaN(t) && isNaN(n)) this.specs.delete(e);else {\n      const r = new o.TimeBucketGranularity(this.prefix);\n      isNaN(t) || r.setByCallBuckets(t), isNaN(n) || r.setTimePeriod(3600 * n * 1e3), this.specs.set(e, r);\n    }\n  }\n  extendFilters(e) {\n    const t = this.selectGranularity(e),\n      [n, r] = t.getCurrentAndUpComingValues(this.clock.now());\n    return {\n      newFilterSettings: e.withChange(i, n),\n      otherFilterSettingsToPrefetch: r.map(t => e.withChange(i, t))\n    };\n  }\n};",
  "9036": "module.exports = {\n  requestContextHeader: \"request-context\",\n  requestContextSourceKey: \"appId\",\n  requestContextTargetKey: \"appId\",\n  requestIdHeader: \"request-id\",\n  parentIdHeader: \"x-ms-request-id\",\n  rootIdHeader: \"x-ms-request-root-id\",\n  correlationContextHeader: \"correlation-context\",\n  traceparentHeader: \"traceparent\",\n  traceStateHeader: \"tracestate\"\n};",
  "9073": "var r = require(2337);\nmodule.exports = function e(t) {\n  if (Array.isArray(t)) return -1 !== t.indexOf(\"ssh\") || -1 !== t.indexOf(\"rsync\");\n  if (\"string\" != typeof t) return !1;\n  var n = r(t);\n  t = t.substring(t.indexOf(\"://\") + 3);\n  if (e(n)) return !0;\n  var o = new RegExp(\".([a-zA-Z\\\\d]+):(\\\\d+)/\");\n  return !t.match(o) && t.indexOf(\"@\") < t.indexOf(\":\");\n};",
  "9090": "var r,\n  o,\n  i = require(6372).wrap,\n  s = [],\n  a = 0,\n  c = !1,\n  l = [];\nfunction u(e, t) {\n  var n = e.length,\n    r = t.length,\n    o = [];\n  if (0 === n && 0 === r) return o;\n  for (var i = 0; i < n; i++) o[i] = e[i];\n  if (0 === r) return o;\n  for (var s = 0; s < r; s++) {\n    var a = !0;\n    for (i = 0; i < n; i++) if (e[i].uid === t[s].uid) {\n      a = !1;\n      break;\n    }\n    a && o.push(t[s]);\n  }\n  return o;\n}\nif (process._fatalException) {\n  var d,\n    p = !1;\n  r = function (e) {\n    var t = s.length;\n    if (p || 0 === t) return !1;\n    var n = !1;\n    p = !0;\n    for (var r = 0; r < t; ++r) {\n      var o = s[r];\n      if (0 != (8 & o.flags)) {\n        var i = d && d[o.uid];\n        n = o.error(i, e) || n;\n      }\n    }\n    p = !1;\n    l.length > 0 && (s = l.pop());\n    d = undefined;\n    return n && !c;\n  };\n  o = function (e, t, n) {\n    var r = [];\n    c = !0;\n    for (var o = 0; o < n; ++o) {\n      var i = t[o];\n      r[i.uid] = i.data;\n      if (0 != (1 & i.flags)) {\n        var a = i.create(i.data);\n        void 0 !== a && (r[i.uid] = a);\n      }\n    }\n    c = !1;\n    return function () {\n      d = r;\n      l.push(s);\n      s = u(t, s);\n      c = !0;\n      for (var o = 0; o < n; ++o) (2 & t[o].flags) > 0 && t[o].before(this, r[t[o].uid]);\n      c = !1;\n      var i = e.apply(this, arguments);\n      for (c = !0, o = 0; o < n; ++o) (4 & t[o].flags) > 0 && t[o].after(this, r[t[o].uid]);\n      c = !1;\n      s = l.pop();\n      d = undefined;\n      return i;\n    };\n  };\n  i(process, \"_fatalException\", function (e) {\n    return function (t) {\n      return r(t) || e(t);\n    };\n  });\n} else {\n  var h = !1;\n  r = function (e) {\n    if (h) throw e;\n    for (var t = !1, n = s.length, r = 0; r < n; ++r) {\n      var o = s[r];\n      0 != (8 & o.flags) && (t = o.error(null, e) || t);\n    }\n    if (!t && c) throw e;\n  };\n  o = function (e, t, n) {\n    var o = [];\n    c = !0;\n    for (var i = 0; i < n; ++i) {\n      var a = t[i];\n      o[a.uid] = a.data;\n      if (0 != (1 & a.flags)) {\n        var d = a.create(a.data);\n        void 0 !== d && (o[a.uid] = d);\n      }\n    }\n    c = !1;\n    return function () {\n      var i,\n        a = !1,\n        d = !1;\n      l.push(s);\n      s = u(t, s);\n      c = !0;\n      for (var p = 0; p < n; ++p) (2 & t[p].flags) > 0 && t[p].before(this, o[t[p].uid]);\n      c = !1;\n      try {\n        i = e.apply(this, arguments);\n      } catch (e) {\n        for (a = !0, p = 0; p < n; ++p) if (0 != (8 & s[p].flags)) try {\n          d = s[p].error(o[t[p].uid], e) || d;\n        } catch (e) {\n          throw h = !0, e;\n        }\n        if (!d) throw process.removeListener(\"uncaughtException\", r), process._originalNextTick(function () {\n          process.addListener(\"uncaughtException\", r);\n        }), e;\n      } finally {\n        if (!a || d) {\n          for (c = !0, p = 0; p < n; ++p) (4 & t[p].flags) > 0 && t[p].after(this, o[t[p].uid]);\n          c = !1;\n        }\n        s = l.pop();\n      }\n      return i;\n    };\n  };\n  process.addListener(\"uncaughtException\", r);\n}\nfunction f(e, t) {\n  \"function\" == typeof e.create && (this.create = e.create, this.flags |= 1);\n  \"function\" == typeof e.before && (this.before = e.before, this.flags |= 2);\n  \"function\" == typeof e.after && (this.after = e.after, this.flags |= 4);\n  \"function\" == typeof e.error && (this.error = e.error, this.flags |= 8);\n  this.uid = ++a;\n  this.data = undefined === t ? null : t;\n}\nfunction m(e, t) {\n  if (\"object\" != typeof e || !e) throw new TypeError(\"callbacks argument must be an object\");\n  return e instanceof f ? e : new f(e, t);\n}\nf.prototype.create = undefined;\nf.prototype.before = undefined;\nf.prototype.after = undefined;\nf.prototype.error = undefined;\nf.prototype.data = undefined;\nf.prototype.uid = 0;\nf.prototype.flags = 0;\nprocess.createAsyncListener = m;\nprocess.addAsyncListener = function (e, t) {\n  var n;\n  n = e instanceof f ? e : m(e, t);\n  for (var r = !1, o = 0; o < s.length; o++) if (n === s[o]) {\n    r = !0;\n    break;\n  }\n  r || s.push(n);\n  return n;\n};\nprocess.removeAsyncListener = function (e) {\n  for (var t = 0; t < s.length; t++) if (e === s[t]) {\n    s.splice(t, 1);\n    break;\n  }\n};\nmodule.exports = function (e) {\n  var t = s.length;\n  if (0 === t) return e;\n  for (var n = s.slice(), r = 0; r < t; ++r) if (n[r].flags > 0) return o(e, n, t);\n  return function (e, t, n) {\n    c = !0;\n    for (var r = 0; r < n; ++r) {\n      var o = t[r];\n      o.create && o.create(o.data);\n    }\n    c = !1;\n    return function () {\n      l.push(s);\n      s = u(t, s);\n      var n = e.apply(this, arguments);\n      s = l.pop();\n      return n;\n    };\n  }(e, n, t);\n};",
  "9125": "require(4433).h;\nexports.SourceMapConsumer = require(6771).SourceMapConsumer;\nrequire(7085);",
  "9166": "module.exports = require(\"applicationinsights-native-metrics\");",
  "9184": "var r = require(5687),\n  o = require(8723),\n  i = require(5282),\n  s = function () {\n    function e(e) {\n      this._config = e;\n      this._consecutiveErrors = 0;\n    }\n    e.prototype.ping = function (e, t) {\n      this._submitData(e, t, \"ping\");\n    };\n    e.prototype.post = function (e, t) {\n      this._submitData([e], t, \"post\");\n    };\n    e.prototype._submitData = function (t, n, s) {\n      var a,\n        c,\n        l = this,\n        u = JSON.stringify(t),\n        d = ((a = {})[o.disableCollectionRequestOption] = !0, a.host = this._config.quickPulseHost, a.method = \"POST\", a.path = \"/QuickPulseService.svc/\" + s + \"?ikey=\" + this._config.instrumentationKey, a.headers = ((c = {\n          Expect: \"100-continue\"\n        })[\"x-ms-qps-transmission-time\"] = 1e4 * Date.now(), c[\"Content-Type\"] = \"application/json\", c[\"Content-Length\"] = Buffer.byteLength(u), c), a),\n        p = r.request(d, function (e) {\n          var t = \"true\" === e.headers[\"x-ms-qps-subscribed\"];\n          l._consecutiveErrors = 0;\n          n(t, e);\n        });\n      p.on(\"error\", function (t) {\n        l._consecutiveErrors++;\n        var r = \"Transient error connecting to the Live Metrics endpoint. This packet will not appear in your Live Metrics Stream. Error:\";\n        l._consecutiveErrors % e.MAX_QPS_FAILURES_BEFORE_WARN == 0 ? (r = \"Live Metrics endpoint could not be reached \" + l._consecutiveErrors + \" consecutive times. Most recent error:\", i.warn(e.TAG, r, t)) : i.info(e.TAG, r, t);\n        n();\n      });\n      p.write(u);\n      p.end();\n    };\n    e.TAG = \"QuickPulseSender\";\n    e.MAX_QPS_FAILURES_BEFORE_WARN = 25;\n    return e;\n  }();\nmodule.exports = s;",
  "9189": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.Features = exports.Task = undefined;\nconst r = require(3055),\n  o = require(299),\n  i = require(3076),\n  s = require(1133),\n  a = require(7744),\n  c = require(9657),\n  l = require(219),\n  u = require(9748),\n  d = require(8142),\n  p = require(9030);\nclass h {\n  constructor(e) {\n    this.ctx = e;\n    this.cache = new i.LRUCache(200);\n  }\n  async fetchExpConfig(e) {\n    let t = this.cache.get(e.stringify());\n    t || (t = new Task(() => this.ctx.get(u.ExpConfigMaker).fetchExperiments(this.ctx, e.toHeaders()), 36e5), this.cache.put(e.stringify(), t));\n    return t.run();\n  }\n  getCachedExpConfig(e) {\n    const t = this.cache.get(e.stringify());\n    return null == t ? undefined : t.value();\n  }\n}\nclass Task {\n  constructor(e, t = 1 / 0) {\n    this.producer = e;\n    this.expirationMs = t;\n  }\n  async run() {\n    undefined === this.promise && (this.promise = this.producer(), this.storeResult(this.promise).then(() => {\n      this.expirationMs < 1 / 0 && undefined !== this.promise && setTimeout(() => this.promise = undefined, this.expirationMs);\n    }));\n    return this.promise;\n  }\n  async storeResult(e) {\n    try {\n      this.result = await e;\n    } finally {\n      undefined === this.result && (this.promise = undefined);\n    }\n  }\n  value() {\n    return this.result;\n  }\n}\nexports.Task = Task;\nclass Features {\n  constructor(e) {\n    this.ctx = e;\n    this.staticFilters = {};\n    this.dynamicFilters = {};\n    this.upcomingDynamicFilters = {};\n    this.assignments = new h(this.ctx);\n    this.granularityDirectory = new p.GranularityDirectory(\"unspecified\", e.get(o.Clock));\n  }\n  setPrefix(e) {\n    this.granularityDirectory = new p.GranularityDirectory(e, this.ctx.get(o.Clock));\n  }\n  registerStaticFilters(e) {\n    Object.assign(this.staticFilters, e);\n  }\n  registerDynamicFilter(e, t) {\n    this.dynamicFilters[e] = t;\n  }\n  getDynamicFilterValues() {\n    const e = {};\n    for (const [t, n] of Object.entries(this.dynamicFilters)) e[t] = n();\n    return e;\n  }\n  registerUpcomingDynamicFilter(e, t) {\n    this.upcomingDynamicFilters[e] = t;\n  }\n  async getAssignment(e, t = {}, n) {\n    var r, o;\n    const i = this.makeFilterSettings(t),\n      s = this.granularityDirectory.extendFilters(i),\n      a = await this.getExpConfig(s.newFilterSettings);\n    this.granularityDirectory.update(i, +(null !== (r = a.variables[l.ExpTreatmentVariables.GranularityByCallBuckets]) && undefined !== r ? r : NaN), +(null !== (o = a.variables[l.ExpTreatmentVariables.GranularityTimePeriodSizeInH]) && undefined !== o ? o : NaN));\n    const c = this.granularityDirectory.extendFilters(i),\n      u = c.newFilterSettings,\n      d = await this.getExpConfig(u);\n    let p = new Promise(e => setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs));\n    for (const e of c.otherFilterSettingsToPrefetch) p = p.then(async () => {\n      await new Promise(e => setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs));\n      this.getExpConfig(e);\n    });\n    this.prepareForUpcomingFilters(u);\n    n && (n.filtersAndExp = {\n      exp: d,\n      filters: u\n    });\n    return d.variables[e];\n  }\n  makeFilterSettings(e) {\n    return new d.FilterSettings({\n      ...this.staticFilters,\n      ...this.getDynamicFilterValues(),\n      ...e\n    });\n  }\n  async getExpConfig(e) {\n    try {\n      return this.assignments.fetchExpConfig(e);\n    } catch (e) {\n      return l.ExpConfig.createFallbackConfig(this.ctx, `Error fetching ExP config: ${e}`);\n    }\n  }\n  async prepareForUpcomingFilters(e) {\n    if (!(new Date().getMinutes() < 60 - Features.upcomingTimeBucketMinutes)) for (const [t, n] of Object.entries(this.upcomingDynamicFilters)) {\n      await new Promise(e => setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs));\n      this.getExpConfig(e.withChange(t, n()));\n    }\n  }\n  stringify() {\n    var e;\n    const t = this.assignments.getCachedExpConfig(new d.FilterSettings({}));\n    return JSON.stringify(null !== (e = null == t ? undefined : t.variables) && undefined !== e ? e : {});\n  }\n  async customEngine(e, t, n, r, o) {\n    var i;\n    const s = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t,\n      [d.Filter.CopilotDogfood]: n,\n      [d.Filter.CopilotUserKind]: r\n    };\n    return null !== (i = await this.getAssignment(l.ExpTreatmentVariables.CustomEngine, s, o)) && undefined !== i ? i : \"\";\n  }\n  async beforeRequestWaitMs(e, t, n) {\n    var r;\n    const o = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t\n    };\n    return null !== (r = await this.getAssignment(l.ExpTreatmentVariables.BeforeRequestWaitMs, o, n)) && undefined !== r ? r : 0;\n  }\n  async multiLogitBias(e, t, n) {\n    var r;\n    const o = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t\n    };\n    return null !== (r = await this.getAssignment(l.ExpTreatmentVariables.MultiLogitBias, o, n)) && undefined !== r && r;\n  }\n  async debounceMs() {\n    var e;\n    return null !== (e = await this.getAssignment(l.ExpTreatmentVariables.DebounceMs)) && undefined !== e ? e : 0;\n  }\n  async debouncePredict() {\n    var e;\n    return null !== (e = await this.getAssignment(l.ExpTreatmentVariables.DebouncePredict)) && undefined !== e && e;\n  }\n  async contextualFilterEnable() {\n    var e;\n    return null === (e = await this.getAssignment(l.ExpTreatmentVariables.ContextualFilterEnable)) || undefined === e || e;\n  }\n  async contextualFilterAcceptThreshold() {\n    var e;\n    return null !== (e = await this.getAssignment(l.ExpTreatmentVariables.ContextualFilterAcceptThreshold)) && undefined !== e ? e : a.contextualFilterAcceptThreshold;\n  }\n  async disableLogProb() {\n    var e;\n    return null !== (e = await this.getAssignment(l.ExpTreatmentVariables.disableLogProb)) && undefined !== e && e;\n  }\n  async overrideBlockMode() {\n    return await this.getAssignment(l.ExpTreatmentVariables.OverrideBlockMode);\n  }\n  async overrideNumGhostCompletions() {\n    return await this.getAssignment(l.ExpTreatmentVariables.OverrideNumGhostCompletions);\n  }\n  async suffixPercent(e, t) {\n    var n;\n    const r = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t\n    };\n    return s.getConfig(this.ctx, s.ConfigKey.DebugOverrideEngine) ? 0 : null !== (n = await this.getAssignment(l.ExpTreatmentVariables.SuffixPercent, r)) && undefined !== n ? n : 0;\n  }\n  async suffixMatchThreshold(e, t) {\n    var n;\n    const r = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t\n    };\n    return null !== (n = await this.getAssignment(l.ExpTreatmentVariables.SuffixMatchThreshold, r)) && undefined !== n ? n : 0;\n  }\n  async fimSuffixLengthThreshold(e, t) {\n    var n;\n    const r = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t\n    };\n    return null !== (n = await this.getAssignment(l.ExpTreatmentVariables.FimSuffixLengthThreshold, r)) && undefined !== n ? n : 0;\n  }\n  async suffixStartMode(e, t) {\n    const n = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t\n    };\n    switch (await this.getAssignment(l.ExpTreatmentVariables.SuffixStartMode, n)) {\n      default:\n        return r.SuffixStartMode.Cursor;\n      case \"cursortrimstart\":\n        return r.SuffixStartMode.CursorTrimStart;\n      case \"siblingblock\":\n        return r.SuffixStartMode.SiblingBlock;\n      case \"siblingblocktrimstart\":\n        return r.SuffixStartMode.SiblingBlockTrimStart;\n    }\n  }\n  async neighboringTabsOption(e, t) {\n    const n = {\n      [d.Filter.CopilotRepository]: e,\n      [d.Filter.CopilotFileType]: t\n    };\n    switch (await this.getAssignment(l.ExpTreatmentVariables.NeighboringTabsOption, n)) {\n      case \"none\":\n        return r.NeighboringTabsOption.None;\n      case \"conservative\":\n        return r.NeighboringTabsOption.Conservative;\n      case \"medium\":\n        return r.NeighboringTabsOption.Medium;\n      default:\n        return r.NeighboringTabsOption.Eager;\n      case \"eagerbutlittle\":\n        return r.NeighboringTabsOption.EagerButLittle;\n    }\n  }\n  async repetitionFilterMode() {\n    switch (await this.getAssignment(l.ExpTreatmentVariables.RepetitionFilterMode)) {\n      case \"proxy\":\n        return c.RepetitionFilterMode.PROXY;\n      case \"both\":\n        return c.RepetitionFilterMode.BOTH;\n      default:\n        return c.RepetitionFilterMode.CLIENT;\n    }\n  }\n  async addExpAndFilterToTelemetry(e) {\n    const t = this.makeFilterSettings({});\n    e.filtersAndExp = {\n      filters: t,\n      exp: await this.getExpConfig(t)\n    };\n  }\n}\nexports.Features = Features;\nFeatures.upcomingDynamicFilterCheckDelayMs = 20;\nFeatures.upcomingTimeBucketMinutes = 5 + Math.floor(11 * Math.random());",
  "9216": "function n(e, r, o, i, s, a) {\n  var c = Math.floor((r - e) / 2) + e,\n    l = s(o, i[c], !0);\n  return 0 === l ? c : l > 0 ? r - c > 1 ? n(c, r, o, i, s, a) : a == exports.LEAST_UPPER_BOUND ? r < i.length ? r : -1 : c : c - e > 1 ? n(e, c, o, i, s, a) : a == exports.LEAST_UPPER_BOUND ? c : e < 0 ? -1 : e;\n}\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\nexports.search = function (e, r, o, i) {\n  if (0 === r.length) return -1;\n  var s = n(-1, r.length, e, r, o, i || exports.GREATEST_LOWER_BOUND);\n  if (s < 0) return -1;\n  for (; s - 1 >= 0 && 0 === o(r[s], r[s - 1], !0);) --s;\n  return s;\n};",
  "9253": "var r = require(9962),\n  o = require(5158),\n  i = require(3580),\n  s = require(7310),\n  a = function () {\n    function e(t) {\n      var n = this;\n      this.endpointBase = i.DEFAULT_BREEZE_ENDPOINT;\n      var r = process.env[e.ENV_connectionString],\n        a = o.parse(t),\n        c = o.parse(r),\n        l = !a.instrumentationkey && Object.keys(a).length > 0 ? null : t;\n      this.instrumentationKey = a.instrumentationkey || l || c.instrumentationkey || e._getInstrumentationKey();\n      this.endpointUrl = (a.ingestionendpoint || c.ingestionendpoint || this.endpointBase) + \"/v2/track\";\n      this.maxBatchSize = 250;\n      this.maxBatchIntervalMs = 15e3;\n      this.disableAppInsights = !1;\n      this.samplingPercentage = 100;\n      this.correlationIdRetryIntervalMs = 3e4;\n      this.correlationHeaderExcludedDomains = [\"*.core.windows.net\", \"*.core.chinacloudapi.cn\", \"*.core.cloudapi.de\", \"*.core.usgovcloudapi.net\", \"*.core.microsoft.scloud\", \"*.core.eaglex.ic.gov\"];\n      this.setCorrelationId = function (e) {\n        return n.correlationId = e;\n      };\n      this.proxyHttpUrl = process.env[e.ENV_http_proxy] || undefined;\n      this.proxyHttpsUrl = process.env[e.ENV_https_proxy] || undefined;\n      this.httpAgent = undefined;\n      this.httpsAgent = undefined;\n      this.profileQueryEndpoint = a.ingestionendpoint || c.ingestionendpoint || process.env[e.ENV_profileQueryEndpoint] || this.endpointBase;\n      this._quickPulseHost = a.liveendpoint || c.liveendpoint || process.env[e.ENV_quickPulseHost] || i.DEFAULT_LIVEMETRICS_HOST;\n      this._quickPulseHost.match(/^https?:\\/\\//) && (this._quickPulseHost = s.parse(this._quickPulseHost).host);\n    }\n    Object.defineProperty(e.prototype, \"profileQueryEndpoint\", {\n      get: function () {\n        return this._profileQueryEndpoint;\n      },\n      set: function (e) {\n        r.cancelCorrelationIdQuery(this, this.setCorrelationId);\n        this._profileQueryEndpoint = e;\n        this.correlationId = r.correlationIdPrefix;\n        r.queryCorrelationId(this, this.setCorrelationId);\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n    Object.defineProperty(e.prototype, \"quickPulseHost\", {\n      get: function () {\n        return this._quickPulseHost;\n      },\n      set: function (e) {\n        this._quickPulseHost = e;\n      },\n      enumerable: !0,\n      configurable: !0\n    });\n    e._getInstrumentationKey = function () {\n      var t = process.env[e.ENV_iKey] || process.env[e.ENV_azurePrefix + e.ENV_iKey] || process.env[e.legacy_ENV_iKey] || process.env[e.ENV_azurePrefix + e.legacy_ENV_iKey];\n      if (!t || \"\" == t) throw new Error(\"Instrumentation key not found, pass the key in the config to this method or set the key in the environment variable APPINSIGHTS_INSTRUMENTATIONKEY before starting the server\");\n      return t;\n    };\n    e.ENV_azurePrefix = \"APPSETTING_\";\n    e.ENV_iKey = \"APPINSIGHTS_INSTRUMENTATIONKEY\";\n    e.legacy_ENV_iKey = \"APPINSIGHTS_INSTRUMENTATION_KEY\";\n    e.ENV_profileQueryEndpoint = \"APPINSIGHTS_PROFILE_QUERY_ENDPOINT\";\n    e.ENV_quickPulseHost = \"APPINSIGHTS_QUICKPULSE_HOST\";\n    e.ENV_connectionString = \"APPLICATIONINSIGHTS_CONNECTION_STRING\";\n    e.ENV_nativeMetricsDisablers = \"APPLICATION_INSIGHTS_DISABLE_EXTENDED_METRIC\";\n    e.ENV_nativeMetricsDisableAll = \"APPLICATION_INSIGHTS_DISABLE_ALL_EXTENDED_METRICS\";\n    e.ENV_http_proxy = \"http_proxy\";\n    e.ENV_https_proxy = \"https_proxy\";\n    return e;\n  }();\nmodule.exports = a;",
  "9266": "var r = require(3905),\n  o = require(9073);\nmodule.exports = function (e) {\n  var t = r(e);\n  t.token = \"\";\n  \"x-oauth-basic\" === t.password ? t.token = t.user : \"x-token-auth\" === t.user && (t.token = t.password);\n  o(t.protocols) || 0 === t.protocols.length && o(e) ? t.protocol = \"ssh\" : t.protocols.length ? t.protocol = t.protocols[0] : (t.protocol = \"file\", t.protocols = [\"file\"]);\n  t.href = t.href.replace(/\\/$/, \"\");\n  return t;\n};",
  "9306": "var n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.DiscrError = undefined;\n(n = exports.DiscrError || (exports.DiscrError = {})).Tag = \"tag\";\nn.Mapping = \"mapping\";",
  "9334": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getGhostText = exports.completionCache = exports.ResultType = exports.ghostTextLogger = undefined;\nconst r = require(3055),\n  o = require(2277),\n  i = require(3076),\n  s = require(106),\n  a = require(6932),\n  c = require(1133),\n  l = require(9189),\n  u = require(9899),\n  d = require(2279),\n  p = require(3),\n  h = require(4419),\n  f = require(937),\n  m = require(6722),\n  g = require(7727),\n  _ = require(4969),\n  y = require(766),\n  v = require(1006),\n  b = require(1124),\n  w = require(6333),\n  x = require(70),\n  E = require(6403),\n  C = require(8965),\n  S = require(5413),\n  T = require(750);\nvar k;\nlet I, P;\nasync function A(e, n, r, o, i, s, a) {\n  var u, p, m;\n  exports.ghostTextLogger.debug(e, `Getting ${s} from network`);\n  r = r.extendedBy();\n  const g = await async function (e, t) {\n      const n = await e.get(l.Features).overrideNumGhostCompletions();\n      return n ? t.isCycling ? Math.max(0, 3 - n) : n : c.shouldDoParsingTrimming(t.blockMode) && t.multiline ? c.getConfig(e, c.ConfigKey.InlineSuggestCount) : t.isCycling ? 2 : 1;\n    }(e, n),\n    _ = f.getTemperatureForSamples(e, g),\n    y = {\n      stream: !0,\n      n: g,\n      temperature: _,\n      extra: {\n        language: n.languageId,\n        next_indent: null !== (u = n.indentation.next) && undefined !== u ? u : 0,\n        trim_by_indentation: c.shouldDoServerTrimming(n.blockMode)\n      }\n    };\n  n.multiline || (y.stop = [\"\\n\"]);\n  n.multiline && n.multiLogitBias && (y.logit_bias = {\n    50256: -100\n  });\n  const v = Date.now(),\n    b = {\n      endpoint: \"completions\",\n      uiKind: h.CopilotUiKind.GhostText,\n      isCycling: JSON.stringify(n.isCycling),\n      temperature: JSON.stringify(_),\n      n: JSON.stringify(g),\n      stop: null !== (p = JSON.stringify(y.stop)) && undefined !== p ? p : \"unset\",\n      logit_bias: JSON.stringify(null !== (m = y.logit_bias) && undefined !== m ? m : null)\n    },\n    E = w.telemetrizePromptLength(n.prompt);\n  Object.assign(r.properties, b);\n  Object.assign(r.measurements, E);\n  try {\n    const s = {\n      prompt: n.prompt,\n      languageId: n.languageId,\n      repoInfo: n.repoInfo,\n      ourRequestId: n.ourRequestId,\n      engineUrl: n.engineURL,\n      count: g,\n      uiKind: h.CopilotUiKind.GhostText,\n      postOptions: y\n    };\n    n.delayMs > 0 && (await new Promise(e => setTimeout(e, n.delayMs)));\n    const c = await e.get(h.OpenAIFetcher).fetchAndStreamCompletions(e, s, r, i, o);\n    return \"failed\" === c.type ? {\n      type: \"failed\",\n      reason: c.reason,\n      telemetryData: T.mkBasicResultTelemetry(r)\n    } : \"canceled\" === c.type ? (exports.ghostTextLogger.debug(e, \"Cancelled after awaiting fetchCompletions\"), {\n      type: \"canceled\",\n      reason: c.reason,\n      telemetryData: T.mkCanceledResultTelemetry(r)\n    }) : a(g, v, c.getProcessingTime(), c.choices);\n  } catch (n) {\n    if (d.isAbortError(n)) return {\n      type: \"canceled\",\n      reason: \"network request aborted\",\n      telemetryData: T.mkCanceledResultTelemetry(r, {\n        cancelledNetworkRequest: !0\n      })\n    };\n    exports.ghostTextLogger.error(e, `Error on ghost text request ${n}`);\n    if ((0, x.shouldFailForDebugPurposes)(e)) throw n;\n    return {\n      type: \"failed\",\n      reason: \"non-abort error on ghost text request\",\n      telemetryData: T.mkBasicResultTelemetry(r)\n    };\n  }\n}\nfunction O(e, t) {\n  const n = {\n    ...e\n  };\n  n.completionText = e.completionText.trimEnd();\n  t.forceSingleLine && (n.completionText = n.completionText.split(\"\\n\")[0]);\n  return n;\n}\nexports.ghostTextLogger = new u.Logger(u.LogLevel.INFO, \"ghostText\");\n(function (e) {\n  e[e.Network = 0] = \"Network\";\n  e[e.Cache = 1] = \"Cache\";\n  e[e.TypingAsSuggested = 2] = \"TypingAsSuggested\";\n  e[e.Cycling = 3] = \"Cycling\";\n})(k = exports.ResultType || (exports.ResultType = {}));\nexports.completionCache = new i.LRUCache(100);\nconst N = new s.Debouncer();\nfunction R(e, t) {\n  I = e;\n  P = t;\n}\nfunction M(e, n, r) {\n  const o = i.keyForPrompt(n.prompt),\n    s = exports.completionCache.get(o);\n  s && s.multiline === r.multiline ? exports.completionCache.put(o, {\n    multiline: s.multiline,\n    choices: s.choices.concat(r.choices)\n  }) : exports.completionCache.put(o, r);\n  exports.ghostTextLogger.debug(e, `Appended cached ghost text for key: ${o}, multiline: ${r.multiline}, number of suggestions: ${r.choices.length}`);\n}\nfunction L(e, n) {\n  const r = exports.completionCache.get(e);\n  if (r && (!n || r.multiline)) return r.choices;\n}\nfunction $(e, t, n) {\n  if (n.length > 0) {\n    if (t.startsWith(n)) return {\n      completionIndex: e,\n      completionText: t,\n      displayText: t.substr(n.length),\n      displayNeedsWsOffset: !1\n    };\n    {\n      const r = t.substr(0, t.length - t.trimLeft().length);\n      return n.startsWith(r) ? {\n        completionIndex: e,\n        completionText: t,\n        displayText: t.trimLeft(),\n        displayNeedsWsOffset: !0\n      } : {\n        completionIndex: e,\n        completionText: t,\n        displayText: t,\n        displayNeedsWsOffset: !1\n      };\n    }\n  }\n  return {\n    completionIndex: e,\n    completionText: t,\n    displayText: t,\n    displayNeedsWsOffset: !1\n  };\n}\nfunction D(e, n) {\n  const r = n.requestId,\n    o = {\n      choiceIndex: n.choiceIndex.toString()\n    },\n    i = {\n      numTokens: n.numTokens,\n      compCharLen: n.completionText.length,\n      numLines: n.completionText.split(\"\\n\").length\n    };\n  n.meanLogProb && (i.meanLogProb = n.meanLogProb);\n  n.meanAlternativeLogProb && (i.meanAlternativeLogProb = n.meanAlternativeLogProb);\n  const s = n.telemetryData.extendedBy(o, i);\n  s.extendWithRequestId(r);\n  s.measurements.confidence = v.ghostTextScoreConfidence(e, s);\n  s.measurements.quantile = v.ghostTextScoreQuantile(e, s);\n  exports.ghostTextLogger.debug(e, `Extended telemetry for ${n.telemetryData.properties.headerRequestId} with retention confidence ${s.measurements.confidence} (expected as good or better than about ${s.measurements.quantile} of all suggestions)`);\n  return s;\n}\nfunction F(e, t, n, r, o) {\n  const i = Date.now() - r,\n    s = i - o,\n    a = n.telemetryData.extendedBy({}, {\n      completionCharLen: n.completionText.length,\n      requestTimeMs: i,\n      processingTimeMs: o,\n      deltaMs: s,\n      meanLogProb: n.meanLogProb || NaN,\n      meanAlternativeLogProb: n.meanAlternativeLogProb || NaN,\n      numTokens: n.numTokens\n    });\n  a.extendWithRequestId(n.requestId);\n  w.telemetry(e, `ghostText.${t}`, a);\n}\nexports.getGhostText = async function (e, n, s, u, d, f) {\n  var v, j;\n  const q = await _.extractPrompt(e, n, s);\n  if (\"contextTooShort\" === q.type) {\n    exports.ghostTextLogger.debug(e, \"Breaking, not enough context\");\n    return {\n      type: \"abortedBeforeIssued\",\n      reason: \"Not enough context\"\n    };\n  }\n  if (null == f ? undefined : f.isCancellationRequested) {\n    exports.ghostTextLogger.info(e, \"Cancelled after extractPrompt\");\n    return {\n      type: \"abortedBeforeIssued\",\n      reason: \"Cancelled after extractPrompt\"\n    };\n  }\n  const B = function (e, t) {\n    const n = (o = t, 0 != e.lineAt(o).text.substr(o.character).trim().length),\n      r = function (e, t) {\n        const n = t.lineAt(e).text.substr(e.character).trim();\n        return /^\\s*[)}\\]\"'`]*\\s*[:{;,]?\\s*$/.test(n);\n      }(t, e);\n    var o;\n    if (!n || r) return n && r;\n  }(n, s);\n  if (undefined === B) {\n    exports.ghostTextLogger.debug(e, \"Breaking, invalid middle of the line\");\n    return {\n      type: \"abortedBeforeIssued\",\n      reason: \"Invalid middle of the line\"\n    };\n  }\n  const U = e.get(m.StatusReporter),\n    H = e.get(E.LocationFactory),\n    z = await async function (e, t, n, o, i, s) {\n      const a = await e.get(c.BlockModeConfig).forLanguage(e, t.languageId);\n      switch (a) {\n        case c.BlockMode.Server:\n          return {\n            blockMode: c.BlockMode.Server,\n            requestMultiline: !0,\n            isCyclingRequest: i,\n            finishedCb: async e => {}\n          };\n        case c.BlockMode.Parsing:\n        case c.BlockMode.ParsingAndServer:\n        default:\n          {\n            const c = await async function (e, t, n, o) {\n              if (t.lineCount >= 8e3) w.telemetry(e, \"ghostText.longFileMultilineSkip\", w.TelemetryData.createAndMarkAsIssued({\n                languageId: t.languageId,\n                lineCount: String(t.lineCount),\n                currentLine: String(n.line)\n              }));else {\n                if (!o && r.isSupportedLanguageId(t.languageId)) return await g.isEmptyBlockStart(t, n);\n                if (o && r.isSupportedLanguageId(t.languageId)) return (await g.isEmptyBlockStart(t, n)) || (await g.isEmptyBlockStart(t, t.lineAt(n).range.end));\n              }\n              return !1;\n            }(e, t, n, s);\n            return c ? {\n              blockMode: a,\n              requestMultiline: !0,\n              isCyclingRequest: !1,\n              finishedCb: async r => {\n                let i;\n                i = o.trailingWs.length > 0 && !o.prompt.prefix.endsWith(o.trailingWs) ? e.get(E.LocationFactory).position(n.line, Math.max(n.character - o.trailingWs.length, 0)) : n;\n                return g.isBlockBodyFinished(e, t, i, r);\n              }\n            } : {\n              blockMode: a,\n              requestMultiline: !1,\n              isCyclingRequest: i,\n              finishedCb: async e => {}\n            };\n          }\n      }\n    }(e, n, s, q, u, B);\n  if (null == f ? undefined : f.isCancellationRequested) {\n    exports.ghostTextLogger.info(e, \"Cancelled after requestMultiline\");\n    return {\n      type: \"abortedBeforeIssued\",\n      reason: \"Cancelled after requestMultiline\"\n    };\n  }\n  const [G] = _.trimLastLine(n.getText(H.range(H.position(0, 0), s)));\n  let V = function (e, n, r, o) {\n    const s = function (e, n, r) {\n      if (!I || !P || !n.startsWith(I)) return;\n      const o = L(P, r);\n      if (!o) return;\n      const i = n.substring(I.length);\n      exports.ghostTextLogger.debug(e, `Getting completions for user-typing flow - remaining prefix: ${i}`);\n      const s = [];\n      o.forEach(e => {\n        const t = O(e, {\n          forceSingleLine: !1\n        });\n        t.completionText.startsWith(i) && (t.completionText = t.completionText.substring(i.length), s.push(t));\n      });\n      return s;\n    }(e, n, o);\n    if (s && s.length > 0) return [s, k.TypingAsSuggested];\n    const a = function (e, n, r, o) {\n      const s = i.keyForPrompt(r);\n      exports.ghostTextLogger.debug(e, `Trying to get completions from cache for key: ${s}`);\n      const a = L(s, o);\n      if (a) {\n        exports.ghostTextLogger.debug(e, `Got completions from cache for key: ${s}`);\n        const r = [];\n        a.forEach(e => {\n          const t = O(e, {\n            forceSingleLine: !o\n          });\n          r.push(t);\n        });\n        const i = r.filter(e => e.completionText);\n        i.length > 0 && R(n, s);\n        return i;\n      }\n    }(e, n, r, o);\n    return a && a.length > 0 ? [a, k.Cache] : undefined;\n  }(e, G, q.prompt, z.requestMultiline);\n  const W = o.v4(),\n    K = y.extractRepoInfoInBackground(e, n.fileName),\n    J = await p.getEngineURL(e, y.tryGetGitHubNWO(K), n.languageId, y.getDogFood(K), await y.getUserKind(e), d),\n    X = await e.get(l.Features).beforeRequestWaitMs(y.tryGetGitHubNWO(K) || \"\", n.languageId),\n    Q = await e.get(l.Features).multiLogitBias(y.tryGetGitHubNWO(K) || \"\", n.languageId),\n    Y = {\n      blockMode: z.blockMode,\n      languageId: n.languageId,\n      repoInfo: K,\n      engineURL: J,\n      ourRequestId: W,\n      prefix: G,\n      prompt: q.prompt,\n      multiline: z.requestMultiline,\n      indentation: g.contextIndentation(n, s),\n      isCycling: u,\n      delayMs: X,\n      multiLogitBias: Q\n    },\n    Z = await e.get(l.Features).debouncePredict(),\n    ee = await e.get(l.Features).contextualFilterEnable(),\n    te = await e.get(l.Features).contextualFilterAcceptThreshold();\n  let ne = !1;\n  (Z || ee) && (ne = !0);\n  const re = function (e, t, n, r, o, i, s) {\n    const a = e.get(E.LocationFactory),\n      c = t.lineAt(r.line),\n      l = t.getText(a.range(c.range.start, r)),\n      u = t.getText(a.range(r, c.range.end)),\n      d = {\n        languageId: t.languageId,\n        beforeCursorWhitespace: JSON.stringify(\"\" === l.trim()),\n        afterCursorWhitespace: JSON.stringify(\"\" === u.trim())\n      },\n      p = {\n        ...w.telemetrizePromptLength(o.prompt),\n        promptEndPos: t.offsetAt(r),\n        documentLength: t.getText().length,\n        delayMs: n.delayMs\n      },\n      f = i.extendedBy(d, p);\n    f.properties.promptChoices = JSON.stringify(o.promptChoices, (e, t) => t instanceof Map ? Array.from(t.entries()).reduce((e, [t, n]) => ({\n      ...e,\n      [t]: n\n    }), {}) : t);\n    f.properties.promptBackground = JSON.stringify(o.promptBackground, (e, t) => t instanceof Map ? Array.from(t.values()) : t);\n    f.measurements.promptComputeTimeMs = o.computeTimeMs;\n    s && (f.measurements.contextualFilterScore = C.contextualFilterScore(e, f, o.prompt));\n    const m = n.repoInfo;\n    f.properties.gitRepoInformation = undefined === m ? \"unavailable\" : m === y.ComputationStatus.PENDING ? \"pending\" : \"available\";\n    undefined !== m && m !== y.ComputationStatus.PENDING && (f.properties.gitRepoUrl = m.url, f.properties.gitRepoHost = m.hostname, f.properties.gitRepoOwner = m.owner, f.properties.gitRepoName = m.repo, f.properties.gitRepoPath = m.pathname);\n    f.properties.engineName = h.extractEngineName(e, n.engineURL);\n    f.properties.isMultiline = JSON.stringify(n.multiline);\n    f.properties.blockMode = n.blockMode;\n    f.properties.isCycling = JSON.stringify(n.isCycling);\n    f.properties.headerRequestId = n.ourRequestId;\n    w.telemetry(e, \"ghostText.issued\", f);\n    return f;\n  }(e, n, Y, s, q, d, ne);\n  if (z.isCyclingRequest && (null !== (v = null == V ? undefined : V[0].length) && undefined !== v ? v : 0) > 1 || !z.isCyclingRequest && undefined !== V) exports.ghostTextLogger.info(e, \"Found inline suggestions locally\");else {\n    null == U || U.setProgress();\n    if (z.isCyclingRequest) {\n      const n = await async function (e, n, r, o, i) {\n        return A(e, n, r, o, i, \"all completions\", async (i, s, a, c) => {\n          const l = [];\n          for await (const n of c) {\n            if (null == o ? void 0 : o.isCancellationRequested) return exports.ghostTextLogger.debug(e, \"Cancelled after awaiting choices iterator\"), {\n              type: \"canceled\",\n              reason: \"after awaiting choices iterator\",\n              telemetryData: (0, T.mkCanceledResultTelemetry)(r)\n            };\n            if (n.completionText.trimEnd()) {\n              if (-1 !== l.findIndex(e => e.completionText.trim() === n.completionText.trim())) continue;\n              l.push(n);\n            }\n          }\n          return l.length > 0 && (M(e, n, {\n            multiline: n.multiline,\n            choices: l\n          }), F(e, \"cyclingPerformance\", l[0], s, a)), {\n            type: \"success\",\n            value: l,\n            telemetryData: (0, T.mkBasicResultTelemetry)(r),\n            telemetryBlob: r\n          };\n        });\n      }(e, Y, re, f, z.finishedCb);\n      if (\"success\" === n.type) {\n        const e = null !== (j = null == V ? void 0 : V[0]) && void 0 !== j ? j : [];\n        n.value.forEach(t => {\n          -1 === e.findIndex(e => e.completionText.trim() === t.completionText.trim()) && e.push(t);\n        }), V = [e, k.Cycling];\n      } else if (void 0 === V) return null == U || U.removeProgress(), n;\n    } else {\n      const n = await (0, S.getDebounceLimit)(e, re);\n      try {\n        await N.debounce(n);\n      } catch {\n        return {\n          type: \"canceled\",\n          reason: \"by debouncer\",\n          telemetryData: (0, T.mkCanceledResultTelemetry)(re)\n        };\n      }\n      if (null == f ? void 0 : f.isCancellationRequested) return exports.ghostTextLogger.info(e, \"Cancelled during debounce\"), {\n        type: \"canceled\",\n        reason: \"during debounce\",\n        telemetryData: (0, T.mkCanceledResultTelemetry)(re)\n      };\n      if (ee && re.measurements.contextualFilterScore && re.measurements.contextualFilterScore < te / 100) return exports.ghostTextLogger.info(e, \"Cancelled by contextual filter\"), {\n        type: \"canceled\",\n        reason: \"contextualFilterScore below threshold\",\n        telemetryData: (0, T.mkCanceledResultTelemetry)(re)\n      };\n      const r = await async function (e, n, r, o, s) {\n        return A(e, n, r, o, s, \"completions\", async (s, a, c, l) => {\n          const u = l[Symbol.asyncIterator](),\n            d = await u.next();\n          if (d.done) return exports.ghostTextLogger.debug(e, \"All choices redacted\"), {\n            type: \"empty\",\n            reason: \"all choices redacted\",\n            telemetryData: (0, T.mkBasicResultTelemetry)(r)\n          };\n          if (null == o ? void 0 : o.isCancellationRequested) return exports.ghostTextLogger.debug(e, \"Cancelled after awaiting redactedChoices iterator\"), {\n            type: \"canceled\",\n            reason: \"after awaiting redactedChoices iterator\",\n            telemetryData: (0, T.mkCanceledResultTelemetry)(r)\n          };\n          const p = d.value;\n          if (void 0 === p) return exports.ghostTextLogger.debug(e, \"Got undefined choice from redactedChoices iterator\"), {\n            type: \"empty\",\n            reason: \"got undefined choice from redactedChoices iterator\",\n            telemetryData: (0, T.mkBasicResultTelemetry)(r)\n          };\n          F(e, \"performance\", p, a, c);\n          const h = s - 1;\n          exports.ghostTextLogger.debug(e, `Awaited first result, id:  ${p.choiceIndex}`), function (e, n, r) {\n            const o = (0, i.keyForPrompt)(n.prompt);\n            R(n.prefix, o), exports.completionCache.put(o, r), exports.ghostTextLogger.debug(e, `Cached ghost text for key: ${o}, multiline: ${r.multiline}, number of suggestions: ${r.choices.length}`);\n          }(e, n, {\n            multiline: n.multiline,\n            choices: [p]\n          });\n          const f = [];\n          for (let e = 0; e < h; e++) f.push(u.next());\n          const m = Promise.all(f).then(r => {\n            exports.ghostTextLogger.debug(e, `Awaited remaining results, number of results: ${r.length}`);\n            const o = [];\n            for (const n of r) {\n              const r = n.value;\n              if (void 0 !== r && (exports.ghostTextLogger.info(e, `GhostText later completion: [${r.completionText}]`), r.completionText.trimEnd())) {\n                if (-1 !== o.findIndex(e => e.completionText.trim() === r.completionText.trim())) continue;\n                if (r.completionText.trim() === p.completionText.trim()) continue;\n                o.push(r);\n              }\n            }\n            o.length > 0 && M(e, n, {\n              multiline: n.multiline,\n              choices: o\n            });\n          });\n          return (0, x.isRunningInTest)(e) && (await m), {\n            type: \"success\",\n            value: O(d.value, {\n              forceSingleLine: !1\n            }),\n            telemetryData: (0, T.mkBasicResultTelemetry)(r),\n            telemetryBlob: r\n          };\n        });\n      }(e, Y, re, f, z.finishedCb);\n      if (\"success\" !== r.type) return null == U || U.removeProgress(), r;\n      V = [[r.value], k.Network];\n    }\n    null == U || U.removeProgress();\n  }\n  if (undefined === V) return {\n    type: \"failed\",\n    reason: \"internal error: choices should be defined after network call\",\n    telemetryData: T.mkBasicResultTelemetry(re)\n  };\n  const [oe, ie] = V,\n    se = a.asyncIterableMapFilter(a.asyncIterableFromArray(oe), async r => b.postProcessChoice(e, \"ghostText\", n, s, r, B, exports.ghostTextLogger)),\n    ae = [];\n  for await (const r of se) {\n    const o = B && b.checkSuffix(n, s, r);\n    if (null == f ? undefined : f.isCancellationRequested) {\n      exports.ghostTextLogger.info(e, \"Cancelled after post processing completions\");\n      return {\n        type: \"canceled\",\n        reason: \"after post processing completions\",\n        telemetryData: T.mkCanceledResultTelemetry(re)\n      };\n    }\n    const i = D(e, r),\n      a = {\n        completion: $(r.choiceIndex, r.completionText, q.trailingWs),\n        telemetry: i,\n        isMiddleOfTheLine: B,\n        coversSuffix: o\n      };\n    ae.push(a);\n  }\n  return {\n    type: \"success\",\n    value: [ae, ie],\n    telemetryData: T.mkBasicResultTelemetry(re),\n    telemetryBlob: re\n  };\n};",
  "9351": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(412),\n  o = require(3487),\n  i = require(2141),\n  s = require(6776),\n  a = {\n    keyword: \"additionalProperties\",\n    type: [\"object\"],\n    schemaType: [\"boolean\", \"object\"],\n    allowUndefined: !0,\n    trackErrors: !0,\n    error: {\n      message: \"must NOT have additional properties\",\n      params: ({\n        params: e\n      }) => o._`{additionalProperty: ${e.additionalProperty}}`\n    },\n    code(e) {\n      const {\n        gen: t,\n        schema: n,\n        parentSchema: a,\n        data: c,\n        errsCount: l,\n        it: u\n      } = e;\n      if (!l) throw new Error(\"ajv implementation error\");\n      const {\n        allErrors: d,\n        opts: p\n      } = u;\n      u.props = !0;\n      if (\"all\" !== p.removeAdditional && (0, s.alwaysValidSchema)(u, n)) return;\n      const h = r.allSchemaProperties(a.properties),\n        f = r.allSchemaProperties(a.patternProperties);\n      function m(e) {\n        t.code(o._`delete ${c}[${e}]`);\n      }\n      function g(r) {\n        if (\"all\" === p.removeAdditional || p.removeAdditional && !1 === n) m(r);else {\n          if (!1 === n) {\n            e.setParams({\n              additionalProperty: r\n            });\n            e.error();\n            return void (d || t.break());\n          }\n          if (\"object\" == typeof n && !s.alwaysValidSchema(u, n)) {\n            const n = t.name(\"valid\");\n            \"failing\" === p.removeAdditional ? (_(r, n, !1), t.if(o.not(n), () => {\n              e.reset();\n              m(r);\n            })) : (_(r, n), d || t.if(o.not(n), () => t.break()));\n          }\n        }\n      }\n      function _(t, n, r) {\n        const o = {\n          keyword: \"additionalProperties\",\n          dataProp: t,\n          dataPropType: s.Type.Str\n        };\n        !1 === r && Object.assign(o, {\n          compositeRule: !0,\n          createErrors: !1,\n          allErrors: !1\n        });\n        e.subschema(o, n);\n      }\n      t.forIn(\"key\", c, n => {\n        h.length || f.length ? t.if(function (n) {\n          let i;\n          if (h.length > 8) {\n            const e = s.schemaRefOrVal(u, a.properties, \"properties\");\n            i = r.isOwnProperty(t, e, n);\n          } else i = h.length ? o.or(...h.map(e => o._`${n} === ${e}`)) : o.nil;\n          f.length && (i = o.or(i, ...f.map(t => o._`${r.usePattern(e, t)}.test(${n})`)));\n          return o.not(i);\n        }(n), () => g(n)) : g(n);\n      });\n      e.ok(o._`${l} === ${i.default.errors}`);\n    }\n  };\nexports.default = a;",
  "9380": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.setupExperimentationService = exports.logger = undefined;\nconst r = require(9496),\n  o = require(1133),\n  i = require(9189),\n  s = require(8142),\n  a = require(9899);\nfunction c(e) {\n  return e.split(\"-\")[0];\n}\nexports.logger = new a.Logger(a.LogLevel.INFO, \"Exp\");\nexports.setupExperimentationService = function (e) {\n  const t = e.get(i.Features);\n  t.setPrefix(r.env.machineId);\n  t.registerStaticFilters(function (e) {\n    const t = e.get(o.BuildInfo);\n    return {\n      [s.Filter.ApplicationVersion]: c(r.version),\n      [s.Filter.Build]: r.env.appName,\n      [s.Filter.ClientId]: r.env.machineId,\n      [s.Filter.ExtensionName]: t.getName(),\n      [s.Filter.ExtensionVersion]: c(t.getVersion()),\n      [s.Filter.Language]: r.env.language,\n      [s.Filter.TargetPopulation]: s.TargetPopulation.Public\n    };\n  }(e));\n  t.registerDynamicFilter(s.Filter.CopilotOverrideEngine, () => o.getConfig(e, o.ConfigKey.DebugOverrideEngine));\n};",
  "9382": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r = require(9958),\n  RemoteDependencyDataConstants = function () {\n    function e() {}\n    e.TYPE_HTTP = \"Http\";\n    e.TYPE_AI = \"Http (tracked component)\";\n    return e;\n  }();\nexports.RemoteDependencyDataConstants = RemoteDependencyDataConstants;\nexports.domainSupportsProperties = function (e) {\n  return \"properties\" in e || e instanceof r.EventData || e instanceof r.ExceptionData || e instanceof r.MessageData || e instanceof r.MetricData || e instanceof r.PageViewData || e instanceof r.RemoteDependencyData || e instanceof r.RequestData;\n};",
  "9407": "const {\n    randomBytes: r\n  } = require(6113),\n  {\n    Readable: o\n  } = require(2781),\n  i = e => \"object\" == typeof e && 0 === [\"arrayBuffer\", \"stream\", \"text\", \"slice\", \"constructor\"].map(t => typeof e[t]).filter(e => \"function\" !== e).length && \"string\" == typeof e.type && \"number\" == typeof e.size && /^(Blob|File)$/.test(e[Symbol.toStringTag]),\n  s = e => `--${e}--\\r\\n\\r\\n`,\n  a = (e, t, n) => {\n    let r = \"\";\n    r += `--${e}\\r\\n`;\n    r += `Content-Disposition: form-data; name=\"${t}\"`;\n    i(n) && (r += `; filename=\"${n.name}\"\\r\\n`, r += `Content-Type: ${n.type || \"application/octet-stream\"}`);\n    return `${r}\\r\\n\\r\\n`;\n  };\nmodule.exports = {\n  isFormData: e => null != e && \"object\" == typeof e && 0 === [\"append\", \"delete\", \"get\", \"getAll\", \"has\", \"set\", \"keys\", \"values\", \"entries\", \"constructor\"].map(t => typeof e[t]).filter(e => \"function\" !== e).length && \"FormData\" === e[Symbol.toStringTag],\n  FormDataSerializer: class {\n    constructor(e) {\n      this.fd = e;\n      this.boundary = r(8).toString(\"hex\");\n    }\n    length() {\n      undefined === this._length && (this._length = ((e, t) => {\n        let n = 0;\n        for (const [r, o] of e) {\n          n += Buffer.byteLength(a(t, r, o));\n          n += i(o) ? o.size : Buffer.byteLength(String(o));\n          n += Buffer.byteLength(\"\\r\\n\");\n        }\n        n += Buffer.byteLength(s(t));\n        return n;\n      })(this.fd, this.boundary));\n      return this._length;\n    }\n    contentType() {\n      return `multipart/form-data; boundary=${this.boundary}`;\n    }\n    stream() {\n      return o.from(async function* (e, t) {\n        for (const [n, r] of e) {\n          yield a(t, n, r);\n          i(r) ? yield* r.stream() : yield r;\n          yield \"\\r\\n\";\n        }\n        yield s(t);\n      }(this.fd, this.boundary));\n    }\n  }\n};",
  "9408": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.registerDefaultHandlers = undefined;\nconst r = require(2279),\n  o = require(6333);\nexports.registerDefaultHandlers = function (e, t) {\n  process.addListener(\"uncaughtException\", t => {\n    console.error(\"uncaughtException\", t);\n    o.telemetryException(e, t, \"uncaughtException\");\n  });\n  let n = !1;\n  process.addListener(\"unhandledRejection\", (i, s) => {\n    if (n) return;\n    n = !0;\n    if (\"vscode\" === t && !i) return;\n    if (\"aborted\" === i.type || r.isAbortError(i)) return;\n    if (\"vscode\" === t && [\"ENOTFOUND\", \"ECONNREFUSED\", \"ECONNRESET\", \"ETIMEDOUT\", \"ENETDOWN\", \"ENETUNREACH\", \"EADDRNOTAVAIL\"].includes(i.code)) return;\n    if (\"ENOENT\" == i.code) return;\n    let a = \"\";\n    try {\n      a = `${i.message} (${i.code})`;\n      a = JSON.stringify(i);\n    } catch (e) {\n      a = \"[actual reason JSON was cyclic]\";\n    }\n    \"vscode\" === t && \"{}\" === a || (console.error(\"unhandledRejection\", a), o.telemetryError(e, \"unhandledRejection\", o.TelemetryData.createAndMarkAsIssued({\n      origin: \"unhandledRejection\",\n      reason: \"Unhandled rejection logged to restricted telemetry\"\n    }), !1), o.telemetryError(e, \"unhandledRejection\", o.TelemetryData.createAndMarkAsIssued({\n      origin: \"unhandledRejection\",\n      reason: a\n    }), !0), n = !1);\n  });\n};",
  "9425": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.VSCodeEditorInfo = exports.makeVscInfo = exports.getExtension = exports.setExtension = exports.VSCodeConfigProvider = undefined;\nconst r = require(9496),\n  o = require(1133),\n  i = require(4197),\n  s = require(70),\n  a = require(4147);\nfunction c(e) {\n  return \"string\" == typeof e ? e : JSON.stringify(e);\n}\nclass VSCodeConfigProvider extends o.ConfigProvider {\n  constructor() {\n    super();\n    this.config = r.workspace.getConfiguration(i.CopilotConfigPrefix);\n    r.workspace.onDidChangeConfiguration(e => {\n      e.affectsConfiguration(i.CopilotConfigPrefix) && (this.config = r.workspace.getConfiguration(i.CopilotConfigPrefix));\n    });\n  }\n  getConfigKeyFromObject(e, t) {\n    const n = this.config[e][t];\n    return undefined === n ? o.getConfigDefaultForObjectKey(e, t) : n;\n  }\n  getConfig(e) {\n    if (Array.isArray(e)) return this.getConfigKeyFromObject(e[0], e[1]);\n    const t = this.config.get(e);\n    if (undefined === t) throw new Error(`Missing config default value: ${i.CopilotConfigPrefix}.${e}`);\n    return t;\n  }\n  isDefaultSettingOverwritten(e) {\n    if (Array.isArray(e)) return undefined !== this.config[e[0]][e[1]];\n    const t = this.config.inspect(e);\n    return !!t && !!(t.globalValue || t.workspaceValue || t.workspaceFolderValue || t.defaultLanguageValue || t.globalLanguageValue || t.workspaceLanguageValue || t.workspaceFolderLanguageValue);\n  }\n  dumpConfig() {\n    const e = {};\n    try {\n      const t = a.contributes.configuration[0].properties;\n      for (const n in t) {\n        const t = n.replace(`${i.CopilotConfigPrefix}.`, \"\").split(\".\").reduce((e, t) => e[t], this.config);\n        \"object\" == typeof t && null !== t ? Object.keys(t).filter(e => \"secret_key\" !== e).forEach(r => e[`${n}.${r}`] = c(t[r])) : e[n] = c(t);\n      }\n    } catch (e) {\n      console.error(`Failed to retrieve configuration properties ${e}`);\n    }\n    return e;\n  }\n  getLanguageConfig(e, t) {\n    const n = this.getConfig(e);\n    if (undefined === t) {\n      const e = r.window.activeTextEditor;\n      t = e && e.document.languageId;\n    }\n    return t && t in n ? n[t] : n[\"*\"];\n  }\n  updateEnabledConfig(e, t, n) {\n    const r = e.get(o.ConfigProvider).getConfig(o.ConfigKey.Enable);\n    r[t] = n;\n    return this.config.update(o.ConfigKey.Enable, r, !0);\n  }\n}\nlet u;\nexports.VSCodeConfigProvider = VSCodeConfigProvider;\nexports.setExtension = function (e) {\n  u = e;\n};\nexports.getExtension = function (e) {\n  !u && s.isRunningInTest(e) && (u = r.extensions.all.find(e => e.id.startsWith(\"GitHub.copilot\")));\n  if (!u) throw new Error(\"No GitHub.copilot extension found\");\n  return u;\n};\nexports.makeVscInfo = function () {\n  return new o.VscInfo(r.env.sessionId, r.env.machineId, r.version);\n};\nclass VSCodeEditorInfo extends o.EditorAndPluginInfo {\n  getEditorInfo(e) {\n    return {\n      name: \"vscode\",\n      version: r.version\n    };\n  }\n  getEditorPluginInfo(e) {\n    return {\n      name: \"copilot\",\n      version: o.getVersion(e)\n    };\n  }\n}\nexports.VSCodeEditorInfo = VSCodeEditorInfo;",
  "9428": "function r(e) {\n  for (var n in e) exports.hasOwnProperty(n) || (exports[n] = e[n]);\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nr(require(608));\nr(require(4127));",
  "9434": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"if\",\n    schemaType: [\"object\", \"boolean\"],\n    trackErrors: !0,\n    error: {\n      message: ({\n        params: e\n      }) => r.str`must match \"${e.ifClause}\" schema`,\n      params: ({\n        params: e\n      }) => r._`{failingKeyword: ${e.ifClause}}`\n    },\n    code(e) {\n      const {\n        gen: t,\n        parentSchema: n,\n        it: i\n      } = e;\n      undefined === n.then && undefined === n.else && o.checkStrictMode(i, '\"if\" without \"then\" and \"else\" is ignored');\n      const a = s(i, \"then\"),\n        c = s(i, \"else\");\n      if (!a && !c) return;\n      const l = t.let(\"valid\", !0),\n        u = t.name(\"_valid\");\n      (function () {\n        const t = e.subschema({\n          keyword: \"if\",\n          compositeRule: !0,\n          createErrors: !1,\n          allErrors: !1\n        }, u);\n        e.mergeEvaluated(t);\n      })();\n      e.reset();\n      if (a && c) {\n        const n = t.let(\"ifClause\");\n        e.setParams({\n          ifClause: n\n        }), t.if(u, d(\"then\", n), d(\"else\", n));\n      } else a ? t.if(u, d(\"then\")) : t.if((0, r.not)(u), d(\"else\"));\n      function d(n, o) {\n        return () => {\n          const i = e.subschema({\n            keyword: n\n          }, u);\n          t.assign(l, u);\n          e.mergeValidEvaluated(i, l);\n          o ? t.assign(o, r._`${n}`) : e.setParams({\n            ifClause: n\n          });\n        };\n      }\n      e.pass(l, () => e.error(!0));\n    }\n  };\nfunction s(e, t) {\n  const n = e.schema[t];\n  return undefined !== n && !o.alwaysValidSchema(e, n);\n}\nexports.default = i;",
  "9461": "var t = module.exports = function (e, t, r) {\n  \"function\" == typeof t && (r = t, t = {});\n  n(t, \"function\" == typeof (r = t.cb || r) ? r : r.pre || function () {}, r.post || function () {}, e, \"\", e);\n};\nfunction n(e, r, o, i, s, a, c, l, u, d) {\n  if (i && \"object\" == typeof i && !Array.isArray(i)) {\n    for (var p in r(i, s, a, c, l, u, d), i) {\n      var h = i[p];\n      if (Array.isArray(h)) {\n        if (p in t.arrayKeywords) for (var f = 0; f < h.length; f++) n(e, r, o, h[f], s + \"/\" + p + \"/\" + f, a, s, p, i, f);\n      } else if (p in t.propsKeywords) {\n        if (h && \"object\" == typeof h) for (var m in h) n(e, r, o, h[m], s + \"/\" + p + \"/\" + m.replace(/~/g, \"~0\").replace(/\\//g, \"~1\"), a, s, p, i, m);\n      } else (p in t.keywords || e.allKeys && !(p in t.skipKeywords)) && n(e, r, o, h, s + \"/\" + p, a, s, p, i);\n    }\n    o(i, s, a, c, l, u, d);\n  }\n}\nt.keywords = {\n  additionalItems: !0,\n  items: !0,\n  contains: !0,\n  additionalProperties: !0,\n  propertyNames: !0,\n  not: !0,\n  if: !0,\n  then: !0,\n  else: !0\n};\nt.arrayKeywords = {\n  items: !0,\n  allOf: !0,\n  anyOf: !0,\n  oneOf: !0\n};\nt.propsKeywords = {\n  $defs: !0,\n  definitions: !0,\n  properties: !0,\n  patternProperties: !0,\n  dependencies: !0\n};\nt.skipKeywords = {\n  default: !0,\n  enum: !0,\n  const: !0,\n  required: !0,\n  maximum: !0,\n  minimum: !0,\n  exclusiveMaximum: !0,\n  exclusiveMinimum: !0,\n  multipleOf: !0,\n  maxLength: !0,\n  minLength: !0,\n  pattern: !0,\n  format: !0,\n  maxItems: !0,\n  minItems: !0,\n  uniqueItems: !0,\n  maxProperties: !0,\n  minProperties: !0\n};",
  "9477": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.initProxyEnvironment = undefined;\nconst r = require(1808),\n  o = require(7310),\n  i = require(9496);\nexports.initProxyEnvironment = function (e, t) {\n  let n = i.workspace.getConfiguration(\"http\").get(\"proxy\") || function (e) {\n    return e.HTTPS_PROXY || e.https_proxy || e.HTTP_PROXY || e.http_proxy || null;\n  }(t);\n  if (n) {\n    const t = {},\n      s = i.workspace.getConfiguration(\"http\").get(\"proxyAuthorization\"),\n      a = i.workspace.getConfiguration(\"http\").get(\"proxyStrictSSL\", !0);\n    s && (t[\"Proxy-Authorization\"] = s);\n    let c = n;\n    const l = n.split(\":\");\n    if (l.length > 2) {\n      if (n.includes(\"[\")) {\n        const e = n.indexOf(\"[\"),\n          t = n.indexOf(\"]\");\n        c = n.substring(e + 1, t);\n      }\n    } else c = l[0];\n    const u = r.isIP(c);\n    4 === u ? n = `https://${n}` : 6 === u && (n.includes(\"[\") ? n.startsWith(\"https://\") || (n = `https://${n}`) : n = `https://[${n}]`);\n    const {\n        hostname: d,\n        port: p,\n        username: h,\n        password: f\n      } = function (e) {\n        try {\n          return new o.URL(e);\n        } catch (t) {\n          throw new Error(`Invalid proxy URL: '${e}'`);\n        }\n      }(n),\n      m = h && f && `${h}:${f}`;\n    e.proxySettings = {\n      host: d,\n      port: parseInt(p),\n      proxyAuth: m,\n      headers: t,\n      rejectUnauthorized: a\n    };\n  }\n};",
  "9491": "module.exports = require(\"assert\");",
  "9496": "module.exports = require(\"vscode\");",
  "9502": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = [require(9651).default];\nexports.default = r;",
  "9512": "module.exports = require(\"timers\");",
  "9523": "module.exports = require(\"dns\");",
  "9562": "const r = require(9012);\nprocess && r.gte(process.versions.node, \"8.0.0\") ? module.exports = require(3964) : module.exports = require(4046);",
  "9565": "function t() {}\nmodule.exports = function () {\n  const e = this._hooks,\n    n = this._state,\n    r = global.Promise,\n    o = r.prototype.then;\n  function i(t, n, r, o) {\n    return \"function\" != typeof t ? o ? function (t) {\n      return function (n) {\n        e.destroy.call(null, t);\n        return n;\n      };\n    }(r) : function (t) {\n      return function (n) {\n        throw e.destroy.call(null, t), n;\n      };\n    }(r) : function () {\n      e.pre.call(n, r);\n      try {\n        return t.apply(this, arguments);\n      } finally {\n        e.post.call(n, r, !1);\n        e.destroy.call(null, r);\n      }\n    };\n  }\n  r.prototype.then = function (r, s) {\n    if (!n.enabled) return o.call(this, r, s);\n    const a = new t(),\n      c = --n.counter;\n    e.init.call(a, c, 0, null, null);\n    return o.call(this, i(r, a, c, !0), i(s, a, c, !1));\n  };\n};",
  "9574": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nvar r,\n  o = require(894),\n  i = require(6281),\n  s = require(6639),\n  a = require(4350),\n  c = require(8723),\n  l = require(731),\n  u = require(9962),\n  d = require(5282),\n  p = require(3668),\n  h = require(1629);\nexports.TelemetryClient = require(1259);\nexports.Contracts = require(5290);\n(function (e) {\n  e[e.AI = 0] = \"AI\";\n  e[e.AI_AND_W3C = 1] = \"AI_AND_W3C\";\n})(r = exports.DistributedTracingModes || (exports.DistributedTracingModes = {}));\nvar f,\n  m,\n  g,\n  _,\n  y,\n  v,\n  b,\n  w,\n  x,\n  E = !0,\n  C = !1,\n  S = !0,\n  T = !0,\n  k = !0,\n  I = !0,\n  P = !0,\n  A = !0,\n  O = !1,\n  N = !0,\n  R = undefined,\n  M = undefined,\n  L = !1;\nfunction start() {\n  exports.defaultClient ? (L = !0, g.enable(E, C), _.enable(S), y.enable(T), v.enable(N, m), b.useAutoCorrelation(A, f), b.enable(k), w.enable(I), exports.liveMetricsClient && O && exports.liveMetricsClient.enable(O)) : d.warn(\"Start cannot be called before setup\");\n  return Configuration;\n}\nexports.setup = function (e) {\n  exports.defaultClient ? d.info(\"The default client is already setup\") : (exports.defaultClient = new exports.TelemetryClient(e), g = new i(exports.defaultClient), _ = new s(exports.defaultClient), y = new a(exports.defaultClient), b = new l(exports.defaultClient), w = new c(exports.defaultClient), v || (v = new h.AutoCollectNativePerformance(exports.defaultClient)));\n  exports.defaultClient && exports.defaultClient.channel && exports.defaultClient.channel.setUseDiskRetryCaching(P, R, M);\n  return Configuration;\n};\nexports.start = start;\nexports.getCorrelationContext = function () {\n  return A ? o.CorrelationContextManager.getCurrentContext() : null;\n};\nexports.wrapWithCorrelationContext = function (e) {\n  return o.CorrelationContextManager.wrapCallback(e);\n};\nvar Configuration = function () {\n  function e() {}\n  e.setDistributedTracingMode = function (t) {\n    u.w3cEnabled = t === r.AI_AND_W3C;\n    return e;\n  };\n  e.setAutoCollectConsole = function (t, n) {\n    undefined === n && (n = !1);\n    E = t;\n    C = n;\n    L && g.enable(t, n);\n    return e;\n  };\n  e.setAutoCollectExceptions = function (t) {\n    S = t;\n    L && _.enable(t);\n    return e;\n  };\n  e.setAutoCollectPerformance = function (t, n) {\n    undefined === n && (n = !0);\n    T = t;\n    var r = h.AutoCollectNativePerformance.parseEnabled(n);\n    N = r.isEnabled;\n    m = r.disabledMetrics;\n    L && (y.enable(t), v.enable(r.isEnabled, r.disabledMetrics));\n    return e;\n  };\n  e.setAutoCollectRequests = function (t) {\n    k = t;\n    L && b.enable(t);\n    return e;\n  };\n  e.setAutoCollectDependencies = function (t) {\n    I = t;\n    L && w.enable(t);\n    return e;\n  };\n  e.setAutoDependencyCorrelation = function (t, n) {\n    A = t;\n    f = n;\n    L && b.useAutoCorrelation(t, n);\n    return e;\n  };\n  e.setUseDiskRetryCaching = function (n, r, o) {\n    P = n;\n    R = r;\n    M = o;\n    exports.defaultClient && exports.defaultClient.channel && exports.defaultClient.channel.setUseDiskRetryCaching(n, r, o);\n    return e;\n  };\n  e.setInternalLogging = function (t, n) {\n    undefined === t && (t = !1);\n    undefined === n && (n = !0);\n    d.enableDebug = t;\n    d.disableWarnings = !n;\n    return e;\n  };\n  e.setSendLiveMetrics = function (n) {\n    undefined === n && (n = !1);\n    return exports.defaultClient ? (!exports.liveMetricsClient && n ? (exports.liveMetricsClient = new p(exports.defaultClient.config.instrumentationKey), x = new a(exports.liveMetricsClient, 1e3, !0), exports.liveMetricsClient.addCollector(x), exports.defaultClient.quickPulseClient = exports.liveMetricsClient) : exports.liveMetricsClient && exports.liveMetricsClient.enable(n), O = n, e) : (d.warn(\"Live metrics client cannot be setup without the default client\"), e);\n  };\n  e.start = start;\n  return e;\n}();\nexports.Configuration = Configuration;\nexports.dispose = function () {\n  exports.defaultClient = null;\n  L = !1;\n  g && g.dispose();\n  _ && _.dispose();\n  y && y.dispose();\n  v && v.dispose();\n  b && b.dispose();\n  w && w.dispose();\n  exports.liveMetricsClient && (exports.liveMetricsClient.enable(!1), O = !1, exports.liveMetricsClient = undefined);\n};",
  "9575": "const {\n    Readable: r\n  } = require(2781),\n  o = require(4404),\n  {\n    types: {\n      isAnyArrayBuffer: i\n    }\n  } = require(3837),\n  s = require(8348),\n  a = require(8104)(\"helix-fetch:core\"),\n  {\n    RequestAbortedError: c\n  } = require(1787),\n  l = require(9803),\n  u = require(7262),\n  d = require(3769),\n  {\n    isPlainObject: p\n  } = require(4544),\n  {\n    isFormData: h,\n    FormDataSerializer: f\n  } = require(9407),\n  {\n    version: m\n  } = require(5258),\n  g = \"h2\",\n  _ = \"h2c\",\n  y = \"http/1.0\",\n  v = \"http/1.1\",\n  b = 100,\n  w = 36e5,\n  x = [g, v, y],\n  E = `helix-fetch/${m}`,\n  C = {\n    method: \"GET\",\n    compress: !0,\n    decode: !0\n  };\nlet S = 0;\nconst T = d(),\n  k = (e, t) => new Promise((n, r) => {\n    const {\n      signal: i\n    } = t;\n    let s;\n    const l = () => {\n      i.removeEventListener(\"abort\", l);\n      const e = new c();\n      r(e);\n      s && s.destroy(e);\n    };\n    if (i) {\n      if (i.aborted) return void r(new c());\n      i.addEventListener(\"abort\", l);\n    }\n    const u = +e.port || 443,\n      d = t => {\n        i && i.removeEventListener(\"abort\", l);\n        t instanceof c || (a(`connecting to ${e.hostname}:${u} failed with: ${t.message}`), r(t));\n      };\n    s = o.connect(u, e.hostname, t);\n    s.once(\"secureConnect\", () => {\n      i && i.removeEventListener(\"abort\", l);\n      s.off(\"error\", d);\n      S += 1;\n      s.id = S;\n      s.secureConnecting = !1;\n      a(`established TLS connection: #${s.id} (${s.servername})`);\n      n(s);\n    });\n    s.once(\"error\", d);\n  });\nmodule.exports = {\n  request: async (e, t, n) => {\n    const o = new URL(t),\n      s = {\n        ...C,\n        ...(n || {})\n      };\n    let c;\n    \"string\" == typeof s.method && (s.method = s.method.toUpperCase());\n    s.headers = (e => {\n      const t = {};\n      Object.keys(e).forEach(n => {\n        t[n.toLowerCase()] = e[n];\n      });\n      return t;\n    })(s.headers || {});\n    undefined === s.headers.host && (s.headers.host = o.host);\n    e.userAgent && undefined === s.headers[\"user-agent\"] && (s.headers[\"user-agent\"] = e.userAgent);\n    if (s.body instanceof URLSearchParams) c = \"application/x-www-form-urlencoded; charset=utf-8\", s.body = s.body.toString();else if (h(s.body)) {\n      const e = new f(s.body);\n      c = e.contentType(), s.body = e.stream(), void 0 === s.headers[\"transfer-encoding\"] && void 0 === s.headers[\"content-length\"] && (s.headers[\"content-length\"] = String(e.length()));\n    } else \"string\" == typeof s.body || s.body instanceof String ? c = \"text/plain; charset=utf-8\" : p(s.body) ? (s.body = JSON.stringify(s.body), c = \"application/json\") : i(s.body) && (s.body = Buffer.from(s.body));\n    undefined === s.headers[\"content-type\"] && undefined !== c && (s.headers[\"content-type\"] = c);\n    null != s.body && (s.body instanceof r || (\"string\" == typeof s.body || s.body instanceof String || Buffer.isBuffer(s.body) || (s.body = String(s.body)), undefined === s.headers[\"transfer-encoding\"] && undefined === s.headers[\"content-length\"] && (s.headers[\"content-length\"] = String(Buffer.isBuffer(s.body) ? s.body.length : Buffer.byteLength(s.body, \"utf-8\")))));\n    undefined === s.headers.accept && (s.headers.accept = \"*/*\");\n    null == s.body && [\"POST\", \"PUT\"].includes(s.method) && (s.headers[\"content-length\"] = \"0\");\n    s.compress && undefined === s.headers[\"accept-encoding\"] && (s.headers[\"accept-encoding\"] = \"gzip,deflate,br\");\n    const {\n        signal: d\n      } = s,\n      {\n        protocol: m,\n        socket: b = null\n      } = e.socketFactory ? await (async (e, t, n, r) => {\n        const o = \"https:\" === t.protocol;\n        let i;\n        i = t.port ? t.port : o ? 443 : 80;\n        const s = {\n            ...n,\n            host: t.host,\n            port: i\n          },\n          a = await e(s);\n        if (o) {\n          const e = {\n            ...s,\n            ALPNProtocols: r\n          };\n          e.socket = a;\n          const n = await k(t, e);\n          return {\n            protocol: n.alpnProtocol || v,\n            socket: n\n          };\n        }\n        return {\n          protocol: a.alpnProtocol || v,\n          socket: a\n        };\n      })(e.socketFactory, o, s, e.alpnProtocols) : await (async (e, t, n) => {\n        const r = `${t.protocol}//${t.host}`;\n        let o = e.alpnCache.get(r);\n        if (o) return {\n          protocol: o\n        };\n        switch (t.protocol) {\n          case \"http:\":\n            o = v;\n            e.alpnCache.set(r, o);\n            return {\n              protocol: o\n            };\n          case \"http2:\":\n            o = _;\n            e.alpnCache.set(r, o);\n            return {\n              protocol: o\n            };\n          case \"https:\":\n            break;\n          default:\n            throw new TypeError(`unsupported protocol: ${t.protocol}`);\n        }\n        const {\n            options: {\n              rejectUnauthorized: i,\n              h1: s = {},\n              h2: a = {}\n            }\n          } = e,\n          c = !(!1 === i || !1 === s.rejectUnauthorized || !1 === a.rejectUnauthorized),\n          l = {\n            servername: t.hostname,\n            ALPNProtocols: e.alpnProtocols,\n            signal: n,\n            rejectUnauthorized: c\n          },\n          u = await (async (e, t) => {\n            let n = await T.acquire(e.origin);\n            try {\n              n || (n = await k(e, t));\n              return n;\n            } finally {\n              T.release(e.origin, n);\n            }\n          })(t, l);\n        o = u.alpnProtocol;\n        o || (o = v);\n        e.alpnCache.set(r, o);\n        return {\n          protocol: o,\n          socket: u\n        };\n      })(e, o, d);\n    switch (a(`${o.host} -> ${m}`), m) {\n      case g:\n        try {\n          return await u.request(e, o, b ? {\n            ...s,\n            socket: b\n          } : s);\n        } catch (t) {\n          const {\n            code: n,\n            message: r\n          } = t;\n          throw \"ERR_HTTP2_ERROR\" === n && \"Protocol error\" === r && e.alpnCache.delete(`${o.protocol}//${o.host}`), t;\n        }\n      case _:\n        return u.request(e, new URL(`http://${o.host}${o.pathname}${o.hash}${o.search}`), b ? {\n          ...s,\n          socket: b\n        } : s);\n      case y:\n      case v:\n        return l.request(e, o, b ? {\n          ...s,\n          socket: b\n        } : s);\n      default:\n        throw new TypeError(`unsupported protocol: ${m}`);\n    }\n  },\n  setupContext: e => {\n    const {\n      options: {\n        alpnProtocols: t = x,\n        alpnCacheTTL: n = w,\n        alpnCacheSize: r = b,\n        userAgent: o = E,\n        socketFactory: i\n      }\n    } = e;\n    e.alpnProtocols = t;\n    e.alpnCache = new s({\n      max: r,\n      ttl: n\n    });\n    e.userAgent = o;\n    e.socketFactory = i;\n    l.setupContext(e);\n    u.setupContext(e);\n  },\n  resetContext: async e => (e.alpnCache.clear(), Promise.all([l.resetContext(e), u.resetContext(e)])),\n  RequestAbortedError: c,\n  ALPN_HTTP2: g,\n  ALPN_HTTP2C: _,\n  ALPN_HTTP1_1: v,\n  ALPN_HTTP1_0: y\n};",
  "9608": "function isVirtual(e) {\n  return \"virtual\" === e.type;\n}\nfunction isTop(e) {\n  return \"top\" === e.type;\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.duplicateTree = exports.cutTreeAfterLine = exports.isTop = exports.isVirtual = exports.isLine = exports.isBlank = exports.topNode = exports.blankNode = exports.lineNode = exports.virtualNode = undefined;\nexports.virtualNode = function (e, t, n) {\n  return {\n    type: \"virtual\",\n    indentation: e,\n    subs: t,\n    label: n\n  };\n};\nexports.lineNode = function (e, t, n, r, o) {\n  if (\"\" === n) throw new Error(\"Cannot create a line node with an empty source line\");\n  return {\n    type: \"line\",\n    indentation: e,\n    lineNumber: t,\n    sourceLine: n,\n    subs: r,\n    label: o\n  };\n};\nexports.blankNode = function (e) {\n  return {\n    type: \"blank\",\n    lineNumber: e,\n    subs: []\n  };\n};\nexports.topNode = function (e) {\n  return {\n    type: \"top\",\n    indentation: -1,\n    subs: null != e ? e : []\n  };\n};\nexports.isBlank = function (e) {\n  return \"blank\" === e.type;\n};\nexports.isLine = function (e) {\n  return \"line\" === e.type;\n};\nexports.isVirtual = isVirtual;\nexports.isTop = isTop;\nexports.cutTreeAfterLine = function (e, t) {\n  !function e(o) {\n    if (!isVirtual(o) && !isTop(o) && o.lineNumber === t) {\n      o.subs = [];\n      return !0;\n    }\n    for (let t = 0; t < o.subs.length; t++) if (e(o.subs[t])) {\n      o.subs = o.subs.slice(0, t + 1);\n      return !0;\n    }\n    return !1;\n  }(e);\n};\nexports.duplicateTree = function (e) {\n  return JSON.parse(JSON.stringify(e));\n};",
  "9651": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: !0,\n    error: {\n      message: ({\n        schemaCode: e\n      }) => r.str`must match format \"${e}\"`,\n      params: ({\n        schemaCode: e\n      }) => r._`{format: ${e}}`\n    },\n    code(e, t) {\n      const {\n          gen: n,\n          data: o,\n          $data: i,\n          schema: s,\n          schemaCode: a,\n          it: c\n        } = e,\n        {\n          opts: l,\n          errSchemaPath: u,\n          schemaEnv: d,\n          self: p\n        } = c;\n      l.validateFormats && (i ? function () {\n        const i = n.scopeValue(\"formats\", {\n            ref: p.formats,\n            code: l.code.formats\n          }),\n          s = n.const(\"fDef\", r._`${i}[${a}]`),\n          c = n.let(\"fType\"),\n          u = n.let(\"format\");\n        n.if(r._`typeof ${s} == \"object\" && !(${s} instanceof RegExp)`, () => n.assign(c, r._`${s}.type || \"string\"`).assign(u, r._`${s}.validate`), () => n.assign(c, r._`\"string\"`).assign(u, s));\n        e.fail$data(r.or(!1 === l.strictSchema ? r.nil : r._`${a} && !${u}`, function () {\n          const e = d.$async ? r._`(${s}.async ? await ${u}(${o}) : ${u}(${o}))` : r._`${u}(${o})`,\n            n = r._`(typeof ${u} == \"function\" ? ${e} : ${u}.test(${o}))`;\n          return r._`${u} && ${u} !== true && ${c} === ${t} && !${n}`;\n        }()));\n      }() : function () {\n        const i = p.formats[s];\n        if (!i) return void function () {\n          if (!1 !== l.strictSchema) throw new Error(e());\n          function e() {\n            return `unknown format \"${s}\" ignored in schema at path \"${u}\"`;\n          }\n          p.logger.warn(e());\n        }();\n        if (!0 === i) return;\n        const [a, c, h] = function (e) {\n          const t = e instanceof RegExp ? r.regexpCode(e) : l.code.formats ? r._`${l.code.formats}${r.getProperty(s)}` : undefined,\n            o = n.scopeValue(\"formats\", {\n              key: s,\n              ref: e,\n              code: t\n            });\n          return \"object\" != typeof e || e instanceof RegExp ? [\"string\", e, o] : [e.type || \"string\", e.validate, r._`${o}.validate`];\n        }(i);\n        a === t && e.pass(function () {\n          if (\"object\" == typeof i && !(i instanceof RegExp) && i.async) {\n            if (!d.$async) throw new Error(\"async format in sync schema\");\n            return r._`await ${h}(${o})`;\n          }\n          return \"function\" == typeof c ? r._`${h}(${o})` : r._`${h}.test(${o})`;\n        }());\n      }());\n    }\n  };\nexports.default = o;",
  "9657": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.isRepetitive = exports.RepetitionFilterMode = undefined;\nconst n = [{\n  max_token_sequence_length: 1,\n  last_tokens_to_consider: 10\n}, {\n  max_token_sequence_length: 10,\n  last_tokens_to_consider: 30\n}, {\n  max_token_sequence_length: 20,\n  last_tokens_to_consider: 45\n}, {\n  max_token_sequence_length: 30,\n  last_tokens_to_consider: 60\n}];\nvar r;\nfunction o(e) {\n  const t = function (e) {\n    const t = Array(e.length).fill(0);\n    t[0] = -1;\n    let n = -1;\n    for (let r = 1; r < e.length; r++) {\n      for (; n >= 0 && e[n + 1] !== e[r];) n = t[n];\n      e[n + 1] === e[r] && n++;\n      t[r] = n;\n    }\n    return t;\n  }(e);\n  for (const r of n) if (!(e.length < r.last_tokens_to_consider) && r.last_tokens_to_consider - 1 - t[r.last_tokens_to_consider - 1] <= r.max_token_sequence_length) return !0;\n  return !1;\n}\n!function (e) {\n  e.CLIENT = \"client\";\n  e.PROXY = \"proxy\";\n  e.BOTH = \"both\";\n}(r = exports.RepetitionFilterMode || (exports.RepetitionFilterMode = {}));\nexports.isRepetitive = function (e, t = r.CLIENT) {\n  return t !== r.PROXY && (o(e.reverse()) || o(e.reverse().filter(e => e.trim().length > 0)));\n};",
  "9697": "var t;\n!function (e) {\n  e[e.Verbose = 0] = \"Verbose\";\n  e[e.Information = 1] = \"Information\";\n  e[e.Warning = 2] = \"Warning\";\n  e[e.Error = 3] = \"Error\";\n  e[e.Critical = 4] = \"Critical\";\n}(t || (t = {}));\nmodule.exports = t;",
  "9748": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.ExpConfigNone = exports.ExpConfigFromTAS = exports.ExpConfigMaker = undefined;\nconst r = require(2279),\n  o = require(219);\nclass ExpConfigMaker {}\nexports.ExpConfigMaker = ExpConfigMaker;\nexports.ExpConfigFromTAS = class extends ExpConfigMaker {\n  async fetchExperiments(e, t) {\n    var n;\n    const i = e.get(r.Fetcher);\n    let s;\n    try {\n      s = await i.fetch(\"https://default.exp-tas.com/vscode/ab\", {\n        method: \"GET\",\n        headers: t\n      });\n    } catch (t) {\n      return o.ExpConfig.createFallbackConfig(e, `Error fetching ExP config: ${t}`);\n    }\n    if (!s.ok) return o.ExpConfig.createFallbackConfig(e, `ExP responded with ${s.status}`);\n    const a = await s.json(),\n      c = null !== (n = a.Configs.find(e => \"vscode\" === e.Id)) && undefined !== n ? n : {\n        Id: \"vscode\",\n        Parameters: {}\n      },\n      l = Object.entries(c.Parameters).map(([e, t]) => e + (t ? \"\" : \"cf\"));\n    return new o.ExpConfig(c.Parameters, a.AssignmentContext, l.join(\";\"));\n  }\n};\nexports.ExpConfigNone = class extends ExpConfigMaker {\n  async fetchExperiments(e, t) {\n    return o.ExpConfig.createEmptyConfig();\n  }\n};",
  "9796": "module.exports = require(\"zlib\");",
  "9803": "const r = require(3685),\n  o = require(5687),\n  {\n    Readable: i\n  } = require(2781),\n  s = require(8104)(\"helix-fetch:h1\"),\n  {\n    RequestAbortedError: a\n  } = require(1787),\n  {\n    decodeStream: c\n  } = require(4544);\nmodule.exports = {\n  request: async (e, t, n) => {\n    const {\n        request: l\n      } = \"https:\" === t.protocol ? o : r,\n      u = ((e, t) => {\n        const {\n          h1: n,\n          options: {\n            h1: i,\n            rejectUnauthorized: s\n          }\n        } = e;\n        return \"https:\" === t ? n.httpsAgent ? n.httpsAgent : i || \"boolean\" == typeof s ? (n.httpsAgent = new o.Agent(\"boolean\" == typeof s ? {\n          ...(i || {}),\n          rejectUnauthorized: s\n        } : i), n.httpsAgent) : undefined : n.httpAgent ? n.httpAgent : i ? (n.httpAgent = new r.Agent(i), n.httpAgent) : undefined;\n      })(e, t.protocol),\n      d = {\n        ...n,\n        agent: u\n      },\n      {\n        socket: p,\n        body: h\n      } = d;\n    p && (delete d.socket, p.assigned || (p.assigned = !0, u ? d.agent = new Proxy(u, {\n      get: (e, t) => \"createConnection\" !== t || p.inUse ? e[t] : (e, t) => {\n        s(`agent reusing socket #${p.id} (${p.servername})`);\n        p.inUse = !0;\n        t(null, p);\n      }\n    }) : d.createConnection = (e, t) => {\n      s(`reusing socket #${p.id} (${p.servername})`);\n      p.inUse = !0;\n      t(null, p);\n    }));\n    return new Promise((e, n) => {\n      let r;\n      s(`${d.method} ${t.href}`);\n      const {\n          signal: o\n        } = d,\n        u = () => {\n          o.removeEventListener(\"abort\", u);\n          p && !p.inUse && (s(`discarding redundant socket used for ALPN: #${p.id} ${p.servername}`), p.destroy());\n          n(new a());\n          r && r.abort();\n        };\n      if (o) {\n        if (o.aborted) return void n(new a());\n        o.addEventListener(\"abort\", u);\n      }\n      r = l(t, d);\n      r.once(\"response\", t => {\n        o && o.removeEventListener(\"abort\", u);\n        p && !p.inUse && (s(`discarding redundant socket used for ALPN: #${p.id} ${p.servername}`), p.destroy());\n        e(((e, t, n) => {\n          const {\n              statusCode: r,\n              statusMessage: o,\n              httpVersion: i,\n              httpVersionMajor: s,\n              httpVersionMinor: a,\n              headers: l\n            } = e,\n            u = t ? c(r, l, e, n) : e;\n          return {\n            statusCode: r,\n            statusText: o,\n            httpVersion: i,\n            httpVersionMajor: s,\n            httpVersionMinor: a,\n            headers: l,\n            readable: u,\n            decoded: !(!t || u === e)\n          };\n        })(t, d.decode, n));\n      });\n      r.once(\"error\", e => {\n        o && o.removeEventListener(\"abort\", u);\n        p && !p.inUse && (s(`discarding redundant socket used for ALPN: #${p.id} ${p.servername}`), p.destroy());\n        r.aborted || (s(`${d.method} ${t.href} failed with: ${e.message}`), r.abort(), n(e));\n      });\n      h instanceof i ? h.pipe(r) : (h && r.write(h), r.end());\n    });\n  },\n  setupContext: e => {\n    e.h1 = {};\n  },\n  resetContext: async ({\n    h1: e\n  }) => {\n    e.httpAgent && (s(\"resetContext: destroying httpAgent\"), e.httpAgent.destroy(), delete e.httpAgent);\n    e.httpsAgent && (s(\"resetContext: destroying httpsAgent\"), e.httpsAgent.destroy(), delete e.httpsAgent);\n  }\n};",
  "9813": "var r = require(5290),\n  o = require(5740),\n  i = require(894),\n  s = function () {\n    function e() {}\n    e.createEnvelope = function (t, n, i, s, a) {\n      var c = null;\n      switch (n) {\n        case r.TelemetryType.Trace:\n          c = e.createTraceData(t);\n          break;\n        case r.TelemetryType.Dependency:\n          c = e.createDependencyData(t);\n          break;\n        case r.TelemetryType.Event:\n          c = e.createEventData(t);\n          break;\n        case r.TelemetryType.Exception:\n          c = e.createExceptionData(t);\n          break;\n        case r.TelemetryType.Request:\n          c = e.createRequestData(t);\n          break;\n        case r.TelemetryType.Metric:\n          c = e.createMetricData(t);\n          break;\n        case r.TelemetryType.Availability:\n          c = e.createAvailabilityData(t);\n      }\n      if (i && r.domainSupportsProperties(c.baseData)) {\n        if (c && c.baseData) if (c.baseData.properties) for (var l in i) c.baseData.properties[l] || (c.baseData.properties[l] = i[l]);else c.baseData.properties = i;\n        c.baseData.properties = o.validateStringMap(c.baseData.properties);\n      }\n      var u = a && a.instrumentationKey || \"\",\n        d = new r.Envelope();\n      d.data = c;\n      d.iKey = u;\n      d.name = \"Microsoft.ApplicationInsights.\" + u.replace(/-/g, \"\") + \".\" + c.baseType.substr(0, c.baseType.length - 4);\n      d.tags = this.getTags(s, t.tagOverrides);\n      d.time = new Date().toISOString();\n      d.ver = 1;\n      d.sampleRate = a ? a.samplingPercentage : 100;\n      n === r.TelemetryType.Metric && (d.sampleRate = 100);\n      return d;\n    };\n    e.createTraceData = function (e) {\n      var t = new r.MessageData();\n      t.message = e.message;\n      t.properties = e.properties;\n      isNaN(e.severity) ? t.severityLevel = r.SeverityLevel.Information : t.severityLevel = e.severity;\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Trace);\n      n.baseData = t;\n      return n;\n    };\n    e.createDependencyData = function (e) {\n      var t = new r.RemoteDependencyData();\n      \"string\" == typeof e.name && (t.name = e.name.length > 1024 ? e.name.slice(0, 1021) + \"...\" : e.name);\n      t.data = e.data;\n      t.target = e.target;\n      t.duration = o.msToTimeSpan(e.duration);\n      t.success = e.success;\n      t.type = e.dependencyTypeName;\n      t.properties = e.properties;\n      t.resultCode = e.resultCode ? e.resultCode + \"\" : \"\";\n      e.id ? t.id = e.id : t.id = o.w3cTraceId();\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Dependency);\n      n.baseData = t;\n      return n;\n    };\n    e.createEventData = function (e) {\n      var t = new r.EventData();\n      t.name = e.name;\n      t.properties = e.properties;\n      t.measurements = e.measurements;\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Event);\n      n.baseData = t;\n      return n;\n    };\n    e.createExceptionData = function (e) {\n      var t = new r.ExceptionData();\n      t.properties = e.properties;\n      isNaN(e.severity) ? t.severityLevel = r.SeverityLevel.Error : t.severityLevel = e.severity;\n      t.measurements = e.measurements;\n      t.exceptions = [];\n      var n = e.exception.stack,\n        i = new r.ExceptionDetails();\n      i.message = e.exception.message;\n      i.typeName = e.exception.name;\n      i.parsedStack = this.parseStack(n);\n      i.hasFullStack = o.isArray(i.parsedStack) && i.parsedStack.length > 0;\n      t.exceptions.push(i);\n      var s = new r.Data();\n      s.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Exception);\n      s.baseData = t;\n      return s;\n    };\n    e.createRequestData = function (e) {\n      var t = new r.RequestData();\n      e.id ? t.id = e.id : t.id = o.w3cTraceId();\n      t.name = e.name;\n      t.url = e.url;\n      t.source = e.source;\n      t.duration = o.msToTimeSpan(e.duration);\n      t.responseCode = e.resultCode ? e.resultCode + \"\" : \"\";\n      t.success = e.success;\n      t.properties = e.properties;\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Request);\n      n.baseData = t;\n      return n;\n    };\n    e.createMetricData = function (e) {\n      var t = new r.MetricData();\n      t.metrics = [];\n      var n = new r.DataPoint();\n      n.count = isNaN(e.count) ? 1 : e.count;\n      n.kind = r.DataPointType.Aggregation;\n      n.max = isNaN(e.max) ? e.value : e.max;\n      n.min = isNaN(e.min) ? e.value : e.min;\n      n.name = e.name;\n      n.stdDev = isNaN(e.stdDev) ? 0 : e.stdDev;\n      n.value = e.value;\n      t.metrics.push(n);\n      t.properties = e.properties;\n      var o = new r.Data();\n      o.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Metric);\n      o.baseData = t;\n      return o;\n    };\n    e.createAvailabilityData = function (e) {\n      var t = new r.AvailabilityData();\n      e.id ? t.id = e.id : t.id = o.w3cTraceId();\n      t.name = e.name;\n      t.duration = o.msToTimeSpan(e.duration);\n      t.success = e.success;\n      t.runLocation = e.runLocation;\n      t.message = e.message;\n      t.measurements = e.measurements;\n      t.properties = e.properties;\n      var n = new r.Data();\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Availability);\n      n.baseData = t;\n      return n;\n    };\n    e.getTags = function (e, t) {\n      var n = i.CorrelationContextManager.getCurrentContext(),\n        r = {};\n      if (e && e.tags) for (var o in e.tags) r[o] = e.tags[o];\n      if (t) for (var o in t) r[o] = t[o];\n      n && (r[e.keys.operationId] = r[e.keys.operationId] || n.operation.id, r[e.keys.operationName] = r[e.keys.operationName] || n.operation.name, r[e.keys.operationParentId] = r[e.keys.operationParentId] || n.operation.parentId);\n      return r;\n    };\n    e.parseStack = function (e) {\n      var t = undefined;\n      if (\"string\" == typeof e) {\n        var n = e.split(\"\\n\");\n        t = [];\n        for (var r = 0, o = 0, i = 0; i <= n.length; i++) {\n          var s = n[i];\n          if (a.regex.test(s)) {\n            var c = new a(n[i], r++);\n            o += c.sizeInBytes;\n            t.push(c);\n          }\n        }\n        if (o > 32768) for (var l = 0, u = t.length - 1, d = 0, p = l, h = u; l < u;) {\n          if ((d += t[l].sizeInBytes + t[u].sizeInBytes) > 32768) {\n            var f = h - p + 1;\n            t.splice(p, f);\n            break;\n          }\n          p = l;\n          h = u;\n          l++;\n          u--;\n        }\n      }\n      return t;\n    };\n    return e;\n  }(),\n  a = function () {\n    function e(t, n) {\n      this.sizeInBytes = 0;\n      this.level = n;\n      this.method = \"<no_method>\";\n      this.assembly = o.trim(t);\n      var r = t.match(e.regex);\n      r && r.length >= 5 && (this.method = o.trim(r[2]) || this.method, this.fileName = o.trim(r[4]) || \"<no_filename>\", this.line = parseInt(r[5]) || 0);\n      this.sizeInBytes += this.method.length;\n      this.sizeInBytes += this.fileName.length;\n      this.sizeInBytes += this.assembly.length;\n      this.sizeInBytes += e.baseSize;\n      this.sizeInBytes += this.level.toString().length;\n      this.sizeInBytes += this.line.toString().length;\n    }\n    e.regex = /^([\\s]+at)?(.*?)(\\@|\\s\\(|\\s)([^\\(\\@\\n]+):([0-9]+):([0-9]+)(\\)?)$/;\n    e.baseSize = 58;\n    return e;\n  }();\nmodule.exports = s;",
  "9822": "const r = process.binding(\"async_wrap\"),\n  o = r.Providers.TIMERWRAP,\n  i = {\n    nextTick: require(3269),\n    promise: require(9565),\n    timers: require(7190)\n  },\n  s = new Set();\nfunction a() {\n  this.enabled = !1;\n  this.counter = 0;\n}\nfunction c() {\n  const e = this.initFns = [],\n    t = this.preFns = [],\n    n = this.postFns = [],\n    r = this.destroyFns = [];\n  this.init = function (t, n, r, i) {\n    if (n !== o) for (const o of e) o(t, this, n, r, i);else s.add(t);\n  };\n  this.pre = function (e) {\n    if (!s.has(e)) for (const n of t) n(e, this);\n  };\n  this.post = function (e, t) {\n    if (!s.has(e)) for (const r of n) r(e, this, t);\n  };\n  this.destroy = function (e) {\n    if (s.has(e)) s.delete(e);else for (const t of r) t(e);\n  };\n}\nfunction l(e, t) {\n  const n = e.indexOf(t);\n  -1 !== n && e.splice(n, 1);\n}\nfunction u() {\n  this._state = new a();\n  this._hooks = new c();\n  this.version = require(6157).i8;\n  this.providers = r.Providers;\n  for (const e of Object.keys(i)) i[e].call(this);\n  process.env.hasOwnProperty(\"NODE_ASYNC_HOOK_WARNING\") && console.warn(\"warning: you are using async-hook-jl which is unstable.\");\n  r.setupHooks({\n    init: this._hooks.init,\n    pre: this._hooks.pre,\n    post: this._hooks.post,\n    destroy: this._hooks.destroy\n  });\n}\nc.prototype.add = function (e) {\n  e.init && this.initFns.push(e.init);\n  e.pre && this.preFns.push(e.pre);\n  e.post && this.postFns.push(e.post);\n  e.destroy && this.destroyFns.push(e.destroy);\n};\nc.prototype.remove = function (e) {\n  e.init && l(this.initFns, e.init);\n  e.pre && l(this.preFns, e.pre);\n  e.post && l(this.postFns, e.post);\n  e.destroy && l(this.destroyFns, e.destroy);\n};\nmodule.exports = u;\nu.prototype.addHooks = function (e) {\n  this._hooks.add(e);\n};\nu.prototype.removeHooks = function (e) {\n  this._hooks.remove(e);\n};\nu.prototype.enable = function () {\n  this._state.enabled = !0;\n  r.enable();\n};\nu.prototype.disable = function () {\n  this._state.enabled = !1;\n  r.disable();\n};",
  "9824": "var r, o, i;\no = (r = require(8249)).lib.Base;\ni = r.enc.Utf8;\nmodule.exports = void (r.algo.HMAC = o.extend({\n  init: function (e, t) {\n    e = this._hasher = new e.init(), \"string\" == typeof t && (t = i.parse(t));\n    var n = e.blockSize,\n      r = 4 * n;\n    t.sigBytes > r && (t = e.finalize(t)), t.clamp();\n    for (var o = this._oKey = t.clone(), s = this._iKey = t.clone(), a = o.words, c = s.words, l = 0; l < n; l++) a[l] ^= 1549556828, c[l] ^= 909522486;\n    o.sigBytes = s.sigBytes = r, this.reset();\n  },\n  reset: function () {\n    var e = this._hasher;\n    e.reset(), e.update(this._iKey);\n  },\n  update: function (e) {\n    return this._hasher.update(e), this;\n  },\n  finalize: function (e) {\n    var t = this._hasher,\n      n = t.finalize(e);\n    return t.reset(), t.finalize(this._oKey.clone().concat(n));\n  }\n}));",
  "9825": "module.exports = require(6143);",
  "9829": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.rebuildTree = exports.foldTree = exports.visitTreeConditionally = exports.visitTree = exports.resetLineNumbers = exports.mapLabels = exports.clearLabelsIf = exports.clearLabels = undefined;\nconst r = require(9608);\nfunction visitTree(e, t, n) {\n  !function e(r) {\n    \"topDown\" === n && t(r);\n    r.subs.forEach(t => {\n      e(t);\n    });\n    \"bottomUp\" === n && t(r);\n  }(e);\n}\nexports.clearLabels = function (e) {\n  visitTree(e, e => {\n    e.label = undefined;\n  }, \"bottomUp\");\n  return e;\n};\nexports.clearLabelsIf = function (e, t) {\n  visitTree(e, e => {\n    e.label = e.label ? t(e.label) ? undefined : e.label : undefined;\n  }, \"bottomUp\");\n  return e;\n};\nexports.mapLabels = function e(t, n) {\n  switch (t.type) {\n    case \"line\":\n    case \"virtual\":\n      const r = t.subs.map(t => e(t, n));\n      return {\n        ...t,\n        subs: r,\n        label: t.label ? n(t.label) : undefined\n      };\n    case \"blank\":\n      return {\n        ...t,\n        label: t.label ? n(t.label) : undefined\n      };\n    case \"top\":\n      return {\n        ...t,\n        subs: t.subs.map(t => e(t, n)),\n        label: t.label ? n(t.label) : undefined\n      };\n  }\n};\nexports.resetLineNumbers = function (e) {\n  let t = 0;\n  visitTree(e, function (e) {\n    r.isVirtual(e) || r.isTop(e) || (e.lineNumber = t, t++);\n  }, \"topDown\");\n};\nexports.visitTree = visitTree;\nexports.visitTreeConditionally = function (e, t, n) {\n  !function e(r) {\n    if (\"topDown\" === n && !t(r)) return !1;\n    let o = !0;\n    r.subs.forEach(t => {\n      o = o && e(t);\n    });\n    \"bottomUp\" === n && (o = o && t(r));\n    return o;\n  }(e);\n};\nexports.foldTree = function (e, t, n, r) {\n  let i = t;\n  visitTree(e, function (e) {\n    i = n(e, i);\n  }, r);\n  return i;\n};\nexports.rebuildTree = function (e, t, n) {\n  const o = e => {\n      if (undefined !== n && n(e)) return e;\n      {\n        const n = e.subs.map(o).filter(e => undefined !== e);\n        e.subs = n;\n        return t(e);\n      }\n    },\n    i = o(e);\n  return undefined !== i ? i : r.topNode();\n};",
  "9852": "const r = require(7147),\n  o = require(1017),\n  i = (e, t) => Array.from(Array(t).keys()).slice(e),\n  s = e => e.charCodeAt(0),\n  a = new TextDecoder(\"utf-8\"),\n  c = e => a.decode(new Uint8Array(e));\nfunction l(e) {\n  const t = new Set();\n  let n = e[0];\n  for (let r = 1; r < e.length; r++) {\n    const o = e[r];\n    t.add([n, o]);\n    n = o;\n  }\n  return t;\n}\nconst u = new TextEncoder(\"utf-8\");\nconst d = /'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu;\nlet p = !1;\nconst h = {};\nlet f,\n  m = {},\n  g = new Map(),\n  _ = new Map();\nconst y = new Map();\nfunction v() {\n  if (p) return;\n  m = JSON.parse(r.readFileSync(o.resolve(__dirname, \"..\", \"dist\", \"tokenizer.json\")));\n  Object.keys(m).map(e => {\n    h[m[e]] = e;\n  });\n  const e = r.readFileSync(o.resolve(__dirname, \"..\", \"dist\", \"vocab.bpe\"), \"utf-8\").split(\"\\n\"),\n    t = e.slice(1, e.length - 1).map(e => e.split(/(\\s+)/).filter(function (e) {\n      return e.trim().length > 0;\n    }));\n  f = ((e, t) => {\n    const n = {};\n    e.map((r, o) => {\n      n[e[o]] = t[o];\n    });\n    return n;\n  })(t, i(0, t.length));\n  (function (e) {\n    const t = i(s(\"!\"), s(\"~\") + 1).concat(i(s(\"¡\"), s(\"¬\") + 1), i(s(\"®\"), s(\"ÿ\") + 1));\n    let n = t.slice(),\n      r = 0;\n    for (let e = 0; e < 256; e++) t.includes(e) || (t.push(e), n.push(256 + r), r += 1);\n    n = n.map(e => (e => String.fromCharCode(e))(e));\n    for (let r = 0; r < t.length; r++) e.set(t[r], n[r]);\n  })(g);\n  g.forEach(function (e, t, n) {\n    _.set(e, t);\n  });\n  p = !0;\n}\nfunction b(e) {\n  if (y.has(e)) return y.get(e);\n  let t = (r = e, Array.from(u.encode(r))).map(e => g.get(e)),\n    n = l(t);\n  var r;\n  if (!n) return t.map(e => m[e]);\n  for (;;) {\n    const e = {};\n    Array.from(n).map(t => {\n      const n = f[t];\n      e[isNaN(n) ? 1e11 : n] = t;\n    });\n    const r = e[Math.min(...Object.keys(e).map(e => parseInt(e)))];\n    if (!(r in f)) break;\n    const o = r[0],\n      i = r[1];\n    let s = [],\n      a = 0;\n    for (; a < t.length;) {\n      const e = t.indexOf(o, a);\n      if (-1 === e) {\n        Array.prototype.push.apply(s, t.slice(a));\n        break;\n      }\n      Array.prototype.push.apply(s, t.slice(a, e));\n      a = e;\n      t[a] === o && a < t.length - 1 && t[a + 1] === i ? (s.push(o + i), a += 2) : (s.push(t[a]), a += 1);\n    }\n    t = s;\n    if (1 === t.length) break;\n    n = l(t);\n  }\n  tokens = t.map(e => m[e]);\n  y.set(e, tokens);\n  return tokens;\n}\nfunction w(e) {\n  v();\n  let t = [];\n  const n = Array.from(e.matchAll(d)).map(e => e[0]);\n  for (let e of n) {\n    const n = b(e);\n    Array.prototype.push.apply(t, n);\n  }\n  return t;\n}\nfunction x(e, t) {\n  if (t <= 0) return \"\";\n  let n = Math.min(e.length, 4 * t),\n    r = e.slice(-n),\n    o = w(r);\n  for (; o.length < t + 2 && n < e.length;) {\n    n = Math.min(e.length, n + 1 * t);\n    r = e.slice(-n);\n    o = w(r);\n  }\n  return o.length < t ? e : (o = o.slice(-t), E(o));\n}\nfunction E(e) {\n  v();\n  let t = e.map(e => h[e]).join(\"\");\n  t = c(t.split(\"\").map(e => _.get(e)));\n  return t;\n}\nmodule.exports = {\n  prepareTokenizer: v,\n  tokenize: w,\n  tokenize_strings: function (e) {\n    return w(e).map(e => c(h[e].split(\"\").map(e => _.get(e))));\n  },\n  tokenLength: function (e) {\n    return w(e).length;\n  },\n  takeLastTokens: x,\n  takeLastLinesTokens: function (e, t) {\n    const n = x(e, t);\n    if (n.length === e.length || \"\\n\" === e[e.length - n.length - 1]) return n;\n    let r = n.indexOf(\"\\n\");\n    return n.substring(r + 1);\n  },\n  takeFirstTokens: function (e, t) {\n    if (t <= 0) return {\n      text: \"\",\n      tokens: []\n    };\n    let n = Math.min(e.length, 4 * t),\n      r = e.slice(0, n),\n      o = w(r);\n    for (; o.length < t + 2 && n < e.length;) {\n      n = Math.min(e.length, n + 1 * t);\n      r = e.slice(0, n);\n      o = w(r);\n    }\n    return o.length < t ? {\n      text: e,\n      tokens: o\n    } : (o = o.slice(0, t), {\n      text: E(o),\n      tokens: o\n    });\n  },\n  detokenize: E\n};",
  "9864": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nconst r = require(3487),\n  o = require(6776),\n  i = {\n    keyword: \"contains\",\n    type: \"array\",\n    schemaType: [\"object\", \"boolean\"],\n    before: \"uniqueItems\",\n    trackErrors: !0,\n    error: {\n      message: ({\n        params: {\n          min: e,\n          max: t\n        }\n      }) => undefined === t ? r.str`must contain at least ${e} valid item(s)` : r.str`must contain at least ${e} and no more than ${t} valid item(s)`,\n      params: ({\n        params: {\n          min: e,\n          max: t\n        }\n      }) => undefined === t ? r._`{minContains: ${e}}` : r._`{minContains: ${e}, maxContains: ${t}}`\n    },\n    code(e) {\n      const {\n        gen: t,\n        schema: n,\n        parentSchema: i,\n        data: s,\n        it: a\n      } = e;\n      let c, l;\n      const {\n        minContains: u,\n        maxContains: d\n      } = i;\n      a.opts.next ? (c = undefined === u ? 1 : u, l = d) : c = 1;\n      const p = t.const(\"len\", r._`${s}.length`);\n      e.setParams({\n        min: c,\n        max: l\n      });\n      if (void 0 === l && 0 === c) return void (0, o.checkStrictMode)(a, '\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored');\n      if (undefined !== l && c > l) {\n        o.checkStrictMode(a, '\"minContains\" > \"maxContains\" is always invalid');\n        return void e.fail();\n      }\n      if (o.alwaysValidSchema(a, n)) {\n        let t = r._`${p} >= ${c}`;\n        undefined !== l && (t = r._`${t} && ${p} <= ${l}`);\n        return void e.pass(t);\n      }\n      a.items = !0;\n      const h = t.name(\"valid\");\n      if (undefined === l && 1 === c) f(h, () => t.if(h, () => t.break()));else {\n        t.let(h, !1);\n        const e = t.name(\"_valid\"),\n          n = t.let(\"count\", 0);\n        f(e, () => t.if(e, () => function (e) {\n          t.code(r._`${e}++`);\n          undefined === l ? t.if(r._`${e} >= ${c}`, () => t.assign(h, !0).break()) : (t.if(r._`${e} > ${l}`, () => t.assign(h, !1).break()), 1 === c ? t.assign(h, !0) : t.if(r._`${e} >= ${c}`, () => t.assign(h, !0)));\n        }(n)));\n      }\n      function f(n, r) {\n        t.forRange(\"i\", 0, p, t => {\n          e.subschema({\n            keyword: \"contains\",\n            dataProp: t,\n            dataPropType: o.Type.Num,\n            compositeRule: !0\n          }, n);\n          r();\n        });\n      }\n      e.result(h, () => e.reset());\n    }\n  };\nexports.default = i;",
  "9867": "var r = require(6372),\n  o = r.wrap,\n  i = r.unwrap,\n  s = \"wrap@before\";\nfunction a(e, t, n) {\n  var r = !!e[t] && e.propertyIsEnumerable(t);\n  Object.defineProperty(e, t, {\n    configurable: !0,\n    enumerable: r,\n    writable: !0,\n    value: n\n  });\n}\nfunction c(e, t) {\n  var n;\n  n = e._events && e._events[t];\n  Array.isArray(n) || (n = n ? [n] : []);\n  return n;\n}\nfunction l(e, t) {\n  if (e) {\n    var n = e;\n    if (\"function\" == typeof e) n = t(e);else if (Array.isArray(e)) {\n      n = [];\n      for (var r = 0; r < e.length; r++) n[r] = t(e[r]);\n    }\n    return n;\n  }\n}\nmodule.exports = function (e, t, n) {\n  if (!(e && e.on && e.addListener && e.removeListener && e.emit)) throw new Error(\"can only wrap real EEs\");\n  if (!t) throw new Error(\"must have function to run on listener addition\");\n  if (!n) throw new Error(\"must have function to wrap listeners when emitting\");\n  function r(e) {\n    return function (t, n) {\n      var i = c(this, t).slice();\n      try {\n        var a = e.call(this, t, n);\n        (function (e, t, n) {\n          var r = c(e, t).filter(function (e) {\n            return -1 === n.indexOf(e);\n          });\n          r.length > 0 && function (e, t) {\n            for (var n = t.length, r = 0; r < n; r++) {\n              var o = t[r],\n                i = e[s];\n              if (\"function\" == typeof i) i(o);else if (Array.isArray(i)) for (var a = i.length, c = 0; c < a; c++) i[c](o);\n            }\n          }(e, r);\n        })(this, t, i);\n        return a;\n      } finally {\n        this.on.__wrapped || o(this, \"on\", r);\n        this.addListener.__wrapped || o(this, \"addListener\", r);\n      }\n    };\n  }\n  e[s] ? \"function\" == typeof e[s] ? a(e, s, [e[s], t]) : Array.isArray(e[s]) && e[s].push(t) : a(e, s, t);\n  e.__wrapped || (o(e, \"addListener\", r), o(e, \"on\", r), o(e, \"emit\", function (e) {\n    return function (t) {\n      if (!this._events || !this._events[t]) return e.apply(this, arguments);\n      var r = this._events[t];\n      function s(e) {\n        return function () {\n          this._events[t] = r;\n          try {\n            return e.apply(this, arguments);\n          } finally {\n            r = this._events[t];\n            this._events[t] = l(r, n);\n          }\n        };\n      }\n      o(this, \"removeListener\", s);\n      try {\n        this._events[t] = l(r, n);\n        return e.apply(this, arguments);\n      } finally {\n        i(this, \"removeListener\");\n        this._events[t] = r;\n      }\n    };\n  }), a(e, \"__unwrap\", function () {\n    i(e, \"addListener\");\n    i(e, \"on\");\n    i(e, \"emit\");\n    delete e[s];\n    delete e.__wrapped;\n  }), a(e, \"__wrapped\", !0));\n};",
  "9871": "module.exports = function () {\n  this.applicationVersion = \"ai.application.ver\";\n  this.deviceId = \"ai.device.id\";\n  this.deviceLocale = \"ai.device.locale\";\n  this.deviceModel = \"ai.device.model\";\n  this.deviceOEMName = \"ai.device.oemName\";\n  this.deviceOSVersion = \"ai.device.osVersion\";\n  this.deviceType = \"ai.device.type\";\n  this.locationIp = \"ai.location.ip\";\n  this.operationId = \"ai.operation.id\";\n  this.operationName = \"ai.operation.name\";\n  this.operationParentId = \"ai.operation.parentId\";\n  this.operationSyntheticSource = \"ai.operation.syntheticSource\";\n  this.operationCorrelationVector = \"ai.operation.correlationVector\";\n  this.sessionId = \"ai.session.id\";\n  this.sessionIsFirst = \"ai.session.isFirst\";\n  this.userAccountId = \"ai.user.accountId\";\n  this.userId = \"ai.user.id\";\n  this.userAuthUserId = \"ai.user.authUserId\";\n  this.cloudRole = \"ai.cloud.role\";\n  this.cloudRoleInstance = \"ai.cloud.roleInstance\";\n  this.internalSdkVersion = \"ai.internal.sdkVersion\";\n  this.internalAgentVersion = \"ai.internal.agentVersion\";\n  this.internalNodeName = \"ai.internal.nodeName\";\n};",
  "9872": "const {\n    validateHeaderName: r,\n    validateHeaderValue: o\n  } = require(3685),\n  {\n    isPlainObject: i\n  } = require(4544),\n  s = Symbol(\"Headers internals\"),\n  a = e => {\n    const t = \"string\" != typeof e ? String(e) : e;\n    if (\"function\" == typeof r) r(t);else if (!/^[\\^`\\-\\w!#$%&'*+.|~]+$/.test(t)) {\n      const e = new TypeError(`Header name must be a valid HTTP token [${t}]`);\n      throw Object.defineProperty(e, \"code\", {\n        value: \"ERR_INVALID_HTTP_TOKEN\"\n      }), e;\n    }\n    return t.toLowerCase();\n  },\n  c = (e, t) => {\n    const n = \"string\" != typeof e ? String(e) : e;\n    if (\"function\" == typeof o) o(t, n);else if (/[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/.test(n)) {\n      const e = new TypeError(`Invalid character in header content [\"${t}\"]`);\n      throw Object.defineProperty(e, \"code\", {\n        value: \"ERR_INVALID_CHAR\"\n      }), e;\n    }\n    return n;\n  };\nclass l {\n  constructor(e = {}) {\n    this[s] = {\n      map: new Map()\n    };\n    if (e instanceof l) e.forEach((e, t) => {\n      this.append(t, e);\n    });else if (Array.isArray(e)) e.forEach(([e, t]) => {\n      this.append(e, t);\n    });else if (i(e)) for (const [t, n] of Object.entries(e)) this.append(t, n);\n  }\n  set(e, t) {\n    this[s].map.set(a(e), c(t, e));\n  }\n  has(e) {\n    return this[s].map.has(a(e));\n  }\n  get(e) {\n    const t = this[s].map.get(a(e));\n    return undefined === t ? null : t;\n  }\n  append(e, t) {\n    const n = a(e),\n      r = c(t, e),\n      o = this[s].map.get(n);\n    this[s].map.set(n, o ? `${o}, ${r}` : r);\n  }\n  delete(e) {\n    this[s].map.delete(a(e));\n  }\n  forEach(e, t) {\n    for (const n of this.keys()) e.call(t, this.get(n), n);\n  }\n  keys() {\n    return Array.from(this[s].map.keys()).sort();\n  }\n  *values() {\n    for (const e of this.keys()) yield this.get(e);\n  }\n  *entries() {\n    for (const e of this.keys()) yield [e, this.get(e)];\n  }\n  [Symbol.iterator]() {\n    return this.entries();\n  }\n  get [Symbol.toStringTag]() {\n    return this.constructor.name;\n  }\n  plain() {\n    return Object.fromEntries(this[s].map);\n  }\n}\nObject.defineProperties(l.prototype, [\"append\", \"delete\", \"entries\", \"forEach\", \"get\", \"has\", \"keys\", \"set\", \"values\"].reduce((e, t) => (e[t] = {\n  enumerable: !0\n}, e), {}));\nmodule.exports = {\n  Headers: l\n};",
  "9899": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.logger = exports.toPlainText = exports.Logger = exports.MultiLog = exports.OutputChannelLog = exports.ConsoleLog = exports.LogTarget = exports.verboseLogging = exports.LogVerbose = exports.LogLevel = undefined;\nconst r = require(299),\n  o = require(1133),\n  i = require(6333);\nvar s;\n!function (e) {\n  e[e.DEBUG = 0] = \"DEBUG\";\n  e[e.INFO = 1] = \"INFO\";\n  e[e.WARN = 2] = \"WARN\";\n  e[e.ERROR = 3] = \"ERROR\";\n}(s = exports.LogLevel || (exports.LogLevel = {}));\nclass LogVerbose {\n  constructor(e) {\n    this.logVerbose = e;\n  }\n}\nfunction verboseLogging(e) {\n  return e.get(LogVerbose).logVerbose;\n}\nexports.LogVerbose = LogVerbose;\nexports.verboseLogging = verboseLogging;\nclass LogTarget {\n  shouldLog(e, t) {}\n}\nexports.LogTarget = LogTarget;\nexports.ConsoleLog = class extends LogTarget {\n  constructor(e) {\n    super();\n    this.console = e;\n  }\n  logIt(e, t, n, ...r) {\n    verboseLogging(e) || t == s.ERROR ? this.console.error(n, ...r) : t == s.WARN && this.console.warn(n, ...r);\n  }\n};\nexports.OutputChannelLog = class extends LogTarget {\n  constructor(e) {\n    super();\n    this.output = e;\n  }\n  logIt(e, t, n, ...r) {\n    this.output.appendLine(`${n} ${r.map(toPlainText)}`);\n  }\n};\nexports.MultiLog = class extends LogTarget {\n  constructor(e) {\n    super();\n    this.targets = e;\n  }\n  logIt(e, t, n, ...r) {\n    this.targets.forEach(o => o.logIt(e, t, n, ...r));\n  }\n};\nclass Logger {\n  constructor(e, t) {\n    this.minLoggedLevel = e;\n    this.context = t;\n  }\n  setLevel(e) {\n    this.minLoggedLevel = e;\n  }\n  stringToLevel(e) {\n    return s[e];\n  }\n  log(e, t, n, ...o) {\n    const a = s[t];\n    t == s.ERROR && i.telemetryError(e, \"log\", i.TelemetryData.createAndMarkAsIssued({\n      context: this.context,\n      level: a,\n      message: o.length > 0 ? JSON.stringify(o) : \"no msg\"\n    }), n);\n    const c = e.get(LogTarget),\n      u = c.shouldLog(e, t);\n    if (!1 === u) return;\n    if (undefined === u && !this.shouldLog(e, t, this.context)) return;\n    const d = e.get(r.Clock).now().toISOString(),\n      p = `[${a}] [${this.context}] [${d}]`;\n    c.logIt(e, t, p, ...o);\n  }\n  shouldLog(e, t, n) {\n    var r, i;\n    if (verboseLogging(e)) return !0;\n    const s = o.getConfig(e, o.ConfigKey.DebugFilterLogCategories);\n    if (s.length > 0 && !s.includes(n)) return !1;\n    if (o.isProduction(e)) return t >= this.minLoggedLevel;\n    const a = o.getConfig(e, o.ConfigKey.DebugOverrideLogLevels);\n    return t >= (null !== (i = null !== (r = this.stringToLevel(a[\"*\"])) && undefined !== r ? r : this.stringToLevel(a[this.context])) && undefined !== i ? i : this.minLoggedLevel);\n  }\n  debug(e, ...t) {\n    this.log(e, s.DEBUG, !1, ...t);\n  }\n  info(e, ...t) {\n    this.log(e, s.INFO, !1, ...t);\n  }\n  warn(e, ...t) {\n    this.log(e, s.WARN, !1, ...t);\n  }\n  error(e, ...t) {\n    this.log(e, s.ERROR, !1, ...t);\n  }\n  secureError(e, t, ...n) {\n    this.log(e, s.ERROR, !1, t);\n    this.log(e, s.ERROR, !0, t, ...n);\n  }\n}\nfunction toPlainText(e) {\n  return \"object\" == typeof e ? JSON.stringify(e) : String(e);\n}\nexports.Logger = Logger;\nexports.toPlainText = toPlainText;\nexports.logger = new Logger(s.INFO, \"default\");",
  "9931": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getNeighborSnippets = exports.neighborOptionToSelection = undefined;\nconst r = require(1788),\n  o = require(569);\nfunction i(e) {\n  return [e.relativePath ? \"Compare this snippet from \" + e.relativePath + \":\" : \"Compare this snippet:\"].concat(e.snippet.split(\"\\n\"));\n}\nexports.neighborOptionToSelection = {\n  none: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(1),\n    threshold: -1,\n    numberOfSnippets: 0\n  },\n  conservative: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\n    threshold: .3,\n    numberOfSnippets: 1\n  },\n  medium: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(20),\n    threshold: .1,\n    numberOfSnippets: 2\n  },\n  eager: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(60),\n    threshold: 0,\n    numberOfSnippets: 4\n  },\n  eagerButLittle: {\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\n    threshold: 0,\n    numberOfSnippets: 1\n  }\n};\nexports.getNeighborSnippets = async function (e, n, s, a, c, l, u) {\n  const d = exports.neighborOptionToSelection[s],\n    p = function (e, n, r, i) {\n      const s = {\n        ...exports.neighborOptionToSelection[n]\n      };\n      undefined !== r && undefined !== i && (s.matcherFactory = o.IndentationBasedJaccardMatcher.FACTORY(r, i));\n      return s.matcherFactory.to(e);\n    }(e, s, a, c);\n  return n.filter(e => e.source.length < 1e4 && e.source.length > 0).slice(0, 20).reduce((e, t) => e.concat(p.findMatches(t, l, u).map(e => ({\n    relativePath: t.relativePath,\n    ...e\n  }))), []).filter(e => e.score && e.snippet && e.score > d.threshold).sort((e, t) => e.score - t.score).slice(-d.numberOfSnippets).map(t => ({\n    score: t.score,\n    snippet: i(t).map(t => r.comment(t, e.languageId) + \"\\n\").join(\"\"),\n    startLine: t.startLine,\n    endLine: t.endLine\n  }));\n};",
  "9940": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.getNodeStart = exports.isBlockBodyFinished = exports.isEmptyBlockStart = exports.getBlockParser = undefined;\nconst r = require(464);\nclass o {\n  constructor(e, t, n) {\n    this.languageId = e;\n    this.nodeMatch = t;\n    this.nodeTypesWithBlockOrStmtChild = n;\n  }\n  async getNodeMatchAtPosition(e, t, n) {\n    const o = await r.parseTree(this.languageId, e);\n    try {\n      let e = o.rootNode.descendantForIndex(t);\n      for (; e;) {\n        const t = this.nodeMatch[e.type];\n        if (t) {\n          if (!this.nodeTypesWithBlockOrStmtChild.has(e.type)) break;\n          const n = this.nodeTypesWithBlockOrStmtChild.get(e.type),\n            r = \"\" == n ? e.namedChildren[0] : e.childForFieldName(n);\n          if ((null == r ? undefined : r.type) == t) break;\n        }\n        e = e.parent;\n      }\n      if (!e) return;\n      return n(e);\n    } finally {\n      o.delete();\n    }\n  }\n  getNextBlockAtPosition(e, t, n) {\n    return this.getNodeMatchAtPosition(e, t, e => {\n      let t = e.children.reverse().find(t => t.type == this.nodeMatch[e.type]);\n      if (t) {\n        if (\"python\" == this.languageId && t.parent) {\n          const e = \":\" == t.parent.type ? t.parent.parent : t.parent;\n          let n = null == e ? undefined : e.nextSibling;\n          for (; n && \"comment\" == n.type;) {\n            const r = n.startPosition.row == t.endPosition.row && n.startPosition.column >= t.endPosition.column,\n              o = n.startPosition.row > e.endPosition.row && n.startPosition.column > e.startPosition.column;\n            if (!r && !o) break;\n            t = n;\n            n = n.nextSibling;\n          }\n        }\n        if (!(t.endIndex >= t.tree.rootNode.endIndex - 1 && (t.hasError() || t.parent.hasError()))) return n(t);\n      }\n    });\n  }\n  async isBlockBodyFinished(e, t, n) {\n    const r = (e + t).trimEnd(),\n      o = await this.getNextBlockAtPosition(r, n, e => e.endIndex);\n    if (undefined !== o && o < r.length) {\n      const t = o - e.length;\n      return t > 0 ? t : undefined;\n    }\n  }\n  getNodeStart(e, t) {\n    const n = e.trimEnd();\n    return this.getNodeMatchAtPosition(n, t, e => e.startIndex);\n  }\n}\nclass i extends o {\n  constructor(e, t, n, r, o) {\n    super(e, r, o);\n    this.blockEmptyMatch = t;\n    this.lineMatch = n;\n  }\n  isBlockStart(e) {\n    return this.lineMatch.test(e.trimStart());\n  }\n  async isBlockBodyEmpty(e, t) {\n    const n = await this.getNextBlockAtPosition(e, t, n => {\n      n.startIndex < t && (t = n.startIndex);\n      let r = e.substring(t, n.endIndex).trim();\n      return \"\" == r || r.replace(/\\s/g, \"\") == this.blockEmptyMatch;\n    });\n    return undefined === n || n;\n  }\n  async isEmptyBlockStart(e, t) {\n    t = s(e, t);\n    return this.isBlockStart(function (e, t) {\n      const n = e.lastIndexOf(\"\\n\", t - 1);\n      let r = e.indexOf(\"\\n\", t);\n      r < 0 && (r = e.length);\n      return e.slice(n + 1, r);\n    }(e, t)) && this.isBlockBodyEmpty(e, t);\n  }\n}\nfunction s(e, t) {\n  let n = t;\n  for (; n > 0 && /\\s/.test(e.charAt(n - 1));) n--;\n  return n;\n}\nfunction a(e, t) {\n  const n = e.startIndex,\n    r = e.startIndex - e.startPosition.column,\n    o = t.substring(r, n);\n  if (/^\\s*$/.test(o)) return o;\n}\nfunction c(e, t, n) {\n  if (t.startPosition.row <= e.startPosition.row) return !1;\n  const r = a(e, n),\n    o = a(t, n);\n  return undefined !== r && undefined !== o && r.startsWith(o);\n}\nclass l extends o {\n  constructor(e, t, n, r, o, i, s) {\n    super(e, t, n);\n    this.startKeywords = r;\n    this.blockNodeType = o;\n    this.emptyStatementType = i;\n    this.curlyBraceLanguage = s;\n  }\n  isBlockEmpty(e, t) {\n    var n, o;\n    let i = e.text.trim();\n    this.curlyBraceLanguage && (i.startsWith(\"{\") && (i = i.slice(1)), i.endsWith(\"}\") && (i = i.slice(0, -1)), i = i.trim());\n    return 0 == i.length || !(\"python\" != this.languageId || \"class_definition\" != (null === (n = e.parent) || undefined === n ? undefined : n.type) && \"function_definition\" != (null === (o = e.parent) || undefined === o ? undefined : o.type) || 1 != e.children.length || !r.queryPythonIsDocstring(e.parent));\n  }\n  async isEmptyBlockStart(e, t) {\n    var n, o, i;\n    if (t > e.length) throw new RangeError(\"Invalid offset\");\n    for (let n = t; n < e.length && \"\\n\" != e.charAt(n); n++) if (/\\S/.test(e.charAt(n))) return !1;\n    t = s(e, t);\n    const a = await r.parseTree(this.languageId, e);\n    try {\n      const r = a.rootNode.descendantForIndex(t - 1);\n      if (null == r) return !1;\n      if (this.curlyBraceLanguage && \"}\" == r.type) return !1;\n      if ((\"javascript\" == this.languageId || \"typescript\" == this.languageId) && r.parent && \"object\" == r.parent.type && \"{\" == r.parent.text.trim()) return !0;\n      if (\"typescript\" == this.languageId) {\n        let n = r;\n        for (; n.parent;) {\n          if (\"function_signature\" == n.type || \"method_signature\" == n.type) {\n            const o = r.nextSibling;\n            return !!(o && n.hasError() && c(n, o, e)) || !n.children.find(e => \";\" == e.type) && n.endIndex <= t;\n          }\n          n = n.parent;\n        }\n      }\n      let s = null,\n        l = null,\n        u = null,\n        d = r;\n      for (; null != d;) {\n        if (d.type == this.blockNodeType) {\n          l = d;\n          break;\n        }\n        if (this.nodeMatch[d.type]) {\n          u = d;\n          break;\n        }\n        if (\"ERROR\" == d.type) {\n          s = d;\n          break;\n        }\n        d = d.parent;\n      }\n      if (null != l) {\n        if (!l.parent || !this.nodeMatch[l.parent.type]) return !1;\n        if (\"python\" == this.languageId) {\n          const e = l.previousSibling;\n          if (null != e && e.hasError() && (e.text.startsWith('\"\"\"') || e.text.startsWith(\"'''\"))) return !0;\n        }\n        return this.isBlockEmpty(l, t);\n      }\n      if (null != s) {\n        if (\"module\" == (null === (n = s.previousSibling) || undefined === n ? undefined : n.type) || \"internal_module\" == (null === (o = s.previousSibling) || undefined === o ? undefined : o.type)) return !0;\n        const e = [...s.children].reverse(),\n          a = e.find(e => this.startKeywords.includes(e.type));\n        let c = e.find(e => e.type == this.blockNodeType);\n        if (a) {\n          switch (this.languageId) {\n            case \"python\":\n              {\n                \"try\" == a.type && \"identifier\" == r.type && r.text.length > 4 && (c = null === (i = e.find(e => e.hasError())) || undefined === i ? undefined : i.children.find(e => \"block\" == e.type));\n                const t = e.find(e => \":\" == e.type);\n                if (t && a.endIndex <= t.startIndex && t.nextSibling) {\n                  if (\"def\" == a.type) {\n                    const e = t.nextSibling;\n                    if ('\"' == e.type || \"'\" == e.type) return !0;\n                    if (\"ERROR\" == e.type && ('\"\"\"' == e.text || \"'''\" == e.text)) return !0;\n                  }\n                  return !1;\n                }\n                break;\n              }\n            case \"javascript\":\n              {\n                const t = e.find(e => \"formal_parameters\" == e.type);\n                if (\"class\" == a.type && t) return !0;\n                const n = e.find(e => \"{\" == e.type);\n                if (n && n.startIndex > a.endIndex && null != n.nextSibling) return !1;\n                if (e.find(e => \"do\" == e.type) && \"while\" == a.type) return !1;\n                if (\"=>\" == a.type && a.nextSibling && \"{\" != a.nextSibling.type) return !1;\n                break;\n              }\n            case \"typescript\":\n              {\n                const t = e.find(e => \"{\" == e.type);\n                if (t && t.startIndex > a.endIndex && null != t.nextSibling) return !1;\n                if (e.find(e => \"do\" == e.type) && \"while\" == a.type) return !1;\n                if (\"=>\" == a.type && a.nextSibling && \"{\" != a.nextSibling.type) return !1;\n                break;\n              }\n          }\n          return !(c && c.startIndex > a.endIndex) || this.isBlockEmpty(c, t);\n        }\n      }\n      if (null != u) {\n        const e = this.nodeMatch[u.type],\n          n = u.children.slice().reverse().find(t => t.type == e);\n        if (n) return this.isBlockEmpty(n, t);\n        if (this.nodeTypesWithBlockOrStmtChild.has(u.type)) {\n          const e = this.nodeTypesWithBlockOrStmtChild.get(u.type),\n            t = \"\" == e ? u.children[0] : u.childForFieldName(e);\n          if (t && t.type != this.blockNodeType && t.type != this.emptyStatementType) return !1;\n        }\n        return !0;\n      }\n      return !1;\n    } finally {\n      a.delete();\n    }\n  }\n}\nconst u = {\n  python: new l(\"python\", {\n    class_definition: \"block\",\n    elif_clause: \"block\",\n    else_clause: \"block\",\n    except_clause: \"block\",\n    finally_clause: \"block\",\n    for_statement: \"block\",\n    function_definition: \"block\",\n    if_statement: \"block\",\n    try_statement: \"block\",\n    while_statement: \"block\",\n    with_statement: \"block\"\n  }, new Map(), [\"def\", \"class\", \"if\", \"elif\", \"else\", \"for\", \"while\", \"try\", \"except\", \"finally\", \"with\"], \"block\", null, !1),\n  javascript: new l(\"javascript\", {\n    arrow_function: \"statement_block\",\n    catch_clause: \"statement_block\",\n    do_statement: \"statement_block\",\n    else_clause: \"statement_block\",\n    finally_clause: \"statement_block\",\n    for_in_statement: \"statement_block\",\n    for_statement: \"statement_block\",\n    function: \"statement_block\",\n    function_declaration: \"statement_block\",\n    generator_function: \"statement_block\",\n    generator_function_declaration: \"statement_block\",\n    if_statement: \"statement_block\",\n    method_definition: \"statement_block\",\n    try_statement: \"statement_block\",\n    while_statement: \"statement_block\",\n    with_statement: \"statement_block\",\n    class: \"class_body\",\n    class_declaration: \"class_body\"\n  }, new Map([[\"arrow_function\", \"body\"], [\"do_statement\", \"body\"], [\"else_clause\", \"\"], [\"for_in_statement\", \"body\"], [\"for_statement\", \"body\"], [\"if_statement\", \"consequence\"], [\"while_statement\", \"body\"], [\"with_statement\", \"body\"]]), [\"=>\", \"try\", \"catch\", \"finally\", \"do\", \"for\", \"if\", \"else\", \"while\", \"with\", \"function\", \"function*\", \"class\"], \"statement_block\", \"empty_statement\", !0),\n  typescript: new l(\"typescript\", {\n    ambient_declaration: \"statement_block\",\n    arrow_function: \"statement_block\",\n    catch_clause: \"statement_block\",\n    do_statement: \"statement_block\",\n    else_clause: \"statement_block\",\n    finally_clause: \"statement_block\",\n    for_in_statement: \"statement_block\",\n    for_statement: \"statement_block\",\n    function: \"statement_block\",\n    function_declaration: \"statement_block\",\n    generator_function: \"statement_block\",\n    generator_function_declaration: \"statement_block\",\n    if_statement: \"statement_block\",\n    internal_module: \"statement_block\",\n    method_definition: \"statement_block\",\n    module: \"statement_block\",\n    try_statement: \"statement_block\",\n    while_statement: \"statement_block\",\n    abstract_class_declaration: \"class_body\",\n    class: \"class_body\",\n    class_declaration: \"class_body\"\n  }, new Map([[\"arrow_function\", \"body\"], [\"do_statement\", \"body\"], [\"else_clause\", \"\"], [\"for_in_statement\", \"body\"], [\"for_statement\", \"body\"], [\"if_statement\", \"consequence\"], [\"while_statement\", \"body\"], [\"with_statement\", \"body\"]]), [\"declare\", \"=>\", \"try\", \"catch\", \"finally\", \"do\", \"for\", \"if\", \"else\", \"while\", \"with\", \"function\", \"function*\", \"class\"], \"statement_block\", \"empty_statement\", !0),\n  go: new i(\"go\", \"{}\", /\\b(func|if|else|for)\\b/, {\n    communication_case: \"block\",\n    default_case: \"block\",\n    expression_case: \"block\",\n    for_statement: \"block\",\n    func_literal: \"block\",\n    function_declaration: \"block\",\n    if_statement: \"block\",\n    labeled_statement: \"block\",\n    method_declaration: \"block\",\n    type_case: \"block\"\n  }, new Map()),\n  ruby: new i(\"ruby\", \"end\", /\\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\\b|->/, {\n    begin_block: \"}\",\n    block: \"}\",\n    end_block: \"}\",\n    lambda: \"block\",\n    for: \"do\",\n    until: \"do\",\n    while: \"do\",\n    case: \"end\",\n    do: \"end\",\n    if: \"end\",\n    method: \"end\",\n    module: \"end\",\n    unless: \"end\",\n    do_block: \"end\"\n  }, new Map())\n};\nfunction getBlockParser(e) {\n  return u[r.languageIdToWasmLanguage(e)];\n}\nexports.getBlockParser = getBlockParser;\nexports.isEmptyBlockStart = async function (e, t, n) {\n  return !!r.isSupportedLanguageId(e) && getBlockParser(e).isEmptyBlockStart(t, n);\n};\nexports.isBlockBodyFinished = async function (e, t, n, o) {\n  if (r.isSupportedLanguageId(e)) return getBlockParser(e).isBlockBodyFinished(t, n, o);\n};\nexports.getNodeStart = async function (e, t, n) {\n  if (r.isSupportedLanguageId(e)) return getBlockParser(e).getNodeStart(t, n);\n};",
  "9958": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.AvailabilityData = require(7220);\nexports.Base = require(4101);\nexports.ContextTagKeys = require(9871);\nexports.Data = require(320);\nexports.DataPoint = require(8602);\nexports.DataPointType = require(495);\nexports.Domain = require(8934);\nexports.Envelope = require(7300);\nexports.EventData = require(4526);\nexports.ExceptionData = require(935);\nexports.ExceptionDetails = require(8082);\nexports.MessageData = require(901);\nexports.MetricData = require(3092);\nexports.PageViewData = require(6279);\nexports.RemoteDependencyData = require(6290);\nexports.RequestData = require(7339);\nexports.SeverityLevel = require(9697);\nexports.StackFrame = require(6376);",
  "9962": "var r = require(5740),\n  o = require(5282),\n  i = function () {\n    function e() {}\n    e.queryCorrelationId = function (t, n) {\n      var i = t.profileQueryEndpoint + \"/api/profiles/\" + t.instrumentationKey + \"/appId\";\n      if (e.completedLookups.hasOwnProperty(i)) n(e.completedLookups[i]);else if (e.pendingLookups[i]) e.pendingLookups[i].push(n);else {\n        e.pendingLookups[i] = [n];\n        var s = function () {\n          if (e.pendingLookups[i]) {\n            var n = {\n              method: \"GET\",\n              disableAppInsightsAutoCollection: !0\n            };\n            o.info(e.TAG, n);\n            var a = r.makeRequest(t, i, n, function (n) {\n              if (200 === n.statusCode) {\n                var r = \"\";\n                n.setEncoding(\"utf-8\");\n                n.on(\"data\", function (e) {\n                  r += e;\n                });\n                n.on(\"end\", function () {\n                  o.info(e.TAG, r);\n                  var t = e.correlationIdPrefix + r;\n                  e.completedLookups[i] = t;\n                  e.pendingLookups[i] && e.pendingLookups[i].forEach(function (e) {\n                    return e(t);\n                  });\n                  delete e.pendingLookups[i];\n                });\n              } else n.statusCode >= 400 && n.statusCode < 500 ? (e.completedLookups[i] = undefined, delete e.pendingLookups[i]) : setTimeout(s, t.correlationIdRetryIntervalMs);\n            });\n            a && (a.on(\"error\", function (t) {\n              o.warn(e.TAG, t);\n            }), a.end());\n          }\n        };\n        setTimeout(s, 0);\n      }\n    };\n    e.cancelCorrelationIdQuery = function (t, n) {\n      var r = t.profileQueryEndpoint + \"/api/profiles/\" + t.instrumentationKey + \"/appId\",\n        o = e.pendingLookups[r];\n      o && (e.pendingLookups[r] = o.filter(function (e) {\n        return e != n;\n      }), 0 == e.pendingLookups[r].length && delete e.pendingLookups[r]);\n    };\n    e.generateRequestId = function (t) {\n      if (t) {\n        \".\" !== (t = \"|\" == t[0] ? t : \"|\" + t)[t.length - 1] && (t += \".\");\n        var n = (e.currentRootId++).toString(16);\n        return e.appendSuffix(t, n, \"_\");\n      }\n      return e.generateRootId();\n    };\n    e.getRootId = function (e) {\n      var t = e.indexOf(\".\");\n      t < 0 && (t = e.length);\n      var n = \"|\" === e[0] ? 1 : 0;\n      return e.substring(n, t);\n    };\n    e.generateRootId = function () {\n      return \"|\" + r.w3cTraceId() + \".\";\n    };\n    e.appendSuffix = function (t, n, o) {\n      if (t.length + n.length < e.requestIdMaxLength) return t + n + o;\n      var i = e.requestIdMaxLength - 9;\n      if (t.length > i) for (; i > 1; --i) {\n        var s = t[i - 1];\n        if (\".\" === s || \"_\" === s) break;\n      }\n      if (i <= 1) return e.generateRootId();\n      for (n = r.randomu32().toString(16); n.length < 8;) n = \"0\" + n;\n      return t.substring(0, i) + n + \"#\";\n    };\n    e.TAG = \"CorrelationIdManager\";\n    e.correlationIdPrefix = \"cid-v1:\";\n    e.w3cEnabled = !1;\n    e.pendingLookups = {};\n    e.completedLookups = {};\n    e.requestIdMaxLength = 1024;\n    e.currentRootId = r.randomu32();\n    return e;\n  }();\nmodule.exports = i;",
  "9968": "var r;\nr = require(8249);\nrequire(5109);\nr.mode.CTRGladman = function () {\n  var e = r.lib.BlockCipherMode.extend();\n  function t(e) {\n    if (255 == (e >> 24 & 255)) {\n      var t = e >> 16 & 255,\n        n = e >> 8 & 255,\n        r = 255 & e;\n      255 === t ? (t = 0, 255 === n ? (n = 0, 255 === r ? r = 0 : ++r) : ++n) : ++t;\n      e = 0;\n      e += t << 16;\n      e += n << 8;\n      e += r;\n    } else e += 1 << 24;\n    return e;\n  }\n  var n = e.Encryptor = e.extend({\n    processBlock: function (e, n) {\n      var r = this._cipher,\n        o = r.blockSize,\n        i = this._iv,\n        s = this._counter;\n      i && (s = this._counter = i.slice(0), this._iv = undefined);\n      (function (e) {\n        0 === (e[0] = t(e[0])) && (e[1] = t(e[1]));\n      })(s);\n      var a = s.slice(0);\n      r.encryptBlock(a, 0);\n      for (var c = 0; c < o; c++) e[n + c] ^= a[c];\n    }\n  });\n  e.Decryptor = n;\n  return e;\n}();\nmodule.exports = r.mode.CTRGladman;",
  "main": "Object.defineProperty(exports, \"__esModule\", {\n  value: !0\n});\nexports.deactivate = exports.activate = exports.init = undefined;\nconst t = require(3055);\nrequire(406);\nconst o = require(9496),\n  i = require(362),\n  s = require(299),\n  a = require(1133),\n  c = require(4197),\n  l = require(7870),\n  u = require(9408),\n  d = require(1839),\n  p = require(9189),\n  h = require(9748),\n  f = require(8965),\n  m = require(5413),\n  g = require(9899),\n  _ = require(2279),\n  y = require(1547),\n  v = require(4419),\n  b = require(6722),\n  w = require(2533),\n  x = require(766),\n  E = require(6333),\n  C = require(956),\n  S = require(70),\n  T = require(8771),\n  k = require(6403),\n  I = require(3136),\n  P = require(7057),\n  A = require(3197),\n  O = require(1862),\n  N = require(9425),\n  R = require(3060),\n  M = (require(1929), require(6267)),\n  L = require(2990),\n  $ = require(6857),\n  D = require(9477),\n  F = require(7254),\n  j = require(4428),\n  q = require(8129),\n  B = require(385),\n  U = o.window.createOutputChannel(\"GitHub Copilot\");\nfunction init() {\n  _.init(new a.BuildInfo().getVersion());\n}\nfunction z(e, t, n) {\n  return o.commands.registerCommand(t, async (...r) => {\n    try {\n      return await n(...r);\n    } catch (n) {\n      E.telemetryException(e, n, t);\n    }\n  });\n}\nlet G;\nexports.init = init;\ninit();\nexports.activate = async function (e) {\n  const n = new l.Context();\n  n.set(a.ConfigProvider, new N.VSCodeConfigProvider());\n  n.set(s.Clock, new s.Clock());\n  n.set(a.BuildInfo, new a.BuildInfo());\n  n.set(a.EditorAndPluginInfo, new N.VSCodeEditorInfo());\n  n.set(g.LogVerbose, new g.LogVerbose(!1));\n  n.set(m.GhostTextDebounceManager, new m.GhostTextDebounceManager());\n  n.set(f.ContextualFilterManager, new f.ContextualFilterManager());\n  const r = new g.MultiLog([new g.ConsoleLog(console), new g.OutputChannelLog(U)]);\n  n.set(g.LogTarget, r);\n  n.set(k.LocationFactory, new q.ExtensionLocationFactory());\n  n.set(I.TextDocumentManager, new B.ExtensionTextDocumentManager());\n  n.set(p.Features, new p.Features(n));\n  const H = new _.HelixFetcher(n);\n  n.set(_.Fetcher, H);\n  D.initProxyEnvironment(H, process.env);\n  n.set(t.FileSystem, $.extensionFileSystem);\n  n.set(y.NotificationSender, new O.ExtensionNotificationSender());\n  n.set(E.TelemetryEndpointUrl, new E.TelemetryEndpointUrl());\n  e.extensionMode === o.ExtensionMode.Test ? (n.set(i.CopilotTokenManager, C.makeTestingCopilotTokenManager()), n.set(a.VscInfo, a.getTestVscInfo()), n.set(S.RuntimeMode, S.RuntimeMode.fromEnvironment(!0)), n.set(h.ExpConfigMaker, new h.ExpConfigNone()), n.set(E.TelemetryReporters, E.setupStandardReporters(n, \"copilot-test\")), n.set(P.UrlOpener, new T.TestUrlOpener())) : (n.set(i.CopilotTokenManager, new O.VSCodeCopilotTokenManager()), n.set(a.VscInfo, N.makeVscInfo()), n.set(v.OpenAIFetcher, new v.LiveOpenAIFetcher()), n.set(a.BlockModeConfig, new a.ConfigBlockModeConfig()), n.set(S.RuntimeMode, S.RuntimeMode.fromEnvironment(!1)), n.set(h.ExpConfigMaker, new h.ExpConfigFromTAS()), n.set(E.TelemetryReporters, j.activate(n, e)), n.set(P.UrlOpener, new P.RealUrlOpener()));\n  \"GitHub.copilot-nightly\" === e.extension.id && u.registerDefaultHandlers(n, \"vscode\");\n  N.setExtension(e.extension);\n  O.setExtensionContext(e);\n  e.globalState.setKeysForSync([O.telemetryAcceptanceKey]);\n  const V = a.getBuildType(n) === a.BuildType.DEV,\n    W = \"GitHub.copilot-nightly\" === e.extension.id;\n  if (W && o.extensions.all.find(e => \"GitHub.copilot\" === e.id)) return void (\"Uninstall\" === (await o.window.showWarningMessage(\"To use GitHub Copilot Nightly you need to uninstall GitHub Copilot extension\", \"Uninstall\")) && (await o.commands.executeCommand(\"workbench.extensions.uninstallExtension\", \"GitHub.copilot\")));\n  (W || V) && o.commands.executeCommand(\"setContext\", \"github.copilot.nightly\", !0);\n  const K = function (e, t) {\n    const n = new F.CopilotStatusBar(e);\n    t.subscriptions.push(z(e, R.CMDToggleCopilot, () => {\n      n.toggleStatusBar();\n    }));\n    t.subscriptions.push(z(e, R.CMDShowActivationErrors, () => {\n      n.showActivationErrors(U);\n    }));\n    t.subscriptions.push(n.getStatusBarItem());\n    return n;\n  }(n, e);\n  n.set(b.StatusReporter, K);\n  const J = async () => {\n    try {\n      await n.get(i.CopilotTokenManager).getCopilotToken(n);\n    } catch (e) {\n      const t = e.message || e;\n      E.telemetryError(n, \"activationFailed\", E.TelemetryData.createAndMarkAsIssued({\n        reason: t\n      }));\n      n.get(E.TelemetryReporters).deactivate();\n      const r = `GitHub Copilot could not connect to server. Extension activation failed: \"${t}\"`;\n      K.setError(r, J);\n      g.logger.error(n, r);\n      return void o.commands.executeCommand(\"setContext\", \"github.copilot.activated\", !1);\n    }\n    K.forceNormal();\n    o.commands.executeCommand(\"setContext\", \"github.copilot.activated\", !0);\n    e.subscriptions.push(z(n, R.CMDOpenPanel, () => {\n      o.commands.executeCommand(\"editor.action.inlineSuggest.hide\");\n      M.commandOpenPanel(n);\n    }));\n    e.subscriptions.push(z(n, R.CMDOpenPanelForRange, e => {\n      M.commandOpenPanel(n, e);\n    }), z(n, R.CMDAcceptPanelSolution, async (e, t, n, r, i) => {\n      const s = new o.WorkspaceEdit();\n      s.insert(e, t, n);\n      await o.workspace.applyEdit(s);\n      i();\n      await o.commands.executeCommand(\"workbench.action.closeActiveEditor\");\n      if (r && o.window.activeTextEditor && o.window.activeTextEditor.document.uri.toString() === e.toString()) {\n        const e = t.translate(1).with(void 0, 0),\n          n = new o.Selection(e, e);\n        o.window.activeTextEditor.selection = n;\n      }\n    }));\n    e.subscriptions.push(z(n, R.CMDSendFeedback, () => {\n      o.env.openExternal(o.Uri.parse(\"https://github.com/github/feedback/discussions/categories/copilot\"));\n    }));\n    const t = new L.CopilotPanel(n);\n    e.subscriptions.push(o.workspace.registerTextDocumentContentProvider(c.CopilotScheme, t), o.languages.registerCodeLensProvider({\n      scheme: c.CopilotScheme\n    }, t));\n    try {\n      e.subscriptions.push(...A.registerGhostText(n));\n      const t = o.workspace.getConfiguration(),\n        r = t.inspect(\"editor.inlineSuggest.enabled\");\n      undefined === (null == r ? undefined : r.globalValue) && t.update(\"editor.inlineSuggest.enabled\", !0, o.ConfigurationTarget.Global);\n    } catch (e) {\n      o.window.showErrorMessage(\"GitHub Copilot requires VS Code 1.57+. Please update your VS Code\");\n    }\n    e.subscriptions.push(d.registerDocumentTracker(n));\n    e.subscriptions.push(o.window.onDidChangeActiveTextEditor(e => e ? e.document.isUntitled || \"file\" === e.document.uri.scheme && x.extractRepoInfoInBackground(n, e.document.fileName) : undefined));\n    const r = e.extensionMode !== o.ExtensionMode.Development;\n    w.init(n, r, new g.Logger(g.LogLevel.INFO, \"promptlib proxy\"));\n    E.telemetry(n, \"extension.activate\");\n    G = n;\n  };\n  await J();\n};\nexports.deactivate = function () {\n  G && (E.telemetry(G, \"extension.deactivate\"), G.get(E.TelemetryReporters).deactivate());\n  w.terminate();\n};"
}