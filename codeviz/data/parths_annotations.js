let parths_annotations = {"module-code-4428":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.activate = undefined;\\nconst r = require(4398),\\n  o = require(\\"config_stuff\\"),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(9380);\\nfunction a(e, t, n, o, a) {\\n  const c = new r.default(t, n, o);\\n  s.setupExperimentationService(e);\\n  i.configureReporter(e, c);\\n  return c;\\n}\\nexports.activate = function (e, t) {\\n  const n = t.extension.packageJSON.name,\\n    r = o.getVersion(e),\\n    s = a(e, n, r, i.APP_INSIGHTS_KEY, t.globalState),\\n    c = a(e, n, r, i.APP_INSIGHTS_KEY_SECURE, t.globalState);\\n  t.subscriptions.push(s);\\n  t.subscriptions.push(c);\\n  return new i.TelemetryReporters(s, c);\\n};","module-code-6333":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.forceSendingTelemetry =\\n  exports.dropTelemetryConfig =\\n  exports.setTelemetryConfig =\\n  exports.logEnginePrompt =\\n  exports.logEngineCompletion =\\n  exports.telemetryError =\\n  exports.telemetryException =\\n  exports.telemetryRaw =\\n  exports.telemetryExpProblem =\\n  exports.telemetry =\\n  exports.configureReporter =\\n  exports.TelemetryEndpointUrl =\\n  exports.now =\\n  exports.telemetrizePromptLength =\\n  exports.TelemetryData =\\n  exports.setupEmptyReporters =\\n  exports.setupStandardReporters =\\n  exports.TelemetryReporters =\\n  exports.APP_INSIGHTS_KEY_SECURE =\\n  exports.APP_INSIGHTS_KEY =\\n    undefined;\\nconst r = require(\\"json-schema-stuff\\"),\\n  o = require(4398),\\n  i = require(\\"config_stuff\\"),\\n  s = require(9189),\\n  a = require(6500),\\n  c = require(70),\\n  l = require(2499);\\nexports.APP_INSIGHTS_KEY = \\"7d7048df-6dd0-4048-bb23-b716c1461f8f\\";\\nexports.APP_INSIGHTS_KEY_SECURE = \\"3fdd7f28-937a-48c8-9a21-ba337db23bd1\\";\\nclass TelemetryReporters {\\n  constructor(e, t) {\\n    this.reporter = e;\\n    this.reporterSecure = t;\\n  }\\n  getReporter(e) {\\n    return this.reporter;\\n  }\\n  getSecureReporter(e) {\\n    if (y()) return this.reporterSecure;\\n    if (c.shouldFailForDebugPurposes(e))\\n      throw new Error(\\"Internal error: telemetry opt-out\\");\\n  }\\n  setReporter(e) {\\n    this.reporter = e;\\n  }\\n  setSecureReporter(e) {\\n    this.reporterSecure = e;\\n  }\\n  async deactivate() {\\n    let e = Promise.resolve();\\n    if (this.reporter) {\\n      e = this.reporter.dispose();\\n      this.reporter = undefined;\\n    }\\n    let t = Promise.resolve();\\n    if (this.reporterSecure) {\\n      t = this.reporterSecure.dispose();\\n      this.reporterSecure = undefined;\\n    }\\n    await Promise.all([e, t]);\\n  }\\n  hackOptOutListener() {\\n    this.reporter.optOutListener = {\\n      dispose() {},\\n    };\\n    this.reporterSecure.optOutListener = {\\n      dispose() {},\\n    };\\n  }\\n  setToken(e) {\\n    if (this.reporter) {\\n      this.configureToken(this.reporter, e);\\n    }\\n    if (this.reporterSecure) {\\n      this.configureToken(this.reporterSecure, e);\\n    }\\n  }\\n  configureToken(e, t) {\\n    const n = e;\\n    if (n && n.appInsightsClient) {\\n      n.appInsightsClient.context.tags.github_telemetry_token = t.token;\\n    }\\n  }\\n}\\nlet d;\\nfunction p(e, t, n, r) {\\n  const i = new o.default(t, n, r);\\n  configureReporter(e, i);\\n  return i;\\n}\\nexports.TelemetryReporters = TelemetryReporters;\\nexports.setupStandardReporters = function (e, n) {\\n  const r = i.getVersion(e),\\n    o = p(e, n, r, exports.APP_INSIGHTS_KEY),\\n    s = p(e, n, r, exports.APP_INSIGHTS_KEY_SECURE),\\n    a = e.get(TelemetryReporters);\\n  a.setReporter(o);\\n  a.setSecureReporter(s);\\n  return a;\\n};\\nexports.setupEmptyReporters = function () {\\n  return new TelemetryReporters();\\n};\\nclass TelemetryData {\\n  constructor(e, t, n) {\\n    this.properties = e;\\n    this.measurements = t;\\n    this.issuedTime = n;\\n  }\\n  static createAndMarkAsIssued(e, t) {\\n    return new TelemetryData(e || {}, t || {}, now());\\n  }\\n  extendedBy(e, t) {\\n    const n = {\\n        ...this.properties,\\n        ...e,\\n      },\\n      r = {\\n        ...this.measurements,\\n        ...t,\\n      },\\n      o = new TelemetryData(n, r, this.issuedTime);\\n    o.displayedTime = this.displayedTime;\\n    o.filtersAndExp = this.filtersAndExp;\\n    return o;\\n  }\\n  markAsDisplayed() {\\n    if (undefined === this.displayedTime) {\\n      this.displayedTime = now();\\n    }\\n  }\\n  async extendWithExpTelemetry(e) {\\n    if (this.filtersAndExp) {\\n      await e.get(s.Features).addExpAndFilterToTelemetry(this);\\n    }\\n    this.filtersAndExp.exp.addToTelemetry(this);\\n    this.filtersAndExp.filters.addToTelemetry(this);\\n  }\\n  extendWithEditorAgnosticFields(e) {\\n    this.properties.editor_version = i.formatNameAndVersion(\\n      e.get(i.EditorAndPluginInfo).getEditorInfo(e)\\n    );\\n    this.properties.editor_plugin_version = i.formatNameAndVersion(\\n      e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e)\\n    );\\n    const t = e.get(i.VscInfo);\\n    this.properties.client_machineid = t.machineId;\\n    this.properties.client_sessionid = t.sessionId;\\n    this.properties.copilot_version = `copilot/${i.getVersion(e)}`;\\n    this.properties.common_extname = e\\n      .get(i.EditorAndPluginInfo)\\n      .getEditorPluginInfo(e).name;\\n    this.properties.common_extversion = e\\n      .get(i.EditorAndPluginInfo)\\n      .getEditorPluginInfo(e).version;\\n  }\\n  extendWithConfigProperties(e) {\\n    const t = i.dumpConfig(e);\\n    try {\\n      t[\\"copilot.build\\"] = i.getBuild(e);\\n      t[\\"copilot.buildType\\"] = i.getBuildType(e);\\n    } catch (e) {}\\n    if (d) {\\n      t[\\"copilot.trackingId\\"] = d.trackingId;\\n    }\\n    this.properties = {\\n      ...this.properties,\\n      ...t,\\n    };\\n  }\\n  extendWithRequestId(e) {\\n    const t = {\\n      completionId: e.completionId,\\n      created: e.created.toString(),\\n      headerRequestId: e.headerRequestId,\\n      serverExperiments: e.serverExperiments,\\n      deploymentId: e.deploymentId,\\n    };\\n    this.properties = {\\n      ...this.properties,\\n      ...t,\\n    };\\n  }\\n  static maybeRemoveRepoInfoFromPropertiesHack(e, t) {\\n    if (e) return t;\\n    const n = {};\\n    for (const e in t)\\n      if (TelemetryData.keysToRemoveFromStandardTelemetryHack.includes(e)) {\\n        n[e] = t[e];\\n      }\\n    return n;\\n  }\\n  sanitizeKeys() {\\n    this.properties = TelemetryData.sanitizeKeys(this.properties);\\n    this.measurements = TelemetryData.sanitizeKeys(this.measurements);\\n  }\\n  static sanitizeKeys(e) {\\n    e = e || {};\\n    const t = {};\\n    for (const n in e)\\n      t[\\n        TelemetryData.keysExemptedFromSanitization.includes(n)\\n          ? n\\n          : n.replace(/\\\\./g, \\"_\\")\\n      ] = e[n];\\n    return t;\\n  }\\n  updateTimeSinceIssuedAndDisplayed() {\\n    const e = now() - this.issuedTime;\\n    this.measurements.timeSinceIssuedMs = e;\\n    if (void 0 !== this.displayedTime) {\\n      const e = now() - this.displayedTime;\\n      this.measurements.timeSinceDisplayedMs = e;\\n    }\\n  }\\n  validateData(e, t) {\\n    var n;\\n    let r;\\n    if (TelemetryData.validateTelemetryProperties(this.properties)) {\\n      r = {\\n        problem: \\"properties\\",\\n        error: JSON.stringify(TelemetryData.validateTelemetryProperties.errors),\\n      };\\n    }\\n    if (!TelemetryData.validateTelemetryMeasurements(this.measurements)) {\\n      const e = JSON.stringify(\\n        TelemetryData.validateTelemetryMeasurements.errors\\n      );\\n      void 0 === r\\n        ? (r = {\\n            problem: \\"measurements\\",\\n            error: e,\\n          })\\n        : ((r.problem = \\"both\\"), (r.error += `; ${e}`));\\n    }\\n    if (undefined === r) return !0;\\n    if (c.shouldFailForDebugPurposes(e))\\n      throw new Error(\\n        `Invalid telemetry data: ${r.problem} ${\\n          r.error\\n        } properties=${JSON.stringify(\\n          this.properties\\n        )} measurements=${JSON.stringify(this.measurements)}`\\n      );\\n    telemetryError(\\n      e,\\n      \\"invalidTelemetryData\\",\\n      TelemetryData.createAndMarkAsIssued({\\n        properties: JSON.stringify(this.properties),\\n        measurements: JSON.stringify(this.measurements),\\n        problem: r.problem,\\n        validationError: r.error,\\n      }),\\n      t\\n    );\\n    if (t) {\\n      telemetryError(\\n        e,\\n        \\"invalidTelemetryData_in_secure\\",\\n        TelemetryData.createAndMarkAsIssued({\\n          problem: r.problem,\\n          requestId:\\n            null !== (n = this.properties.requestId) && undefined !== n\\n              ? n\\n              : \\"unknown\\",\\n        }),\\n        !1\\n      );\\n    }\\n    return !1;\\n  }\\n  async makeReadyForSending(e, t, n) {\\n    this.extendWithConfigProperties(e);\\n    this.extendWithEditorAgnosticFields(e);\\n    this.sanitizeKeys();\\n    if (\\"IncludeExp\\" === n) {\\n      await this.extendWithExpTelemetry(e);\\n    }\\n    this.updateTimeSinceIssuedAndDisplayed();\\n    if (this.validateData(e, t)) {\\n      this.properties.telemetry_failed_validation = \\"true\\";\\n    }\\n  }\\n}\\nfunction f(e, t, n, r) {\\n  const o = t\\n    ? e.get(TelemetryReporters).getSecureReporter(e)\\n    : e.get(TelemetryReporters).getReporter(e);\\n  if (o) {\\n    o.sendTelemetryEvent(\\n      n,\\n      TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(t, r.properties),\\n      r.measurements\\n    );\\n  }\\n}\\nfunction now() {\\n  return new Date().getTime();\\n}\\nexports.TelemetryData = TelemetryData;\\nTelemetryData.ajv = new r.default({\\n  strictNumbers: !1,\\n});\\nTelemetryData.validateTelemetryProperties = TelemetryData.ajv.compile({\\n  type: \\"object\\",\\n  additionalProperties: {\\n    type: \\"string\\",\\n  },\\n  required: [],\\n});\\nTelemetryData.validateTelemetryMeasurements = TelemetryData.ajv.compile({\\n  type: \\"object\\",\\n  properties: {\\n    meanLogProb: {\\n      type: \\"number\\",\\n      nullable: !0,\\n    },\\n    meanAlternativeLogProb: {\\n      type: \\"number\\",\\n      nullable: !0,\\n    },\\n  },\\n  additionalProperties: {\\n    type: \\"number\\",\\n  },\\n  required: [],\\n});\\nTelemetryData.keysExemptedFromSanitization = [\\n  a.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName,\\n  a.ExpServiceTelemetryNames.featuresTelemetryPropertyName,\\n];\\nTelemetryData.keysToRemoveFromStandardTelemetryHack = [\\n  \\"gitRepoHost\\",\\n  \\"gitRepoName\\",\\n  \\"gitRepoOwner\\",\\n  \\"gitRepoUrl\\",\\n  \\"gitRepoPath\\",\\n  \\"repo\\",\\n  \\"request_option_nwo\\",\\n];\\nexports.telemetrizePromptLength = function (e) {\\n  return e.isFimEnabled\\n    ? {\\n        promptPrefixCharLen: e.prefix.length,\\n        promptSuffixCharLen: e.suffix.length,\\n      }\\n    : {\\n        promptCharLen: e.prefix.length,\\n      };\\n};\\nexports.now = now;\\nclass TelemetryEndpointUrl {\\n  constructor(e = \\"https://copilot-telemetry.githubusercontent.com/telemetry\\") {\\n    this.url = e;\\n  }\\n  getUrl() {\\n    return this.url;\\n  }\\n  setUrlForTesting(e) {\\n    this.url = e;\\n  }\\n}\\nfunction configureReporter(e, t) {\\n  const n = t;\\n  if (n.appInsightsClient) {\\n    const t = n.appInsightsClient.commonProperties,\\n      r = TelemetryData.sanitizeKeys(t);\\n    n.appInsightsClient.commonProperties = r;\\n    n.appInsightsClient.context.tags[\\n      n.appInsightsClient.context.keys.cloudRoleInstance\\n    ] = \\"REDACTED\\";\\n    const o = e.get(TelemetryEndpointUrl).getUrl();\\n    n.appInsightsClient.config.endpointUrl = o;\\n  }\\n}\\nfunction y() {\\n  var e;\\n  return (\\n    null !== (e = null == d ? undefined : d.optedIn) && undefined !== e && e\\n  );\\n}\\nasync function telemetry(e, t, n, r) {\\n  if (r && !y()) return;\\n  const o = n || TelemetryData.createAndMarkAsIssued({}, {});\\n  await o.makeReadyForSending(e, null != r && r, \\"IncludeExp\\");\\n  f(e, null != r && r, t, o);\\n}\\nasync function telemetryError(e, t, n, r) {\\n  if (r && !y()) return;\\n  const o = n || TelemetryData.createAndMarkAsIssued({}, {});\\n  await o.makeReadyForSending(e, null != r && r, \\"IncludeExp\\");\\n  (function (e, t, n, r) {\\n    const o = t\\n      ? e.get(TelemetryReporters).getSecureReporter(e)\\n      : e.get(TelemetryReporters).getReporter(e);\\n    if (o) {\\n      o.sendTelemetryErrorEvent(\\n        n,\\n        TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(t, r.properties),\\n        r.measurements\\n      );\\n    }\\n  })(e, null != r && r, t, o);\\n}\\nexports.TelemetryEndpointUrl = TelemetryEndpointUrl;\\nexports.configureReporter = configureReporter;\\nexports.telemetry = telemetry;\\nexports.telemetryExpProblem = async function (e, t) {\\n  const n = TelemetryData.createAndMarkAsIssued(t, {});\\n  await n.makeReadyForSending(e, !1, \\"SkipExp\\");\\n  f(e, !1, \\"expProblem\\", n);\\n};\\nexports.telemetryRaw = async function (e, t, n, r) {\\n  f(e, !1, t, {\\n    properties: n,\\n    measurements: r,\\n  });\\n};\\nexports.telemetryException = async function (e, t, n, r) {\\n  const o = t instanceof Error ? t : new Error(\\"Non-error thrown: \\" + t),\\n    i = y(),\\n    s = TelemetryData.createAndMarkAsIssued({\\n      origin: l.redactPaths(n),\\n      reason: i\\n        ? \\"Exception logged to restricted telemetry\\"\\n        : \\"Exception, not logged due to opt-out\\",\\n      ...r,\\n    });\\n  await s.makeReadyForSending(e, !1, \\"IncludeExp\\");\\n  f(e, !1, \\"exception\\", s);\\n  if (!i) return;\\n  const a = TelemetryData.createAndMarkAsIssued({\\n    origin: n,\\n    ...r,\\n  });\\n  await a.makeReadyForSending(e, !0, \\"IncludeExp\\");\\n  (function (e, t, n, r) {\\n    const o = e.get(TelemetryReporters).getSecureReporter(e);\\n    if (o) {\\n      o.sendTelemetryException(\\n        n,\\n        TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(true, r.properties),\\n        r.measurements\\n      );\\n    }\\n  })(e, 0, o, a);\\n};\\nexports.telemetryError = telemetryError;\\nexports.logEngineCompletion = async function (e, t, n, r, o) {\\n  var i;\\n  const s = TelemetryData.createAndMarkAsIssued({\\n    completionTextJson: JSON.stringify(t),\\n    choiceIndex: o.toString(),\\n  });\\n  if (n.logprobs)\\n    for (const [e, t] of Object.entries(n.logprobs))\\n      s.properties[\\"logprobs_\\" + e] =\\n        null !== (i = JSON.stringify(t)) && undefined !== i ? i : \\"unset\\";\\n  s.extendWithRequestId(r);\\n  await telemetry(e, \\"engine.completion\\", s, !0);\\n};\\nexports.logEnginePrompt = async function (e, t, n) {\\n  let r;\\n  r = t.isFimEnabled\\n    ? {\\n        promptPrefixJson: JSON.stringify(t.prefix),\\n        promptSuffixJson: JSON.stringify(t.suffix),\\n        promptElementRanges: JSON.stringify(t.promptElementRanges),\\n      }\\n    : {\\n        promptJson: JSON.stringify(t.prefix),\\n        promptElementRanges: JSON.stringify(t.promptElementRanges),\\n      };\\n  const o = n.extendedBy(r);\\n  await telemetry(e, \\"engine.prompt\\", o, !0);\\n};\\nexports.setTelemetryConfig = function (e) {\\n  d = e;\\n};\\nexports.dropTelemetryConfig = function () {\\n  d = undefined;\\n};\\nexports.forceSendingTelemetry = function (e, n) {\\n  const r = n.getReporter(e);\\n  if (r) {\\n    const n = r;\\n    n.userOptIn = !0;\\n    n.createAppInsightsClient(exports.APP_INSIGHTS_KEY);\\n    configureReporter(e, r);\\n  }\\n  try {\\n    const r = n.getSecureReporter(e);\\n    if (r) {\\n      const n = r;\\n      n.userOptIn = !0;\\n      n.createAppInsightsClient(exports.APP_INSIGHTS_KEY_SECURE);\\n      configureReporter(e, r);\\n    }\\n  } catch (e) {}\\n};","module-code-3197":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.registerGhostText =\\n  exports.handleGhostTextPostInsert =\\n  exports.handleGhostTextShown =\\n  exports.provideInlineCompletions =\\n  exports.ghostTextLogger =\\n  exports.getInsertionTextFromCompletion =\\n    undefined;\\nconst r = require(9496),\\n  o = require(\\"config_stuff\\"),\\n  i = require(2218),\\n  s = require(\\"ghost-text-provider\\"),\\n  a = require(750),\\n  c = require(\\"logging-utils\\"),\\n  l = require(7017),\\n  u = require(\\"telemetry-stuff\\"),\\n  d = require(4540),\\n  p = \\"_ghostTextPostInsert\\";\\nfunction getInsertionTextFromCompletion(e) {\\n  return e.insertText;\\n}\\nlet f, m;\\nexports.getInsertionTextFromCompletion = getInsertionTextFromCompletion;\\nexports.ghostTextLogger = new c.Logger(c.LogLevel.INFO, \\"ghostText\\");\\nlet g,\\n  _ = [];\\nasync function provideInlineCompletions(e, n, c, h, y) {\\n  const v = await (async function (e, n, a, c, h) {\\n    const y = u.TelemetryData.createAndMarkAsIssued();\\n    if (\\n      !(function (e) {\\n        return o.getConfig(e, o.ConfigKey.InlineSuggestEnable);\\n      })(e)\\n    )\\n      return {\\n        type: \\"abortedBeforeIssued\\",\\n        reason: \\"ghost text is disabled\\",\\n      };\\n    if (d.ignoreDocument(e, n))\\n      return {\\n        type: \\"abortedBeforeIssued\\",\\n        reason: \\"document is ignored\\",\\n      };\\n    exports.ghostTextLogger.debug(\\n      e,\\n      `Ghost text called at [${a.line}, ${a.character}], with triggerKind ${c.triggerKind}`\\n    );\\n    if (h.isCancellationRequested)\\n      return (\\n        exports.ghostTextLogger.info(e, \\"Cancelled before extractPrompt\\"),\\n        {\\n          type: \\"abortedBeforeIssued\\",\\n          reason: \\"cancelled before extractPrompt\\",\\n        }\\n      );\\n    if (c.selectedCompletionInfo) {\\n      exports.ghostTextLogger.debug(\\n        e,\\n        \\"Not showing ghost text because autocomplete widget is displayed\\"\\n      );\\n      return {\\n        type: \\"abortedBeforeIssued\\",\\n        reason: \\"autocomplete widget is displayed\\",\\n      };\\n    }\\n    const v = await s.getGhostText(\\n      e,\\n      n,\\n      a,\\n      c.triggerKind === r.InlineCompletionTriggerKind.Invoke,\\n      y,\\n      h\\n    );\\n    if (\\"success\\" !== v.type) {\\n      exports.ghostTextLogger.debug(\\n        e,\\n        \\"Breaking, no results from getGhostText -- \\" + v.type + \\": \\" + v.reason\\n      );\\n      return v;\\n    }\\n    const [b, w] = v.value;\\n    if (\\n      f &&\\n      m &&\\n      (!f.isEqual(a) || m !== n.uri) &&\\n      w !== s.ResultType.TypingAsSuggested\\n    ) {\\n      const t = _.flatMap((e) =>\\n        e.displayText && e.telemetry\\n          ? [\\n              {\\n                completionText: e.displayText,\\n                completionTelemetryData: e.telemetry,\\n              },\\n            ]\\n          : []\\n      );\\n      if (t.length > 0) {\\n        l.postRejectionTasks(e, \\"ghostText\\", n.offsetAt(f), m, t);\\n      }\\n    }\\n    f = a;\\n    m = n.uri;\\n    _ = [];\\n    if (h.isCancellationRequested)\\n      return (\\n        exports.ghostTextLogger.info(e, \\"Cancelled after getGhostText\\"),\\n        {\\n          type: \\"canceled\\",\\n          reason: \\"after getGhostText\\",\\n          telemetryData: {\\n            telemetryBlob: v.telemetryBlob,\\n          },\\n        }\\n      );\\n    const x = i.completionsFromGhostTextResults(\\n      e,\\n      b,\\n      w,\\n      n,\\n      a,\\n      (function (e) {\\n        const t = r.window.visibleTextEditors.find((t) => t.document === e);\\n        return null == t ? undefined : t.options;\\n      })(n),\\n      g\\n    );\\n    exports.ghostTextLogger.debug(e, \\"Completions\\", x);\\n    const E = x.map((e) => {\\n      const { text: t, range: o } = e,\\n        i = new r.Range(\\n          new r.Position(o.start.line, o.start.character),\\n          new r.Position(o.end.line, o.end.character)\\n        ),\\n        s = new r.InlineCompletionItem(t, i);\\n      s.index = e.index;\\n      s.telemetry = e.telemetry;\\n      s.displayText = e.displayText;\\n      s.resultType = e.resultType;\\n      s.uri = n.uri;\\n      s.insertOffset = n.offsetAt(\\n        new r.Position(e.position.line, e.position.character)\\n      );\\n      s.command = {\\n        title: \\"PostInsertTask\\",\\n        command: p,\\n        arguments: [s],\\n      };\\n      return s;\\n    });\\n    return 0 === E.length\\n      ? {\\n          type: \\"empty\\",\\n          reason: \\"no completions in final result\\",\\n          telemetryData: v.telemetryData,\\n        }\\n      : {\\n          ...v,\\n          value: E,\\n        };\\n  })(e, n, c, h, y);\\n  return await a.handleGhostTextResultTelemetry(e, v);\\n}\\nexports.provideInlineCompletions = provideInlineCompletions;\\nclass v {\\n  constructor(e) {\\n    this.ctx = e;\\n  }\\n  async provideInlineCompletionItems(e, t, n, r) {\\n    return provideInlineCompletions(this.ctx, e, t, n, r);\\n  }\\n  handleDidShowCompletionItem(e) {\\n    handleGhostTextShown(this.ctx, e);\\n  }\\n}\\nfunction handleGhostTextShown(e, n) {\\n  g = n.index;\\n  if (!_.find((e) => e.index === n.index) && (_.push(n), n.telemetry)) {\\n    const r = !(n.resultType === s.ResultType.Network);\\n    exports.ghostTextLogger.debug(\\n      e,\\n      `[${n.telemetry.properties.headerRequestId}] shown choiceIndex: ${n.telemetry.properties.choiceIndex}, fromCache ${r}`\\n    ),\\n      (0, a.telemetryShown)(e, \\"ghostText\\", n.telemetry, r);\\n  }\\n}\\nasync function handleGhostTextPostInsert(e, n) {\\n  _ = [];\\n  m = undefined;\\n  f = undefined;\\n  exports.ghostTextLogger.debug(e, \\"Ghost text post insert\\");\\n  if (\\n    n.telemetry &&\\n    n.uri &&\\n    n.displayText &&\\n    undefined !== n.insertOffset &&\\n    n.range\\n  ) {\\n    n.telemetry.measurements.compCharLen =\\n      getInsertionTextFromCompletion(n).length;\\n    await l.postInsertionTasks(\\n      e,\\n      \\"ghostText\\",\\n      n.displayText,\\n      n.insertOffset,\\n      n.uri,\\n      n.telemetry\\n    );\\n  }\\n}\\nexports.handleGhostTextShown = handleGhostTextShown;\\nexports.handleGhostTextPostInsert = handleGhostTextPostInsert;\\nexports.registerGhostText = function (e) {\\n  const t = new v(e);\\n  return [\\n    r.languages.registerInlineCompletionItemProvider(\\n      {\\n        pattern: \\"**\\",\\n      },\\n      t\\n    ),\\n    r.commands.registerCommand(p, async (t) => handleGhostTextPostInsert(e, t)),\\n  ];\\n};","module-code-893":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.CopilotListDocument = undefined;\\nconst r = require(106),\\n  o = require(\\"config_stuff\\"),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(\\"completion-normalizer\\");\\nclass CopilotListDocument {\\n  constructor(e, t, n, s, a, c) {\\n    this.targetDocument = n;\\n    this.completionContext = s;\\n    this.token = c;\\n    this._solutionCount = 0;\\n    this.solutionCountTarget = 0;\\n    this._solutions = [];\\n    this._wasCancelled = !1;\\n    this._updateHandlers = new Set();\\n    this.savedTelemetryData = i.TelemetryData.createAndMarkAsIssued();\\n    this.debouncedEventFire = r.debounce(10, () =>\\n      this._updateHandlers.forEach((e) => e(this._uri))\\n    );\\n    this.onDidResultUpdated = (e) => (\\n      this._updateHandlers.add(e),\\n      {\\n        dispose: () => {\\n          this._updateHandlers.delete(e);\\n        },\\n      }\\n    );\\n    this.solutionCountTarget = a;\\n    this._ctx = e;\\n    this._uri = t;\\n    this._showLogprobs = o.getConfig(e, o.ConfigKey.DebugShowScores);\\n    this.startPosition = this.completionContext.insertPosition;\\n    this.numberHeaderLines = Math.max(\\n      1,\\n      this.formatDisplayLines(\\"\\").length - 1\\n    );\\n  }\\n  async getDocument() {\\n    return this.targetDocument;\\n  }\\n  get targetUri() {\\n    return this.targetDocument.uri;\\n  }\\n  header() {\\n    if (this._wasCancelled) return \\"No synthesized solutions found.\\";\\n    {\\n      const e =\\n        this._solutionCount - this._solutions.length > 0\\n          ? \\" (Duplicates hidden)\\"\\n          : \\"\\";\\n      return `Synthesizing ${this._solutionCount}/${this.solutionCountTarget} solutions${e}`;\\n    }\\n  }\\n  areSolutionsDuplicates(e, t) {\\n    return (\\n      s.normalizeCompletionText(e.completionText) ===\\n      s.normalizeCompletionText(t.completionText)\\n    );\\n  }\\n  insertSorted(e, t, n) {\\n    if (!/^\\\\s*$/.test(t.completionText)) {\\n      for (let r = 0; r < e.length; r++) {\\n        const o = e[r];\\n        if (this.areSolutionsDuplicates(o, t)) {\\n          if (n(o) < n(t)) {\\n            e.splice(r, 1);\\n            break;\\n          }\\n          return;\\n        }\\n      }\\n      for (let r = 0; r < e.length; r++)\\n        if (n(e[r]) < n(t)) return void e.splice(r, 0, t);\\n      e.push(t);\\n    }\\n  }\\n  reportCancelled() {\\n    this._wasCancelled = !0;\\n    this.debouncedEventFire();\\n  }\\n  getCancellationToken() {\\n    return this.token;\\n  }\\n  insertSolution(e) {\\n    const t = {\\n      displayLines: this.formatDisplayLines(\\n        e.displayText,\\n        e.meanProb,\\n        e.meanLogProb\\n      ),\\n      completionText: e.completionText,\\n      meanLogProb: e.meanLogProb,\\n      meanProb: e.meanProb,\\n      prependToCompletion: e.prependToCompletion,\\n      requestId: e.requestId,\\n      choiceIndex: e.choiceIndex,\\n    };\\n    this.insertSorted(this._solutions, t, (e) => e.meanProb);\\n    this._solutionCount++;\\n    this.debouncedEventFire();\\n  }\\n  formatDisplayLines(e, t, n) {\\n    let r = \\"\\";\\n    if (this._showLogprobs) {\\n      n = n || 0;\\n      r += `\\\\n\\\\t# mean prob: ${t}`;\\n    }\\n    return `${CopilotListDocument.separator}${r}\\\\n\\\\n${e}`.split(\\"\\\\n\\");\\n  }\\n  async runQuery() {\\n    const e = await s.launchSolutions(this._ctx, this);\\n    this.processNextSolution(e);\\n  }\\n  async processNextSolution(e) {\\n    switch (e.status) {\\n      case \\"FinishedNormally\\":\\n      case \\"FinishedWithError\\":\\n        return;\\n      case \\"Solution\\":\\n        this.insertSolution(e.solution);\\n        this.processNextSolution(await e.next);\\n    }\\n  }\\n  solutionsReceived() {\\n    return this._solutionCount;\\n  }\\n  solutions() {\\n    return this._solutions;\\n  }\\n  get value() {\\n    return [this.header()]\\n      .concat(this._solutions.flatMap((e) => e.displayLines))\\n      .concat(\\"\\")\\n      .join(\\"\\\\n\\");\\n  }\\n}\\nexports.CopilotListDocument = CopilotListDocument;\\nCopilotListDocument.separator = \\"\\\\n=======\\";","module-code-2990":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.CopilotPanel = undefined;\\nconst r = require(9496),\\n  o = require(\\"config_stuff\\"),\\n  i = require(4197),\\n  s = require(256),\\n  a = require(\\"copilot_list_doc\\"),\\n  c = require(7017),\\n  l = require(3060);\\nexports.CopilotPanel = class {\\n  constructor(e) {\\n    this._onDidChange = new r.EventEmitter();\\n    this._documents = new Map();\\n    this._editorDecoration = r.window.createTextEditorDecorationType({\\n      textDecoration: \\"underline\\",\\n    });\\n    this._ctx = e;\\n    this._subscriptions = r.workspace.onDidCloseTextDocument((e) => {\\n      if (e.isClosed && e.uri.scheme == i.CopilotScheme) {\\n        this._documents.delete(e.uri.toString());\\n      }\\n    });\\n  }\\n  dispose() {\\n    this._subscriptions.dispose();\\n    this._documents.clear();\\n    this._editorDecoration.dispose();\\n    this._onDidChange.dispose();\\n  }\\n  get onDidChange() {\\n    return this._onDidChange.event;\\n  }\\n  async provideTextDocumentContent(e) {\\n    var t;\\n    let n =\\n      null === (t = this._documents.get(e.toString())) || undefined === t\\n        ? undefined\\n        : t.model;\\n    if (n) return n.value;\\n    const i = new r.CancellationTokenSource(),\\n      [c, l] = s.decodeLocation(this._ctx, e),\\n      u = await r.workspace.openTextDocument(c);\\n    n = new a.CopilotListDocument(\\n      this._ctx,\\n      e,\\n      u,\\n      l,\\n      o.getConfig(this._ctx, o.ConfigKey.ListCount),\\n      i.token\\n    );\\n    n.onDidResultUpdated((e) => this._onDidChange.fire(e));\\n    this._documents.set(e.toString(), {\\n      model: n,\\n      cts: i,\\n    });\\n    n.runQuery();\\n    return n.value;\\n  }\\n  getCodeLens(e) {\\n    const t = e.model;\\n    let n = t.numberHeaderLines;\\n    const o = t.completionContext.insertPosition,\\n      i = a.CopilotListDocument.separator.split(\\"\\\\n\\").length - 1;\\n    return t.solutions().map((a, u) => {\\n      const d = new r.Position(n + i, 0),\\n        p = new r.Position(n + a.displayLines.length - 1, 0),\\n        h = t.savedTelemetryData.extendedBy(\\n          {\\n            choiceIndex: a.choiceIndex.toString(),\\n          },\\n          {\\n            compCharLen: a.completionText.length,\\n            meanProb: a.meanProb,\\n            rank: u,\\n          }\\n        );\\n      h.extendWithRequestId(a.requestId);\\n      h.markAsDisplayed();\\n      const f = new r.CodeLens(new r.Range(d, p), {\\n        title: \\"Accept Solution\\",\\n        tooltip: \\"Replace code with this solution\\",\\n        command: l.CMDAcceptPanelSolution,\\n        arguments: [\\n          t.targetUri,\\n          o,\\n          a.completionText,\\n          t.completionContext.completionType ===\\n            s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX,\\n          async () => {\\n            const n = (\\n              await r.workspace.openTextDocument(t.targetUri)\\n            ).offsetAt(o);\\n            e.cts.cancel();\\n            await c.postInsertionTasks(\\n              this._ctx,\\n              \\"solution\\",\\n              a.completionText,\\n              n,\\n              t.targetUri,\\n              h\\n            );\\n          },\\n        ],\\n      });\\n      n += a.displayLines.length;\\n      return f;\\n    });\\n  }\\n  provideCodeLenses(e, t) {\\n    const n = this._documents.get(e.uri.toString());\\n    if (n) return this.getCodeLens(n);\\n  }\\n};","module-code-7017":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.postInsertionTasks =\\n  exports.postRejectionTasks =\\n  exports.captureCode =\\n    undefined;\\nconst r = require(6881),\\n  o = require(750),\\n  i = require(\\"logging-utils\\"),\\n  s = require(7727),\\n  a = require(4969),\\n  c = require(5120),\\n  l = require(\\"telemetry-stuff\\"),\\n  u = require(3136),\\n  d = new i.Logger(i.LogLevel.INFO, \\"post-insertion\\"),\\n  p = [\\n    {\\n      seconds: 15,\\n      captureCode: !1,\\n      captureRejection: !1,\\n    },\\n    {\\n      seconds: 30,\\n      captureCode: !0,\\n      captureRejection: !0,\\n    },\\n    {\\n      seconds: 120,\\n      captureCode: !1,\\n      captureRejection: !1,\\n    },\\n    {\\n      seconds: 300,\\n      captureCode: !1,\\n      captureRejection: !1,\\n    },\\n    {\\n      seconds: 600,\\n      captureCode: !1,\\n      captureRejection: !1,\\n    },\\n  ];\\nasync function captureCode(e, t, n) {\\n  const r = await e.get(u.TextDocumentManager).getTextDocument(t);\\n  if (!r) {\\n    d.info(\\n      e,\\n      `Could not get document for ${t.fsPath}. Maybe it was closed by the editor.`\\n    );\\n    return {\\n      prompt: {\\n        prefix: \\"\\",\\n        suffix: \\"\\",\\n        isFimEnabled: !1,\\n        promptElementRanges: [],\\n      },\\n      capturedCode: \\"\\",\\n      terminationOffset: 0,\\n    };\\n  }\\n  const o = r.getText(),\\n    i = o.substring(0, n),\\n    c = r.positionAt(n),\\n    l = await a.extractPrompt(e, r, c),\\n    p =\\n      \\"prompt\\" === l.type\\n        ? l.prompt\\n        : {\\n            prefix: i,\\n            suffix: \\"\\",\\n            isFimEnabled: !1,\\n            promptElementRanges: [],\\n          },\\n    h = o.substring(n),\\n    f = s.contextIndentationFromText(i, n, r.languageId),\\n    m = s.indentationBlockFinished(f, undefined),\\n    g = await m(h),\\n    _ = Math.min(o.length, n + (g ? 2 * g : 500));\\n  return {\\n    prompt: p,\\n    capturedCode: o.substring(n, _),\\n    terminationOffset: null != g ? g : -1,\\n  };\\n}\\nfunction f(e, t, n, r) {\\n  const o = e.substring(\\n      Math.max(0, r - n),\\n      Math.min(e.length, r + t.length + n)\\n    ),\\n    i = c.lexEditDistance(o, t),\\n    s = i.lexDistance / i.needleLexLength,\\n    { distance: a } = c.editDistance(\\n      o.substring(i.startOffset, i.endOffset),\\n      t\\n    );\\n  return {\\n    relativeLexEditDistance: s,\\n    charEditDistance: a,\\n    completionLexLength: i.needleLexLength,\\n    foundOffset: i.startOffset + Math.max(0, r - n),\\n    lexEditDistance: i.lexDistance,\\n    stillInCodeHeuristic: s <= 0.5 ? 1 : 0,\\n  };\\n}\\nexports.captureCode = captureCode;\\nexports.postRejectionTasks = function (e, t, n, i, s) {\\n  s.forEach(({ completionText: n, completionTelemetryData: r }) => {\\n    d.debug(e, `${t}.rejected choiceIndex: ${r.properties.choiceIndex}`);\\n    o.telemetryRejected(e, t, r);\\n  });\\n  const a = new r.ChangeTracker(e, i, n);\\n  p.filter((e) => e.captureRejection).map((r) => {\\n    a.push(async () => {\\n      d.debug(e, `Original offset: ${n}, Tracked offset: ${a.offset}`);\\n      const { completionTelemetryData: o } = s[0],\\n        {\\n          prompt: c,\\n          capturedCode: u,\\n          terminationOffset: p,\\n        } = await captureCode(e, i, a.offset);\\n      let f;\\n      f = c.isFimEnabled\\n        ? {\\n            hypotheticalPromptPrefixJson: JSON.stringify(c.prefix),\\n            hypotheticalPromptSuffixJson: JSON.stringify(c.suffix),\\n          }\\n        : {\\n            hypotheticalPromptJson: JSON.stringify(c.prefix),\\n          };\\n      const m = o.extendedBy(\\n        {\\n          ...f,\\n          capturedCodeJson: JSON.stringify(u),\\n        },\\n        {\\n          timeout: r.seconds,\\n          insertionOffset: n,\\n          trackedOffset: a.offset,\\n          terminationOffsetInCapturedCode: p,\\n        }\\n      );\\n      d.debug(\\n        e,\\n        `${t}.capturedAfterRejected choiceIndex: ${o.properties.choiceIndex}`,\\n        m\\n      );\\n      l.telemetry(e, t + \\".capturedAfterRejected\\", m, !0);\\n    }, 1e3 * r.seconds);\\n  });\\n};\\nexports.postInsertionTasks = async function (e, t, n, i, s, a) {\\n  d.debug(e, `${t}.accepted choiceIndex: ${a.properties.choiceIndex}`);\\n  o.telemetryAccepted(e, t, a);\\n  const c = new r.ChangeTracker(e, s, i),\\n    m = n.trim();\\n  p.map((n) =>\\n    c.push(\\n      () =>\\n        (async function (e, t, n, r, o, i, s, a) {\\n          const c = await e.get(u.TextDocumentManager).getTextDocument(o);\\n          if (c) {\\n            const u = c.getText();\\n            let p = f(u, n, 50, a.offset);\\n            if (p.stillInCodeHeuristic) {\\n              p = f(u, n, 1500, a.offset);\\n            }\\n            d.debug(\\n              e,\\n              `stillInCode: ${\\n                p.stillInCodeHeuristic ? \\"Found\\" : \\"Not found\\"\\n              }! Completion \'${n}\' in file ${\\n                o.fsPath\\n              }. lexEditDistance fraction was ${\\n                p.relativeLexEditDistance\\n              }. Char edit distance was ${\\n                p.charEditDistance\\n              }. Inserted at ${r}, tracked at ${a.offset}, found at ${\\n                p.foundOffset\\n              }. choiceIndex: ${s.properties.choiceIndex}`\\n            );\\n            const m = s\\n              .extendedBy(\\n                {},\\n                {\\n                  timeout: i.seconds,\\n                  insertionOffset: r,\\n                  trackedOffset: a.offset,\\n                }\\n              )\\n              .extendedBy({}, p);\\n            l.telemetry(e, t + \\".stillInCode\\", m);\\n            if (i.captureCode) {\\n              const {\\n                prompt: n,\\n                capturedCode: c,\\n                terminationOffset: u,\\n              } = await captureCode(e, o, a.offset);\\n              let p;\\n              p = n.isFimEnabled\\n                ? {\\n                    hypotheticalPromptPrefixJson: JSON.stringify(n.prefix),\\n                    hypotheticalPromptSuffixJson: JSON.stringify(n.suffix),\\n                  }\\n                : {\\n                    hypotheticalPromptJson: JSON.stringify(n.prefix),\\n                  };\\n              const f = s.extendedBy(\\n                {\\n                  ...p,\\n                  capturedCodeJson: JSON.stringify(c),\\n                },\\n                {\\n                  timeout: i.seconds,\\n                  insertionOffset: r,\\n                  trackedOffset: a.offset,\\n                  terminationOffsetInCapturedCode: u,\\n                }\\n              );\\n              d.debug(\\n                e,\\n                `${t}.capturedAfterAccepted choiceIndex: ${s.properties.choiceIndex}`,\\n                m\\n              ),\\n                (0, l.telemetry)(e, t + \\".capturedAfterAccepted\\", f, !0);\\n            }\\n          }\\n        })(e, t, m, i, s, n, a, c),\\n      1e3 * n.seconds\\n    )\\n  );\\n};","module-code-1929":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.OpenCopilotActionProvider = undefined;\\nconst r = require(9496),\\n  o = require(256),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(3060),\\n  a = require(4540);\\nexports.OpenCopilotActionProvider = class {\\n  constructor(e) {\\n    this.ctx = e;\\n    this.lastVersion = 0;\\n    this.lastRange = undefined;\\n  }\\n  indexOfGroup(e, t) {\\n    let n = e.index;\\n    for (let r = 1; r < t; r++) n += e[r].length;\\n    return n;\\n  }\\n  telemetryCodeAction(e, t) {\\n    const n = {\\n      languageId: e.languageId,\\n      codeActionType: o.completionTypeToString(t),\\n    };\\n    i.telemetry(\\n      this.ctx,\\n      \\"codeAction.displayed\\",\\n      i.TelemetryData.createAndMarkAsIssued(n)\\n    );\\n  }\\n  async provideCodeActions(e, t, n, i) {\\n    var c;\\n    if (a.ignoreDocument(this.ctx, e)) return;\\n    const l = e.lineAt(t.start);\\n    if (\\n      e.version === this.lastVersion &&\\n      this.lastRange &&\\n      this.lastRange.isEqual(t)\\n    )\\n      return;\\n    this.lastVersion = e.version;\\n    this.lastRange = t;\\n    const u = /^(\\\\W+)(todo)/i.exec(l.text);\\n    if (u) {\\n      const n = u[u.length - 1],\\n        i = this.indexOfGroup(u, u.length - 1);\\n      if (\\n        new r.Range(\\n          new r.Position(t.start.line, i),\\n          new r.Position(t.start.line, i + n.length)\\n        ).contains(t.start)\\n      ) {\\n        const t = new r.CodeAction(\\n            \\"Implement with GitHub Copilot\\",\\n            r.CodeActionKind.QuickFix\\n          ),\\n          n = {\\n            title: \\"Implement with GitHub Copilot\\",\\n            command: s.CMDOpenPanelForRange,\\n            arguments: [\\n              new o.CompletionContext(\\n                this.ctx,\\n                l.rangeIncludingLineBreak.end,\\n                o.CompletionType.TODO_QUICK_FIX\\n              ),\\n            ],\\n          };\\n        t.command = n;\\n        this.telemetryCodeAction(e, o.CompletionType.TODO_QUICK_FIX);\\n        return [t];\\n      }\\n    }\\n    const d = n.diagnostics.find((e) => \\"ts\\" === e.source && 2304 === e.code);\\n    if (d) {\\n      const t = await r.commands.executeCommand(\\n          \\"vscode.executeCodeActionProvider\\",\\n          e.uri,\\n          d.range\\n        ),\\n        n =\\n          null == t\\n            ? undefined\\n            : t.find((e) =>\\n                e.title.startsWith(\\"Add missing function declaration\\")\\n              ),\\n        i =\\n          null === (c = null == n ? undefined : n.edit) || undefined === c\\n            ? undefined\\n            : c.get(e.uri).pop();\\n      if (i) {\\n        const t = new r.CodeAction(\\n            \\"Implement with GitHub Copilot\\",\\n            r.CodeActionKind.QuickFix\\n          ),\\n          n = new o.CompletionContext(\\n            this.ctx,\\n            i.range.start,\\n            o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\\n          ),\\n          a = i.newText.trim().split(\\"\\\\n\\")[0];\\n        n.prependToCompletion = \\"\\\\n\\" + a;\\n        const c = {\\n          title: \\"Implement with GitHub Copilot\\",\\n          command: s.CMDOpenPanelForRange,\\n          arguments: [n],\\n        };\\n        t.command = c;\\n        this.telemetryCodeAction(\\n          e,\\n          o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\\n        );\\n        return [t];\\n      }\\n    }\\n  }\\n};","module-code-1862":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.VSCodeCopilotTokenManager =\\n  exports.ExtensionNotificationSender =\\n  exports.setExtensionContext =\\n  exports.telemetryAcceptanceKey =\\n    undefined;\\nconst r = require(9496),\\n  o = require(\\"copilot-github-auth-stuff\\"),\\n  i = require(6794),\\n  s = require(\\"logging-utils\\"),\\n  a = require(\\"telemetry-stuff\\"),\\n  c = require(47);\\nexports.telemetryAcceptanceKey = `github.copilot.telemetryAccepted.${i.LAST_TELEMETRY_TERMS_UPDATE}`;\\nconst l = new s.Logger(s.LogLevel.INFO, \\"auth\\");\\nlet u,\\n  d = !1;\\nexports.setExtensionContext = function (e) {\\n  u = e;\\n};\\nexports.ExtensionNotificationSender = class {\\n  async showWarningMessage(e, ...t) {\\n    return {\\n      title: await r.window.showWarningMessage(e, ...t.map((e) => e.title)),\\n    };\\n  }\\n};\\nclass VSCodeCopilotTokenManager extends o.CopilotTokenManager {\\n  constructor() {\\n    super();\\n    this.copilotToken = undefined;\\n  }\\n  async getGitHubToken() {\\n    const e = await c.getSession();\\n    return null == e ? undefined : e.accessToken;\\n  }\\n  async getCopilotToken(e, n) {\\n    if (\\n      !this.copilotToken ||\\n      this.copilotToken.expires_at < o.nowSeconds() ||\\n      n\\n    ) {\\n      this.copilotToken = await (async function (e) {\\n        var n;\\n        const s = await (async function (e) {\\n          const t = await c.getSession();\\n          if (!t) {\\n            l.info(e, \\"GitHub login failed\\");\\n            a.telemetryError(e, \\"auth.github_login_failed\\");\\n            return {\\n              kind: \\"failure\\",\\n              reason: \\"GitHubLoginFailed\\",\\n            };\\n          }\\n          l.debug(\\n            e,\\n            `Logged in as ${t.account.label}, oauth token ${t.accessToken}`\\n          );\\n          const n = await o.authFromGitHubToken(e, {\\n            token: t.accessToken,\\n          });\\n          if (\\"success\\" == n.kind) {\\n            const r = n.token;\\n            l.debug(e, `Copilot HMAC for ${t.account.label}: ${r}`);\\n          }\\n          return n;\\n        })(e);\\n        if (\\"failure\\" === s.kind && \\"NotAuthorized\\" === s.reason)\\n          throw Error(\\n            null !== (n = s.message) && undefined !== n\\n              ? n\\n              : \\"User not authorized\\"\\n          );\\n        if (\\"failure\\" === s.kind && \\"HTTP401\\" === s.reason) {\\n          const e =\\n            \\"Your GitHub token is invalid. Please sign out from your GitHub account using VSCode UI and try again.\\";\\n          throw (d || ((d = !0), r.window.showWarningMessage(e)), Error(e));\\n        }\\n        if (\\"failure\\" === s.kind) throw Error(\\"Failed to get copilot token\\");\\n        if (\\n          \\"unconfigured\\" === s.telemetry &&\\n          !(await (async function (e) {\\n            var n;\\n            const o = null == u ? undefined : u.globalState;\\n            if (!o) return !1;\\n            const s =\\n              null === (n = c.getGithubAccount()) || undefined === n\\n                ? undefined\\n                : n.label;\\n            if (!s) return !1;\\n            const l = s,\\n              d = o.get(exports.telemetryAcceptanceKey, undefined);\\n            if (d && d === s) return !0;\\n            const p = await r.window.showWarningMessage(\\n              `I agree to these [telemetry terms](${i.TELEMETRY_TERMS_URL}) as part of the GitHub Copilot technical preview.`,\\n              \\"Cancel\\",\\n              \\"Agree\\"\\n            );\\n            if (\\"Agree\\" !== p) {\\n              const t = a.TelemetryData.createAndMarkAsIssued({\\n                choice: null != p ? p : \\"undefined\\",\\n              });\\n              a.telemetry(e, \\"auth.telemetry_terms_rejected\\", t);\\n              return !1;\\n            }\\n            o.update(exports.telemetryAcceptanceKey, l);\\n            const h = a.TelemetryData.createAndMarkAsIssued({\\n              terms_date: i.LAST_TELEMETRY_TERMS_UPDATE,\\n            });\\n            a.telemetry(e, \\"auth.telemetry_terms_accepted\\", h);\\n            return !0;\\n          })(e))\\n        )\\n          throw Error(\\"User did not agree to telemetry\\");\\n        return s;\\n      })(e);\\n      o.refreshToken(e, this, this.copilotToken.refresh_in);\\n    }\\n    return this.copilotToken;\\n  }\\n  resetCopilotToken(e, t) {\\n    if (undefined !== t) {\\n      a.telemetry(e, \\"auth.reset_token_\\" + t);\\n    }\\n    l.debug(e, `Resetting copilot token on HTTP error ${t || \\"unknown\\"}`);\\n    this.copilotToken = undefined;\\n  }\\n}\\nexports.VSCodeCopilotTokenManager = VSCodeCopilotTokenManager;","module-code-2533":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.parsesWithoutError =\\n  exports.getPrompt =\\n  exports.getNodeStart =\\n  exports.getFunctionPositions =\\n  exports.getBlockCloseToken =\\n  exports.isSupportedLanguageId =\\n  exports.isBlockBodyFinished =\\n  exports.isEmptyBlockStart =\\n  exports.terminate =\\n  exports.init =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\");\\nlet o = null;\\nconst i = new Map();\\nlet s = 0;\\nexports.init = function (t, u, d) {\\n  if (!u) {\\n    const t = require(4723);\\n    for (const n of [...a, ...c]) module.exports[n] = t[n];\\n    return;\\n  }\\n  for (const n of a) module.exports[n] = l(t, d, n);\\n  module.exports.getPrompt = (function (e, t) {\\n    return function (n, ...r) {\\n      const a = s++;\\n      return new Promise((n, s) => {\\n        i.set(a, {\\n          resolve: n,\\n          reject: s,\\n        });\\n        t.debug(e, `Proxy getPrompt - ${a}`);\\n        if (null == o) {\\n          o.postMessage({\\n            id: a,\\n            fn: \\"getPrompt\\",\\n            args: r,\\n          });\\n        }\\n      });\\n    };\\n  })(t, d);\\n  o = r.createWorker();\\n  i.clear();\\n  s = 0;\\n  const p = t.get(r.FileSystem);\\n  function h(e) {\\n    d.error(t, e);\\n    for (const t of i.values()) t.reject(e);\\n    i.clear();\\n  }\\n  o.on(\\"message\\", ({ id: e, err: n, res: r }) => {\\n    const o = i.get(e);\\n    d.debug(t, `Response ${e} - ${r}, ${n}`);\\n    if (o) {\\n      i.delete(e);\\n      if (n) {\\n        o.reject(n);\\n      } else {\\n        o.resolve(r);\\n      }\\n    }\\n  });\\n  o.on(\\"error\\", h);\\n  o.on(\\"exit\\", (e) => {\\n    if (0 !== e) {\\n      h(new Error(`Worker thread exited with code ${e}.`));\\n    }\\n  });\\n  o.on(\\"readFileReq\\", (e) => {\\n    d.debug(t, `READ_FILE_REQ - ${e}`);\\n    p.readFile(e)\\n      .then((e) => {\\n        if (null == o) {\\n          o.emit(\\"readFileRes\\", e);\\n        }\\n      })\\n      .catch(h);\\n  });\\n  o.on(\\"mtimeRes\\", (e) => {\\n    d.debug(t, `mTime_REQ - ${e}`);\\n    p.mtime(e)\\n      .then((e) => {\\n        if (null == o) {\\n          o.emit(\\"mtimeRes\\", e);\\n        }\\n      })\\n      .catch(h);\\n  });\\n};\\nexports.terminate = function () {\\n  if (o) {\\n    o.removeAllListeners();\\n    o.terminate();\\n    o = null;\\n    i.clear();\\n  }\\n};\\nconst a = [\\n    \\"getFunctionPositions\\",\\n    \\"isEmptyBlockStart\\",\\n    \\"isBlockBodyFinished\\",\\n    \\"getNodeStart\\",\\n    \\"parsesWithoutError\\",\\n  ],\\n  c = [\\"isSupportedLanguageId\\", \\"getBlockCloseToken\\"];\\nfunction l(e, t, n) {\\n  return function (...r) {\\n    const a = s++;\\n    return new Promise((s, c) => {\\n      i.set(a, {\\n        resolve: s,\\n        reject: c,\\n      });\\n      t.debug(e, `Proxy ${n}`);\\n      if (null == o) {\\n        o.postMessage({\\n          id: a,\\n          fn: n,\\n          args: r,\\n        });\\n      }\\n    });\\n  };\\n}\\nexports.isEmptyBlockStart = r.isEmptyBlockStart;\\nexports.isBlockBodyFinished = r.isBlockBodyFinished;\\nexports.isSupportedLanguageId = r.isSupportedLanguageId;\\nexports.getBlockCloseToken = r.getBlockCloseToken;\\nexports.getFunctionPositions = r.getFunctionPositions;\\nexports.getNodeStart = r.getNodeStart;\\nexports.getPrompt = r.getPrompt;\\nexports.parsesWithoutError = r.parsesWithoutError;","module-code-956":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.readTestingGitHubToken = exports.makeTestingCopilotTokenManager =\\n  undefined;\\nconst r = require(\\"fs\\"),\\n  o = require(\\"copilot-github-auth-stuff\\");\\nfunction readTestingGitHubToken() {\\n  const e = `${process.env.HOME}/.copilot-testing-gh-token`;\\n  if (r.existsSync(e)) return r.readFileSync(e).toString();\\n  throw new Error(\\n    `Tests: either GH_COPILOT_TOKEN, or GITHUB_TOKEN, must be set, or there must be a GitHub token from an app with access to Copilot in ${e}. Run \\"npm run get_token\\" to get one.`\\n  );\\n}\\nexports.makeTestingCopilotTokenManager = function () {\\n  if (process.env.GH_COPILOT_TOKEN)\\n    return new o.FixedCopilotTokenManager({\\n      token: process.env.GH_COPILOT_TOKEN,\\n      telemetry: \\"enabled\\",\\n    });\\n  if (process.env.GITHUB_TOKEN)\\n    return new o.CopilotTokenManagerFromGitHubToken({\\n      token: process.env.GITHUB_TOKEN,\\n    });\\n  const e = readTestingGitHubToken();\\n  process.env.GITHUB_TOKEN = e;\\n  return new o.CopilotTokenManagerFromGitHubToken({\\n    token: e,\\n  });\\n};\\nexports.readTestingGitHubToken = readTestingGitHubToken;","module-label-2388":"completion-normalizer","module-code-main":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.deactivate = exports.activate = exports.init = undefined;\\nconst t = require(\\"getPrompt-main-stuff\\");\\nrequire(406);\\nconst o = require(\\"vscode\\"),\\n  i = require(\\"copilot-github-auth-stuff\\"),\\n  s = require(\\"clock\\"),\\n  a = require(\\"config_stuff\\"),\\n  c = require(4197),\\n  l = require(7870),\\n  u = require(9408),\\n  d = require(1839),\\n  p = require(9189),\\n  h = require(9748),\\n  f = require(8965),\\n  m = require(5413),\\n  g = require(\\"logging-utils\\"),\\n  _ = require(2279),\\n  y = require(1547),\\n  v = require(4419),\\n  b = require(6722),\\n  w = require(2533),\\n  x = require(766),\\n  E = require(\\"telemetry-stuff\\"),\\n  C = require(956),\\n  S = require(70),\\n  T = require(8771),\\n  k = require(6403),\\n  I = require(3136),\\n  P = require(7057),\\n  A = require(3197),\\n  O = require(1862),\\n  N = require(9425),\\n  R = require(3060),\\n  M = (require(1929), require(6267)),\\n  L = require(\\"copilot_panel\\"),\\n  $ = require(6857),\\n  D = require(9477),\\n  F = require(7254),\\n  j = require(4428),\\n  q = require(8129),\\n  B = require(385),\\n  U = o.window.createOutputChannel(\\"GitHub Copilot\\");\\nfunction init() {\\n  _.init(new a.BuildInfo().getVersion());\\n}\\nfunction z(e, t, n) {\\n  return o.commands.registerCommand(t, async (...r) => {\\n    try {\\n      return await n(...r);\\n    } catch (n) {\\n      E.telemetryException(e, n, t);\\n    }\\n  });\\n}\\nlet G;\\nexports.init = init;\\ninit();\\nexports.activate = async function (e) {\\n  const n = new l.Context();\\n  n.set(a.ConfigProvider, new N.VSCodeConfigProvider());\\n  n.set(s.Clock, new s.Clock());\\n  n.set(a.BuildInfo, new a.BuildInfo());\\n  n.set(a.EditorAndPluginInfo, new N.VSCodeEditorInfo());\\n  n.set(g.LogVerbose, new g.LogVerbose(!1));\\n  n.set(m.GhostTextDebounceManager, new m.GhostTextDebounceManager());\\n  n.set(f.ContextualFilterManager, new f.ContextualFilterManager());\\n  const r = new g.MultiLog([\\n    new g.ConsoleLog(console),\\n    new g.OutputChannelLog(U),\\n  ]);\\n  n.set(g.LogTarget, r);\\n  n.set(k.LocationFactory, new q.ExtensionLocationFactory());\\n  n.set(I.TextDocumentManager, new B.ExtensionTextDocumentManager());\\n  n.set(p.Features, new p.Features(n));\\n  const H = new _.HelixFetcher(n);\\n  n.set(_.Fetcher, H);\\n  D.initProxyEnvironment(H, process.env);\\n  n.set(t.FileSystem, $.extensionFileSystem);\\n  n.set(y.NotificationSender, new O.ExtensionNotificationSender());\\n  n.set(E.TelemetryEndpointUrl, new E.TelemetryEndpointUrl());\\n  if (e.extensionMode === o.ExtensionMode.Test) {\\n    n.set(i.CopilotTokenManager, C.makeTestingCopilotTokenManager());\\n    n.set(a.VscInfo, a.getTestVscInfo());\\n    n.set(S.RuntimeMode, S.RuntimeMode.fromEnvironment(!0));\\n    n.set(h.ExpConfigMaker, new h.ExpConfigNone());\\n    n.set(E.TelemetryReporters, E.setupStandardReporters(n, \\"copilot-test\\"));\\n    n.set(P.UrlOpener, new T.TestUrlOpener());\\n  } else {\\n    n.set(i.CopilotTokenManager, new O.VSCodeCopilotTokenManager());\\n    n.set(a.VscInfo, N.makeVscInfo());\\n    n.set(v.OpenAIFetcher, new v.LiveOpenAIFetcher());\\n    n.set(a.BlockModeConfig, new a.ConfigBlockModeConfig());\\n    n.set(S.RuntimeMode, S.RuntimeMode.fromEnvironment(!1));\\n    n.set(h.ExpConfigMaker, new h.ExpConfigFromTAS());\\n    n.set(E.TelemetryReporters, j.activate(n, e));\\n    n.set(P.UrlOpener, new P.RealUrlOpener());\\n  }\\n  if (\\"GitHub.copilot-nightly\\" === e.extension.id) {\\n    u.registerDefaultHandlers(n, \\"vscode\\");\\n  }\\n  N.setExtension(e.extension);\\n  O.setExtensionContext(e);\\n  e.globalState.setKeysForSync([O.telemetryAcceptanceKey]);\\n  const V = a.getBuildType(n) === a.BuildType.DEV,\\n    W = \\"GitHub.copilot-nightly\\" === e.extension.id;\\n  if (W && o.extensions.all.find((e) => \\"GitHub.copilot\\" === e.id))\\n    return void (\\n      \\"Uninstall\\" ===\\n        (await o.window.showWarningMessage(\\n          \\"To use GitHub Copilot Nightly you need to uninstall GitHub Copilot extension\\",\\n          \\"Uninstall\\"\\n        )) &&\\n      (await o.commands.executeCommand(\\n        \\"workbench.extensions.uninstallExtension\\",\\n        \\"GitHub.copilot\\"\\n      ))\\n    );\\n  if (W || V) {\\n    o.commands.executeCommand(\\"setContext\\", \\"github.copilot.nightly\\", !0);\\n  }\\n  const K = (function (e, t) {\\n    const n = new F.CopilotStatusBar(e);\\n    t.subscriptions.push(\\n      z(e, R.CMDToggleCopilot, () => {\\n        n.toggleStatusBar();\\n      })\\n    );\\n    t.subscriptions.push(\\n      z(e, R.CMDShowActivationErrors, () => {\\n        n.showActivationErrors(U);\\n      })\\n    );\\n    t.subscriptions.push(n.getStatusBarItem());\\n    return n;\\n  })(n, e);\\n  n.set(b.StatusReporter, K);\\n  const J = async () => {\\n    try {\\n      await n.get(i.CopilotTokenManager).getCopilotToken(n);\\n    } catch (e) {\\n      const t = e.message || e;\\n      E.telemetryError(\\n        n,\\n        \\"activationFailed\\",\\n        E.TelemetryData.createAndMarkAsIssued({\\n          reason: t,\\n        })\\n      );\\n      n.get(E.TelemetryReporters).deactivate();\\n      const r = `GitHub Copilot could not connect to server. Extension activation failed: \\"${t}\\"`;\\n      K.setError(r, J);\\n      g.logger.error(n, r);\\n      return void o.commands.executeCommand(\\n        \\"setContext\\",\\n        \\"github.copilot.activated\\",\\n        !1\\n      );\\n    }\\n    K.forceNormal();\\n    o.commands.executeCommand(\\"setContext\\", \\"github.copilot.activated\\", !0);\\n    e.subscriptions.push(\\n      z(n, R.CMDOpenPanel, () => {\\n        o.commands.executeCommand(\\"editor.action.inlineSuggest.hide\\");\\n        M.commandOpenPanel(n);\\n      })\\n    );\\n    e.subscriptions.push(\\n      z(n, R.CMDOpenPanelForRange, (e) => {\\n        M.commandOpenPanel(n, e);\\n      }),\\n      z(n, R.CMDAcceptPanelSolution, async (e, t, n, r, i) => {\\n        const s = new o.WorkspaceEdit();\\n        s.insert(e, t, n);\\n        await o.workspace.applyEdit(s);\\n        i();\\n        await o.commands.executeCommand(\\"workbench.action.closeActiveEditor\\");\\n        if (\\n          r &&\\n          o.window.activeTextEditor &&\\n          o.window.activeTextEditor.document.uri.toString() === e.toString()\\n        ) {\\n          const e = t.translate(1).with(void 0, 0),\\n            n = new o.Selection(e, e);\\n          o.window.activeTextEditor.selection = n;\\n        }\\n      })\\n    );\\n    e.subscriptions.push(\\n      z(n, R.CMDSendFeedback, () => {\\n        o.env.openExternal(\\n          o.Uri.parse(\\n            \\"https://github.com/github/feedback/discussions/categories/copilot\\"\\n          )\\n        );\\n      })\\n    );\\n    const t = new L.CopilotPanel(n);\\n    e.subscriptions.push(\\n      o.workspace.registerTextDocumentContentProvider(c.CopilotScheme, t),\\n      o.languages.registerCodeLensProvider(\\n        {\\n          scheme: c.CopilotScheme,\\n        },\\n        t\\n      )\\n    );\\n    try {\\n      e.subscriptions.push(...A.registerGhostText(n));\\n      const t = o.workspace.getConfiguration(),\\n        r = t.inspect(\\"editor.inlineSuggest.enabled\\");\\n      if (undefined === (null == r ? undefined : r.globalValue)) {\\n        t.update(\\n          \\"editor.inlineSuggest.enabled\\",\\n          !0,\\n          o.ConfigurationTarget.Global\\n        );\\n      }\\n    } catch (e) {\\n      o.window.showErrorMessage(\\n        \\"GitHub Copilot requires VS Code 1.57+. Please update your VS Code\\"\\n      );\\n    }\\n    e.subscriptions.push(d.registerDocumentTracker(n));\\n    e.subscriptions.push(\\n      o.window.onDidChangeActiveTextEditor((e) =>\\n        e\\n          ? e.document.isUntitled ||\\n            (\\"file\\" === e.document.uri.scheme &&\\n              x.extractRepoInfoInBackground(n, e.document.fileName))\\n          : undefined\\n      )\\n    );\\n    const r = e.extensionMode !== o.ExtensionMode.Development;\\n    w.init(n, r, new g.Logger(g.LogLevel.INFO, \\"promptlib proxy\\"));\\n    E.telemetry(n, \\"extension.activate\\");\\n    G = n;\\n  };\\n  await J();\\n};\\nexports.deactivate = function () {\\n  if (G) {\\n    E.telemetry(G, \\"extension.deactivate\\");\\n    G.get(E.TelemetryReporters).deactivate();\\n  }\\n  w.terminate();\\n};","module-label-3458":"git-url-parser","module-code-1133":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.editorVersionHeaders =\\n  exports.EditorAndPluginInfo =\\n  exports.formatNameAndVersion =\\n  exports.getTestVscInfo =\\n  exports.VscInfo =\\n  exports.getVersion =\\n  exports.getBuild =\\n  exports.getBuildType =\\n  exports.isProduction =\\n  exports.BuildInfo =\\n  exports.fimSuffixLengthThreshold =\\n  exports.suffixMatchThreshold =\\n  exports.suffixPercent =\\n  exports.getEnabledConfig =\\n  exports.getLanguageConfig =\\n  exports.dumpConfig =\\n  exports.getHiddenConfig =\\n  exports.isDefaultSettingOverwritten =\\n  exports.getConfig =\\n  exports.getConfigDefaultForObjectKey =\\n  exports.getConfigDefaultForKey =\\n  exports.InMemoryConfigProvider =\\n  exports.DefaultsOnlyConfigProvider =\\n  exports.ConfigProvider =\\n  exports.ConfigBlockModeConfig =\\n  exports.BlockModeConfig =\\n  exports.BuildType =\\n  exports.shouldDoServerTrimming =\\n  exports.shouldDoParsingTrimming =\\n  exports.BlockMode =\\n  exports.ConfigKey =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(4197),\\n  i = require(9189),\\n  s = require(4147);\\nvar a, c;\\nexports.ConfigKey = {\\n  Enable: \\"enable\\",\\n  InlineSuggestEnable: \\"inlineSuggest.enable\\",\\n  ShowEditorCompletions: [\\"editor\\", \\"showEditorCompletions\\"],\\n  EnableAutoCompletions: [\\"editor\\", \\"enableAutoCompletions\\"],\\n  DelayCompletions: [\\"editor\\", \\"delayCompletions\\"],\\n  FilterCompletions: [\\"editor\\", \\"filterCompletions\\"],\\n  DisplayStyle: [\\"advanced\\", \\"displayStyle\\"],\\n  SecretKey: [\\"advanced\\", \\"secret_key\\"],\\n  SolutionLength: [\\"advanced\\", \\"length\\"],\\n  Stops: [\\"advanced\\", \\"stops\\"],\\n  Temperature: [\\"advanced\\", \\"temperature\\"],\\n  TopP: [\\"advanced\\", \\"top_p\\"],\\n  IndentationMode: [\\"advanced\\", \\"indentationMode\\"],\\n  InlineSuggestCount: [\\"advanced\\", \\"inlineSuggestCount\\"],\\n  ListCount: [\\"advanced\\", \\"listCount\\"],\\n  DebugOverrideProxyUrl: [\\"advanced\\", \\"debug.overrideProxyUrl\\"],\\n  DebugTestOverrideProxyUrl: [\\"advanced\\", \\"debug.testOverrideProxyUrl\\"],\\n  DebugOverrideEngine: [\\"advanced\\", \\"debug.overrideEngine\\"],\\n  DebugShowScores: [\\"advanced\\", \\"debug.showScores\\"],\\n  DebugOverrideLogLevels: [\\"advanced\\", \\"debug.overrideLogLevels\\"],\\n  DebugFilterLogCategories: [\\"advanced\\", \\"debug.filterLogCategories\\"],\\n  DebugUseSuffix: [\\"advanced\\", \\"debug.useSuffix\\"],\\n};\\n(function (e) {\\n  e.Parsing = \\"parsing\\";\\n  e.Server = \\"server\\";\\n  e.ParsingAndServer = \\"parsingandserver\\";\\n})((a = exports.BlockMode || (exports.BlockMode = {})));\\nexports.shouldDoParsingTrimming = function (e) {\\n  return [a.Parsing, a.ParsingAndServer].includes(e);\\n};\\nexports.shouldDoServerTrimming = function (e) {\\n  return [a.Server, a.ParsingAndServer].includes(e);\\n};\\n(c = exports.BuildType || (exports.BuildType = {})).DEV = \\"dev\\";\\nc.PROD = \\"prod\\";\\nc.NIGHTLY = \\"nightly\\";\\nclass BlockModeConfig {}\\nfunction u(e, t) {\\n  return e !== a.ParsingAndServer || r.isSupportedLanguageId(t) ? e : a.Server;\\n}\\nexports.BlockModeConfig = BlockModeConfig;\\nexports.ConfigBlockModeConfig = class extends BlockModeConfig {\\n  async forLanguage(e, n) {\\n    if (\\n      e\\n        .get(ConfigProvider)\\n        .isDefaultSettingOverwritten(exports.ConfigKey.IndentationMode)\\n    )\\n      switch (\\n        e\\n          .get(ConfigProvider)\\n          .getLanguageConfig(exports.ConfigKey.IndentationMode, n)\\n      ) {\\n        case \\"client\\":\\n        case !0:\\n        case \\"server\\":\\n          return a.Server;\\n        case \\"clientandserver\\":\\n          return u(a.ParsingAndServer, n);\\n        default:\\n          return a.Parsing;\\n      }\\n    const o = await e.get(i.Features).overrideBlockMode();\\n    return o ? u(o, n) : r.isSupportedLanguageId(n) ? a.Parsing : a.Server;\\n  }\\n};\\nclass ConfigProvider {}\\nfunction getConfigDefaultForKey(e) {\\n  try {\\n    const t =\\n      s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`]\\n        .default;\\n    if (undefined === t)\\n      throw new Error(\\n        `Missing config default value: ${o.CopilotConfigPrefix}.${e}`\\n      );\\n    return t;\\n  } catch (t) {\\n    throw new Error(\\n      `Error inspecting config default value ${o.CopilotConfigPrefix}.${e}: ${t}`\\n    );\\n  }\\n}\\nfunction getConfigDefaultForObjectKey(e, t) {\\n  try {\\n    const n =\\n      s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`]\\n        .properties[t].default;\\n    if (undefined === n)\\n      throw new Error(\\n        `Missing config default value: ${o.CopilotConfigPrefix}.${e}`\\n      );\\n    return n;\\n  } catch (n) {\\n    throw new Error(\\n      `Error inspecting config default value ${o.CopilotConfigPrefix}.${e}.${t}: ${n}`\\n    );\\n  }\\n}\\nfunction getConfig(e, t) {\\n  return e.get(ConfigProvider).getConfig(t);\\n}\\nfunction isDefaultSettingOverwritten(e, t) {\\n  return e.get(ConfigProvider).isDefaultSettingOverwritten(t);\\n}\\nfunction getHiddenConfig(e, t, n) {\\n  return isDefaultSettingOverwritten(e, t) ? getConfig(e, t) : n.default;\\n}\\nfunction getLanguageConfig(e, t, n) {\\n  return e.get(ConfigProvider).getLanguageConfig(t, n);\\n}\\nexports.ConfigProvider = ConfigProvider;\\nexports.DefaultsOnlyConfigProvider = class extends ConfigProvider {\\n  getConfig(e) {\\n    return Array.isArray(e)\\n      ? getConfigDefaultForObjectKey(e[0], e[1])\\n      : getConfigDefaultForKey(e);\\n  }\\n  isDefaultSettingOverwritten(e) {\\n    return !1;\\n  }\\n  dumpConfig() {\\n    return {};\\n  }\\n  getLanguageConfig(e, t) {\\n    const n = this.getConfig(e);\\n    return t && t in n ? n[t] : n[\\"*\\"];\\n  }\\n};\\nexports.InMemoryConfigProvider = class {\\n  constructor(e, t) {\\n    this.baseConfigProvider = e;\\n    this.overrides = t;\\n  }\\n  getConfig(e) {\\n    const t = this.overrides.get(e);\\n    return undefined !== t ? t : this.baseConfigProvider.getConfig(e);\\n  }\\n  setConfig(e, t) {\\n    if (undefined !== t) {\\n      this.overrides.set(e, t);\\n    } else {\\n      this.overrides.delete(e);\\n    }\\n  }\\n  setLanguageEnablement(e, n) {\\n    this.overrides.set(exports.ConfigKey.Enable, {\\n      [e]: n,\\n    });\\n  }\\n  isDefaultSettingOverwritten(e) {\\n    return (\\n      !!this.overrides.has(e) ||\\n      this.baseConfigProvider.isDefaultSettingOverwritten(e)\\n    );\\n  }\\n  keyAsString(e) {\\n    return Array.isArray(e) ? e.join(\\".\\") : e;\\n  }\\n  dumpConfig() {\\n    const e = this.baseConfigProvider.dumpConfig();\\n    this.overrides.forEach((t, n) => {\\n      e[this.keyAsString(n)] = JSON.stringify(t);\\n    });\\n    return e;\\n  }\\n  getLanguageConfig(e, t) {\\n    const n = this.overrides.get(e);\\n    return undefined !== n\\n      ? undefined !== t\\n        ? n[t]\\n        : n[\\"*\\"]\\n      : this.baseConfigProvider.getLanguageConfig(e, t);\\n  }\\n};\\nexports.getConfigDefaultForKey = getConfigDefaultForKey;\\nexports.getConfigDefaultForObjectKey = getConfigDefaultForObjectKey;\\nexports.getConfig = getConfig;\\nexports.isDefaultSettingOverwritten = isDefaultSettingOverwritten;\\nexports.getHiddenConfig = getHiddenConfig;\\nexports.dumpConfig = function (e) {\\n  return e.get(ConfigProvider).dumpConfig();\\n};\\nexports.getLanguageConfig = getLanguageConfig;\\nexports.getEnabledConfig = function (e, n) {\\n  return getLanguageConfig(e, exports.ConfigKey.Enable, n);\\n};\\nexports.suffixPercent = async function (e, n, r) {\\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\\n    default: !1,\\n  })\\n    ? 15\\n    : e.get(i.Features).suffixPercent(n, r);\\n};\\nexports.suffixMatchThreshold = async function (e, n, r) {\\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\\n    default: !1,\\n  })\\n    ? 0\\n    : e.get(i.Features).suffixMatchThreshold(n, r);\\n};\\nexports.fimSuffixLengthThreshold = async function (e, n, r) {\\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\\n    default: !1,\\n  })\\n    ? -1\\n    : e.get(i.Features).fimSuffixLengthThreshold(n, r);\\n};\\nclass BuildInfo {\\n  constructor() {\\n    this.packageJson = s;\\n  }\\n  isProduction() {\\n    return \\"dev\\" != this.getBuildType();\\n  }\\n  getBuildType() {\\n    return this.packageJson.buildType;\\n  }\\n  getVersion() {\\n    return this.packageJson.version;\\n  }\\n  getBuild() {\\n    return this.packageJson.build;\\n  }\\n  getName() {\\n    return this.packageJson.name;\\n  }\\n}\\nexports.BuildInfo = BuildInfo;\\nexports.isProduction = function (e) {\\n  return e.get(BuildInfo).isProduction();\\n};\\nexports.getBuildType = function (e) {\\n  return e.get(BuildInfo).getBuildType();\\n};\\nexports.getBuild = function (e) {\\n  return e.get(BuildInfo).getBuild();\\n};\\nexports.getVersion = function (e) {\\n  return e.get(BuildInfo).getVersion();\\n};\\nclass VscInfo {\\n  constructor(e, t, n) {\\n    this.sessionId = e;\\n    this.machineId = t;\\n    this.vsCodeVersion = n;\\n  }\\n}\\nfunction formatNameAndVersion({ name: e, version: t }) {\\n  return `${e}/${t}`;\\n}\\nexports.VscInfo = VscInfo;\\nexports.getTestVscInfo = function () {\\n  return new VscInfo(\\n    \\"test-session-id\\",\\n    \\"test-machine-id\\",\\n    \\"test-vscode-version\\"\\n  );\\n};\\nexports.formatNameAndVersion = formatNameAndVersion;\\nclass EditorAndPluginInfo {}\\nexports.EditorAndPluginInfo = EditorAndPluginInfo;\\nexports.editorVersionHeaders = function (e) {\\n  const t = e.get(EditorAndPluginInfo);\\n  return {\\n    \\"Editor-Version\\": formatNameAndVersion(t.getEditorInfo(e)),\\n    \\"Editor-Plugin-Version\\": formatNameAndVersion(t.getEditorPluginInfo(e)),\\n  };\\n};","module-code-9408":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.registerDefaultHandlers = undefined;\\nconst r = require(2279),\\n  o = require(\\"telemetry-stuff\\");\\nexports.registerDefaultHandlers = function (e, t) {\\n  process.addListener(\\"uncaughtException\\", (t) => {\\n    console.error(\\"uncaughtException\\", t);\\n    o.telemetryException(e, t, \\"uncaughtException\\");\\n  });\\n  let n = !1;\\n  process.addListener(\\"unhandledRejection\\", (i, s) => {\\n    if (n) return;\\n    n = !0;\\n    if (\\"vscode\\" === t && !i) return;\\n    if (\\"aborted\\" === i.type || r.isAbortError(i)) return;\\n    if (\\n      \\"vscode\\" === t &&\\n      [\\n        \\"ENOTFOUND\\",\\n        \\"ECONNREFUSED\\",\\n        \\"ECONNRESET\\",\\n        \\"ETIMEDOUT\\",\\n        \\"ENETDOWN\\",\\n        \\"ENETUNREACH\\",\\n        \\"EADDRNOTAVAIL\\",\\n      ].includes(i.code)\\n    )\\n      return;\\n    if (\\"ENOENT\\" == i.code) return;\\n    let a = \\"\\";\\n    try {\\n      a = `${i.message} (${i.code})`;\\n      a = JSON.stringify(i);\\n    } catch (e) {\\n      a = \\"[actual reason JSON was cyclic]\\";\\n    }\\n    if (\\"vscode\\" === t && \\"{}\\" === a) {\\n      console.error(\\"unhandledRejection\\", a);\\n      o.telemetryError(\\n        e,\\n        \\"unhandledRejection\\",\\n        o.TelemetryData.createAndMarkAsIssued({\\n          origin: \\"unhandledRejection\\",\\n          reason: \\"Unhandled rejection logged to restricted telemetry\\",\\n        }),\\n        !1\\n      );\\n      o.telemetryError(\\n        e,\\n        \\"unhandledRejection\\",\\n        o.TelemetryData.createAndMarkAsIssued({\\n          origin: \\"unhandledRejection\\",\\n          reason: a,\\n        }),\\n        !0\\n      );\\n      n = !1;\\n    }\\n  });\\n};","module-label-299":"clock","module-code-4540":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ignoreDocument = undefined;\\nconst r = require(\\"config_stuff\\"),\\n  o = require(4197);\\nexports.ignoreDocument = function (e, t) {\\n  const n = t.languageId;\\n  return (\\n    !r.getEnabledConfig(e, n) ||\\n    !![o.CopilotScheme, \\"output\\", \\"search-editor\\"].includes(t.uri.scheme)\\n  );\\n};","module-label-9334":"ghost-text-provider","module-label-1133":"config_stuff","module-code-2901":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.prepareSolutionForReturn =\\n  exports.processSSE =\\n  exports.splitChunk =\\n    undefined;\\nconst r = require(\\"logging-utils\\"),\\n  o = require(\\"telemetry-stuff\\"),\\n  i = require(\\"openai-choices-utils\\"),\\n  s = new r.Logger(r.LogLevel.INFO, \\"streamChoices\\");\\nfunction splitChunk(e) {\\n  const t = e.split(\\"\\\\n\\"),\\n    n = t.pop();\\n  return [t.filter((e) => \\"\\" != e), n];\\n}\\nexports.splitChunk = splitChunk;\\nexports.processSSE = async function* (e, t, n, r, c) {\\n  var l, u, d, p, h, f, m, g, _;\\n  const y = await t.body();\\n  y.setEncoding(\\"utf8\\");\\n  let v = i.getRequestId(t);\\n  s.debug(e, `requestId: ${v.headerRequestId}`);\\n  const b = {};\\n  let w = \\"\\";\\n  for await (const x of y) {\\n    if (null == c ? undefined : c.isCancellationRequested) {\\n      s.info(e, \\"Cancelled after awaiting body chunk\\");\\n      return void y.destroy();\\n    }\\n    s.debug(e, \\"chunk\\", x.toString());\\n    const [E, C] = splitChunk(w + x.toString());\\n    w = C;\\n    for (const a of E) {\\n      const w = a.slice(\\"data:\\".length).trim();\\n      if (\\"[DONE]\\" == w) {\\n        for (const [t, n] of Object.entries(b)) {\\n          const r = Number(t);\\n          if (\\n            null != n &&\\n            (yield {\\n              solution: n,\\n              finishOffset: undefined,\\n              reason: \\"DONE\\",\\n              requestId: v,\\n              index: r,\\n            },\\n            null == c ? undefined : c.isCancellationRequested)\\n          ) {\\n            s.debug(e, \\"Cancelled after yielding on DONE\\");\\n            return void y.destroy();\\n          }\\n        }\\n        return;\\n      }\\n      let x;\\n      try {\\n        x = JSON.parse(w);\\n      } catch (t) {\\n        s.error(e, \\"Error parsing JSON stream data\\", a);\\n        continue;\\n      }\\n      if (undefined !== x.choices || undefined === x.error) {\\n        if (0 == v.created) {\\n          v = i.getRequestId(t, x);\\n          if (0 == v.created) {\\n            s.error(\\n              e,\\n              `Request id invalid, should have \\"completionId\\" and \\"created\\": ${v}`,\\n              v\\n            );\\n          }\\n        }\\n        for (let t = 0; t < x.choices.length; t++) {\\n          const i = x.choices[t];\\n          s.debug(e, \\"choice\\", i);\\n          if (i.index in b) {\\n            b[i.index] = {\\n              logprobs: [],\\n              top_logprobs: [],\\n              text: [],\\n              text_offset: [],\\n              tokens: [],\\n            };\\n          }\\n          const a = b[i.index];\\n          if (null == a) continue;\\n          let w;\\n          a.text.push(i.text);\\n          a.tokens.push(\\n            null !==\\n              (u =\\n                null === (l = i.logprobs) || undefined === l\\n                  ? undefined\\n                  : l.tokens) && undefined !== u\\n              ? u\\n              : []\\n          );\\n          a.text_offset.push(\\n            null !==\\n              (p =\\n                null === (d = i.logprobs) || undefined === d\\n                  ? undefined\\n                  : d.text_offset) && undefined !== p\\n              ? p\\n              : []\\n          );\\n          a.logprobs.push(\\n            null !==\\n              (f =\\n                null === (h = i.logprobs) || undefined === h\\n                  ? undefined\\n                  : h.token_logprobs) && undefined !== f\\n              ? f\\n              : []\\n          );\\n          a.top_logprobs.push(\\n            null !==\\n              (g =\\n                null === (m = i.logprobs) || undefined === m\\n                  ? undefined\\n                  : m.top_logprobs) && undefined !== g\\n              ? g\\n              : []\\n          );\\n          if (\\n            (i.finish_reason || i.text.indexOf(\\"\\\\n\\") > -1) &&\\n            ((w = await n(a.text.join(\\"\\"))),\\n            null == c ? void 0 : c.isCancellationRequested)\\n          )\\n            return (\\n              s.debug(e, \\"Cancelled after awaiting finishedCb\\"),\\n              void y.destroy()\\n            );\\n          if (i.finish_reason || undefined !== w) {\\n            const t =\\n              null !== (_ = i.finish_reason) && undefined !== _\\n                ? _\\n                : \\"client-trimmed\\";\\n            o.telemetry(\\n              e,\\n              \\"completion.finishReason\\",\\n              r.extendedBy({\\n                completionChoiceFinishReason: t,\\n              })\\n            );\\n            yield {\\n              solution: a,\\n              finishOffset: w,\\n              reason: JSON.stringify(i.finish_reason),\\n              requestId: v,\\n              index: i.index,\\n            };\\n            if (null == c ? void 0 : c.isCancellationRequested)\\n              return (\\n                s.debug(e, \\"Cancelled after yielding finished choice\\"),\\n                void y.destroy()\\n              );\\n            b[i.index] = null;\\n          }\\n        }\\n      } else s.error(e, \\"Error in response:\\", x.error.message);\\n    }\\n  }\\n  for (const [t, n] of Object.entries(b)) {\\n    const r = Number(t);\\n    if (\\n      null != n &&\\n      (yield {\\n        solution: n,\\n        finishOffset: undefined,\\n        reason: \\"Iteration Done\\",\\n        requestId: v,\\n        index: r,\\n      },\\n      null == c ? undefined : c.isCancellationRequested)\\n    ) {\\n      s.debug(e, \\"Cancelled after yielding after iteration done\\");\\n      return void y.destroy();\\n    }\\n  }\\n  if (w.length > 0)\\n    try {\\n      const t = JSON.parse(w);\\n      if (undefined !== t.error) {\\n        s.error(e, `Error in response: ${t.error.message}`, t.error);\\n      }\\n    } catch (t) {\\n      s.error(e, `Error parsing extraData: ${w}`);\\n    }\\n};\\nexports.prepareSolutionForReturn = function (e, t, n) {\\n  let r = t.solution.text.join(\\"\\"),\\n    o = !1;\\n  if (undefined !== t.finishOffset) {\\n    s.debug(e, `solution ${t.index}: early finish at offset ${t.finishOffset}`);\\n    r = r.substring(0, t.finishOffset);\\n    o = !0;\\n  }\\n  s.info(\\n    e,\\n    `solution ${t.index} returned. finish reason: [${t.reason}] finishOffset: [${t.finishOffset}] completionId: [{${t.requestId.completionId}}] created: [{${t.requestId.created}}]`\\n  );\\n  const a = (function (e, t) {\\n    const n = {\\n      text: t.text.join(\\"\\"),\\n      tokens: t.text,\\n    };\\n    if (0 === t.logprobs.length) return n;\\n    const r = t.logprobs.reduce((e, t) => e.concat(t), []),\\n      o = t.top_logprobs.reduce((e, t) => e.concat(t), []),\\n      i = t.text_offset.reduce((e, t) => e.concat(t), []),\\n      s = t.tokens.reduce((e, t) => e.concat(t), []);\\n    return {\\n      ...n,\\n      logprobs: {\\n        token_logprobs: r,\\n        top_logprobs: o,\\n        text_offset: i,\\n        tokens: s,\\n      },\\n    };\\n  })(0, t.solution);\\n  return i.convertToAPIChoice(e, r, a, t.index, t.requestId, o, n);\\n};","module-code-1124":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.checkSuffix = exports.postProcessChoice = undefined;\\nconst r = require(9189),\\n  o = require(2533),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(70),\\n  a = require(9657);\\nexports.postProcessChoice = async function (e, t, n, c, l, u, d) {\\n  if (\\n    a.isRepetitive(l.tokens, await e.get(r.Features).repetitionFilterMode())\\n  ) {\\n    const t = i.TelemetryData.createAndMarkAsIssued();\\n    t.extendWithRequestId(l.requestId);\\n    i.telemetry(e, \\"repetition.detected\\", t, !0);\\n    return void d.info(e, \\"Filtered out repetitive solution\\");\\n  }\\n  const p = {\\n    ...l,\\n  };\\n  if (\\n    (function (e, t, n) {\\n      let r = \\"\\",\\n        o = t.line + 1;\\n      for (; \\"\\" === r && o < e.lineCount; ) {\\n        r = e.lineAt(o).text.trim();\\n        if (r === n.trim()) return !0;\\n        o++;\\n      }\\n      return !1;\\n    })(n, c, p.completionText)\\n  ) {\\n    const t = i.TelemetryData.createAndMarkAsIssued();\\n    t.extendWithRequestId(l.requestId);\\n    i.telemetry(e, \\"completion.alreadyInDocument\\", t);\\n    i.telemetry(\\n      e,\\n      \\"completion.alreadyInDocument\\",\\n      t.extendedBy({\\n        completionTextJson: JSON.stringify(p.completionText),\\n      }),\\n      !0\\n    );\\n    return void d.info(e, \\"Filtered out solution matching next line\\");\\n  }\\n  p.completionText = await (async function (e, t, n, r, i) {\\n    var a;\\n    if (\\"\\" === r) return r;\\n    let c = \\"}\\";\\n    try {\\n      c =\\n        null !== (a = o.getBlockCloseToken(t.languageId)) && undefined !== a\\n          ? a\\n          : \\"}\\";\\n    } catch (e) {}\\n    let l = r.length;\\n    do {\\n      const o = r.lastIndexOf(\\"\\\\n\\", l - 2) + 1,\\n        a = r.substring(o, l);\\n      if (a.trim() === c) {\\n        for (let e = n.line; e < t.lineCount; e++) {\\n          let s = t.lineAt(e).text;\\n          if (e === n.line) {\\n            s = s.substr(n.character);\\n          }\\n          if (s.startsWith(a.trimRight()))\\n            return r.substring(0, Math.max(0, i ? o : o - 1));\\n          if (\\"\\" !== s.trim()) break;\\n        }\\n        break;\\n      }\\n      if (l === o) {\\n        if (s.shouldFailForDebugPurposes(e))\\n          throw Error(\\n            `Aborting: maybeSnipCompletion would have looped on completion: ${r}`\\n          );\\n        break;\\n      }\\n      l = o;\\n    } while (l > 1);\\n    return r;\\n  })(e, n, c, p.completionText, u);\\n  return p.completionText ? p : undefined;\\n};\\nexports.checkSuffix = function (e, t, n) {\\n  const r = e.lineAt(t.line).text.substring(t.character);\\n  if (r.length > 0) {\\n    if (-1 !== n.completionText.indexOf(r)) return !0;\\n    {\\n      let e = 0;\\n      for (const t of r) {\\n        const r = n.completionText.indexOf(t, e + 1);\\n        if (!(r > e)) {\\n          e = -1;\\n          break;\\n        }\\n        e = r;\\n      }\\n      return -1 !== e;\\n    }\\n  }\\n  return !1;\\n};","module-label-3":"openai_conn_utils","module-code-9380":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.setupExperimentationService = exports.logger = undefined;\\nconst r = require(9496),\\n  o = require(\\"config_stuff\\"),\\n  i = require(9189),\\n  s = require(8142),\\n  a = require(\\"logging-utils\\");\\nfunction c(e) {\\n  return e.split(\\"-\\")[0];\\n}\\nexports.logger = new a.Logger(a.LogLevel.INFO, \\"Exp\\");\\nexports.setupExperimentationService = function (e) {\\n  const t = e.get(i.Features);\\n  t.setPrefix(r.env.machineId);\\n  t.registerStaticFilters(\\n    (function (e) {\\n      const t = e.get(o.BuildInfo);\\n      return {\\n        [s.Filter.ApplicationVersion]: c(r.version),\\n        [s.Filter.Build]: r.env.appName,\\n        [s.Filter.ClientId]: r.env.machineId,\\n        [s.Filter.ExtensionName]: t.getName(),\\n        [s.Filter.ExtensionVersion]: c(t.getVersion()),\\n        [s.Filter.Language]: r.env.language,\\n        [s.Filter.TargetPopulation]: s.TargetPopulation.Public,\\n      };\\n    })(e)\\n  );\\n  t.registerDynamicFilter(s.Filter.CopilotOverrideEngine, () =>\\n    o.getConfig(e, o.ConfigKey.DebugOverrideEngine)\\n  );\\n};","module-label-9899":"logging-utils","module-label-937":"openai-choices-utils","module-label-893":"copilot_list_doc","module-label-3055563":"getPrompt-main-stuff","module-label-1581":"json-schema-stuff","module-code-2218":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.completionsFromGhostTextResults = undefined;\\nconst r = require(\\"uuid-utils\\"),\\n  o = require(6403),\\n  i = require(\\"ghost-text-provider\\"),\\n  s = require(3286);\\nexports.completionsFromGhostTextResults = function (e, t, n, a, c, l, u) {\\n  const d = e.get(o.LocationFactory),\\n    p = a.lineAt(c);\\n  let h = t.map((e) => {\\n    let t,\\n      o = \\"\\";\\n    if (l) {\\n      e.completion = s.normalizeIndentCharacter(\\n        l,\\n        e.completion,\\n        p.isEmptyOrWhitespace\\n      );\\n    }\\n    if (e.completion.displayNeedsWsOffset && p.isEmptyOrWhitespace)\\n      (t = d.range(d.position(c.line, 0), c)),\\n        (o = e.completion.completionText);\\n    else if (\\n      p.isEmptyOrWhitespace &&\\n      e.completion.completionText.startsWith(p.text)\\n    )\\n      (t = d.range(d.position(c.line, 0), c)),\\n        (o = e.completion.completionText);\\n    else {\\n      const n = a.getWordRangeAtPosition(c);\\n      if (e.isMiddleOfTheLine) {\\n        const n = a.lineAt(c),\\n          r = d.range(d.position(c.line, 0), c),\\n          i = a.getText(r);\\n        (t = e.coversSuffix ? n.range : r), (o = i + e.completion.displayText);\\n      } else if (n) {\\n        const r = a.getText(n);\\n        (t = d.range(n.start, c)), (o = r + e.completion.completionText);\\n      } else {\\n        const n = d.range(d.position(c.line, 0), c);\\n        (t = n), (o = a.getText(n) + e.completion.displayText);\\n      }\\n    }\\n    return {\\n      uuid: r.v4(),\\n      text: o,\\n      range: t,\\n      file: a.uri,\\n      index: e.completion.completionIndex,\\n      telemetry: e.telemetry,\\n      displayText: e.completion.displayText,\\n      position: c,\\n      offset: a.offsetAt(c),\\n      resultType: n,\\n    };\\n  });\\n  if (n === i.ResultType.TypingAsSuggested && undefined !== u) {\\n    const e = h.find((e) => e.index === u);\\n    if (e) {\\n      const t = h.filter((e) => e.index !== u);\\n      h = [e, ...t];\\n    }\\n  }\\n  return h;\\n};","module-label-2990":"copilot_panel","module-label-6333":"telemetry-stuff","module-code-9334":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getGhostText =\\n  exports.completionCache =\\n  exports.ResultType =\\n  exports.ghostTextLogger =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"uuid-utils\\"),\\n  i = require(3076),\\n  s = require(106),\\n  a = require(6932),\\n  c = require(\\"config_stuff\\"),\\n  l = require(9189),\\n  u = require(\\"logging-utils\\"),\\n  d = require(2279),\\n  p = require(\\"openai_conn_utils\\"),\\n  h = require(4419),\\n  f = require(\\"openai-choices-utils\\"),\\n  m = require(6722),\\n  g = require(7727),\\n  _ = require(4969),\\n  y = require(766),\\n  v = require(1006),\\n  b = require(1124),\\n  w = require(\\"telemetry-stuff\\"),\\n  x = require(70),\\n  E = require(6403),\\n  C = require(8965),\\n  S = require(5413),\\n  T = require(750);\\nvar k;\\nlet I, P;\\nasync function A(e, n, r, o, i, s, a) {\\n  var u, p, m;\\n  exports.ghostTextLogger.debug(e, `Getting ${s} from network`);\\n  r = r.extendedBy();\\n  const g = await (async function (e, t) {\\n      const n = await e.get(l.Features).overrideNumGhostCompletions();\\n      return n\\n        ? t.isCycling\\n          ? Math.max(0, 3 - n)\\n          : n\\n        : c.shouldDoParsingTrimming(t.blockMode) && t.multiline\\n        ? c.getConfig(e, c.ConfigKey.InlineSuggestCount)\\n        : t.isCycling\\n        ? 2\\n        : 1;\\n    })(e, n),\\n    _ = f.getTemperatureForSamples(e, g),\\n    y = {\\n      stream: !0,\\n      n: g,\\n      temperature: _,\\n      extra: {\\n        language: n.languageId,\\n        next_indent:\\n          null !== (u = n.indentation.next) && undefined !== u ? u : 0,\\n        trim_by_indentation: c.shouldDoServerTrimming(n.blockMode),\\n      },\\n    };\\n  if (n.multiline) {\\n    y.stop = [\\"\\\\n\\"];\\n  }\\n  if (n.multiline && n.multiLogitBias) {\\n    y.logit_bias = {\\n      50256: -100,\\n    };\\n  }\\n  const v = Date.now(),\\n    b = {\\n      endpoint: \\"completions\\",\\n      uiKind: h.CopilotUiKind.GhostText,\\n      isCycling: JSON.stringify(n.isCycling),\\n      temperature: JSON.stringify(_),\\n      n: JSON.stringify(g),\\n      stop:\\n        null !== (p = JSON.stringify(y.stop)) && undefined !== p ? p : \\"unset\\",\\n      logit_bias: JSON.stringify(\\n        null !== (m = y.logit_bias) && undefined !== m ? m : null\\n      ),\\n    },\\n    E = w.telemetrizePromptLength(n.prompt);\\n  Object.assign(r.properties, b);\\n  Object.assign(r.measurements, E);\\n  try {\\n    const s = {\\n      prompt: n.prompt,\\n      languageId: n.languageId,\\n      repoInfo: n.repoInfo,\\n      ourRequestId: n.ourRequestId,\\n      engineUrl: n.engineURL,\\n      count: g,\\n      uiKind: h.CopilotUiKind.GhostText,\\n      postOptions: y,\\n    };\\n    if (n.delayMs > 0) {\\n      await new Promise((e) => setTimeout(e, n.delayMs));\\n    }\\n    const c = await e\\n      .get(h.OpenAIFetcher)\\n      .fetchAndStreamCompletions(e, s, r, i, o);\\n    return \\"failed\\" === c.type\\n      ? {\\n          type: \\"failed\\",\\n          reason: c.reason,\\n          telemetryData: T.mkBasicResultTelemetry(r),\\n        }\\n      : \\"canceled\\" === c.type\\n      ? (exports.ghostTextLogger.debug(\\n          e,\\n          \\"Cancelled after awaiting fetchCompletions\\"\\n        ),\\n        {\\n          type: \\"canceled\\",\\n          reason: c.reason,\\n          telemetryData: T.mkCanceledResultTelemetry(r),\\n        })\\n      : a(g, v, c.getProcessingTime(), c.choices);\\n  } catch (n) {\\n    if (d.isAbortError(n))\\n      return {\\n        type: \\"canceled\\",\\n        reason: \\"network request aborted\\",\\n        telemetryData: T.mkCanceledResultTelemetry(r, {\\n          cancelledNetworkRequest: !0,\\n        }),\\n      };\\n    exports.ghostTextLogger.error(e, `Error on ghost text request ${n}`);\\n    if ((0, x.shouldFailForDebugPurposes)(e)) throw n;\\n    return {\\n      type: \\"failed\\",\\n      reason: \\"non-abort error on ghost text request\\",\\n      telemetryData: T.mkBasicResultTelemetry(r),\\n    };\\n  }\\n}\\nfunction O(e, t) {\\n  const n = {\\n    ...e,\\n  };\\n  n.completionText = e.completionText.trimEnd();\\n  if (t.forceSingleLine) {\\n    n.completionText = n.completionText.split(\\"\\\\n\\")[0];\\n  }\\n  return n;\\n}\\nexports.ghostTextLogger = new u.Logger(u.LogLevel.INFO, \\"ghostText\\");\\n(function (e) {\\n  e[(e.Network = 0)] = \\"Network\\";\\n  e[(e.Cache = 1)] = \\"Cache\\";\\n  e[(e.TypingAsSuggested = 2)] = \\"TypingAsSuggested\\";\\n  e[(e.Cycling = 3)] = \\"Cycling\\";\\n})((k = exports.ResultType || (exports.ResultType = {})));\\nexports.completionCache = new i.LRUCache(100);\\nconst N = new s.Debouncer();\\nfunction R(e, t) {\\n  I = e;\\n  P = t;\\n}\\nfunction M(e, n, r) {\\n  const o = i.keyForPrompt(n.prompt),\\n    s = exports.completionCache.get(o);\\n  if (s && s.multiline === r.multiline) {\\n    exports.completionCache.put(o, {\\n      multiline: s.multiline,\\n      choices: s.choices.concat(r.choices),\\n    });\\n  } else {\\n    exports.completionCache.put(o, r);\\n  }\\n  exports.ghostTextLogger.debug(\\n    e,\\n    `Appended cached ghost text for key: ${o}, multiline: ${r.multiline}, number of suggestions: ${r.choices.length}`\\n  );\\n}\\nfunction L(e, n) {\\n  const r = exports.completionCache.get(e);\\n  if (r && (!n || r.multiline)) return r.choices;\\n}\\nfunction $(e, t, n) {\\n  if (n.length > 0) {\\n    if (t.startsWith(n))\\n      return {\\n        completionIndex: e,\\n        completionText: t,\\n        displayText: t.substr(n.length),\\n        displayNeedsWsOffset: !1,\\n      };\\n    {\\n      const r = t.substr(0, t.length - t.trimLeft().length);\\n      return n.startsWith(r)\\n        ? {\\n            completionIndex: e,\\n            completionText: t,\\n            displayText: t.trimLeft(),\\n            displayNeedsWsOffset: !0,\\n          }\\n        : {\\n            completionIndex: e,\\n            completionText: t,\\n            displayText: t,\\n            displayNeedsWsOffset: !1,\\n          };\\n    }\\n  }\\n  return {\\n    completionIndex: e,\\n    completionText: t,\\n    displayText: t,\\n    displayNeedsWsOffset: !1,\\n  };\\n}\\nfunction D(e, n) {\\n  const r = n.requestId,\\n    o = {\\n      choiceIndex: n.choiceIndex.toString(),\\n    },\\n    i = {\\n      numTokens: n.numTokens,\\n      compCharLen: n.completionText.length,\\n      numLines: n.completionText.split(\\"\\\\n\\").length,\\n    };\\n  if (n.meanLogProb) {\\n    i.meanLogProb = n.meanLogProb;\\n  }\\n  if (n.meanAlternativeLogProb) {\\n    i.meanAlternativeLogProb = n.meanAlternativeLogProb;\\n  }\\n  const s = n.telemetryData.extendedBy(o, i);\\n  s.extendWithRequestId(r);\\n  s.measurements.confidence = v.ghostTextScoreConfidence(e, s);\\n  s.measurements.quantile = v.ghostTextScoreQuantile(e, s);\\n  exports.ghostTextLogger.debug(\\n    e,\\n    `Extended telemetry for ${n.telemetryData.properties.headerRequestId} with retention confidence ${s.measurements.confidence} (expected as good or better than about ${s.measurements.quantile} of all suggestions)`\\n  );\\n  return s;\\n}\\nfunction F(e, t, n, r, o) {\\n  const i = Date.now() - r,\\n    s = i - o,\\n    a = n.telemetryData.extendedBy(\\n      {},\\n      {\\n        completionCharLen: n.completionText.length,\\n        requestTimeMs: i,\\n        processingTimeMs: o,\\n        deltaMs: s,\\n        meanLogProb: n.meanLogProb || NaN,\\n        meanAlternativeLogProb: n.meanAlternativeLogProb || NaN,\\n        numTokens: n.numTokens,\\n      }\\n    );\\n  a.extendWithRequestId(n.requestId);\\n  w.telemetry(e, `ghostText.${t}`, a);\\n}\\nexports.getGhostText = async function (e, n, s, u, d, f) {\\n  var v, j;\\n  const q = await _.extractPrompt(e, n, s);\\n  if (\\"contextTooShort\\" === q.type) {\\n    exports.ghostTextLogger.debug(e, \\"Breaking, not enough context\\");\\n    return {\\n      type: \\"abortedBeforeIssued\\",\\n      reason: \\"Not enough context\\",\\n    };\\n  }\\n  if (null == f ? undefined : f.isCancellationRequested) {\\n    exports.ghostTextLogger.info(e, \\"Cancelled after extractPrompt\\");\\n    return {\\n      type: \\"abortedBeforeIssued\\",\\n      reason: \\"Cancelled after extractPrompt\\",\\n    };\\n  }\\n  const B = (function (e, t) {\\n    const n =\\n        ((o = t), 0 != e.lineAt(o).text.substr(o.character).trim().length),\\n      r = (function (e, t) {\\n        const n = t.lineAt(e).text.substr(e.character).trim();\\n        return /^\\\\s*[)}\\\\]\\"\'`]*\\\\s*[:{;,]?\\\\s*$/.test(n);\\n      })(t, e);\\n    var o;\\n    if (!n || r) return n && r;\\n  })(n, s);\\n  if (undefined === B) {\\n    exports.ghostTextLogger.debug(e, \\"Breaking, invalid middle of the line\\");\\n    return {\\n      type: \\"abortedBeforeIssued\\",\\n      reason: \\"Invalid middle of the line\\",\\n    };\\n  }\\n  const U = e.get(m.StatusReporter),\\n    H = e.get(E.LocationFactory),\\n    z = await (async function (e, t, n, o, i, s) {\\n      const a = await e.get(c.BlockModeConfig).forLanguage(e, t.languageId);\\n      switch (a) {\\n        case c.BlockMode.Server:\\n          return {\\n            blockMode: c.BlockMode.Server,\\n            requestMultiline: !0,\\n            isCyclingRequest: i,\\n            finishedCb: async (e) => {},\\n          };\\n        case c.BlockMode.Parsing:\\n        case c.BlockMode.ParsingAndServer:\\n        default: {\\n          const c = await (async function (e, t, n, o) {\\n            if (t.lineCount >= 8e3)\\n              w.telemetry(\\n                e,\\n                \\"ghostText.longFileMultilineSkip\\",\\n                w.TelemetryData.createAndMarkAsIssued({\\n                  languageId: t.languageId,\\n                  lineCount: String(t.lineCount),\\n                  currentLine: String(n.line),\\n                })\\n              );\\n            else {\\n              if (!o && r.isSupportedLanguageId(t.languageId))\\n                return await g.isEmptyBlockStart(t, n);\\n              if (o && r.isSupportedLanguageId(t.languageId))\\n                return (\\n                  (await g.isEmptyBlockStart(t, n)) ||\\n                  (await g.isEmptyBlockStart(t, t.lineAt(n).range.end))\\n                );\\n            }\\n            return !1;\\n          })(e, t, n, s);\\n          return c\\n            ? {\\n                blockMode: a,\\n                requestMultiline: !0,\\n                isCyclingRequest: !1,\\n                finishedCb: async (r) => {\\n                  let i;\\n                  i =\\n                    o.trailingWs.length > 0 &&\\n                    !o.prompt.prefix.endsWith(o.trailingWs)\\n                      ? e\\n                          .get(E.LocationFactory)\\n                          .position(\\n                            n.line,\\n                            Math.max(n.character - o.trailingWs.length, 0)\\n                          )\\n                      : n;\\n                  return g.isBlockBodyFinished(e, t, i, r);\\n                },\\n              }\\n            : {\\n                blockMode: a,\\n                requestMultiline: !1,\\n                isCyclingRequest: i,\\n                finishedCb: async (e) => {},\\n              };\\n        }\\n      }\\n    })(e, n, s, q, u, B);\\n  if (null == f ? undefined : f.isCancellationRequested) {\\n    exports.ghostTextLogger.info(e, \\"Cancelled after requestMultiline\\");\\n    return {\\n      type: \\"abortedBeforeIssued\\",\\n      reason: \\"Cancelled after requestMultiline\\",\\n    };\\n  }\\n  const [G] = _.trimLastLine(n.getText(H.range(H.position(0, 0), s)));\\n  let V = (function (e, n, r, o) {\\n    const s = (function (e, n, r) {\\n      if (!I || !P || !n.startsWith(I)) return;\\n      const o = L(P, r);\\n      if (!o) return;\\n      const i = n.substring(I.length);\\n      exports.ghostTextLogger.debug(\\n        e,\\n        `Getting completions for user-typing flow - remaining prefix: ${i}`\\n      );\\n      const s = [];\\n      o.forEach((e) => {\\n        const t = O(e, {\\n          forceSingleLine: !1,\\n        });\\n        if (t.completionText.startsWith(i)) {\\n          t.completionText = t.completionText.substring(i.length);\\n          s.push(t);\\n        }\\n      });\\n      return s;\\n    })(e, n, o);\\n    if (s && s.length > 0) return [s, k.TypingAsSuggested];\\n    const a = (function (e, n, r, o) {\\n      const s = i.keyForPrompt(r);\\n      exports.ghostTextLogger.debug(\\n        e,\\n        `Trying to get completions from cache for key: ${s}`\\n      );\\n      const a = L(s, o);\\n      if (a) {\\n        exports.ghostTextLogger.debug(\\n          e,\\n          `Got completions from cache for key: ${s}`\\n        );\\n        const r = [];\\n        a.forEach((e) => {\\n          const t = O(e, {\\n            forceSingleLine: !o,\\n          });\\n          r.push(t);\\n        });\\n        const i = r.filter((e) => e.completionText);\\n        if (i.length > 0) {\\n          R(n, s);\\n        }\\n        return i;\\n      }\\n    })(e, n, r, o);\\n    return a && a.length > 0 ? [a, k.Cache] : undefined;\\n  })(e, G, q.prompt, z.requestMultiline);\\n  const W = o.v4(),\\n    K = y.extractRepoInfoInBackground(e, n.fileName),\\n    J = await p.getEngineURL(\\n      e,\\n      y.tryGetGitHubNWO(K),\\n      n.languageId,\\n      y.getDogFood(K),\\n      await y.getUserKind(e),\\n      d\\n    ),\\n    X = await e\\n      .get(l.Features)\\n      .beforeRequestWaitMs(y.tryGetGitHubNWO(K) || \\"\\", n.languageId),\\n    Q = await e\\n      .get(l.Features)\\n      .multiLogitBias(y.tryGetGitHubNWO(K) || \\"\\", n.languageId),\\n    Y = {\\n      blockMode: z.blockMode,\\n      languageId: n.languageId,\\n      repoInfo: K,\\n      engineURL: J,\\n      ourRequestId: W,\\n      prefix: G,\\n      prompt: q.prompt,\\n      multiline: z.requestMultiline,\\n      indentation: g.contextIndentation(n, s),\\n      isCycling: u,\\n      delayMs: X,\\n      multiLogitBias: Q,\\n    },\\n    Z = await e.get(l.Features).debouncePredict(),\\n    ee = await e.get(l.Features).contextualFilterEnable(),\\n    te = await e.get(l.Features).contextualFilterAcceptThreshold();\\n  let ne = !1;\\n  if (Z || ee) {\\n    ne = !0;\\n  }\\n  const re = (function (e, t, n, r, o, i, s) {\\n    const a = e.get(E.LocationFactory),\\n      c = t.lineAt(r.line),\\n      l = t.getText(a.range(c.range.start, r)),\\n      u = t.getText(a.range(r, c.range.end)),\\n      d = {\\n        languageId: t.languageId,\\n        beforeCursorWhitespace: JSON.stringify(\\"\\" === l.trim()),\\n        afterCursorWhitespace: JSON.stringify(\\"\\" === u.trim()),\\n      },\\n      p = {\\n        ...w.telemetrizePromptLength(o.prompt),\\n        promptEndPos: t.offsetAt(r),\\n        documentLength: t.getText().length,\\n        delayMs: n.delayMs,\\n      },\\n      f = i.extendedBy(d, p);\\n    f.properties.promptChoices = JSON.stringify(o.promptChoices, (e, t) =>\\n      t instanceof Map\\n        ? Array.from(t.entries()).reduce(\\n            (e, [t, n]) => ({\\n              ...e,\\n              [t]: n,\\n            }),\\n            {}\\n          )\\n        : t\\n    );\\n    f.properties.promptBackground = JSON.stringify(o.promptBackground, (e, t) =>\\n      t instanceof Map ? Array.from(t.values()) : t\\n    );\\n    f.measurements.promptComputeTimeMs = o.computeTimeMs;\\n    if (s) {\\n      f.measurements.contextualFilterScore = C.contextualFilterScore(\\n        e,\\n        f,\\n        o.prompt\\n      );\\n    }\\n    const m = n.repoInfo;\\n    f.properties.gitRepoInformation =\\n      undefined === m\\n        ? \\"unavailable\\"\\n        : m === y.ComputationStatus.PENDING\\n        ? \\"pending\\"\\n        : \\"available\\";\\n    if (undefined !== m && m !== y.ComputationStatus.PENDING) {\\n      f.properties.gitRepoUrl = m.url;\\n      f.properties.gitRepoHost = m.hostname;\\n      f.properties.gitRepoOwner = m.owner;\\n      f.properties.gitRepoName = m.repo;\\n      f.properties.gitRepoPath = m.pathname;\\n    }\\n    f.properties.engineName = h.extractEngineName(e, n.engineURL);\\n    f.properties.isMultiline = JSON.stringify(n.multiline);\\n    f.properties.blockMode = n.blockMode;\\n    f.properties.isCycling = JSON.stringify(n.isCycling);\\n    f.properties.headerRequestId = n.ourRequestId;\\n    w.telemetry(e, \\"ghostText.issued\\", f);\\n    return f;\\n  })(e, n, Y, s, q, d, ne);\\n  if (\\n    (z.isCyclingRequest &&\\n      (null !== (v = null == V ? undefined : V[0].length) && undefined !== v\\n        ? v\\n        : 0) > 1) ||\\n    (!z.isCyclingRequest && undefined !== V)\\n  )\\n    exports.ghostTextLogger.info(e, \\"Found inline suggestions locally\\");\\n  else {\\n    if (null == U) {\\n      U.setProgress();\\n    }\\n    if (z.isCyclingRequest) {\\n      const n = await (async function (e, n, r, o, i) {\\n        return A(e, n, r, o, i, \\"all completions\\", async (i, s, a, c) => {\\n          const l = [];\\n          for await (const n of c) {\\n            if (null == o ? void 0 : o.isCancellationRequested)\\n              return (\\n                exports.ghostTextLogger.debug(\\n                  e,\\n                  \\"Cancelled after awaiting choices iterator\\"\\n                ),\\n                {\\n                  type: \\"canceled\\",\\n                  reason: \\"after awaiting choices iterator\\",\\n                  telemetryData: (0, T.mkCanceledResultTelemetry)(r),\\n                }\\n              );\\n            if (n.completionText.trimEnd()) {\\n              if (\\n                -1 !==\\n                l.findIndex(\\n                  (e) => e.completionText.trim() === n.completionText.trim()\\n                )\\n              )\\n                continue;\\n              l.push(n);\\n            }\\n          }\\n          return (\\n            l.length > 0 &&\\n              (M(e, n, {\\n                multiline: n.multiline,\\n                choices: l,\\n              }),\\n              F(e, \\"cyclingPerformance\\", l[0], s, a)),\\n            {\\n              type: \\"success\\",\\n              value: l,\\n              telemetryData: (0, T.mkBasicResultTelemetry)(r),\\n              telemetryBlob: r,\\n            }\\n          );\\n        });\\n      })(e, Y, re, f, z.finishedCb);\\n      if (\\"success\\" === n.type) {\\n        const e =\\n          null !== (j = null == V ? void 0 : V[0]) && void 0 !== j ? j : [];\\n        n.value.forEach((t) => {\\n          -1 ===\\n            e.findIndex(\\n              (e) => e.completionText.trim() === t.completionText.trim()\\n            ) && e.push(t);\\n        }),\\n          (V = [e, k.Cycling]);\\n      } else if (void 0 === V) return null == U || U.removeProgress(), n;\\n    } else {\\n      const n = await (0, S.getDebounceLimit)(e, re);\\n      try {\\n        await N.debounce(n);\\n      } catch {\\n        return {\\n          type: \\"canceled\\",\\n          reason: \\"by debouncer\\",\\n          telemetryData: (0, T.mkCanceledResultTelemetry)(re),\\n        };\\n      }\\n      if (null == f ? void 0 : f.isCancellationRequested)\\n        return (\\n          exports.ghostTextLogger.info(e, \\"Cancelled during debounce\\"),\\n          {\\n            type: \\"canceled\\",\\n            reason: \\"during debounce\\",\\n            telemetryData: (0, T.mkCanceledResultTelemetry)(re),\\n          }\\n        );\\n      if (\\n        ee &&\\n        re.measurements.contextualFilterScore &&\\n        re.measurements.contextualFilterScore < te / 100\\n      )\\n        return (\\n          exports.ghostTextLogger.info(e, \\"Cancelled by contextual filter\\"),\\n          {\\n            type: \\"canceled\\",\\n            reason: \\"contextualFilterScore below threshold\\",\\n            telemetryData: (0, T.mkCanceledResultTelemetry)(re),\\n          }\\n        );\\n      const r = await (async function (e, n, r, o, s) {\\n        return A(e, n, r, o, s, \\"completions\\", async (s, a, c, l) => {\\n          const u = l[Symbol.asyncIterator](),\\n            d = await u.next();\\n          if (d.done)\\n            return (\\n              exports.ghostTextLogger.debug(e, \\"All choices redacted\\"),\\n              {\\n                type: \\"empty\\",\\n                reason: \\"all choices redacted\\",\\n                telemetryData: (0, T.mkBasicResultTelemetry)(r),\\n              }\\n            );\\n          if (null == o ? void 0 : o.isCancellationRequested)\\n            return (\\n              exports.ghostTextLogger.debug(\\n                e,\\n                \\"Cancelled after awaiting redactedChoices iterator\\"\\n              ),\\n              {\\n                type: \\"canceled\\",\\n                reason: \\"after awaiting redactedChoices iterator\\",\\n                telemetryData: (0, T.mkCanceledResultTelemetry)(r),\\n              }\\n            );\\n          const p = d.value;\\n          if (void 0 === p)\\n            return (\\n              exports.ghostTextLogger.debug(\\n                e,\\n                \\"Got undefined choice from redactedChoices iterator\\"\\n              ),\\n              {\\n                type: \\"empty\\",\\n                reason: \\"got undefined choice from redactedChoices iterator\\",\\n                telemetryData: (0, T.mkBasicResultTelemetry)(r),\\n              }\\n            );\\n          F(e, \\"performance\\", p, a, c);\\n          const h = s - 1;\\n          exports.ghostTextLogger.debug(\\n            e,\\n            `Awaited first result, id:  ${p.choiceIndex}`\\n          ),\\n            (function (e, n, r) {\\n              const o = (0, i.keyForPrompt)(n.prompt);\\n              R(n.prefix, o),\\n                exports.completionCache.put(o, r),\\n                exports.ghostTextLogger.debug(\\n                  e,\\n                  `Cached ghost text for key: ${o}, multiline: ${r.multiline}, number of suggestions: ${r.choices.length}`\\n                );\\n            })(e, n, {\\n              multiline: n.multiline,\\n              choices: [p],\\n            });\\n          const f = [];\\n          for (let e = 0; e < h; e++) f.push(u.next());\\n          const m = Promise.all(f).then((r) => {\\n            exports.ghostTextLogger.debug(\\n              e,\\n              `Awaited remaining results, number of results: ${r.length}`\\n            );\\n            const o = [];\\n            for (const n of r) {\\n              const r = n.value;\\n              if (\\n                void 0 !== r &&\\n                (exports.ghostTextLogger.info(\\n                  e,\\n                  `GhostText later completion: [${r.completionText}]`\\n                ),\\n                r.completionText.trimEnd())\\n              ) {\\n                if (\\n                  -1 !==\\n                  o.findIndex(\\n                    (e) => e.completionText.trim() === r.completionText.trim()\\n                  )\\n                )\\n                  continue;\\n                if (r.completionText.trim() === p.completionText.trim())\\n                  continue;\\n                o.push(r);\\n              }\\n            }\\n            o.length > 0 &&\\n              M(e, n, {\\n                multiline: n.multiline,\\n                choices: o,\\n              });\\n          });\\n          return (\\n            (0, x.isRunningInTest)(e) && (await m),\\n            {\\n              type: \\"success\\",\\n              value: O(d.value, {\\n                forceSingleLine: !1,\\n              }),\\n              telemetryData: (0, T.mkBasicResultTelemetry)(r),\\n              telemetryBlob: r,\\n            }\\n          );\\n        });\\n      })(e, Y, re, f, z.finishedCb);\\n      if (\\"success\\" !== r.type) return null == U || U.removeProgress(), r;\\n      V = [[r.value], k.Network];\\n    }\\n    if (null == U) {\\n      U.removeProgress();\\n    }\\n  }\\n  if (undefined === V)\\n    return {\\n      type: \\"failed\\",\\n      reason: \\"internal error: choices should be defined after network call\\",\\n      telemetryData: T.mkBasicResultTelemetry(re),\\n    };\\n  const [oe, ie] = V,\\n    se = a.asyncIterableMapFilter(a.asyncIterableFromArray(oe), async (r) =>\\n      b.postProcessChoice(e, \\"ghostText\\", n, s, r, B, exports.ghostTextLogger)\\n    ),\\n    ae = [];\\n  for await (const r of se) {\\n    const o = B && b.checkSuffix(n, s, r);\\n    if (null == f ? undefined : f.isCancellationRequested) {\\n      exports.ghostTextLogger.info(\\n        e,\\n        \\"Cancelled after post processing completions\\"\\n      );\\n      return {\\n        type: \\"canceled\\",\\n        reason: \\"after post processing completions\\",\\n        telemetryData: T.mkCanceledResultTelemetry(re),\\n      };\\n    }\\n    const i = D(e, r),\\n      a = {\\n        completion: $(r.choiceIndex, r.completionText, q.trailingWs),\\n        telemetry: i,\\n        isMiddleOfTheLine: B,\\n        coversSuffix: o,\\n      };\\n    ae.push(a);\\n  }\\n  return {\\n    type: \\"success\\",\\n    value: [ae, ie],\\n    telemetryData: T.mkBasicResultTelemetry(re),\\n    telemetryBlob: re,\\n  };\\n};","module-code-766":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ComputationStatus =\\n  exports.getRepoUrlFromConfigText =\\n  exports.parseRepoUrl =\\n  exports.extractRepoInfoForTesting =\\n  exports.extractRepoInfoInBackground =\\n  exports.tryGetGitHubNWO =\\n  exports.getDogFood =\\n  exports.Dogfood =\\n  exports.getUserKind =\\n  exports.isNotRepo =\\n  exports.isRepoInfo =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"git-url-parser\\"),\\n  i = require(\\"path\\"),\\n  s = require(\\"copilot-github-auth-stuff\\"),\\n  a = require(3076);\\nvar c;\\nfunction tryGetGitHubNWO(e) {\\n  if (undefined !== e && e !== f.PENDING)\\n    return \\"github.com\\" === e.hostname ? e.owner + \\"/\\" + e.repo : undefined;\\n}\\nexports.isRepoInfo = function (e) {\\n  return undefined !== e && e !== f.PENDING;\\n};\\nexports.isNotRepo = function (e) {\\n  return undefined === e;\\n};\\nexports.getUserKind = async function (e) {\\n  var t, n;\\n  const r =\\n    null !==\\n      (t = (await e.get(s.CopilotTokenManager).getCopilotToken(e, !1))\\n        .organization_list) && undefined !== t\\n      ? t\\n      : [];\\n  return null !==\\n    (n = [\\n      \\"a5db0bcaae94032fe715fb34a5e4bce2\\",\\n      \\"4535c7beffc844b46bb1ed4aa04d759a\\",\\n    ].find((e) => r.includes(e))) && undefined !== n\\n    ? n\\n    : \\"\\";\\n};\\n(function (e) {\\n  e.GITHUB = \\"github\\";\\n  e.MICROSOFT = \\"microsoft\\";\\n  e.UNKNOWN = \\"\\";\\n})((c = exports.Dogfood || (exports.Dogfood = {})));\\nexports.getDogFood = function (e) {\\n  return undefined === e || e === f.PENDING\\n    ? c.UNKNOWN\\n    : \\"github/github\\" === tryGetGitHubNWO(e)\\n    ? c.GITHUB\\n    : \\"ssh.dev.azure.com\\" === e.hostname ||\\n      \\"vs-ssh.visualstudio.com\\" === e.hostname ||\\n      \\"dev.azure.com\\" === e.hostname ||\\n      \\"domoreexp.visualstudio.com\\" === e.hostname ||\\n      \\"office.visualstudio.com\\" === e.hostname\\n    ? c.MICROSOFT\\n    : c.UNKNOWN;\\n};\\nexports.tryGetGitHubNWO = tryGetGitHubNWO;\\nexports.extractRepoInfoInBackground = function (e, t) {\\n  if (!t) return;\\n  const n = i.dirname(t);\\n  return u(e, n);\\n};\\nconst u = (function (e, t) {\\n  const n = new a.LRUCache(1e4),\\n    r = new Set();\\n  return (t, ...o) => {\\n    const i = JSON.stringify(o),\\n      s = n.get(i);\\n    if (s) return s.result;\\n    if (r.has(i)) return f.PENDING;\\n    const a = e(t, ...o);\\n    r.add(i);\\n    a.then((e) => {\\n      n.put(i, new m(e));\\n      r.delete(i);\\n    });\\n    return f.PENDING;\\n  };\\n})(d);\\nasync function d(e, t) {\\n  var n;\\n  const o = await (async function (e, t) {\\n    let n = t + \\"_add_to_make_longer\\";\\n    const o = e.get(r.FileSystem);\\n    for (; t.length > 1 && t.length < n.length; ) {\\n      const e = i.join(t, \\".git\\", \\"config\\");\\n      let r = !1;\\n      try {\\n        await o.stat(e);\\n        r = !0;\\n      } catch (e) {\\n        r = !1;\\n      }\\n      if (r) return t;\\n      n = t;\\n      t = i.dirname(t);\\n    }\\n  })(e, t);\\n  if (!o) return;\\n  const s = e.get(r.FileSystem),\\n    a = i.join(o, \\".git\\", \\"config\\"),\\n    c =\\n      null !==\\n        (n = getRepoUrlFromConfigText((await s.readFile(a)).toString())) &&\\n      undefined !== n\\n        ? n\\n        : \\"\\",\\n    l = parseRepoUrl(c);\\n  return undefined === l\\n    ? {\\n        baseFolder: o,\\n        url: c,\\n        hostname: \\"\\",\\n        owner: \\"\\",\\n        repo: \\"\\",\\n        pathname: \\"\\",\\n      }\\n    : {\\n        baseFolder: o,\\n        url: c,\\n        ...l,\\n      };\\n}\\nfunction parseRepoUrl(e) {\\n  let t = {};\\n  try {\\n    t = o(e);\\n    if (\\"\\" == t.host || \\"\\" == t.owner || \\"\\" == t.name || \\"\\" == t.pathname)\\n      return;\\n  } catch (e) {\\n    return;\\n  }\\n  return {\\n    hostname: t.host,\\n    owner: t.owner,\\n    repo: t.name,\\n    pathname: t.pathname,\\n  };\\n}\\nfunction getRepoUrlFromConfigText(e) {\\n  var t;\\n  const n = /^\\\\s*\\\\[\\\\s*remote\\\\s+\\"((\\\\\\\\\\\\\\\\|\\\\\\\\\\"|[^\\\\\\\\\\"])+)\\"/,\\n    r = /^\\\\s*\\\\[remote.([^\\"\\\\s]+)/,\\n    o = /^\\\\s*url\\\\s*=\\\\s*([^\\\\s#;]+)/,\\n    i = /^\\\\s*\\\\[/;\\n  let s,\\n    a,\\n    c = !1;\\n  for (const l of e.split(\\"\\\\n\\"))\\n    if (c && undefined !== s) {\\n      s += l;\\n      if (l.endsWith(\\"\\\\\\\\\\")) s = s.substring(0, s.length - 1);\\n      else if (((c = !1), \\"origin\\" === a)) return s;\\n    } else {\\n      const e = null !== (t = l.match(n)) && undefined !== t ? t : l.match(r);\\n      if (e) a = e[1];\\n      else if (l.match(i)) a = undefined;\\n      else {\\n        if (s && \\"origin\\" !== a) continue;\\n        {\\n          const e = l.match(o);\\n          if (e) {\\n            s = e[1];\\n            if (s.endsWith(\\"\\\\\\\\\\")) {\\n              s = s.substring(0, s.length - 1);\\n              c = !0;\\n            } else if (\\"origin\\" === a) return s;\\n          }\\n        }\\n      }\\n    }\\n  return s;\\n}\\nvar f;\\nexports.extractRepoInfoForTesting = async function (e, t) {\\n  return d(e, t);\\n};\\nexports.parseRepoUrl = parseRepoUrl;\\nexports.getRepoUrlFromConfigText = getRepoUrlFromConfigText;\\n(function (e) {\\n  e[(e.PENDING = 0)] = \\"PENDING\\";\\n})((f = exports.ComputationStatus || (exports.ComputationStatus = {})));\\nclass m {\\n  constructor(e) {\\n    this.result = e;\\n  }\\n}","module-code-7254":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.CopilotStatusBar = undefined;\\nconst r = require(9496),\\n  o = require(106),\\n  i = require(\\"config_stuff\\"),\\n  s = require(\\"telemetry-stuff\\"),\\n  a = require(3060);\\nexports.CopilotStatusBar = class {\\n  constructor(e) {\\n    this.ctx = e;\\n    this.showingMessage = !1;\\n    this.status = \\"Normal\\";\\n    this.errorMessage = \\"\\";\\n    this.disabledColor = new r.ThemeColor(\\"statusBarItem.warningBackground\\");\\n    this.delayedUpdateDisplay = o.debounce(100, () => {\\n      this.updateDisplay();\\n    });\\n    this.enabled = this.checkEnabledForLanguage();\\n    this.item = r.window.createStatusBarItem(r.StatusBarAlignment.Right, 0);\\n    this.updateDisplay();\\n    this.item.show();\\n    r.window.onDidChangeActiveTextEditor(() => {\\n      this.updateStatusBarIndicator();\\n    });\\n    r.workspace.onDidCloseTextDocument(() => {\\n      this.updateStatusBarIndicator();\\n    });\\n    r.workspace.onDidOpenTextDocument(() => {\\n      this.updateStatusBarIndicator();\\n    });\\n  }\\n  updateStatusBarIndicator() {\\n    this.enabled = this.checkEnabledForLanguage();\\n    this.updateDisplay();\\n  }\\n  checkEnabledForLanguage() {\\n    return i.getEnabledConfig(this.ctx) || !1;\\n  }\\n  updateDisplay() {\\n    switch (this.status) {\\n      case \\"Error\\":\\n        this.item.text = \\"$(copilot-notconnected)\\";\\n        this.item.command = a.CMDShowActivationErrors;\\n        this.item.tooltip = \\"Copilot activation failed\\";\\n        break;\\n      case \\"Warning\\":\\n        this.item.text = \\"$(copilot-warning)\\";\\n        this.item.command = undefined;\\n        this.item.tooltip = \\"Copilot is encountering temporary issues\\";\\n        break;\\n      case \\"InProgress\\":\\n        this.item.text = \\"$(loading~spin)\\";\\n        break;\\n      case \\"Normal\\":\\n        this.item.text = \\"$(copilot-logo)\\";\\n        this.item.command = a.CMDToggleCopilot;\\n        this.item.tooltip = this.enabled\\n          ? \\"Deactivate Copilot\\"\\n          : \\"Activate Copilot\\";\\n        this.item.backgroundColor = this.enabled\\n          ? undefined\\n          : this.disabledColor;\\n    }\\n  }\\n  getStatusBarItem() {\\n    return this.item;\\n  }\\n  setProgress() {\\n    if (\\"Error\\" !== this.status) {\\n      this.status = \\"InProgress\\";\\n      this.delayedUpdateDisplay();\\n    }\\n  }\\n  removeProgress() {\\n    if (\\"Error\\" !== this.status && \\"Warning\\" !== this.status) {\\n      this.status = \\"Normal\\";\\n      this.delayedUpdateDisplay();\\n    }\\n  }\\n  setWarning() {\\n    if (\\"Error\\" !== this.status) {\\n      this.status = \\"Warning\\";\\n      this.updateDisplay();\\n    }\\n  }\\n  setError(e, t) {\\n    this.status = \\"Error\\";\\n    this.errorMessage = e;\\n    this.errorRetry = t;\\n    this.updateDisplay();\\n  }\\n  forceNormal() {\\n    this.status = \\"Normal\\";\\n    this.errorMessage = \\"\\";\\n    this.errorRetry = undefined;\\n    this.updateDisplay();\\n  }\\n  toggleStatusBar() {\\n    var e;\\n    const t = this.ctx.get(i.ConfigProvider),\\n      n = this.enabled,\\n      o =\\n        null === (e = r.window.activeTextEditor) || undefined === e\\n          ? undefined\\n          : e.document.languageId,\\n      a = \\"editor.action.inlineSuggest.hide\\";\\n    if (this.showingMessage) return;\\n    const c = s.TelemetryData.createAndMarkAsIssued({\\n      languageId: o || \\"*\\",\\n    });\\n    if (i.getEnabledConfig(this.ctx, \\"*\\") == i.getEnabledConfig(this.ctx, o)) {\\n      this.showingMessage = !0;\\n      setTimeout(() => {\\n        this.showingMessage = !1;\\n      }, 15e3);\\n      const e = n ? \\"Disable\\" : \\"Enable\\",\\n        i = `${e} Globally`,\\n        l = `${e} for ${o}`,\\n        u = o ? [i, l] : [i];\\n      r.window\\n        .showInformationMessage(\\n          `Would you like to ${n ? \\"disable\\" : \\"enable\\"} Copilot?`,\\n          ...u\\n        )\\n        .then((e) => {\\n          const l = e === i;\\n          this.showingMessage = !1;\\n          if (void 0 === e)\\n            return void (0, s.telemetry)(this.ctx, \\"statusBar.cancelToggle\\");\\n          s.telemetry(\\n            this.ctx,\\n            \\"statusBar\\" + (l ? \\".global\\" : \\".language\\") + (n ? \\"Off\\" : \\"On\\"),\\n            c\\n          );\\n          if (n) {\\n            r.commands.executeCommand(a);\\n          }\\n          const u = l ? \\"*\\" : o;\\n          t.updateEnabledConfig(this.ctx, u, !n).then(() => {\\n            this.enabled = !n;\\n            this.updateDisplay();\\n          });\\n        });\\n    } else {\\n      s.telemetry(this.ctx, \\"statusBar.language\\" + (n ? \\"Off\\" : \\"On\\"), c);\\n      if (n) {\\n        r.commands.executeCommand(a);\\n      }\\n      t.updateEnabledConfig(this.ctx, o || \\"*\\", !n).then(() => {\\n        this.enabled = !n;\\n        this.updateDisplay();\\n      });\\n    }\\n    this.updateDisplay();\\n  }\\n  showActivationErrors(e) {\\n    if (this.showingMessage) return;\\n    this.showingMessage = !0;\\n    const t = [\\"Show output log\\"];\\n    if (this.errorRetry) {\\n      t.push(\\"Retry\\");\\n    }\\n    r.window.showWarningMessage(this.errorMessage, ...t).then((t) => {\\n      this.showingMessage = !1;\\n      if (\\"Show Output log\\" === t) {\\n        e.show();\\n      }\\n      if (\\"Retry\\" === t && this.errorRetry) {\\n        this.errorRetry();\\n      }\\n    });\\n  }\\n};","module-code-937":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getTemperatureForSamples =\\n  exports.calculateMeanAlternativeLogProb =\\n  exports.calculateMeanLogProb =\\n  exports.cleanupIndentChoices =\\n  exports.convertToAPIChoice =\\n  exports.DEFAULT_CHARACTER_MULTIPLIER =\\n  exports.MAX_PROMPT_LENGTH =\\n  exports.OpenAIFetcher =\\n  exports.LiveOpenAIFetcher =\\n  exports.getRequestId =\\n  exports.CopilotUiKind =\\n    undefined;\\nconst r = require(\\"config_stuff\\"),\\n  o = require(\\"logging-utils\\"),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(70);\\nvar a = require(4419);\\nfunction calculateMeanLogProb(e, t) {\\n  var n;\\n  if (\\n    null === (n = null == t ? undefined : t.logprobs) || undefined === n\\n      ? undefined\\n      : n.token_logprobs\\n  )\\n    try {\\n      let e = 0,\\n        n = 0,\\n        r = 50;\\n      for (\\n        let o = 0;\\n        o < t.logprobs.token_logprobs.length - 1 && r > 0;\\n        o++, r--\\n      ) {\\n        e += t.logprobs.token_logprobs[o];\\n        n += 1;\\n      }\\n      return n > 0 ? e / n : undefined;\\n    } catch (t) {\\n      o.logger.error(e, `Error calculating mean prob: ${t}`);\\n    }\\n}\\nfunction calculateMeanAlternativeLogProb(e, t) {\\n  var n;\\n  if (\\n    null === (n = null == t ? undefined : t.logprobs) || undefined === n\\n      ? undefined\\n      : n.top_logprobs\\n  )\\n    try {\\n      let e = 0,\\n        n = 0,\\n        r = 50;\\n      for (\\n        let o = 0;\\n        o < t.logprobs.token_logprobs.length - 1 && r > 0;\\n        o++, r--\\n      ) {\\n        const r = {\\n          ...t.logprobs.top_logprobs[o],\\n        };\\n        delete r[t.logprobs.tokens[o]];\\n        e += Math.max(...Object.values(r));\\n        n += 1;\\n      }\\n      return n > 0 ? e / n : undefined;\\n    } catch (t) {\\n      o.logger.error(e, `Error calculating mean prob: ${t}`);\\n    }\\n}\\nexports.CopilotUiKind = a.CopilotUiKind;\\nexports.getRequestId = a.getRequestId;\\nexports.LiveOpenAIFetcher = a.LiveOpenAIFetcher;\\nexports.OpenAIFetcher = a.OpenAIFetcher;\\nexports.MAX_PROMPT_LENGTH = 1500;\\nexports.DEFAULT_CHARACTER_MULTIPLIER = 3;\\nexports.convertToAPIChoice = function (e, t, n, r, o, s, a, u) {\\n  i.logEngineCompletion(e, t, n, o, r);\\n  return {\\n    completionText: t,\\n    meanLogProb: calculateMeanLogProb(e, n),\\n    meanAlternativeLogProb: calculateMeanAlternativeLogProb(e, n),\\n    choiceIndex: r,\\n    requestId: o,\\n    modelInfo: u,\\n    blockFinished: s,\\n    tokens: n.tokens,\\n    numTokens: n.tokens.length,\\n    telemetryData: a,\\n  };\\n};\\nexports.cleanupIndentChoices = async function* (e, t) {\\n  for await (const n of e) {\\n    const e = {\\n        ...n,\\n      },\\n      r = e.completionText.split(\\"\\\\n\\");\\n    for (let e = 0; e < r.length; ++e) {\\n      const n = r[e].trimLeft();\\n      r[e] = \\"\\" === n ? n : t + n;\\n    }\\n    e.completionText = r.join(\\"\\\\n\\");\\n    yield e;\\n  }\\n};\\nexports.calculateMeanLogProb = calculateMeanLogProb;\\nexports.calculateMeanAlternativeLogProb = calculateMeanAlternativeLogProb;\\nexports.getTemperatureForSamples = function (e, t) {\\n  if (s.isRunningInTest(e)) return 0;\\n  const n = parseFloat(r.getConfig(e, r.ConfigKey.Temperature));\\n  return n >= 0 && n <= 1 ? n : t <= 1 ? 0 : t < 10 ? 0.2 : t < 20 ? 0.4 : 0.8;\\n};","module-code-2388":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.launchSolutions = exports.normalizeCompletionText = undefined;\\nconst r = require(\\"uuid-utils\\"),\\n  o = require(6932),\\n  i = require(\\"config_stuff\\"),\\n  s = require(256),\\n  a = require(\\"logging-utils\\"),\\n  c = require(\\"openai_conn_utils\\"),\\n  l = require(\\"openai-choices-utils\\"),\\n  u = require(6722),\\n  d = require(7727),\\n  p = require(4969),\\n  h = require(2533),\\n  f = require(766),\\n  m = require(1124),\\n  g = require(\\"telemetry-stuff\\"),\\n  _ = require(6403),\\n  y = new a.Logger(a.LogLevel.INFO, \\"solutions\\");\\nfunction v(e, t, n, r) {\\n  return async (o) => {\\n    if (r instanceof Array) {\\n      const [i, s] = r;\\n      return d.isBlockBodyFinishedWithPrefix(e, t, n, o, s);\\n    }\\n    return d.isBlockBodyFinished(e, t, n, o);\\n  };\\n}\\nasync function b(e, t, n) {\\n  if (t.isCancellationRequested) {\\n    e.removeProgress();\\n    return {\\n      status: \\"FinishedWithError\\",\\n      error: \\"Cancelled\\",\\n    };\\n  }\\n  const r = await n.next();\\n  return !0 === r.done\\n    ? (e.removeProgress(),\\n      {\\n        status: \\"FinishedNormally\\",\\n      })\\n    : {\\n        status: \\"Solution\\",\\n        solution: r.value,\\n        next: b(e, t, n),\\n      };\\n}\\nexports.normalizeCompletionText = function (e) {\\n  return e.replace(/\\\\s+/g, \\"\\");\\n};\\nexports.launchSolutions = async function (e, t) {\\n  var n, a, w;\\n  const x = t.completionContext.insertPosition,\\n    E = t.completionContext.prependToCompletion,\\n    C = t.completionContext.indentation,\\n    S = e.get(_.LocationFactory),\\n    T = await t.getDocument(),\\n    k = await p.extractPrompt(e, T, x);\\n  if (\\"contextTooShort\\" === k.type) {\\n    t.reportCancelled();\\n    return {\\n      status: \\"FinishedWithError\\",\\n      error: \\"Context too short\\",\\n    };\\n  }\\n  const I = k.prompt,\\n    P = k.trailingWs;\\n  if (P.length > 0) {\\n    t.startPosition = S.position(\\n      t.startPosition.line,\\n      t.startPosition.character - P.length\\n    );\\n  }\\n  const A = t.getCancellationToken(),\\n    O = r.v4();\\n  t.savedTelemetryData = g.TelemetryData.createAndMarkAsIssued(\\n    {\\n      headerRequestId: O,\\n      languageId: T.languageId,\\n      source: s.completionTypeToString(t.completionContext.completionType),\\n    },\\n    {\\n      ...g.telemetrizePromptLength(I),\\n      solutionCount: t.solutionCountTarget,\\n      promptEndPos: T.offsetAt(x),\\n    }\\n  );\\n  if (t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX) {\\n    const e = I.prefix.split(\\"\\\\n\\"),\\n      t = e.pop(),\\n      n = e.pop();\\n    if (n) {\\n      const r = /^\\\\W+(todo:?\\\\s+)/i.exec(n);\\n      if (r) {\\n        const o = r[1],\\n          i = n.replace(o, \\"\\");\\n        I.prefix = e.join(\\"\\\\n\\") + \\"\\\\n\\" + i + \\"\\\\n\\" + t;\\n      }\\n    }\\n  }\\n  if (\\n    t.completionContext.completionType ===\\n    s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\\n  ) {\\n    I.prefix += t.completionContext.prependToCompletion;\\n  }\\n  y.info(e, `prompt: ${JSON.stringify(I)}`);\\n  y.debug(e, `prependToCompletion: ${E}`);\\n  g.telemetry(e, \\"solution.requested\\", t.savedTelemetryData);\\n  const N = await e.get(i.BlockModeConfig).forLanguage(e, T.languageId),\\n    R = h.isSupportedLanguageId(T.languageId),\\n    M = d.contextIndentation(T, x),\\n    L = {\\n      stream: !0,\\n      extra: {\\n        language: T.languageId,\\n        next_indent: null !== (n = M.next) && undefined !== n ? n : 0,\\n      },\\n    };\\n  if (\\"parsing\\" !== N || R) {\\n    L.stop = [\\"\\\\n\\\\n\\", \\"\\\\r\\\\n\\\\r\\\\n\\"];\\n  }\\n  const $ = f.extractRepoInfoInBackground(e, T.fileName),\\n    D = {\\n      prompt: I,\\n      languageId: T.languageId,\\n      repoInfo: $,\\n      ourRequestId: O,\\n      engineUrl: await c.getEngineURL(\\n        e,\\n        f.tryGetGitHubNWO($),\\n        T.languageId,\\n        f.getDogFood($),\\n        await f.getUserKind(e),\\n        t.savedTelemetryData\\n      ),\\n      count: t.solutionCountTarget,\\n      uiKind: l.CopilotUiKind.Panel,\\n      postOptions: L,\\n      requestLogProbs: !0,\\n    };\\n  let F;\\n  const j =\\n    t.completionContext.completionType ===\\n    s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\\n      ? [\\n          s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX,\\n          t.completionContext.prependToCompletion,\\n        ]\\n      : t.completionContext.completionType;\\n  switch (N) {\\n    case i.BlockMode.Server:\\n      F = async (e) => {};\\n      L.extra.force_indent = null !== (a = M.prev) && undefined !== a ? a : -1;\\n      L.extra.trim_by_indentation = !0;\\n      break;\\n    case i.BlockMode.ParsingAndServer:\\n      F = R ? v(e, T, t.startPosition, j) : async (e) => {};\\n      L.extra.force_indent = null !== (w = M.prev) && undefined !== w ? w : -1;\\n      L.extra.trim_by_indentation = !0;\\n      break;\\n    case i.BlockMode.Parsing:\\n    default:\\n      F = R ? v(e, T, t.startPosition, j) : async (e) => {};\\n  }\\n  e.get(u.StatusReporter).setProgress();\\n  const q = await e\\n    .get(l.OpenAIFetcher)\\n    .fetchAndStreamCompletions(\\n      e,\\n      D,\\n      g.TelemetryData.createAndMarkAsIssued(),\\n      F,\\n      A\\n    );\\n  if (\\"failed\\" === q.type || \\"canceled\\" === q.type) {\\n    t.reportCancelled();\\n    e.get(u.StatusReporter).removeProgress();\\n    return {\\n      status: \\"FinishedWithError\\",\\n      error: `${q.type}: ${q.reason}`,\\n    };\\n  }\\n  let B = q.choices;\\n  B = (async function* (e, t) {\\n    for await (const n of e) {\\n      const e = {\\n        ...n,\\n      };\\n      e.completionText = t + e.completionText.trimRight();\\n      yield e;\\n    }\\n  })(B, E);\\n  if (null !== C) {\\n    B = l.cleanupIndentChoices(B, C);\\n  }\\n  B = o.asyncIterableMapFilter(B, async (t) =>\\n    m.postProcessChoice(e, \\"solution\\", T, x, t, !1, y)\\n  );\\n  const U = o.asyncIterableMapFilter(B, async (n) => {\\n    let r = n.completionText;\\n    y.info(e, `Open Copilot completion: [${n.completionText}]`);\\n    if (\\n      t.completionContext.completionType === s.CompletionType.OPEN_COPILOT ||\\n      t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX\\n    ) {\\n      let t = \\"\\";\\n      const o = await (0, d.getNodeStart)(e, T, x, n.completionText);\\n      if (o)\\n        [t] = (0, p.trimLastLine)(\\n          T.getText(S.range(S.position(o.line, o.character), x))\\n        );\\n      else {\\n        const e = S.position(x.line, 0);\\n        t = T.getText(S.range(e, x));\\n      }\\n      r = t + r;\\n    }\\n    let o = n.completionText;\\n    if (\\n      t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX\\n    ) {\\n      if (T.lineAt(x.line).isEmptyOrWhitespace) {\\n        o += \\"\\\\n\\";\\n      }\\n    }\\n    if (P.length > 0 && o.startsWith(P)) {\\n      o = o.substring(P.length);\\n    }\\n    const i = n.meanLogProb;\\n    return {\\n      displayText: r,\\n      meanProb: undefined !== i ? Math.exp(i) : 0,\\n      meanLogProb: i || 0,\\n      completionText: o,\\n      requestId: n.requestId,\\n      choiceIndex: n.choiceIndex,\\n      prependToCompletion: E,\\n    };\\n  });\\n  return b(e.get(u.StatusReporter), A, U[Symbol.asyncIterator]());\\n};","module-code-2279":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.postRequest =\\n  exports.Response =\\n  exports.HelixFetcher =\\n  exports.isAbortError =\\n  exports.Fetcher =\\n  exports.init =\\n    undefined;\\nconst r = require(9825),\\n  o = require(6149),\\n  i = require(3837),\\n  s = require(\\"config_stuff\\"),\\n  a = require(5413),\\n  c = require(\\"telemetry-stuff\\");\\nlet l,\\n  u = !1;\\nexports.init = function (e) {\\n  if (u) {\\n    if (e !== l)\\n      throw new Error(\\n        `Networking re-initialized with mismatched version (old: ${l}, new: ${e})`\\n      );\\n  } else {\\n    l = e;\\n    u = !0;\\n  }\\n};\\nclass Fetcher {}\\nexports.Fetcher = Fetcher;\\nexports.isAbortError = function (e) {\\n  return e instanceof r.AbortError;\\n};\\nexports.HelixFetcher = class extends Fetcher {\\n  constructor(e) {\\n    super();\\n    this.ctx = e;\\n    this.createSocketFactory = (e) => {\\n      const t = o.httpOverHttp({\\n        proxy: e,\\n      });\\n      return (e) =>\\n        new Promise((n) => {\\n          t.createSocket(e, (e) => {\\n            n(e);\\n          });\\n        });\\n    };\\n    this.fetchApi = this.createFetchApi(e);\\n  }\\n  set proxySettings(e) {\\n    this._proxySettings = e;\\n    this.fetchApi = this.createFetchApi(this.ctx);\\n  }\\n  get proxySettings() {\\n    return this._proxySettings;\\n  }\\n  createFetchApi(e) {\\n    var t;\\n    const n = e.get(s.BuildInfo);\\n    if (\\n      !1 ===\\n      (null === (t = this._proxySettings) || undefined === t\\n        ? undefined\\n        : t.rejectUnauthorized)\\n    ) {\\n      process.env.NODE_TLS_REJECT_UNAUTHORIZED = \\"0\\";\\n    }\\n    return r.context({\\n      userAgent: `GithubCopilot/${n.getVersion()}`,\\n      socketFactory: this._proxySettings\\n        ? this.createSocketFactory(this._proxySettings)\\n        : undefined,\\n    });\\n  }\\n  async fetch(e, t) {\\n    const n = {\\n        ...t,\\n        body: t.body ? t.body : t.json,\\n        signal: t.signal,\\n      },\\n      r = await this.fetchApi.fetch(e, n);\\n    return new Response(\\n      r.status,\\n      r.statusText,\\n      r.headers,\\n      () => r.text(),\\n      () => r.json(),\\n      async () => r.body\\n    );\\n  }\\n  disconnectAll() {\\n    return this.fetchApi.reset();\\n  }\\n  makeAbortController() {\\n    return new r.AbortController();\\n  }\\n};\\nclass Response {\\n  constructor(e, t, n, r, o, i) {\\n    this.status = e;\\n    this.statusText = t;\\n    this.headers = n;\\n    this.getText = r;\\n    this.getJson = o;\\n    this.getBody = i;\\n    this.ok = this.status >= 200 && this.status < 300;\\n  }\\n  async text() {\\n    return this.getText();\\n  }\\n  async json() {\\n    return this.getJson();\\n  }\\n  async body() {\\n    return this.getBody();\\n  }\\n}\\nexports.Response = Response;\\nexports.postRequest = function (e, t, n, r, o, l, p) {\\n  if (!u) throw new Error(\\"Networking must be initialized before being used\\");\\n  const h = {\\n    Authorization: i.format(\\"Bearer %s\\", n),\\n    \\"X-Request-Id\\": o,\\n    \\"Openai-Organization\\": \\"github-copilot\\",\\n    \\"VScode-SessionId\\": e.get(s.VscInfo).sessionId,\\n    \\"VScode-MachineId\\": e.get(s.VscInfo).machineId,\\n    ...s.editorVersionHeaders(e),\\n  };\\n  if (r) {\\n    h[\\"OpenAI-Intent\\"] = r;\\n  }\\n  const f = e.get(a.GhostTextDebounceManager).forceDelayMs;\\n  if (f) {\\n    h[\\"X-Copilot-Force-Delay\\"] = f.toString();\\n  }\\n  const m = {\\n      method: \\"POST\\",\\n      headers: h,\\n      json: l,\\n      timeout: 3e4,\\n    },\\n    g = e.get(Fetcher);\\n  if (p) {\\n    const t = g.makeAbortController();\\n    p.onCancellationRequested(() => {\\n      c.telemetry(\\n        e,\\n        \\"networking.cancelRequest\\",\\n        c.TelemetryData.createAndMarkAsIssued({\\n          headerRequestId: o,\\n        })\\n      );\\n      t.abort();\\n    });\\n    m.signal = t.signal;\\n  }\\n  return g.fetch(t, m).catch((n) => {\\n    if (\\n      \\"ECONNRESET\\" == n.code ||\\n      \\"ETIMEDOUT\\" == n.code ||\\n      \\"ERR_HTTP2_INVALID_SESSION\\" == n.code ||\\n      \\"ERR_HTTP2_GOAWAY_SESSION\\" == n.message\\n    ) {\\n      c.telemetry(e, \\"networking.disconnectAll\\");\\n      return g.disconnectAll().then(() => g.fetch(t, m));\\n    }\\n    throw n;\\n  });\\n};","module-label-2277":"uuid-utils","module-code-750":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.handleGhostTextResultTelemetry =\\n  exports.mkBasicResultTelemetry =\\n  exports.mkCanceledResultTelemetry =\\n  exports.telemetryRejected =\\n  exports.telemetryAccepted =\\n  exports.telemetryShown =\\n    undefined;\\nconst r = require(\\"telemetry-stuff\\"),\\n  o = require(8965);\\nexports.telemetryShown = function (e, t, n, o) {\\n  n.markAsDisplayed();\\n  const i = o ? `${t}.shownFromCache` : `${t}.shown`;\\n  r.telemetry(e, i, n);\\n};\\nexports.telemetryAccepted = function (e, t, n) {\\n  const i = t + \\".accepted\\",\\n    s = e.get(o.ContextualFilterManager);\\n  s.previousLabel = 1;\\n  s.previousLabelTimestamp = Date.now();\\n  r.telemetry(e, i, n);\\n};\\nexports.telemetryRejected = function (e, t, n) {\\n  const i = t + \\".rejected\\",\\n    s = e.get(o.ContextualFilterManager);\\n  s.previousLabel = 0;\\n  s.previousLabelTimestamp = Date.now();\\n  r.telemetry(e, i, n);\\n};\\nexports.mkCanceledResultTelemetry = function (e, t = {}) {\\n  return {\\n    ...t,\\n    telemetryBlob: e,\\n  };\\n};\\nexports.mkBasicResultTelemetry = function (e) {\\n  return {\\n    headerRequestId: e.properties.headerRequestId,\\n    copilot_trackingId: e.properties.copilot_trackingId,\\n  };\\n};\\nexports.handleGhostTextResultTelemetry = async function (e, t) {\\n  if (\\"success\\" === t.type) {\\n    r.telemetryRaw(e, \\"ghostText.produced\\", t.telemetryData, {});\\n    return t.value;\\n  }\\n  if (\\"abortedBeforeIssued\\" !== t.type) {\\n    if (\\"canceled\\" !== t.type) {\\n      r.telemetryRaw(\\n        e,\\n        `ghostText.${t.type}`,\\n        {\\n          ...t.telemetryData,\\n          reason: t.reason,\\n        },\\n        {}\\n      );\\n    } else {\\n      r.telemetry(\\n        e,\\n        \\"ghostText.canceled\\",\\n        t.telemetryData.telemetryBlob.extendedBy({\\n          reason: t.reason,\\n          cancelledNetworkRequest: t.telemetryData.cancelledNetworkRequest\\n            ? \\"true\\"\\n            : \\"false\\",\\n        })\\n      );\\n    }\\n  }\\n};","module-code-4419":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.LiveOpenAIFetcher =\\n  exports.postProcessChoices =\\n  exports.OpenAIFetcher =\\n  exports.extractEngineName =\\n  exports.getProcessingTime =\\n  exports.getRequestId =\\n  exports.CopilotUiKind =\\n    undefined;\\nconst r = require(\\"util\\"),\\n  o = require(\\"copilot-github-auth-stuff\\"),\\n  i = require(6932),\\n  s = require(\\"config_stuff\\"),\\n  a = require(9189),\\n  c = require(5413),\\n  l = require(\\"logging-utils\\"),\\n  u = require(2279),\\n  d = require(6722),\\n  p = require(766),\\n  h = require(9657),\\n  f = require(\\"telemetry-stuff\\"),\\n  m = require(\\"openai-choices-utils\\"),\\n  g = require(2901),\\n  _ = new l.Logger(l.LogLevel.INFO, \\"fetch\\");\\nvar y;\\nfunction getRequestId(e, t) {\\n  return {\\n    headerRequestId: e.headers.get(\\"x-request-id\\") || \\"\\",\\n    completionId: t && t.id ? t.id : \\"\\",\\n    created: t && t.created ? t.created : 0,\\n    serverExperiments: e.headers.get(\\"X-Copilot-Experiment\\") || \\"\\",\\n    deploymentId: e.headers.get(\\"azureml-model-deployment\\") || \\"\\",\\n  };\\n}\\nfunction getProcessingTime(e) {\\n  const t = e.headers.get(\\"openai-processing-ms\\");\\n  return t ? parseInt(t, 10) : 0;\\n}\\nfunction extractEngineName(e, t) {\\n  return t.split(\\"/\\").pop() || (_.error(e, \\"Malformed engine URL: \\" + t), t);\\n}\\n!(function (e) {\\n  e.GhostText = \\"ghostText\\";\\n  e.Panel = \\"synthesize\\";\\n})((y = exports.CopilotUiKind || (exports.CopilotUiKind = {})));\\nexports.getRequestId = getRequestId;\\nexports.getProcessingTime = getProcessingTime;\\nexports.extractEngineName = extractEngineName;\\nclass OpenAIFetcher {}\\nfunction postProcessChoices(e, t) {\\n  return null != t && t\\n    ? e\\n    : i.asyncIterableFilter(e, async (e) => e.completionText.trim().length > 0);\\n}\\nexports.OpenAIFetcher = OpenAIFetcher;\\nexports.postProcessChoices = postProcessChoices;\\nexports.LiveOpenAIFetcher = class extends OpenAIFetcher {\\n  async fetchAndStreamCompletions(e, t, n, r, o) {\\n    const s = e.get(d.StatusReporter),\\n      a = \\"completions\\",\\n      c = await this.fetchWithParameters(e, a, t, o);\\n    if (\\"not-sent\\" === c)\\n      return {\\n        type: \\"canceled\\",\\n        reason: \\"before fetch request\\",\\n      };\\n    if (null == o ? undefined : o.isCancellationRequested) {\\n      const t = await c.body();\\n      try {\\n        t.destroy();\\n      } catch (t) {\\n        l.logger.error(e, `Error destroying stream: ${t}`);\\n      }\\n      return {\\n        type: \\"canceled\\",\\n        reason: \\"after fetch request\\",\\n      };\\n    }\\n    if (undefined === c) {\\n      const n = this.createTelemetryData(a, e, t);\\n      s.setWarning();\\n      n.properties.error = \\"Response was undefined\\";\\n      f.telemetry(e, \\"request.shownWarning\\", n);\\n      return {\\n        type: \\"failed\\",\\n        reason: \\"fetch response was undefined\\",\\n      };\\n    }\\n    if (200 !== c.status) {\\n      const n = this.createTelemetryData(a, e, t);\\n      return this.handleError(e, s, n, c);\\n    }\\n    return {\\n      type: \\"success\\",\\n      choices: postProcessChoices(\\n        i.asyncIterableMap(g.processSSE(e, c, r, n, o), async (t) =>\\n          g.prepareSolutionForReturn(e, t, n)\\n        ),\\n        t.allowEmptyChoices\\n      ),\\n      getProcessingTime: () => getProcessingTime(c),\\n    };\\n  }\\n  createTelemetryData(e, t, n) {\\n    return f.TelemetryData.createAndMarkAsIssued({\\n      endpoint: e,\\n      engineName: extractEngineName(t, n.engineUrl),\\n      uiKind: n.uiKind,\\n      headerRequestId: n.ourRequestId,\\n    });\\n  }\\n  async fetchWithParameters(e, t, n, i) {\\n    var g;\\n    const _ = s.getLanguageConfig(e, s.ConfigKey.Stops),\\n      b = await e.get(a.Features).disableLogProb(),\\n      x = {\\n        prompt: n.prompt.prefix,\\n        suffix: n.prompt.suffix,\\n        max_tokens: s.getConfig(e, s.ConfigKey.SolutionLength),\\n        temperature: m.getTemperatureForSamples(e, n.count),\\n        top_p: s.getConfig(e, s.ConfigKey.TopP),\\n        n: n.count,\\n        stop: _,\\n      };\\n    if (!n.requestLogProbs && b) {\\n      x.logprobs = 2;\\n    }\\n    const E = p.tryGetGitHubNWO(n.repoInfo);\\n    if (undefined !== E) {\\n      x.nwo = E;\\n    }\\n    if (\\n      [h.RepetitionFilterMode.PROXY, h.RepetitionFilterMode.BOTH].includes(\\n        await e.get(a.Features).repetitionFilterMode()\\n      )\\n    ) {\\n      x.feature_flags = [\\n        ...(null !== (g = x.feature_flags) && undefined !== g ? g : []),\\n        \\"filter-repetitions\\",\\n      ];\\n    }\\n    if (n.postOptions) {\\n      Object.assign(x, n.postOptions);\\n    }\\n    return (null == i ? undefined : i.isCancellationRequested)\\n      ? \\"not-sent\\"\\n      : (l.logger.info(e, `[fetchCompletions] engine ${n.engineUrl}`),\\n        await (function (e, t, n, o, i, s, a, p, h) {\\n          var m;\\n          const g = e.get(d.StatusReporter),\\n            _ = r.format(\\"%s/%s\\", n, o);\\n          if (!a)\\n            return void l.logger.error(\\n              e,\\n              `Failed to send request to ${_} due to missing key`\\n            );\\n          const b = f.TelemetryData.createAndMarkAsIssued(\\n            {\\n              endpoint: o,\\n              engineName: extractEngineName(e, n),\\n              uiKind: p,\\n            },\\n            f.telemetrizePromptLength(t)\\n          );\\n          for (const [e, t] of Object.entries(s))\\n            if (\\"prompt\\" != e && \\"suffix\\" != e) {\\n              b.properties[`request.option.${e}`] =\\n                null !== (m = JSON.stringify(t)) && undefined !== m\\n                  ? m\\n                  : \\"undefined\\";\\n            }\\n          b.properties.headerRequestId = i;\\n          f.telemetry(e, \\"request.sent\\", b);\\n          const x = f.now(),\\n            E = (function (e) {\\n              switch (e) {\\n                case y.GhostText:\\n                  return \\"copilot-ghost\\";\\n                case y.Panel:\\n                  return \\"copilot-panel\\";\\n              }\\n            })(p);\\n          return u\\n            .postRequest(e, _, a, E, i, s, h)\\n            .then((n) => {\\n              const r = getRequestId(n, undefined);\\n              b.extendWithRequestId(r);\\n              const o = f.now() - x;\\n              b.measurements.totalTimeMs = o;\\n              l.logger.info(e, `request.response: [${_}] took ${o} ms`);\\n              l.logger.debug(e, \\"request.response properties\\", b.properties);\\n              l.logger.debug(\\n                e,\\n                \\"request.response measurements\\",\\n                b.measurements\\n              );\\n              l.logger.debug(e, `prompt: ${JSON.stringify(t)}`);\\n              f.telemetry(e, \\"request.response\\", b);\\n              const i = n.headers.get(\\"x-copilot-delay\\"),\\n                s = i ? parseInt(i, 10) : 0;\\n              e.get(c.GhostTextDebounceManager).extraDebounceMs = s;\\n              return n;\\n            })\\n            .catch((t) => {\\n              var n, r, o, i;\\n              if (u.isAbortError(t)) throw t;\\n              g.setWarning();\\n              const s = b.extendedBy({\\n                error: \\"Network exception\\",\\n              });\\n              f.telemetry(e, \\"request.shownWarning\\", s);\\n              b.properties.code = String(\\n                null !== (n = t.code) && undefined !== n ? n : \\"\\"\\n              );\\n              b.properties.errno = String(\\n                null !== (r = t.errno) && undefined !== r ? r : \\"\\"\\n              );\\n              b.properties.message = String(\\n                null !== (o = t.message) && undefined !== o ? o : \\"\\"\\n              );\\n              b.properties.type = String(\\n                null !== (i = t.type) && undefined !== i ? i : \\"\\"\\n              );\\n              const a = f.now() - x;\\n              throw (\\n                ((b.measurements.totalTimeMs = a),\\n                l.logger.debug(e, `request.response: [${_}] took ${a} ms`),\\n                l.logger.debug(e, \\"request.error properties\\", b.properties),\\n                l.logger.debug(e, \\"request.error measurements\\", b.measurements),\\n                l.logger.error(e, `Request Error: ${t.message}`),\\n                f.telemetry(e, \\"request.error\\", b),\\n                t)\\n              );\\n            })\\n            .finally(() => {\\n              f.logEnginePrompt(e, t, b);\\n            });\\n        })(\\n          e,\\n          n.prompt,\\n          n.engineUrl,\\n          t,\\n          n.ourRequestId,\\n          x,\\n          (\\n            await e.get(o.CopilotTokenManager).getCopilotToken(e)\\n          ).token,\\n          n.uiKind,\\n          i\\n        ));\\n  }\\n  async handleError(e, t, n, r) {\\n    t.setWarning();\\n    n.properties.error = `Response status was ${r.status}`;\\n    n.properties.status = String(r.status);\\n    f.telemetry(e, \\"request.shownWarning\\", n);\\n    if (401 === r.status || 403 === r.status)\\n      return (\\n        e.get(o.CopilotTokenManager).resetCopilotToken(e, r.status),\\n        {\\n          type: \\"failed\\",\\n          reason: `token expired or invalid: ${r.status}`,\\n        }\\n      );\\n    if (499 === r.status) {\\n      _.info(e, \\"Cancelled by server\\");\\n      return {\\n        type: \\"failed\\",\\n        reason: \\"canceled by server\\",\\n      };\\n    }\\n    const i = await r.text();\\n    return 466 === r.status\\n      ? (t.setError(i),\\n        _.info(e, i),\\n        {\\n          type: \\"failed\\",\\n          reason: `client not supported: ${i}`,\\n        })\\n      : (_.error(e, \\"Unhandled status from server:\\", r.status, i),\\n        {\\n          type: \\"failed\\",\\n          reason: `unhandled status from server: ${r.status} ${i}`,\\n        });\\n  }\\n};","module-code-362":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.refreshToken =\\n  exports.CopilotTokenManagerFromGitHubToken =\\n  exports.FixedCopilotTokenManager =\\n  exports.CopilotTokenManager =\\n  exports.setTelemetryConfigFromTokenInfo =\\n  exports.extractTrackingIdFromToken =\\n  exports.authFromGitHubToken =\\n  exports.nowSeconds =\\n  exports.TOKEN_REFRESHED_EVENT =\\n    undefined;\\nconst r = require(2361),\\n  o = require(\\"config_stuff\\"),\\n  i = require(\\"logging-utils\\"),\\n  s = require(2279),\\n  a = require(1547),\\n  c = require(\\"telemetry-stuff\\"),\\n  l = require(7057),\\n  u = new i.Logger(i.LogLevel.INFO, \\"auth\\");\\nlet d = 0;\\nfunction nowSeconds() {\\n  return Math.floor(Date.now() / 1e3);\\n}\\nasync function authFromGitHubToken(e, t) {\\n  var n, r;\\n  c.telemetry(e, \\"auth.new_login\\");\\n  const i =\\n      null !==\\n        (r =\\n          null === (n = t.devOverride) || undefined === n\\n            ? undefined\\n            : n.copilotTokenUrl) && undefined !== r\\n        ? r\\n        : \\"https://api.github.com/copilot_internal/v2/token\\",\\n    a = await e.get(s.Fetcher).fetch(i, {\\n      headers: {\\n        Authorization: `token ${t.token}`,\\n        ...o.editorVersionHeaders(e),\\n      },\\n    });\\n  if (!a) {\\n    u.info(e, \\"Failed to get copilot token\\");\\n    c.telemetryError(e, \\"auth.request_failed\\");\\n    return {\\n      kind: \\"failure\\",\\n      reason: \\"FailedToGetToken\\",\\n    };\\n  }\\n  const l = await a.json();\\n  if (!l) {\\n    u.info(e, \\"Failed to get copilot token\\");\\n    c.telemetryError(e, \\"auth.request_read_failed\\");\\n    return {\\n      kind: \\"failure\\",\\n      reason: \\"FailedToGetToken\\",\\n    };\\n  }\\n  m(e, l.user_notification, t);\\n  if (401 === a.status)\\n    return (\\n      u.info(e, \\"Failed to get copilot token due to 401 status\\"),\\n      (0, c.telemetryError)(e, \\"auth.unknown_401\\"),\\n      {\\n        kind: \\"failure\\",\\n        reason: \\"HTTP401\\",\\n      }\\n    );\\n  if (!a.ok || !l.token) {\\n    u.info(\\n      e,\\n      `Invalid copilot token: missing token: ${a.status} ${a.statusText}`\\n    );\\n    c.telemetryError(\\n      e,\\n      \\"auth.invalid_token\\",\\n      c.TelemetryData.createAndMarkAsIssued({\\n        status: a.status.toString(),\\n        status_text: a.statusText,\\n      })\\n    );\\n    const n = l.error_details;\\n    m(e, n, t);\\n    return {\\n      kind: \\"failure\\",\\n      reason: \\"NotAuthorized\\",\\n      ...n,\\n    };\\n  }\\n  const d = l.expires_at;\\n  l.expires_at = nowSeconds() + l.refresh_in + 60;\\n  e.get(c.TelemetryReporters).setToken(l);\\n  setTelemetryConfigFromTokenInfo(l);\\n  c.telemetry(\\n    e,\\n    \\"auth.new_token\\",\\n    c.TelemetryData.createAndMarkAsIssued(\\n      {},\\n      {\\n        adjusted_expires_at: l.expires_at,\\n        expires_at: d,\\n        current_time: nowSeconds(),\\n      }\\n    )\\n  );\\n  return {\\n    kind: \\"success\\",\\n    ...l,\\n  };\\n}\\nexports.TOKEN_REFRESHED_EVENT = \\"token_refreshed\\";\\nexports.nowSeconds = nowSeconds;\\nexports.authFromGitHubToken = authFromGitHubToken;\\nconst f = new Map();\\nfunction m(e, t, n) {\\n  if (!t) return;\\n  const r = nowSeconds();\\n  if (f.get(t.message)) {\\n    f.set(t.message, r);\\n    e.get(a.NotificationSender)\\n      .showWarningMessage(\\n        t.message,\\n        {\\n          title: t.title,\\n        },\\n        {\\n          title: \\"Dismiss\\",\\n        }\\n      )\\n      .catch((t) => {\\n        console.error(t);\\n        u.error(e, `Error while sending notification: ${t.message}`);\\n      })\\n      .then(async (r) => {\\n        const i = (null == r ? undefined : r.title) === t.title,\\n          a = i || \\"Dismiss\\" === (null == r ? undefined : r.title);\\n        if (i) {\\n          const n = e.get(o.EditorAndPluginInfo).getEditorPluginInfo(e),\\n            r = t.url.replace(\\n              \\"{EDITOR}\\",\\n              encodeURIComponent(n.name + \\"_\\" + n.version)\\n            );\\n          await e.get(l.UrlOpener).open(r);\\n        }\\n        if (\\"notification_id\\" in t && a) {\\n          await (async function (e, t, n) {\\n            var r, i;\\n            const a =\\n                null !==\\n                  (i =\\n                    null === (r = n.devOverride) || undefined === r\\n                      ? undefined\\n                      : r.notificationUrl) && undefined !== i\\n                  ? i\\n                  : \\"https://api.github.com/copilot_internal/notification\\",\\n              c = await e.get(s.Fetcher).fetch(a, {\\n                headers: {\\n                  Authorization: `token ${n.token}`,\\n                  ...o.editorVersionHeaders(e),\\n                },\\n                method: \\"POST\\",\\n                body: JSON.stringify({\\n                  notification_id: t,\\n                }),\\n              });\\n            if (c && c.ok) {\\n              u.error(\\n                e,\\n                `Failed to send notification result to GitHub: ${\\n                  null == c ? undefined : c.status\\n                } ${null == c ? undefined : c.statusText}`\\n              );\\n            }\\n          })(e, t.notification_id, n);\\n        }\\n      });\\n  }\\n}\\nfunction extractTrackingIdFromToken(e) {\\n  const t = null == e ? undefined : e.split(\\":\\")[0],\\n    n = null == t ? undefined : t.split(\\";\\");\\n  for (const e of n) {\\n    const [t, n] = e.split(\\"=\\");\\n    if (\\"tid\\" === t) return n;\\n  }\\n}\\nfunction setTelemetryConfigFromTokenInfo(e) {\\n  const t = extractTrackingIdFromToken(e.token);\\n  if (undefined !== t) {\\n    c.setTelemetryConfig({\\n      trackingId: t,\\n      optedIn: \\"enabled\\" === e.telemetry || \\"unconfigured\\" === e.telemetry,\\n    });\\n  }\\n}\\nexports.extractTrackingIdFromToken = extractTrackingIdFromToken;\\nexports.setTelemetryConfigFromTokenInfo = setTelemetryConfigFromTokenInfo;\\nclass CopilotTokenManager {\\n  constructor() {\\n    this.tokenRefreshEventEmitter = new r.EventEmitter();\\n  }\\n}\\nfunction refreshToken(e, n, r) {\\n  const o = nowSeconds();\\n  if (d > 0) {\\n    d++;\\n    setTimeout(async () => {\\n      let r,\\n        i = \\"\\";\\n      try {\\n        d--;\\n        await n.getCopilotToken(e, !0);\\n        r = \\"success\\";\\n        n.tokenRefreshEventEmitter.emit(exports.TOKEN_REFRESHED_EVENT);\\n      } catch (e) {\\n        r = \\"failure\\";\\n        i = e.toString();\\n      }\\n      const s = c.TelemetryData.createAndMarkAsIssued(\\n        {\\n          result: r,\\n        },\\n        {\\n          time_taken: nowSeconds() - o,\\n          refresh_count: d,\\n        }\\n      );\\n      if (i) {\\n        s.properties.reason = i;\\n      }\\n      c.telemetry(e, \\"auth.token_refresh\\", s);\\n    }, 1e3 * r);\\n  }\\n}\\nexports.CopilotTokenManager = CopilotTokenManager;\\nexports.FixedCopilotTokenManager = class extends CopilotTokenManager {\\n  constructor(e) {\\n    super();\\n    this.tokenInfo = e;\\n    this.wasReset = !1;\\n    setTelemetryConfigFromTokenInfo(e);\\n  }\\n  async getGitHubToken() {\\n    return Promise.resolve(\\"token\\");\\n  }\\n  async getCopilotToken(e, t) {\\n    return this.tokenInfo;\\n  }\\n  resetCopilotToken(e, t) {\\n    this.wasReset = !0;\\n  }\\n  async checkCopilotToken(e) {\\n    return {\\n      status: \\"OK\\",\\n      telemetry: this.tokenInfo.telemetry,\\n    };\\n  }\\n};\\nexports.CopilotTokenManagerFromGitHubToken = class extends CopilotTokenManager {\\n  constructor(e) {\\n    super();\\n    this.githubToken = e;\\n    this.copilotToken = undefined;\\n  }\\n  async getGitHubToken() {\\n    return Promise.resolve(this.githubToken.token);\\n  }\\n  async getCopilotToken(e, t) {\\n    var n;\\n    if (\\n      !this.copilotToken ||\\n      this.copilotToken.expires_at < nowSeconds() ||\\n      t\\n    ) {\\n      const t = await authFromGitHubToken(e, this.githubToken);\\n      if (\\"failure\\" === t.kind)\\n        throw Error(\\n          `Failed to get copilot token: ${t.reason.toString()} ${\\n            null !== (n = t.message) && undefined !== n ? n : \\"\\"\\n          }`\\n        );\\n      this.copilotToken = {\\n        ...t,\\n      };\\n      refreshToken(e, this, t.refresh_in);\\n    }\\n    return this.copilotToken;\\n  }\\n  async checkCopilotToken(e) {\\n    if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds()) {\\n      const t = await authFromGitHubToken(e, this.githubToken);\\n      if (\\"failure\\" === t.kind) return t;\\n      this.copilotToken = {\\n        ...t,\\n      };\\n      refreshToken(e, this, t.refresh_in);\\n    }\\n    return {\\n      status: \\"OK\\",\\n      telemetry: this.copilotToken.telemetry,\\n    };\\n  }\\n  resetCopilotToken(e, t) {\\n    if (undefined !== t) {\\n      c.telemetry(e, \\"auth.reset_token_\\" + t);\\n    }\\n    u.debug(e, `Resetting copilot token on HTTP error ${t || \\"unknown\\"}`);\\n    this.copilotToken = undefined;\\n  }\\n};\\nexports.refreshToken = refreshToken;","module-code-9899":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.logger =\\n  exports.toPlainText =\\n  exports.Logger =\\n  exports.MultiLog =\\n  exports.OutputChannelLog =\\n  exports.ConsoleLog =\\n  exports.LogTarget =\\n  exports.verboseLogging =\\n  exports.LogVerbose =\\n  exports.LogLevel =\\n    undefined;\\nconst r = require(\\"clock\\"),\\n  o = require(\\"config_stuff\\"),\\n  i = require(\\"telemetry-stuff\\");\\nvar s;\\n!(function (e) {\\n  e[(e.DEBUG = 0)] = \\"DEBUG\\";\\n  e[(e.INFO = 1)] = \\"INFO\\";\\n  e[(e.WARN = 2)] = \\"WARN\\";\\n  e[(e.ERROR = 3)] = \\"ERROR\\";\\n})((s = exports.LogLevel || (exports.LogLevel = {})));\\nclass LogVerbose {\\n  constructor(e) {\\n    this.logVerbose = e;\\n  }\\n}\\nfunction verboseLogging(e) {\\n  return e.get(LogVerbose).logVerbose;\\n}\\nexports.LogVerbose = LogVerbose;\\nexports.verboseLogging = verboseLogging;\\nclass LogTarget {\\n  shouldLog(e, t) {}\\n}\\nexports.LogTarget = LogTarget;\\nexports.ConsoleLog = class extends LogTarget {\\n  constructor(e) {\\n    super();\\n    this.console = e;\\n  }\\n  logIt(e, t, n, ...r) {\\n    if (verboseLogging(e) || t == s.ERROR) {\\n      this.console.error(n, ...r);\\n    } else {\\n      if (t == s.WARN) {\\n        this.console.warn(n, ...r);\\n      }\\n    }\\n  }\\n};\\nexports.OutputChannelLog = class extends LogTarget {\\n  constructor(e) {\\n    super();\\n    this.output = e;\\n  }\\n  logIt(e, t, n, ...r) {\\n    this.output.appendLine(`${n} ${r.map(toPlainText)}`);\\n  }\\n};\\nexports.MultiLog = class extends LogTarget {\\n  constructor(e) {\\n    super();\\n    this.targets = e;\\n  }\\n  logIt(e, t, n, ...r) {\\n    this.targets.forEach((o) => o.logIt(e, t, n, ...r));\\n  }\\n};\\nclass Logger {\\n  constructor(e, t) {\\n    this.minLoggedLevel = e;\\n    this.context = t;\\n  }\\n  setLevel(e) {\\n    this.minLoggedLevel = e;\\n  }\\n  stringToLevel(e) {\\n    return s[e];\\n  }\\n  log(e, t, n, ...o) {\\n    const a = s[t];\\n    if (t == s.ERROR) {\\n      i.telemetryError(\\n        e,\\n        \\"log\\",\\n        i.TelemetryData.createAndMarkAsIssued({\\n          context: this.context,\\n          level: a,\\n          message: o.length > 0 ? JSON.stringify(o) : \\"no msg\\",\\n        }),\\n        n\\n      );\\n    }\\n    const c = e.get(LogTarget),\\n      u = c.shouldLog(e, t);\\n    if (!1 === u) return;\\n    if (undefined === u && !this.shouldLog(e, t, this.context)) return;\\n    const d = e.get(r.Clock).now().toISOString(),\\n      p = `[${a}] [${this.context}] [${d}]`;\\n    c.logIt(e, t, p, ...o);\\n  }\\n  shouldLog(e, t, n) {\\n    var r, i;\\n    if (verboseLogging(e)) return !0;\\n    const s = o.getConfig(e, o.ConfigKey.DebugFilterLogCategories);\\n    if (s.length > 0 && !s.includes(n)) return !1;\\n    if (o.isProduction(e)) return t >= this.minLoggedLevel;\\n    const a = o.getConfig(e, o.ConfigKey.DebugOverrideLogLevels);\\n    return (\\n      t >=\\n      (null !==\\n        (i =\\n          null !== (r = this.stringToLevel(a[\\"*\\"])) && undefined !== r\\n            ? r\\n            : this.stringToLevel(a[this.context])) && undefined !== i\\n        ? i\\n        : this.minLoggedLevel)\\n    );\\n  }\\n  debug(e, ...t) {\\n    this.log(e, s.DEBUG, !1, ...t);\\n  }\\n  info(e, ...t) {\\n    this.log(e, s.INFO, !1, ...t);\\n  }\\n  warn(e, ...t) {\\n    this.log(e, s.WARN, !1, ...t);\\n  }\\n  error(e, ...t) {\\n    this.log(e, s.ERROR, !1, ...t);\\n  }\\n  secureError(e, t, ...n) {\\n    this.log(e, s.ERROR, !1, t);\\n    this.log(e, s.ERROR, !0, t, ...n);\\n  }\\n}\\nfunction toPlainText(e) {\\n  return \\"object\\" == typeof e ? JSON.stringify(e) : String(e);\\n}\\nexports.Logger = Logger;\\nexports.toPlainText = toPlainText;\\nexports.logger = new Logger(s.INFO, \\"default\\");","module-code-9425":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.VSCodeEditorInfo =\\n  exports.makeVscInfo =\\n  exports.getExtension =\\n  exports.setExtension =\\n  exports.VSCodeConfigProvider =\\n    undefined;\\nconst r = require(9496),\\n  o = require(\\"config_stuff\\"),\\n  i = require(4197),\\n  s = require(70),\\n  a = require(4147);\\nfunction c(e) {\\n  return \\"string\\" == typeof e ? e : JSON.stringify(e);\\n}\\nclass VSCodeConfigProvider extends o.ConfigProvider {\\n  constructor() {\\n    super();\\n    this.config = r.workspace.getConfiguration(i.CopilotConfigPrefix);\\n    r.workspace.onDidChangeConfiguration((e) => {\\n      if (e.affectsConfiguration(i.CopilotConfigPrefix)) {\\n        this.config = r.workspace.getConfiguration(i.CopilotConfigPrefix);\\n      }\\n    });\\n  }\\n  getConfigKeyFromObject(e, t) {\\n    const n = this.config[e][t];\\n    return undefined === n ? o.getConfigDefaultForObjectKey(e, t) : n;\\n  }\\n  getConfig(e) {\\n    if (Array.isArray(e)) return this.getConfigKeyFromObject(e[0], e[1]);\\n    const t = this.config.get(e);\\n    if (undefined === t)\\n      throw new Error(\\n        `Missing config default value: ${i.CopilotConfigPrefix}.${e}`\\n      );\\n    return t;\\n  }\\n  isDefaultSettingOverwritten(e) {\\n    if (Array.isArray(e)) return undefined !== this.config[e[0]][e[1]];\\n    const t = this.config.inspect(e);\\n    return (\\n      !!t &&\\n      !!(\\n        t.globalValue ||\\n        t.workspaceValue ||\\n        t.workspaceFolderValue ||\\n        t.defaultLanguageValue ||\\n        t.globalLanguageValue ||\\n        t.workspaceLanguageValue ||\\n        t.workspaceFolderLanguageValue\\n      )\\n    );\\n  }\\n  dumpConfig() {\\n    const e = {};\\n    try {\\n      const t = a.contributes.configuration[0].properties;\\n      for (const n in t) {\\n        const t = n\\n          .replace(`${i.CopilotConfigPrefix}.`, \\"\\")\\n          .split(\\".\\")\\n          .reduce((e, t) => e[t], this.config);\\n        if (\\"object\\" == typeof t && null !== t) {\\n          Object.keys(t)\\n            .filter((e) => \\"secret_key\\" !== e)\\n            .forEach((r) => (e[`${n}.${r}`] = c(t[r])));\\n        } else {\\n          e[n] = c(t);\\n        }\\n      }\\n    } catch (e) {\\n      console.error(`Failed to retrieve configuration properties ${e}`);\\n    }\\n    return e;\\n  }\\n  getLanguageConfig(e, t) {\\n    const n = this.getConfig(e);\\n    if (undefined === t) {\\n      const e = r.window.activeTextEditor;\\n      t = e && e.document.languageId;\\n    }\\n    return t && t in n ? n[t] : n[\\"*\\"];\\n  }\\n  updateEnabledConfig(e, t, n) {\\n    const r = e.get(o.ConfigProvider).getConfig(o.ConfigKey.Enable);\\n    r[t] = n;\\n    return this.config.update(o.ConfigKey.Enable, r, !0);\\n  }\\n}\\nlet u;\\nexports.VSCodeConfigProvider = VSCodeConfigProvider;\\nexports.setExtension = function (e) {\\n  u = e;\\n};\\nexports.getExtension = function (e) {\\n  if (!u && s.isRunningInTest(e)) {\\n    u = r.extensions.all.find((e) => e.id.startsWith(\\"GitHub.copilot\\"));\\n  }\\n  if (!u) throw new Error(\\"No GitHub.copilot extension found\\");\\n  return u;\\n};\\nexports.makeVscInfo = function () {\\n  return new o.VscInfo(r.env.sessionId, r.env.machineId, r.version);\\n};\\nclass VSCodeEditorInfo extends o.EditorAndPluginInfo {\\n  getEditorInfo(e) {\\n    return {\\n      name: \\"vscode\\",\\n      version: r.version,\\n    };\\n  }\\n  getEditorPluginInfo(e) {\\n    return {\\n      name: \\"copilot\\",\\n      version: o.getVersion(e),\\n    };\\n  }\\n}\\nexports.VSCodeEditorInfo = VSCodeEditorInfo;","module-code-3":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getEngineURL =\\n  exports.TEST_ENGINE_PATHS =\\n  exports.OPENAI_PROXY_HOST =\\n    undefined;\\nconst r = require(\\"config_stuff\\"),\\n  o = require(9189),\\n  i = require(70);\\nexports.OPENAI_PROXY_HOST = \\"https://copilot-proxy.githubusercontent.com\\";\\nconst s = \\"/v1/engines/copilot-codex\\";\\nexports.TEST_ENGINE_PATHS = [s];\\nexports.getEngineURL = async function (e, n = \\"\\", a, c = \\"\\", l = \\"\\", u) {\\n  return (function (e, n) {\\n    let o = (function (e) {\\n      return i.isRunningInTest(e)\\n        ? r.getConfig(e, r.ConfigKey.DebugTestOverrideProxyUrl)\\n        : r.getConfig(e, r.ConfigKey.DebugOverrideProxyUrl);\\n    })(e);\\n    if (0 == o.length) {\\n      o = exports.OPENAI_PROXY_HOST;\\n    }\\n    return `${o}${n}`;\\n  })(\\n    e,\\n    await (async function (e, t, n, i, a, c) {\\n      const l = r.getConfig(e, r.ConfigKey.DebugOverrideEngine);\\n      if (l) return `/v1/engines/${l}`;\\n      const u = await e.get(o.Features).customEngine(t, n, i, a, c);\\n      return \\"\\" !== u ? `/v1/engines/${u}` : s;\\n    })(e, n, a, c, l, u)\\n  );\\n};","module-code-4969":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.extractPrompt =\\n  exports.trimLastLine =\\n  exports._contextTooShort =\\n  exports.MIN_PROMPT_CHARS =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"config_stuff\\"),\\n  i = require(1839),\\n  s = require(9189),\\n  a = require(3136),\\n  c = require(2533),\\n  l = require(766);\\nfunction trimLastLine(e) {\\n  const t = e.split(\\"\\\\n\\"),\\n    n = t[t.length - 1],\\n    r = n.length - n.trimRight().length,\\n    o = e.slice(0, e.length - r),\\n    i = e.substr(o.length);\\n  return [n.length == r ? o : e, i];\\n}\\nasync function d(e, n, d, p, h, f) {\\n  var m;\\n  const g =\\n      null !==\\n        (m = l.tryGetGitHubNWO(l.extractRepoInfoInBackground(e, h.fsPath))) &&\\n      undefined !== m\\n        ? m\\n        : \\"\\",\\n    _ = await o.suffixPercent(e, g, f),\\n    y = await o.fimSuffixLengthThreshold(e, g, f);\\n  if ((_ > 0 ? n.length : d) < exports.MIN_PROMPT_CHARS)\\n    return exports._contextTooShort;\\n  const v = Date.now(),\\n    {\\n      prefix: b,\\n      suffix: w,\\n      promptChoices: x,\\n      promptBackground: E,\\n      promptElementRanges: C,\\n    } = await (async function (e, t, n, u, d, p) {\\n      var h;\\n      let f = [];\\n      f = await (async function (e, t, n) {\\n        const r = [],\\n          o = i.sortByAccessTimes(e.get(a.TextDocumentManager).textDocuments);\\n        let s = 0;\\n        for (const i of o) {\\n          if (r.length + 1 > 20 || s + i.getText().length > 2e5) break;\\n          if (\\n            \\"file\\" == i.uri.scheme &&\\n            i.fileName !== t &&\\n            i.languageId === n\\n          ) {\\n            r.push({\\n              uri: i.uri.toString(),\\n              relativePath: await e\\n                .get(a.TextDocumentManager)\\n                .getRelativePath(i),\\n              languageId: i.languageId,\\n              source: i.getText(),\\n            });\\n            s += i.getText().length;\\n          }\\n        }\\n        return r;\\n      })(e, d.fsPath, p);\\n      const m = {\\n          uri: d.toString(),\\n          source: t,\\n          offset: n,\\n          relativePath: u,\\n          languageId: p,\\n        },\\n        g =\\n          null !==\\n            (h = l.tryGetGitHubNWO(\\n              l.extractRepoInfoInBackground(e, d.fsPath)\\n            )) && undefined !== h\\n            ? h\\n            : \\"\\";\\n      let _ = {\\n        maxPromptLength: 2048 - o.getConfig(e, o.ConfigKey.SolutionLength),\\n        neighboringTabs: await e.get(s.Features).neighboringTabsOption(g, p),\\n        suffixStartMode: await e.get(s.Features).suffixStartMode(g, p),\\n      };\\n      const y = await o.suffixPercent(e, g, p),\\n        v = await o.suffixMatchThreshold(e, g, p),\\n        b = await o.fimSuffixLengthThreshold(e, g, p);\\n      if (y > 0) {\\n        _ = {\\n          ..._,\\n          includeSiblingFunctions: r.SiblingOption.NoSiblings,\\n          suffixPercent: y,\\n          suffixMatchThreshold: v,\\n          fimSuffixLengthThreshold: b,\\n        };\\n      }\\n      const w = e.get(r.FileSystem);\\n      return await c.getPrompt(w, m, _, f);\\n    })(e, n, d, p, h, f),\\n    [S, T] = trimLastLine(b),\\n    k = Date.now();\\n  return {\\n    type: \\"prompt\\",\\n    prompt: {\\n      prefix: S,\\n      suffix: w,\\n      isFimEnabled: _ > 0 && w.length > y,\\n      promptElementRanges: C.ranges,\\n    },\\n    trailingWs: T,\\n    promptChoices: x,\\n    computeTimeMs: k - v,\\n    promptBackground: E,\\n  };\\n}\\nasync function p(e, t, n) {\\n  const r = await e.get(a.TextDocumentManager).getRelativePath(t);\\n  return d(e, t.getText(), t.offsetAt(n), r, t.uri, t.languageId);\\n}\\nexports.MIN_PROMPT_CHARS = 10;\\nexports._contextTooShort = {\\n  type: \\"contextTooShort\\",\\n};\\nexports.trimLastLine = trimLastLine;\\nexports.extractPrompt = function (e, t, n) {\\n  const r = e.get(a.TextDocumentManager).findNotebook(t);\\n  return undefined === r\\n    ? p(e, t, n)\\n    : (async function (e, t, n, r) {\\n        const o = n.getCells().find((e) => e.document.uri === t.uri);\\n        if (o) {\\n          const i = n\\n              .getCells()\\n              .filter(\\n                (e) =>\\n                  e.index < o.index &&\\n                  e.document.languageId === o.document.languageId\\n              ),\\n            s =\\n              i.length > 0\\n                ? i.map((e) => e.document.getText()).join(\\"\\\\n\\\\n\\") + \\"\\\\n\\\\n\\"\\n                : \\"\\",\\n            c = s + t.getText(),\\n            l = s.length + t.offsetAt(r),\\n            u = await e.get(a.TextDocumentManager).getRelativePath(t);\\n          return d(e, c, l, u, t.uri, o.document.languageId);\\n        }\\n        return p(e, t, r);\\n      })(e, t, r, n);\\n};","module-code-9189":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.Features = exports.Task = undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"clock\\"),\\n  i = require(3076),\\n  s = require(\\"config_stuff\\"),\\n  a = require(7744),\\n  c = require(9657),\\n  l = require(219),\\n  u = require(9748),\\n  d = require(8142),\\n  p = require(9030);\\nclass h {\\n  constructor(e) {\\n    this.ctx = e;\\n    this.cache = new i.LRUCache(200);\\n  }\\n  async fetchExpConfig(e) {\\n    let t = this.cache.get(e.stringify());\\n    if (t) {\\n      t = new Task(\\n        () =>\\n          this.ctx\\n            .get(u.ExpConfigMaker)\\n            .fetchExperiments(this.ctx, e.toHeaders()),\\n        36e5\\n      );\\n      this.cache.put(e.stringify(), t);\\n    }\\n    return t.run();\\n  }\\n  getCachedExpConfig(e) {\\n    const t = this.cache.get(e.stringify());\\n    return null == t ? undefined : t.value();\\n  }\\n}\\nclass Task {\\n  constructor(e, t = 1 / 0) {\\n    this.producer = e;\\n    this.expirationMs = t;\\n  }\\n  async run() {\\n    if (undefined === this.promise) {\\n      this.promise = this.producer();\\n      this.storeResult(this.promise).then(() => {\\n        if (this.expirationMs < 1 / 0 && undefined !== this.promise) {\\n          setTimeout(() => (this.promise = undefined), this.expirationMs);\\n        }\\n      });\\n    }\\n    return this.promise;\\n  }\\n  async storeResult(e) {\\n    try {\\n      this.result = await e;\\n    } finally {\\n      if (undefined === this.result) {\\n        this.promise = undefined;\\n      }\\n    }\\n  }\\n  value() {\\n    return this.result;\\n  }\\n}\\nexports.Task = Task;\\nclass Features {\\n  constructor(e) {\\n    this.ctx = e;\\n    this.staticFilters = {};\\n    this.dynamicFilters = {};\\n    this.upcomingDynamicFilters = {};\\n    this.assignments = new h(this.ctx);\\n    this.granularityDirectory = new p.GranularityDirectory(\\n      \\"unspecified\\",\\n      e.get(o.Clock)\\n    );\\n  }\\n  setPrefix(e) {\\n    this.granularityDirectory = new p.GranularityDirectory(\\n      e,\\n      this.ctx.get(o.Clock)\\n    );\\n  }\\n  registerStaticFilters(e) {\\n    Object.assign(this.staticFilters, e);\\n  }\\n  registerDynamicFilter(e, t) {\\n    this.dynamicFilters[e] = t;\\n  }\\n  getDynamicFilterValues() {\\n    const e = {};\\n    for (const [t, n] of Object.entries(this.dynamicFilters)) e[t] = n();\\n    return e;\\n  }\\n  registerUpcomingDynamicFilter(e, t) {\\n    this.upcomingDynamicFilters[e] = t;\\n  }\\n  async getAssignment(e, t = {}, n) {\\n    var r, o;\\n    const i = this.makeFilterSettings(t),\\n      s = this.granularityDirectory.extendFilters(i),\\n      a = await this.getExpConfig(s.newFilterSettings);\\n    this.granularityDirectory.update(\\n      i,\\n      +(null !==\\n        (r = a.variables[l.ExpTreatmentVariables.GranularityByCallBuckets]) &&\\n      undefined !== r\\n        ? r\\n        : NaN),\\n      +(null !==\\n        (o =\\n          a.variables[l.ExpTreatmentVariables.GranularityTimePeriodSizeInH]) &&\\n      undefined !== o\\n        ? o\\n        : NaN)\\n    );\\n    const c = this.granularityDirectory.extendFilters(i),\\n      u = c.newFilterSettings,\\n      d = await this.getExpConfig(u);\\n    let p = new Promise((e) =>\\n      setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\\n    );\\n    for (const e of c.otherFilterSettingsToPrefetch)\\n      p = p.then(async () => {\\n        await new Promise((e) =>\\n          setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\\n        );\\n        this.getExpConfig(e);\\n      });\\n    this.prepareForUpcomingFilters(u);\\n    if (n) {\\n      n.filtersAndExp = {\\n        exp: d,\\n        filters: u,\\n      };\\n    }\\n    return d.variables[e];\\n  }\\n  makeFilterSettings(e) {\\n    return new d.FilterSettings({\\n      ...this.staticFilters,\\n      ...this.getDynamicFilterValues(),\\n      ...e,\\n    });\\n  }\\n  async getExpConfig(e) {\\n    try {\\n      return this.assignments.fetchExpConfig(e);\\n    } catch (e) {\\n      return l.ExpConfig.createFallbackConfig(\\n        this.ctx,\\n        `Error fetching ExP config: ${e}`\\n      );\\n    }\\n  }\\n  async prepareForUpcomingFilters(e) {\\n    if (!(new Date().getMinutes() < 60 - Features.upcomingTimeBucketMinutes))\\n      for (const [t, n] of Object.entries(this.upcomingDynamicFilters)) {\\n        await new Promise((e) =>\\n          setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\\n        );\\n        this.getExpConfig(e.withChange(t, n()));\\n      }\\n  }\\n  stringify() {\\n    var e;\\n    const t = this.assignments.getCachedExpConfig(new d.FilterSettings({}));\\n    return JSON.stringify(\\n      null !== (e = null == t ? undefined : t.variables) && undefined !== e\\n        ? e\\n        : {}\\n    );\\n  }\\n  async customEngine(e, t, n, r, o) {\\n    var i;\\n    const s = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n      [d.Filter.CopilotDogfood]: n,\\n      [d.Filter.CopilotUserKind]: r,\\n    };\\n    return null !==\\n      (i = await this.getAssignment(\\n        l.ExpTreatmentVariables.CustomEngine,\\n        s,\\n        o\\n      )) && undefined !== i\\n      ? i\\n      : \\"\\";\\n  }\\n  async beforeRequestWaitMs(e, t, n) {\\n    var r;\\n    const o = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return null !==\\n      (r = await this.getAssignment(\\n        l.ExpTreatmentVariables.BeforeRequestWaitMs,\\n        o,\\n        n\\n      )) && undefined !== r\\n      ? r\\n      : 0;\\n  }\\n  async multiLogitBias(e, t, n) {\\n    var r;\\n    const o = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return (\\n      null !==\\n        (r = await this.getAssignment(\\n          l.ExpTreatmentVariables.MultiLogitBias,\\n          o,\\n          n\\n        )) &&\\n      undefined !== r &&\\n      r\\n    );\\n  }\\n  async debounceMs() {\\n    var e;\\n    return null !==\\n      (e = await this.getAssignment(l.ExpTreatmentVariables.DebounceMs)) &&\\n      undefined !== e\\n      ? e\\n      : 0;\\n  }\\n  async debouncePredict() {\\n    var e;\\n    return (\\n      null !==\\n        (e = await this.getAssignment(\\n          l.ExpTreatmentVariables.DebouncePredict\\n        )) &&\\n      undefined !== e &&\\n      e\\n    );\\n  }\\n  async contextualFilterEnable() {\\n    var e;\\n    return (\\n      null ===\\n        (e = await this.getAssignment(\\n          l.ExpTreatmentVariables.ContextualFilterEnable\\n        )) ||\\n      undefined === e ||\\n      e\\n    );\\n  }\\n  async contextualFilterAcceptThreshold() {\\n    var e;\\n    return null !==\\n      (e = await this.getAssignment(\\n        l.ExpTreatmentVariables.ContextualFilterAcceptThreshold\\n      )) && undefined !== e\\n      ? e\\n      : a.contextualFilterAcceptThreshold;\\n  }\\n  async disableLogProb() {\\n    var e;\\n    return (\\n      null !==\\n        (e = await this.getAssignment(\\n          l.ExpTreatmentVariables.disableLogProb\\n        )) &&\\n      undefined !== e &&\\n      e\\n    );\\n  }\\n  async overrideBlockMode() {\\n    return await this.getAssignment(l.ExpTreatmentVariables.OverrideBlockMode);\\n  }\\n  async overrideNumGhostCompletions() {\\n    return await this.getAssignment(\\n      l.ExpTreatmentVariables.OverrideNumGhostCompletions\\n    );\\n  }\\n  async suffixPercent(e, t) {\\n    var n;\\n    const r = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return s.getConfig(this.ctx, s.ConfigKey.DebugOverrideEngine)\\n      ? 0\\n      : null !==\\n          (n = await this.getAssignment(\\n            l.ExpTreatmentVariables.SuffixPercent,\\n            r\\n          )) && undefined !== n\\n      ? n\\n      : 0;\\n  }\\n  async suffixMatchThreshold(e, t) {\\n    var n;\\n    const r = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return null !==\\n      (n = await this.getAssignment(\\n        l.ExpTreatmentVariables.SuffixMatchThreshold,\\n        r\\n      )) && undefined !== n\\n      ? n\\n      : 0;\\n  }\\n  async fimSuffixLengthThreshold(e, t) {\\n    var n;\\n    const r = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return null !==\\n      (n = await this.getAssignment(\\n        l.ExpTreatmentVariables.FimSuffixLengthThreshold,\\n        r\\n      )) && undefined !== n\\n      ? n\\n      : 0;\\n  }\\n  async suffixStartMode(e, t) {\\n    const n = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    switch (\\n      await this.getAssignment(l.ExpTreatmentVariables.SuffixStartMode, n)\\n    ) {\\n      default:\\n        return r.SuffixStartMode.Cursor;\\n      case \\"cursortrimstart\\":\\n        return r.SuffixStartMode.CursorTrimStart;\\n      case \\"siblingblock\\":\\n        return r.SuffixStartMode.SiblingBlock;\\n      case \\"siblingblocktrimstart\\":\\n        return r.SuffixStartMode.SiblingBlockTrimStart;\\n    }\\n  }\\n  async neighboringTabsOption(e, t) {\\n    const n = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    switch (\\n      await this.getAssignment(l.ExpTreatmentVariables.NeighboringTabsOption, n)\\n    ) {\\n      case \\"none\\":\\n        return r.NeighboringTabsOption.None;\\n      case \\"conservative\\":\\n        return r.NeighboringTabsOption.Conservative;\\n      case \\"medium\\":\\n        return r.NeighboringTabsOption.Medium;\\n      default:\\n        return r.NeighboringTabsOption.Eager;\\n      case \\"eagerbutlittle\\":\\n        return r.NeighboringTabsOption.EagerButLittle;\\n    }\\n  }\\n  async repetitionFilterMode() {\\n    switch (\\n      await this.getAssignment(l.ExpTreatmentVariables.RepetitionFilterMode)\\n    ) {\\n      case \\"proxy\\":\\n        return c.RepetitionFilterMode.PROXY;\\n      case \\"both\\":\\n        return c.RepetitionFilterMode.BOTH;\\n      default:\\n        return c.RepetitionFilterMode.CLIENT;\\n    }\\n  }\\n  async addExpAndFilterToTelemetry(e) {\\n    const t = this.makeFilterSettings({});\\n    e.filtersAndExp = {\\n      filters: t,\\n      exp: await this.getExpConfig(t),\\n    };\\n  }\\n}\\nexports.Features = Features;\\nFeatures.upcomingDynamicFilterCheckDelayMs = 20;\\nFeatures.upcomingTimeBucketMinutes = 5 + Math.floor(11 * Math.random());","module-label-362":"copilot-github-auth-stuff","module-code-219":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ExpConfig = exports.ExpTreatmentVariables = undefined;\\nconst r = require(\\"telemetry-stuff\\"),\\n  o = require(6500);\\nvar i;\\n(i = exports.ExpTreatmentVariables || (exports.ExpTreatmentVariables = {})).AA =\\n  \\"copilotaa\\";\\ni.CustomEngine = \\"copilotcustomengine\\";\\ni.Fetcher = \\"copilotfetcher\\";\\ni.OverrideBlockMode = \\"copilotoverrideblockmode\\";\\ni.OverrideNumGhostCompletions = \\"copilotoverridednumghostcompletions\\";\\ni.SuffixPercent = \\"CopilotSuffixPercent\\";\\ni.BeforeRequestWaitMs = \\"copilotlms\\";\\ni.NeighboringTabsOption = \\"copilotneighboringtabs\\";\\ni.DebounceMs = \\"copilotdebouncems\\";\\ni.DebouncePredict = \\"copilotdebouncepredict\\";\\ni.ContextualFilterEnable = \\"copilotcontextualfilterenable\\";\\ni.ContextualFilterAcceptThreshold = \\"copilotcontextualfilteracceptthreshold\\";\\ni.disableLogProb = \\"copilotLogProb\\";\\ni.RepetitionFilterMode = \\"copilotrepetitionfiltermode\\";\\ni.GranularityTimePeriodSizeInH = \\"copilottimeperiodsizeinh\\";\\ni.GranularityByCallBuckets = \\"copilotbycallbuckets\\";\\ni.SuffixStartMode = \\"copilotsuffixstartmode\\";\\ni.SuffixMatchThreshold = \\"copilotsuffixmatchthreshold\\";\\ni.FimSuffixLengthThreshold = \\"copilotfimsuffixlenthreshold\\";\\ni.MultiLogitBias = \\"copilotlbeot\\";\\nclass ExpConfig {\\n  constructor(e, t, n) {\\n    this.variables = e;\\n    this.assignmentContext = t;\\n    this.features = n;\\n  }\\n  static createFallbackConfig(e, t) {\\n    r.telemetryExpProblem(e, {\\n      reason: t,\\n    });\\n    return this.createEmptyConfig();\\n  }\\n  static createEmptyConfig() {\\n    return new ExpConfig({}, \\"\\", \\"\\");\\n  }\\n  addToTelemetry(e) {\\n    e.properties[o.ExpServiceTelemetryNames.featuresTelemetryPropertyName] =\\n      this.features;\\n    e.properties[\\n      o.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName\\n    ] = this.assignmentContext;\\n  }\\n}\\nexports.ExpConfig = ExpConfig;","module-code-1006":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ghostTextScoreQuantile = exports.ghostTextScoreConfidence = undefined;\\nconst r = require(\\"logging-utils\\"),\\n  o = require(7481),\\n  i =\\n    (new r.Logger(r.LogLevel.INFO, \\"restraint\\"),\\n    {\\n      link: (e) => Math.exp(e) / (1 + Math.exp(e)),\\n      unlink: (e) => Math.log(e / (1 - e)),\\n    });\\nclass s {\\n  constructor(e, t, n) {\\n    this.name = e;\\n    this.coefficient = t;\\n    this.transformation = n || ((e) => e);\\n  }\\n  contribution(e) {\\n    return this.coefficient * this.transformation(e);\\n  }\\n}\\nconst a = new (class {\\n  constructor(e, t, n) {\\n    this.link = i;\\n    this.intercept = e;\\n    this.coefficients = t;\\n    this.logitsToQuantiles = new Map();\\n    this.logitsToQuantiles.set(0, 0);\\n    this.logitsToQuantiles.set(1, 1);\\n    if (n) for (const e in n) this.logitsToQuantiles.set(n[e], Number(e));\\n  }\\n  predict(e, t) {\\n    let n = this.intercept;\\n    for (const e of this.coefficients) {\\n      const r = t[e.name];\\n      if (undefined === r) return NaN;\\n      n += e.contribution(r);\\n    }\\n    return this.link.link(n);\\n  }\\n  quantile(e, t) {\\n    return (function (e, t) {\\n      const n = Math.min(...Array.from(t.keys()).filter((t) => t >= e)),\\n        r = Math.max(...Array.from(t.keys()).filter((t) => t < e)),\\n        o = t.get(n),\\n        i = t.get(r);\\n      return i + ((o - i) * (e - r)) / (n - r);\\n    })(this.predict(e, t), this.logitsToQuantiles);\\n  }\\n})(\\n  o.ghostTextDisplayInterceptParameter,\\n  [\\n    new s(\\"compCharLen\\", o.ghostTextDisplayLog1pcompCharLenParameter, (e) =>\\n      Math.log(1 + e)\\n    ),\\n    new s(\\"meanLogProb\\", o.ghostTextDisplayMeanLogProbParameter),\\n    new s(\\n      \\"meanAlternativeLogProb\\",\\n      o.ghostTextDisplayMeanAlternativeLogProbParameter\\n    ),\\n  ].concat(\\n    Object.entries(o.ghostTextDisplayLanguageParameters).map(\\n      (e) => new s(e[0], e[1])\\n    )\\n  ),\\n  o.ghostTextDisplayQuantiles\\n);\\nexports.ghostTextScoreConfidence = function (e, t) {\\n  const n = {\\n    ...t.measurements,\\n  };\\n  Object.keys(o.ghostTextDisplayLanguageParameters).forEach((e) => {\\n    n[e] = t.properties[\\"customDimensions.languageId\\"] == e ? 1 : 0;\\n  });\\n  return a.predict(e, n);\\n};\\nexports.ghostTextScoreQuantile = function (e, t) {\\n  const n = {\\n    ...t.measurements,\\n  };\\n  Object.keys(o.ghostTextDisplayLanguageParameters).forEach((e) => {\\n    n[e] = t.properties[\\"customDimensions.languageId\\"] == e ? 1 : 0;\\n  });\\n  return a.quantile(e, n);\\n};"}