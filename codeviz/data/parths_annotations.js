let parths_annotations = JSON.parse('{"module-label-3060":"copilot-vscode-cmds","module-label-3055306":"get-prompt-parsing-utils","module-code-6267":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.commandOpenPanel = exports.completionContextForEditor = undefined;\\nconst r = require(\\"vscode\\"),\\n  o = require(\\"completion-context\\");\\nfunction completionContextForEditor(e, t, n) {\\n  return n || o.completionContextForDocument(e, t.document, t.selection.active);\\n}\\nexports.completionContextForEditor = completionContextForEditor;\\nexports.commandOpenPanel = function (e, t) {\\n  const n = r.window.activeTextEditor;\\n  if (!n) return;\\n  if (!r.workspace.getConfiguration(\\"editor\\", n.document.uri).get(\\"codeLens\\"))\\n    return void r.window\\n      .showInformationMessage(\\n        \\"GitHub Copilot Panel requires having Code Lens enabled. Please update your settings and then try again.\\",\\n        \\"Open Settings\\"\\n      )\\n      .then((e) => {\\n        if (\\"Open Settings\\" === e) {\\n          r.commands.executeCommand(\\n            \\"workbench.action.openSettings\\",\\n            \\"editor.codeLens\\"\\n          );\\n        }\\n      });\\n  t = completionContextForEditor(e, n, t);\\n  const s = o.encodeLocation(n.document.uri, t),\\n    a = n.document.languageId;\\n  r.workspace.openTextDocument(s).then((e) => {\\n    r.languages.setTextDocumentLanguage(e, a);\\n    r.window.showTextDocument(e, r.ViewColumn.Beside);\\n  });\\n};","module-code-8965":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.contextualFilterScore =\\n  exports.getLastLineLength =\\n  exports.ContextualFilterManager =\\n    undefined;\\nconst r = require(\\"contextual-filter-constants\\");\\nclass ContextualFilterManager {\\n  constructor() {\\n    this.previousLabel = 0;\\n    this.previousLabelTimestamp = Date.now() - 3600;\\n    this.probabilityAccept = 0;\\n  }\\n}\\nfunction getLastLineLength(e) {\\n  const t = e.split(\\"\\\\n\\");\\n  return t[t.length - 1].length;\\n}\\nexports.ContextualFilterManager = ContextualFilterManager;\\nexports.getLastLineLength = getLastLineLength;\\nexports.contextualFilterScore = function (e, t, n) {\\n  const s = e.get(ContextualFilterManager),\\n    a = s.previousLabel;\\n  let c = 0;\\n  if (\\n    \\"afterCursorWhitespace\\" in t.properties &&\\n    \\"true\\" === t.properties.afterCursorWhitespace\\n  ) {\\n    c = 1;\\n  }\\n  const l = (Date.now() - s.previousLabelTimestamp) / 1e3,\\n    u = Math.log(1 + l);\\n  let d = 0,\\n    p = 0;\\n  const h = n.prefix;\\n  if (h) {\\n    d = Math.log(1 + getLastLineLength(h));\\n    const e = h.slice(-1);\\n    if (undefined !== r.contextualFilterCharacterMap[e]) {\\n      p = r.contextualFilterCharacterMap[e];\\n    }\\n  }\\n  let f = 0,\\n    m = 0;\\n  const g = h.trimEnd();\\n  if (g) {\\n    f = Math.log(1 + getLastLineLength(g));\\n    const e = g.slice(-1);\\n    if (undefined !== r.contextualFilterCharacterMap[e]) {\\n      m = r.contextualFilterCharacterMap[e];\\n    }\\n  }\\n  let _ = 0;\\n  if (\\"documentLength\\" in t.measurements) {\\n    const e = t.measurements.documentLength;\\n    _ = Math.log(1 + e);\\n  }\\n  let y = 0;\\n  if (\\"promptEndPos\\" in t.measurements) {\\n    const e = t.measurements.promptEndPos;\\n    y = Math.log(1 + e);\\n  }\\n  let v = 0;\\n  if (\\"promptEndPos\\" in t.measurements && \\"documentLength\\" in t.measurements) {\\n    const e = t.measurements.documentLength;\\n    v = (t.measurements.promptEndPos + 0.5) / (1 + e);\\n  }\\n  let b = 0;\\n  if (undefined !== r.contextualFilterLanguageMap[t.properties.languageId]) {\\n    b = r.contextualFilterLanguageMap[t.properties.languageId];\\n  }\\n  let w = r.contextualFilterIntercept;\\n  w += r.contextualFilterWeights[0] * a;\\n  w += r.contextualFilterWeights[1] * c;\\n  w += r.contextualFilterWeights[2] * u;\\n  w += r.contextualFilterWeights[3] * d;\\n  w += r.contextualFilterWeights[4] * f;\\n  w += r.contextualFilterWeights[5] * _;\\n  w += r.contextualFilterWeights[6] * y;\\n  w += r.contextualFilterWeights[7] * v;\\n  w += r.contextualFilterWeights[8 + b];\\n  w += r.contextualFilterWeights[29 + p];\\n  w += r.contextualFilterWeights[125 + m];\\n  const x = 1 / (1 + Math.exp(-w));\\n  e.get(ContextualFilterManager).probabilityAccept = x;\\n  return x;\\n};","module-code-8723":"var r = require(\\"http\\"),\\n  o = require(\\"https\\"),\\n  i = require(5282),\\n  s = require(5740),\\n  a = require(9036),\\n  c = require(8339),\\n  l = require(\\"correlation-context-manager\\"),\\n  u = require(9962),\\n  d = require(8090),\\n  p = require(7396),\\n  h = (function () {\\n    function e(t) {\\n      if (e.INSTANCE)\\n        throw new Error(\\n          \\"Client request tracking should be configured from the applicationInsights object\\"\\n        );\\n      e.INSTANCE = this;\\n      this._client = t;\\n    }\\n    e.prototype.enable = function (e) {\\n      this._isEnabled = e;\\n      if (this._isEnabled && !this._isInitialized) {\\n        this._initialize();\\n      }\\n      if (p.IsInitialized) {\\n        require(7886).wp(e, this._client);\\n        require(4777).wp(e, this._client);\\n        require(5071).wp(e, this._client);\\n        require(1227).wp(e, this._client);\\n      }\\n    };\\n    e.prototype.isInitialized = function () {\\n      return this._isInitialized;\\n    };\\n    e.prototype._initialize = function () {\\n      var t = this;\\n      this._isInitialized = !0;\\n      r.get;\\n      var n = r.request,\\n        i = o.request,\\n        s = function (n, r) {\\n          var o =\\n            !r[e.disableCollectionRequestOption] &&\\n            !n[e.alreadyAutoCollectedFlag];\\n          n[e.alreadyAutoCollectedFlag] = !0;\\n          if (n && r && o) {\\n            l.CorrelationContextManager.wrapEmitter(n);\\n            e.trackRequest(t._client, {\\n              options: r,\\n              request: n,\\n            });\\n          }\\n        };\\n      r.request = function (e) {\\n        for (var t = [], o = 1; o < arguments.length; o++)\\n          t[o - 1] = arguments[o];\\n        var i = n.call.apply(n, [r, e].concat(t));\\n        s(i, e);\\n        return i;\\n      };\\n      o.request = function (e) {\\n        for (var t = [], n = 1; n < arguments.length; n++)\\n          t[n - 1] = arguments[n];\\n        var r = i.call.apply(i, [o, e].concat(t));\\n        s(r, e);\\n        return r;\\n      };\\n      r.get = function (e) {\\n        for (var t = [], n = 1; n < arguments.length; n++)\\n          t[n - 1] = arguments[n];\\n        var o,\\n          i = (o = r.request).call.apply(o, [r, e].concat(t));\\n        i.end();\\n        return i;\\n      };\\n      o.get = function (e) {\\n        for (var t = [], n = 1; n < arguments.length; n++)\\n          t[n - 1] = arguments[n];\\n        var r,\\n          i = (r = o.request).call.apply(r, [o, e].concat(t));\\n        i.end();\\n        return i;\\n      };\\n    };\\n    e.trackRequest = function (t, n) {\\n      if (n.options && n.request && t) {\\n        var r,\\n          o,\\n          p = new c(n.options, n.request),\\n          h = l.CorrelationContextManager.getCurrentContext();\\n        if (\\n          h &&\\n          h.operation &&\\n          h.operation.traceparent &&\\n          d.isValidTraceId(h.operation.traceparent.traceId)\\n        ) {\\n          h.operation.traceparent.updateSpanId();\\n          r = h.operation.traceparent.getBackCompatRequestId();\\n        } else {\\n          if (u.w3cEnabled) {\\n            o = (m = new d()).toString();\\n            r = m.getBackCompatRequestId();\\n          } else {\\n            r =\\n              h &&\\n              h.operation &&\\n              h.operation.parentId + e.requestNumber++ + \\".\\";\\n          }\\n        }\\n        if (\\n          s.canIncludeCorrelationHeader(t, p.getUrl()) &&\\n          n.request.getHeader &&\\n          n.request.setHeader &&\\n          t.config &&\\n          t.config.correlationId\\n        ) {\\n          var f = n.request.getHeader(a.requestContextHeader);\\n          try {\\n            s.safeIncludeCorrelationHeader(t, n.request, f);\\n          } catch (e) {\\n            i.warn(\\n              \\"Request-Context header could not be set. Correlation of requests may be lost\\",\\n              e\\n            );\\n          }\\n          if (h && h.operation)\\n            try {\\n              if (\\n                (n.request.setHeader(a.requestIdHeader, r),\\n                n.request.setHeader(a.parentIdHeader, h.operation.id),\\n                n.request.setHeader(a.rootIdHeader, r),\\n                o || h.operation.traceparent)\\n              )\\n                n.request.setHeader(\\n                  a.traceparentHeader,\\n                  o || h.operation.traceparent.toString()\\n                );\\n              else if (u.w3cEnabled) {\\n                var m = new d().toString();\\n                n.request.setHeader(a.traceparentHeader, m);\\n              }\\n              if (h.operation.tracestate) {\\n                var g = h.operation.tracestate.toString();\\n                g && n.request.setHeader(a.traceStateHeader, g);\\n              }\\n              var _ = h.customProperties.serializeToHeader();\\n              _ && n.request.setHeader(a.correlationContextHeader, _);\\n            } catch (e) {\\n              i.warn(\\n                \\"Correlation headers could not be set. Correlation of requests may be lost.\\",\\n                e\\n              );\\n            }\\n        }\\n        if (n.request.on) {\\n          n.request.on(\\"response\\", function (e) {\\n            p.onResponse(e);\\n            var o = p.getDependencyTelemetry(n, r);\\n            o.contextObjects = o.contextObjects || {};\\n            o.contextObjects[\\"http.RequestOptions\\"] = n.options;\\n            o.contextObjects[\\"http.ClientRequest\\"] = n.request;\\n            o.contextObjects[\\"http.ClientResponse\\"] = e;\\n            t.trackDependency(o);\\n          });\\n          n.request.on(\\"error\\", function (e) {\\n            p.onError(e);\\n            var o = p.getDependencyTelemetry(n, r);\\n            o.contextObjects = o.contextObjects || {};\\n            o.contextObjects[\\"http.RequestOptions\\"] = n.options;\\n            o.contextObjects[\\"http.ClientRequest\\"] = n.request;\\n            o.contextObjects.Error = e;\\n            t.trackDependency(o);\\n          });\\n        }\\n      } else\\n        i.info(\\n          \\"AutoCollectHttpDependencies.trackRequest was called with invalid parameters: \\",\\n          !n.options,\\n          !n.request,\\n          !t\\n        );\\n    };\\n    e.prototype.dispose = function () {\\n      e.INSTANCE = null;\\n      this.enable(!1);\\n      this._isInitialized = !1;\\n    };\\n    e.disableCollectionRequestOption = \\"disableAppInsightsAutoCollection\\";\\n    e.requestNumber = 1;\\n    e.alreadyAutoCollectedFlag = \\"_appInsightsAutoCollected\\";\\n    return e;\\n  })();\\nmodule.exports = h;","module-label-6403":"location-factory","module-code-820":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getSiblingFunctionStart = exports.getSiblingFunctions = undefined;\\nconst r = require(1747),\\n  o = require(\\"get-prompt-parsing-utils\\");\\nexports.getSiblingFunctions = async function ({\\n  source: e,\\n  offset: t,\\n  languageId: n,\\n}) {\\n  var i, s;\\n  const a = [];\\n  let c = \\"\\",\\n    l = e.substring(0, t);\\n  if (o.isSupportedLanguageId(n)) {\\n    const u = await o.parseTree(n, e);\\n    try {\\n      let d = t;\\n      for (; d >= 0 && /\\\\s/.test(e[d]); ) d--;\\n      const p = u.rootNode.descendantForIndex(d),\\n        h = o.getAncestorWithSiblingFunctions(n, p);\\n      if (h) {\\n        const u = o.getFirstPrecedingComment(h),\\n          d =\\n            null !== (i = null == u ? undefined : u.startIndex) &&\\n            undefined !== i\\n              ? i\\n              : h.startIndex;\\n        let p,\\n          f = 0;\\n        for (; \\" \\" == (p = e[d - f - 1]) || \\"\\\\t\\" == p; ) f++;\\n        const m = e.substring(d - f, d);\\n        for (let i = h.nextSibling; i; i = i.nextSibling)\\n          if (o.isFunctionDefinition(n, i)) {\\n            const n = o.getFirstPrecedingComment(i),\\n              c =\\n                null !== (s = null == n ? undefined : n.startIndex) &&\\n                undefined !== s\\n                  ? s\\n                  : i.startIndex;\\n            if (c < t) continue;\\n            const l = e.substring(c, i.endIndex),\\n              u = r.newLineEnded(l) + \\"\\\\n\\" + m;\\n            a.push(u);\\n          }\\n        c = e.substring(0, d);\\n        l = e.substring(d, t);\\n      }\\n    } finally {\\n      u.delete();\\n    }\\n  }\\n  return {\\n    siblings: a,\\n    beforeInsertion: c,\\n    afterInsertion: l,\\n  };\\n};\\nexports.getSiblingFunctionStart = async function ({\\n  source: e,\\n  offset: t,\\n  languageId: n,\\n}) {\\n  var r;\\n  if (o.isSupportedLanguageId(n)) {\\n    const i = await o.parseTree(n, e);\\n    try {\\n      let s = t;\\n      for (; s >= 0 && /\\\\s/.test(e[s]); ) s--;\\n      const a = i.rootNode.descendantForIndex(s),\\n        c = o.getAncestorWithSiblingFunctions(n, a);\\n      if (c) {\\n        for (let e = c.nextSibling; e; e = e.nextSibling)\\n          if (o.isFunctionDefinition(n, e)) {\\n            const n = o.getFirstPrecedingComment(e),\\n              i =\\n                null !== (r = null == n ? undefined : n.startIndex) &&\\n                undefined !== r\\n                  ? r\\n                  : e.startIndex;\\n            if (i < t) continue;\\n            return i;\\n          }\\n        if (c.endIndex >= t) return c.endIndex;\\n      }\\n    } finally {\\n      i.delete();\\n    }\\n  }\\n  return t;\\n};","module-label-3055417":"language-marker-constants","module-code-893":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.CopilotListDocument = undefined;\\nconst r = require(\\"debouncer\\"),\\n  o = require(\\"config-stuff\\"),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(\\"completion-normalizer\\");\\nclass CopilotListDocument {\\n  constructor(e, t, n, s, a, c) {\\n    this.targetDocument = n;\\n    this.completionContext = s;\\n    this.token = c;\\n    this._solutionCount = 0;\\n    this.solutionCountTarget = 0;\\n    this._solutions = [];\\n    this._wasCancelled = !1;\\n    this._updateHandlers = new Set();\\n    this.savedTelemetryData = i.TelemetryData.createAndMarkAsIssued();\\n    this.debouncedEventFire = r.debounce(10, () =>\\n      this._updateHandlers.forEach((e) => e(this._uri))\\n    );\\n    this.onDidResultUpdated = (e) => (\\n      this._updateHandlers.add(e),\\n      {\\n        dispose: () => {\\n          this._updateHandlers.delete(e);\\n        },\\n      }\\n    );\\n    this.solutionCountTarget = a;\\n    this._ctx = e;\\n    this._uri = t;\\n    this._showLogprobs = o.getConfig(e, o.ConfigKey.DebugShowScores);\\n    this.startPosition = this.completionContext.insertPosition;\\n    this.numberHeaderLines = Math.max(\\n      1,\\n      this.formatDisplayLines(\\"\\").length - 1\\n    );\\n  }\\n  async getDocument() {\\n    return this.targetDocument;\\n  }\\n  get targetUri() {\\n    return this.targetDocument.uri;\\n  }\\n  header() {\\n    if (this._wasCancelled) return \\"No synthesized solutions found.\\";\\n    {\\n      const e =\\n        this._solutionCount - this._solutions.length > 0\\n          ? \\" (Duplicates hidden)\\"\\n          : \\"\\";\\n      return `Synthesizing ${this._solutionCount}/${this.solutionCountTarget} solutions${e}`;\\n    }\\n  }\\n  areSolutionsDuplicates(e, t) {\\n    return (\\n      s.normalizeCompletionText(e.completionText) ===\\n      s.normalizeCompletionText(t.completionText)\\n    );\\n  }\\n  insertSorted(e, t, n) {\\n    if (!/^\\\\s*$/.test(t.completionText)) {\\n      for (let r = 0; r < e.length; r++) {\\n        const o = e[r];\\n        if (this.areSolutionsDuplicates(o, t)) {\\n          if (n(o) < n(t)) {\\n            e.splice(r, 1);\\n            break;\\n          }\\n          return;\\n        }\\n      }\\n      for (let r = 0; r < e.length; r++)\\n        if (n(e[r]) < n(t)) return void e.splice(r, 0, t);\\n      e.push(t);\\n    }\\n  }\\n  reportCancelled() {\\n    this._wasCancelled = !0;\\n    this.debouncedEventFire();\\n  }\\n  getCancellationToken() {\\n    return this.token;\\n  }\\n  insertSolution(e) {\\n    const t = {\\n      displayLines: this.formatDisplayLines(\\n        e.displayText,\\n        e.meanProb,\\n        e.meanLogProb\\n      ),\\n      completionText: e.completionText,\\n      meanLogProb: e.meanLogProb,\\n      meanProb: e.meanProb,\\n      prependToCompletion: e.prependToCompletion,\\n      requestId: e.requestId,\\n      choiceIndex: e.choiceIndex,\\n    };\\n    this.insertSorted(this._solutions, t, (e) => e.meanProb);\\n    this._solutionCount++;\\n    this.debouncedEventFire();\\n  }\\n  formatDisplayLines(e, t, n) {\\n    let r = \\"\\";\\n    if (this._showLogprobs) {\\n      n = n || 0;\\n      r += `\\\\n\\\\t# mean prob: ${t}`;\\n    }\\n    return `${CopilotListDocument.separator}${r}\\\\n\\\\n${e}`.split(\\"\\\\n\\");\\n  }\\n  async runQuery() {\\n    const e = await s.launchSolutions(this._ctx, this);\\n    this.processNextSolution(e);\\n  }\\n  async processNextSolution(e) {\\n    switch (e.status) {\\n      case \\"FinishedNormally\\":\\n      case \\"FinishedWithError\\":\\n        return;\\n      case \\"Solution\\":\\n        this.insertSolution(e.solution);\\n        this.processNextSolution(await e.next);\\n    }\\n  }\\n  solutionsReceived() {\\n    return this._solutionCount;\\n  }\\n  solutions() {\\n    return this._solutions;\\n  }\\n  get value() {\\n    return [this.header()]\\n      .concat(this._solutions.flatMap((e) => e.displayLines))\\n      .concat(\\"\\")\\n      .join(\\"\\\\n\\");\\n  }\\n}\\nexports.CopilotListDocument = CopilotListDocument;\\nCopilotListDocument.separator = \\"\\\\n=======\\";","module-label-3055876":"parse-tree-utils","module-code-2990":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.CopilotPanel = undefined;\\nconst r = require(9496),\\n  o = require(\\"config-stuff\\"),\\n  i = require(\\"copilot-scheme\\"),\\n  s = require(\\"completion-context\\"),\\n  a = require(\\"copilot-list-doc\\"),\\n  c = require(\\"post-accept-or-reject-tasks\\"),\\n  l = require(\\"copilot-vscode-cmds\\");\\nexports.CopilotPanel = class {\\n  constructor(e) {\\n    this._onDidChange = new r.EventEmitter();\\n    this._documents = new Map();\\n    this._editorDecoration = r.window.createTextEditorDecorationType({\\n      textDecoration: \\"underline\\",\\n    });\\n    this._ctx = e;\\n    this._subscriptions = r.workspace.onDidCloseTextDocument((e) => {\\n      if (e.isClosed && e.uri.scheme == i.CopilotScheme) {\\n        this._documents.delete(e.uri.toString());\\n      }\\n    });\\n  }\\n  dispose() {\\n    this._subscriptions.dispose();\\n    this._documents.clear();\\n    this._editorDecoration.dispose();\\n    this._onDidChange.dispose();\\n  }\\n  get onDidChange() {\\n    return this._onDidChange.event;\\n  }\\n  async provideTextDocumentContent(e) {\\n    var t;\\n    let n =\\n      null === (t = this._documents.get(e.toString())) || undefined === t\\n        ? undefined\\n        : t.model;\\n    if (n) return n.value;\\n    const i = new r.CancellationTokenSource(),\\n      [c, l] = s.decodeLocation(this._ctx, e),\\n      u = await r.workspace.openTextDocument(c);\\n    n = new a.CopilotListDocument(\\n      this._ctx,\\n      e,\\n      u,\\n      l,\\n      o.getConfig(this._ctx, o.ConfigKey.ListCount),\\n      i.token\\n    );\\n    n.onDidResultUpdated((e) => this._onDidChange.fire(e));\\n    this._documents.set(e.toString(), {\\n      model: n,\\n      cts: i,\\n    });\\n    n.runQuery();\\n    return n.value;\\n  }\\n  getCodeLens(e) {\\n    const t = e.model;\\n    let n = t.numberHeaderLines;\\n    const o = t.completionContext.insertPosition,\\n      i = a.CopilotListDocument.separator.split(\\"\\\\n\\").length - 1;\\n    return t.solutions().map((a, u) => {\\n      const d = new r.Position(n + i, 0),\\n        p = new r.Position(n + a.displayLines.length - 1, 0),\\n        h = t.savedTelemetryData.extendedBy(\\n          {\\n            choiceIndex: a.choiceIndex.toString(),\\n          },\\n          {\\n            compCharLen: a.completionText.length,\\n            meanProb: a.meanProb,\\n            rank: u,\\n          }\\n        );\\n      h.extendWithRequestId(a.requestId);\\n      h.markAsDisplayed();\\n      const f = new r.CodeLens(new r.Range(d, p), {\\n        title: \\"Accept Solution\\",\\n        tooltip: \\"Replace code with this solution\\",\\n        command: l.CMDAcceptPanelSolution,\\n        arguments: [\\n          t.targetUri,\\n          o,\\n          a.completionText,\\n          t.completionContext.completionType ===\\n            s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX,\\n          async () => {\\n            const n = (\\n              await r.workspace.openTextDocument(t.targetUri)\\n            ).offsetAt(o);\\n            e.cts.cancel();\\n            await c.postInsertionTasks(\\n              this._ctx,\\n              \\"solution\\",\\n              a.completionText,\\n              n,\\n              t.targetUri,\\n              h\\n            );\\n          },\\n        ],\\n      });\\n      n += a.displayLines.length;\\n      return f;\\n    });\\n  }\\n  provideCodeLenses(e, t) {\\n    const n = this._documents.get(e.uri.toString());\\n    if (n) return this.getCodeLens(n);\\n  }\\n};","module-code-7727":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.indentationBlockFinished =\\n  exports.completionCutOrContinue =\\n  exports.contextIndentationFromText =\\n  exports.contextIndentation =\\n  exports.getNodeStart =\\n  exports.isBlockBodyFinishedWithPrefix =\\n  exports.isBlockBodyFinished =\\n  exports.isEmptyBlockStart =\\n    undefined;\\nconst r = require(\\"location-factory\\"),\\n  o = require(2533);\\nexports.isEmptyBlockStart = function (e, t) {\\n  return o.isEmptyBlockStart(e.languageId, e.getText(), e.offsetAt(t));\\n};\\nexports.isBlockBodyFinished = function (e, t, n, i) {\\n  const s = e.get(r.LocationFactory),\\n    a = t.getText(s.range(s.position(0, 0), n)),\\n    c = t.offsetAt(n);\\n  return o.isBlockBodyFinished(t.languageId, a, i, c);\\n};\\nexports.isBlockBodyFinishedWithPrefix = function (e, t, n, i, s) {\\n  const a = e.get(r.LocationFactory),\\n    c = t.getText(a.range(a.position(0, 0), n)),\\n    l = t.offsetAt(n);\\n  return o.isBlockBodyFinished(t.languageId, c + s, i, l + s.length);\\n};\\nexports.getNodeStart = async function (e, t, n, i) {\\n  const s = e.get(r.LocationFactory),\\n    a = t.getText(s.range(s.position(0, 0), n)) + i,\\n    c = await o.getNodeStart(t.languageId, a, t.offsetAt(n));\\n  if (c) return t.positionAt(c);\\n};\\nconst i = [\\"\\\\\\\\{\\", \\"\\\\\\\\}\\", \\"\\\\\\\\[\\", \\"\\\\\\\\]\\", \\"\\\\\\\\(\\", \\"\\\\\\\\)\\"].concat(\\n    [\\n      \\"then\\",\\n      \\"else\\",\\n      \\"elseif\\",\\n      \\"elif\\",\\n      \\"catch\\",\\n      \\"finally\\",\\n      \\"fi\\",\\n      \\"done\\",\\n      \\"end\\",\\n      \\"loop\\",\\n      \\"until\\",\\n      \\"where\\",\\n      \\"when\\",\\n    ].map((e) => e + \\"\\\\\\\\b\\")\\n  ),\\n  s = new RegExp(`^(${i.join(\\"|\\")})`);\\nfunction a(e) {\\n  return s.test(e.trimLeft().toLowerCase());\\n}\\nfunction c(e) {\\n  const t = /^(\\\\s*)([^]*)$/.exec(e);\\n  return t && t[2] && t[2].length > 0 ? t[1].length : undefined;\\n}\\nfunction contextIndentationFromText(e, t, n) {\\n  const r = e.slice(0, t).split(\\"\\\\n\\"),\\n    o = e.slice(t).split(\\"\\\\n\\");\\n  function i(e, t, r) {\\n    let o,\\n      i,\\n      s = t;\\n    for (; undefined === o && s >= 0 && s < e.length; ) {\\n      o = c(e[s]);\\n      i = s;\\n      s += r;\\n    }\\n    if (\\"python\\" === n && -1 === r) {\\n      s++;\\n      const t = e[s].trim();\\n      if (t.endsWith(\'\\"\\"\\"\')) {\\n        if (!t.startsWith(\'\\"\\"\\"\') || \'\\"\\"\\"\' === t)\\n          for (s--; s >= 0 && !e[s].trim().startsWith(\'\\"\\"\\"\'); ) s--;\\n        if (s >= 0)\\n          for (o = undefined, s--; undefined === o && s >= 0; ) {\\n            o = c(e[s]);\\n            i = s;\\n            s--;\\n          }\\n      }\\n    }\\n    return [o, i];\\n  }\\n  const [s, a] = i(r, r.length - 1, -1),\\n    l = (() => {\\n      if (undefined !== s && undefined !== a)\\n        for (let e = a - 1; e >= 0; e--) {\\n          const t = c(r[e]);\\n          if (undefined !== t && t < s) return t;\\n        }\\n    })(),\\n    [u] = i(o, 1, 1);\\n  return {\\n    prev: l,\\n    current: null != s ? s : 0,\\n    next: u,\\n  };\\n}\\nfunction completionCutOrContinue(e, t, n) {\\n  var r;\\n  const o = e.split(\\"\\\\n\\"),\\n    i = undefined !== n,\\n    s = null == n ? undefined : n.split(\\"\\\\n\\").pop();\\n  let l = 0;\\n  if (i && \\"\\" != (null == s ? undefined : s.trim()) && \\"\\" !== o[0].trim()) {\\n    l++;\\n  }\\n  if (i) {\\n    l++;\\n  }\\n  if (o.length === l) return \\"continue\\";\\n  const u = Math.max(\\n    t.current,\\n    null !== (r = t.next) && undefined !== r ? r : 0\\n  );\\n  for (let e = l; e < o.length; e++) {\\n    let t = o[e];\\n    if (0 == e && undefined !== s) {\\n      t = s + t;\\n    }\\n    const n = c(t);\\n    if (undefined !== n && (n < u || (n === u && !a(t))))\\n      return o.slice(0, e).join(\\"\\\\n\\").length;\\n  }\\n  return \\"continue\\";\\n}\\nexports.contextIndentation = function (e, t) {\\n  return contextIndentationFromText(e.getText(), e.offsetAt(t), e.languageId);\\n};\\nexports.contextIndentationFromText = contextIndentationFromText;\\nexports.completionCutOrContinue = completionCutOrContinue;\\nexports.indentationBlockFinished = function (e, t) {\\n  return async (n) => {\\n    const r = completionCutOrContinue(n, e, t);\\n    return \\"continue\\" === r ? undefined : r;\\n  };\\n};","module-label-4723":"worker-utils-and-other-prompt-collection-stuff","module-label-2388":"completion-normalizer","module-label-9574":"telemetry-client-manager","module-code-main":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.deactivate = exports.activate = exports.init = undefined;\\nconst t = require(\\"getPrompt-main-stuff\\");\\nrequire(406);\\nconst o = require(\\"vscode\\"),\\n  i = require(\\"copilot-github-auth-stuff\\"),\\n  s = require(\\"clock\\"),\\n  a = require(\\"config-stuff\\"),\\n  c = require(\\"copilot-scheme\\"),\\n  l = require(\\"context\\"),\\n  u = require(\\"nightly-telemetry-stuff\\"),\\n  d = require(\\"doc-tracker\\"),\\n  p = require(9189),\\n  h = require(9748),\\n  f = require(\\"contextual-filter-manager\\"),\\n  m = require(5413),\\n  g = require(\\"logging-utils\\"),\\n  _ = require(\\"helix-fetcher-and-network-stuff\\"),\\n  y = require(1547),\\n  v = require(\\"live-openai-fetcher\\"),\\n  b = require(6722),\\n  w = require(2533),\\n  x = require(\\"background-context-provider\\"),\\n  E = require(\\"telemetry-stuff\\"),\\n  C = require(956),\\n  S = require(70),\\n  T = require(8771),\\n  k = require(\\"location-factory\\"),\\n  I = require(\\"text-doc-relative-path\\"),\\n  P = require(\\"url-opener\\"),\\n  A = require(\\"inline-completion-provider\\"),\\n  O = require(1862),\\n  N = require(\\"vscode-utils\\"),\\n  R = require(\\"copilot-vscode-cmds\\"),\\n  M = (require(\\"open-copilot-action-provider\\"), require(6267)),\\n  L = require(\\"copilot-panel\\"),\\n  $ = require(6857),\\n  D = require(9477),\\n  F = require(\\"copilot-status-bar\\"),\\n  j = require(\\"telemetry-wrapper\\"),\\n  q = require(\\"extension-location-factory\\"),\\n  B = require(\\"text-doc-manager\\"),\\n  U = o.window.createOutputChannel(\\"GitHub Copilot\\");\\nfunction init() {\\n  _.init(new a.BuildInfo().getVersion());\\n}\\nfunction z(e, t, n) {\\n  return o.commands.registerCommand(t, async (...r) => {\\n    try {\\n      return await n(...r);\\n    } catch (n) {\\n      E.telemetryException(e, n, t);\\n    }\\n  });\\n}\\nlet G;\\nexports.init = init;\\ninit();\\nexports.activate = async function (e) {\\n  const n = new l.Context();\\n  n.set(a.ConfigProvider, new N.VSCodeConfigProvider());\\n  n.set(s.Clock, new s.Clock());\\n  n.set(a.BuildInfo, new a.BuildInfo());\\n  n.set(a.EditorAndPluginInfo, new N.VSCodeEditorInfo());\\n  n.set(g.LogVerbose, new g.LogVerbose(!1));\\n  n.set(m.GhostTextDebounceManager, new m.GhostTextDebounceManager());\\n  n.set(f.ContextualFilterManager, new f.ContextualFilterManager());\\n  const r = new g.MultiLog([\\n    new g.ConsoleLog(console),\\n    new g.OutputChannelLog(U),\\n  ]);\\n  n.set(g.LogTarget, r);\\n  n.set(k.LocationFactory, new q.ExtensionLocationFactory());\\n  n.set(I.TextDocumentManager, new B.ExtensionTextDocumentManager());\\n  n.set(p.Features, new p.Features(n));\\n  const H = new _.HelixFetcher(n);\\n  n.set(_.Fetcher, H);\\n  D.initProxyEnvironment(H, process.env);\\n  n.set(t.FileSystem, $.extensionFileSystem);\\n  n.set(y.NotificationSender, new O.ExtensionNotificationSender());\\n  n.set(E.TelemetryEndpointUrl, new E.TelemetryEndpointUrl());\\n  if (e.extensionMode === o.ExtensionMode.Test) {\\n    n.set(i.CopilotTokenManager, C.makeTestingCopilotTokenManager());\\n    n.set(a.VscInfo, a.getTestVscInfo());\\n    n.set(S.RuntimeMode, S.RuntimeMode.fromEnvironment(!0));\\n    n.set(h.ExpConfigMaker, new h.ExpConfigNone());\\n    n.set(E.TelemetryReporters, E.setupStandardReporters(n, \\"copilot-test\\"));\\n    n.set(P.UrlOpener, new T.TestUrlOpener());\\n  } else {\\n    n.set(i.CopilotTokenManager, new O.VSCodeCopilotTokenManager());\\n    n.set(a.VscInfo, N.makeVscInfo());\\n    n.set(v.OpenAIFetcher, new v.LiveOpenAIFetcher());\\n    n.set(a.BlockModeConfig, new a.ConfigBlockModeConfig());\\n    n.set(S.RuntimeMode, S.RuntimeMode.fromEnvironment(!1));\\n    n.set(h.ExpConfigMaker, new h.ExpConfigFromTAS());\\n    n.set(E.TelemetryReporters, j.activate(n, e));\\n    n.set(P.UrlOpener, new P.RealUrlOpener());\\n  }\\n  if (\\"GitHub.copilot-nightly\\" === e.extension.id) {\\n    u.registerDefaultHandlers(n, \\"vscode\\");\\n  }\\n  N.setExtension(e.extension);\\n  O.setExtensionContext(e);\\n  e.globalState.setKeysForSync([O.telemetryAcceptanceKey]);\\n  const V = a.getBuildType(n) === a.BuildType.DEV,\\n    W = \\"GitHub.copilot-nightly\\" === e.extension.id;\\n  if (W && o.extensions.all.find((e) => \\"GitHub.copilot\\" === e.id))\\n    return void (\\n      \\"Uninstall\\" ===\\n        (await o.window.showWarningMessage(\\n          \\"To use GitHub Copilot Nightly you need to uninstall GitHub Copilot extension\\",\\n          \\"Uninstall\\"\\n        )) &&\\n      (await o.commands.executeCommand(\\n        \\"workbench.extensions.uninstallExtension\\",\\n        \\"GitHub.copilot\\"\\n      ))\\n    );\\n  if (W || V) {\\n    o.commands.executeCommand(\\"setContext\\", \\"github.copilot.nightly\\", !0);\\n  }\\n  const K = (function (e, t) {\\n    const n = new F.CopilotStatusBar(e);\\n    t.subscriptions.push(\\n      z(e, R.CMDToggleCopilot, () => {\\n        n.toggleStatusBar();\\n      })\\n    );\\n    t.subscriptions.push(\\n      z(e, R.CMDShowActivationErrors, () => {\\n        n.showActivationErrors(U);\\n      })\\n    );\\n    t.subscriptions.push(n.getStatusBarItem());\\n    return n;\\n  })(n, e);\\n  n.set(b.StatusReporter, K);\\n  const J = async () => {\\n    try {\\n      await n.get(i.CopilotTokenManager).getCopilotToken(n);\\n    } catch (e) {\\n      const t = e.message || e;\\n      E.telemetryError(\\n        n,\\n        \\"activationFailed\\",\\n        E.TelemetryData.createAndMarkAsIssued({\\n          reason: t,\\n        })\\n      );\\n      n.get(E.TelemetryReporters).deactivate();\\n      const r = `GitHub Copilot could not connect to server. Extension activation failed: \\"${t}\\"`;\\n      K.setError(r, J);\\n      g.logger.error(n, r);\\n      return void o.commands.executeCommand(\\n        \\"setContext\\",\\n        \\"github.copilot.activated\\",\\n        !1\\n      );\\n    }\\n    K.forceNormal();\\n    o.commands.executeCommand(\\"setContext\\", \\"github.copilot.activated\\", !0);\\n    e.subscriptions.push(\\n      z(n, R.CMDOpenPanel, () => {\\n        o.commands.executeCommand(\\"editor.action.inlineSuggest.hide\\");\\n        M.commandOpenPanel(n);\\n      })\\n    );\\n    e.subscriptions.push(\\n      z(n, R.CMDOpenPanelForRange, (e) => {\\n        M.commandOpenPanel(n, e);\\n      }),\\n      z(n, R.CMDAcceptPanelSolution, async (e, t, n, r, i) => {\\n        const s = new o.WorkspaceEdit();\\n        s.insert(e, t, n);\\n        await o.workspace.applyEdit(s);\\n        i();\\n        await o.commands.executeCommand(\\"workbench.action.closeActiveEditor\\");\\n        if (\\n          r &&\\n          o.window.activeTextEditor &&\\n          o.window.activeTextEditor.document.uri.toString() === e.toString()\\n        ) {\\n          const e = t.translate(1).with(void 0, 0),\\n            n = new o.Selection(e, e);\\n          o.window.activeTextEditor.selection = n;\\n        }\\n      })\\n    );\\n    e.subscriptions.push(\\n      z(n, R.CMDSendFeedback, () => {\\n        o.env.openExternal(\\n          o.Uri.parse(\\n            \\"https://github.com/github/feedback/discussions/categories/copilot\\"\\n          )\\n        );\\n      })\\n    );\\n    const t = new L.CopilotPanel(n);\\n    e.subscriptions.push(\\n      o.workspace.registerTextDocumentContentProvider(c.CopilotScheme, t),\\n      o.languages.registerCodeLensProvider(\\n        {\\n          scheme: c.CopilotScheme,\\n        },\\n        t\\n      )\\n    );\\n    try {\\n      e.subscriptions.push(...A.registerGhostText(n));\\n      const t = o.workspace.getConfiguration(),\\n        r = t.inspect(\\"editor.inlineSuggest.enabled\\");\\n      if (undefined === (null == r ? undefined : r.globalValue)) {\\n        t.update(\\n          \\"editor.inlineSuggest.enabled\\",\\n          !0,\\n          o.ConfigurationTarget.Global\\n        );\\n      }\\n    } catch (e) {\\n      o.window.showErrorMessage(\\n        \\"GitHub Copilot requires VS Code 1.57+. Please update your VS Code\\"\\n      );\\n    }\\n    e.subscriptions.push(d.registerDocumentTracker(n));\\n    e.subscriptions.push(\\n      o.window.onDidChangeActiveTextEditor((e) =>\\n        e\\n          ? e.document.isUntitled ||\\n            (\\"file\\" === e.document.uri.scheme &&\\n              x.extractRepoInfoInBackground(n, e.document.fileName))\\n          : undefined\\n      )\\n    );\\n    const r = e.extensionMode !== o.ExtensionMode.Development;\\n    w.init(n, r, new g.Logger(g.LogLevel.INFO, \\"promptlib proxy\\"));\\n    E.telemetry(n, \\"extension.activate\\");\\n    G = n;\\n  };\\n  await J();\\n};\\nexports.deactivate = function () {\\n  if (G) {\\n    E.telemetry(G, \\"extension.deactivate\\");\\n    G.get(E.TelemetryReporters).deactivate();\\n  }\\n  w.terminate();\\n};","module-label-3458":"git-url-parser","module-label-3055312":"get-prompt-actual","module-label-9334":"ghost-text-provider","module-label-3055456":"prompt-choices-and-wishlist","module-label-1259":"telemetry-client","module-code-2901":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.prepareSolutionForReturn =\\n  exports.processSSE =\\n  exports.splitChunk =\\n    undefined;\\nconst r = require(\\"logging-utils\\"),\\n  o = require(\\"telemetry-stuff\\"),\\n  i = require(\\"openai-choices-utils\\"),\\n  s = new r.Logger(r.LogLevel.INFO, \\"streamChoices\\");\\nfunction splitChunk(e) {\\n  const t = e.split(\\"\\\\n\\"),\\n    n = t.pop();\\n  return [t.filter((e) => \\"\\" != e), n];\\n}\\nexports.splitChunk = splitChunk;\\nexports.processSSE = async function* (e, t, n, r, c) {\\n  var l, u, d, p, h, f, m, g, _;\\n  const y = await t.body();\\n  y.setEncoding(\\"utf8\\");\\n  let v = i.getRequestId(t);\\n  s.debug(e, `requestId: ${v.headerRequestId}`);\\n  const b = {};\\n  let w = \\"\\";\\n  for await (const x of y) {\\n    if (null == c ? undefined : c.isCancellationRequested) {\\n      s.info(e, \\"Cancelled after awaiting body chunk\\");\\n      return void y.destroy();\\n    }\\n    s.debug(e, \\"chunk\\", x.toString());\\n    const [E, C] = splitChunk(w + x.toString());\\n    w = C;\\n    for (const a of E) {\\n      const w = a.slice(\\"data:\\".length).trim();\\n      if (\\"[DONE]\\" == w) {\\n        for (const [t, n] of Object.entries(b)) {\\n          const r = Number(t);\\n          if (\\n            null != n &&\\n            (yield {\\n              solution: n,\\n              finishOffset: undefined,\\n              reason: \\"DONE\\",\\n              requestId: v,\\n              index: r,\\n            },\\n            null == c ? undefined : c.isCancellationRequested)\\n          ) {\\n            s.debug(e, \\"Cancelled after yielding on DONE\\");\\n            return void y.destroy();\\n          }\\n        }\\n        return;\\n      }\\n      let x;\\n      try {\\n        x = JSON.parse(w);\\n      } catch (t) {\\n        s.error(e, \\"Error parsing JSON stream data\\", a);\\n        continue;\\n      }\\n      if (undefined !== x.choices || undefined === x.error) {\\n        if (0 == v.created) {\\n          v = i.getRequestId(t, x);\\n          if (0 == v.created) {\\n            s.error(\\n              e,\\n              `Request id invalid, should have \\"completionId\\" and \\"created\\": ${v}`,\\n              v\\n            );\\n          }\\n        }\\n        for (let t = 0; t < x.choices.length; t++) {\\n          const i = x.choices[t];\\n          s.debug(e, \\"choice\\", i);\\n          if (i.index in b) {\\n            b[i.index] = {\\n              logprobs: [],\\n              top_logprobs: [],\\n              text: [],\\n              text_offset: [],\\n              tokens: [],\\n            };\\n          }\\n          const a = b[i.index];\\n          if (null == a) continue;\\n          let w;\\n          a.text.push(i.text);\\n          a.tokens.push(\\n            null !==\\n              (u =\\n                null === (l = i.logprobs) || undefined === l\\n                  ? undefined\\n                  : l.tokens) && undefined !== u\\n              ? u\\n              : []\\n          );\\n          a.text_offset.push(\\n            null !==\\n              (p =\\n                null === (d = i.logprobs) || undefined === d\\n                  ? undefined\\n                  : d.text_offset) && undefined !== p\\n              ? p\\n              : []\\n          );\\n          a.logprobs.push(\\n            null !==\\n              (f =\\n                null === (h = i.logprobs) || undefined === h\\n                  ? undefined\\n                  : h.token_logprobs) && undefined !== f\\n              ? f\\n              : []\\n          );\\n          a.top_logprobs.push(\\n            null !==\\n              (g =\\n                null === (m = i.logprobs) || undefined === m\\n                  ? undefined\\n                  : m.top_logprobs) && undefined !== g\\n              ? g\\n              : []\\n          );\\n          if (\\n            (i.finish_reason || i.text.indexOf(\\"\\\\n\\") > -1) &&\\n            ((w = await n(a.text.join(\\"\\"))),\\n            null == c ? void 0 : c.isCancellationRequested)\\n          )\\n            return (\\n              s.debug(e, \\"Cancelled after awaiting finishedCb\\"),\\n              void y.destroy()\\n            );\\n          if (i.finish_reason || undefined !== w) {\\n            const t =\\n              null !== (_ = i.finish_reason) && undefined !== _\\n                ? _\\n                : \\"client-trimmed\\";\\n            o.telemetry(\\n              e,\\n              \\"completion.finishReason\\",\\n              r.extendedBy({\\n                completionChoiceFinishReason: t,\\n              })\\n            );\\n            yield {\\n              solution: a,\\n              finishOffset: w,\\n              reason: JSON.stringify(i.finish_reason),\\n              requestId: v,\\n              index: i.index,\\n            };\\n            if (null == c ? void 0 : c.isCancellationRequested)\\n              return (\\n                s.debug(e, \\"Cancelled after yielding finished choice\\"),\\n                void y.destroy()\\n              );\\n            b[i.index] = null;\\n          }\\n        }\\n      } else s.error(e, \\"Error in response:\\", x.error.message);\\n    }\\n  }\\n  for (const [t, n] of Object.entries(b)) {\\n    const r = Number(t);\\n    if (\\n      null != n &&\\n      (yield {\\n        solution: n,\\n        finishOffset: undefined,\\n        reason: \\"Iteration Done\\",\\n        requestId: v,\\n        index: r,\\n      },\\n      null == c ? undefined : c.isCancellationRequested)\\n    ) {\\n      s.debug(e, \\"Cancelled after yielding after iteration done\\");\\n      return void y.destroy();\\n    }\\n  }\\n  if (w.length > 0)\\n    try {\\n      const t = JSON.parse(w);\\n      if (undefined !== t.error) {\\n        s.error(e, `Error in response: ${t.error.message}`, t.error);\\n      }\\n    } catch (t) {\\n      s.error(e, `Error parsing extraData: ${w}`);\\n    }\\n};\\nexports.prepareSolutionForReturn = function (e, t, n) {\\n  let r = t.solution.text.join(\\"\\"),\\n    o = !1;\\n  if (undefined !== t.finishOffset) {\\n    s.debug(e, `solution ${t.index}: early finish at offset ${t.finishOffset}`);\\n    r = r.substring(0, t.finishOffset);\\n    o = !0;\\n  }\\n  s.info(\\n    e,\\n    `solution ${t.index} returned. finish reason: [${t.reason}] finishOffset: [${t.finishOffset}] completionId: [{${t.requestId.completionId}}] created: [{${t.requestId.created}}]`\\n  );\\n  const a = (function (e, t) {\\n    const n = {\\n      text: t.text.join(\\"\\"),\\n      tokens: t.text,\\n    };\\n    if (0 === t.logprobs.length) return n;\\n    const r = t.logprobs.reduce((e, t) => e.concat(t), []),\\n      o = t.top_logprobs.reduce((e, t) => e.concat(t), []),\\n      i = t.text_offset.reduce((e, t) => e.concat(t), []),\\n      s = t.tokens.reduce((e, t) => e.concat(t), []);\\n    return {\\n      ...n,\\n      logprobs: {\\n        token_logprobs: r,\\n        top_logprobs: o,\\n        text_offset: i,\\n        tokens: s,\\n      },\\n    };\\n  })(0, t.solution);\\n  return i.convertToAPIChoice(e, r, a, t.index, t.requestId, o, n);\\n};","module-label-766":"background-context-provider","module-code-9380":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.setupExperimentationService = exports.logger = undefined;\\nconst r = require(9496),\\n  o = require(\\"config-stuff\\"),\\n  i = require(9189),\\n  s = require(8142),\\n  a = require(\\"logging-utils\\");\\nfunction c(e) {\\n  return e.split(\\"-\\")[0];\\n}\\nexports.logger = new a.Logger(a.LogLevel.INFO, \\"Exp\\");\\nexports.setupExperimentationService = function (e) {\\n  const t = e.get(i.Features);\\n  t.setPrefix(r.env.machineId);\\n  t.registerStaticFilters(\\n    (function (e) {\\n      const t = e.get(o.BuildInfo);\\n      return {\\n        [s.Filter.ApplicationVersion]: c(r.version),\\n        [s.Filter.Build]: r.env.appName,\\n        [s.Filter.ClientId]: r.env.machineId,\\n        [s.Filter.ExtensionName]: t.getName(),\\n        [s.Filter.ExtensionVersion]: c(t.getVersion()),\\n        [s.Filter.Language]: r.env.language,\\n        [s.Filter.TargetPopulation]: s.TargetPopulation.Public,\\n      };\\n    })(e)\\n  );\\n  t.registerDynamicFilter(s.Filter.CopilotOverrideEngine, () =>\\n    o.getConfig(e, o.ConfigKey.DebugOverrideEngine)\\n  );\\n};","module-label-1581":"json-schema-stuff","module-code-3055456":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.Priorities =\\n  exports.PromptWishlist =\\n  exports.PromptElementRanges =\\n  exports.PromptChoices =\\n  exports.PromptBackground =\\n  exports.PromptElementKind =\\n    undefined;\\nconst r = require(\\"get-prompt-actual\\"),\\n  o = require(\\"tokenizer\\");\\nvar i;\\n!(function (e) {\\n  e.BeforeCursor = \\"BeforeCursor\\";\\n  e.AfterCursor = \\"AfterCursor\\";\\n  e.SimilarFile = \\"SimilarFile\\";\\n  e.ImportedFile = \\"ImportedFile\\";\\n  e.LanguageMarker = \\"LanguageMarker\\";\\n  e.PathMarker = \\"PathMarker\\";\\n})((i = exports.PromptElementKind || (exports.PromptElementKind = {})));\\nclass PromptBackground {\\n  constructor() {\\n    this.used = new Map();\\n    this.unused = new Map();\\n  }\\n  markUsed(e) {\\n    if (this.IsNeighboringTab(e)) {\\n      this.used.set(e.id, this.convert(e));\\n    }\\n  }\\n  undoMarkUsed(e) {\\n    if (this.IsNeighboringTab(e)) {\\n      this.used.delete(e.id);\\n    }\\n  }\\n  markUnused(e) {\\n    if (this.IsNeighboringTab(e)) {\\n      this.unused.set(e.id, this.convert(e));\\n    }\\n  }\\n  convert(e) {\\n    return {\\n      score: e.score.toFixed(4),\\n      length: e.text.length,\\n    };\\n  }\\n  IsNeighboringTab(e) {\\n    return e.kind == i.SimilarFile;\\n  }\\n}\\nexports.PromptBackground = PromptBackground;\\nclass PromptChoices {\\n  constructor() {\\n    this.used = new Map();\\n    this.unused = new Map();\\n  }\\n  markUsed(e) {\\n    this.used.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\\n  }\\n  undoMarkUsed(e) {\\n    this.used.set(e.kind, (this.used.get(e.kind) || 0) - e.tokens);\\n  }\\n  markUnused(e) {\\n    this.unused.set(e.kind, (this.used.get(e.kind) || 0) + e.tokens);\\n  }\\n}\\nexports.PromptChoices = PromptChoices;\\nclass PromptElementRanges {\\n  constructor(e) {\\n    this.ranges = new Array();\\n    let t,\\n      n = 0;\\n    for (const { element: r } of e)\\n      if (0 !== r.text.length) {\\n        if (t === i.BeforeCursor && r.kind === i.BeforeCursor) {\\n          this.ranges[this.ranges.length - 1].end += r.text.length;\\n        } else {\\n          this.ranges.push({\\n            kind: r.kind,\\n            start: n,\\n            end: n + r.text.length,\\n          });\\n        }\\n        t = r.kind;\\n        n += r.text.length;\\n      }\\n  }\\n}\\nexports.PromptElementRanges = PromptElementRanges;\\nexports.PromptWishlist = class {\\n  constructor(e) {\\n    this.content = [];\\n    this.lineEndingOption = e;\\n  }\\n  getContent() {\\n    return [...this.content];\\n  }\\n  convertLineEndings(e) {\\n    if (this.lineEndingOption === r.LineEndingOptions.ConvertToUnix) {\\n      e = e.replace(/\\\\r\\\\n/g, \\"\\\\n\\").replace(/\\\\r/g, \\"\\\\n\\");\\n    }\\n    return e;\\n  }\\n  append(e, t, n, r = o.tokenLength(e), i = NaN) {\\n    e = this.convertLineEndings(e);\\n    const s = this.content.length;\\n    this.content.push({\\n      id: s,\\n      text: e,\\n      kind: t,\\n      priority: n,\\n      tokens: r,\\n      requires: [],\\n      excludes: [],\\n      score: i,\\n    });\\n    return s;\\n  }\\n  appendLineForLine(e, t, n) {\\n    const r = (e = this.convertLineEndings(e)).split(\\"\\\\n\\");\\n    for (let e = 0; e < r.length - 1; e++) r[e] += \\"\\\\n\\";\\n    const o = [];\\n    r.forEach((e, t) => {\\n      if (\\"\\\\n\\" === e && o.length > 0 && !o[o.length - 1].endsWith(\\"\\\\n\\\\n\\")) {\\n        o[o.length - 1] += \\"\\\\n\\";\\n      } else {\\n        o.push(e);\\n      }\\n    });\\n    const i = [];\\n    o.forEach((e, r) => {\\n      if (\\"\\" !== e) {\\n        i.push(this.append(e, t, n));\\n        if (r > 0) {\\n          this.content[this.content.length - 2].requires = [\\n            this.content[this.content.length - 1],\\n          ];\\n        }\\n      }\\n    });\\n    return i;\\n  }\\n  require(e, t) {\\n    const n = this.content.find((t) => t.id === e),\\n      r = this.content.find((e) => e.id === t);\\n    if (n && r) {\\n      n.requires.push(r);\\n    }\\n  }\\n  exclude(e, t) {\\n    const n = this.content.find((t) => t.id === e),\\n      r = this.content.find((e) => e.id === t);\\n    if (n && r) {\\n      n.excludes.push(r);\\n    }\\n  }\\n  fulfill(e) {\\n    const t = new PromptChoices(),\\n      n = new PromptBackground(),\\n      r = this.content.map((e, t) => ({\\n        element: e,\\n        index: t,\\n      }));\\n    r.sort((e, t) =>\\n      e.element.priority === t.element.priority\\n        ? t.index - e.index\\n        : t.element.priority - e.element.priority\\n    );\\n    const i = new Set(),\\n      l = new Set();\\n    let u;\\n    const d = [];\\n    let p = e;\\n    r.forEach((e) => {\\n      var r;\\n      const o = e.element,\\n        s = e.index;\\n      if (\\n        p >= 0 &&\\n        (p > 0 || undefined === u) &&\\n        o.requires.every((e) => i.has(e.id)) &&\\n        !l.has(o.id)\\n      ) {\\n        let a = o.tokens;\\n        const c =\\n          null ===\\n            (r = (function (e, t) {\\n              let n,\\n                r = 1 / 0;\\n              for (const o of e)\\n                if (o.index > t && o.index < r) {\\n                  n = o;\\n                  r = o.index;\\n                }\\n              return n;\\n            })(d, s)) || undefined === r\\n            ? undefined\\n            : r.element;\\n        if (o.text.endsWith(\\"\\\\n\\\\n\\") && c && !c.text.match(/^\\\\s/)) {\\n          a++;\\n        }\\n        if (p >= a) {\\n          p -= a;\\n          i.add(o.id);\\n          o.excludes.forEach((e) => l.add(e.id));\\n          t.markUsed(o);\\n          n.markUsed(o);\\n          d.push(e);\\n        } else {\\n          u = null != u ? u : e;\\n        }\\n      } else {\\n        t.markUnused(o);\\n        n.markUnused(o);\\n      }\\n    });\\n    d.sort((e, t) => e.index - t.index);\\n    let h = d.reduce((e, t) => e + t.element.text, \\"\\"),\\n      f = o.tokenLength(h);\\n    for (; f > e; ) {\\n      d.sort((e, t) =>\\n        t.element.priority === e.element.priority\\n          ? t.index - e.index\\n          : t.element.priority - e.element.priority\\n      );\\n      const e = d.pop();\\n      if (e) {\\n        t.undoMarkUsed(e.element);\\n        t.markUnused(e.element);\\n        n.undoMarkUsed(e.element);\\n        n.markUnused(e.element);\\n        u = undefined;\\n      }\\n      d.sort((e, t) => e.index - t.index);\\n      h = d.reduce((e, t) => e + t.element.text, \\"\\");\\n      f = o.tokenLength(h);\\n    }\\n    const m = [...d];\\n    if (undefined !== u) {\\n      m.push(u);\\n      m.sort((e, t) => e.index - t.index);\\n      const r = m.reduce((e, t) => e + t.element.text, \\"\\"),\\n        i = o.tokenLength(r);\\n      if (i <= e) {\\n        t.markUsed(u.element);\\n        n.markUsed(u.element);\\n        const e = new PromptElementRanges(m);\\n        return {\\n          prefix: r,\\n          suffix: \\"\\",\\n          prefixLength: i,\\n          suffixLength: 0,\\n          promptChoices: t,\\n          promptBackground: n,\\n          promptElementRanges: e,\\n        };\\n      }\\n      t.markUnused(u.element);\\n      n.markUnused(u.element);\\n    }\\n    const g = new PromptElementRanges(d);\\n    return {\\n      prefix: h,\\n      suffix: \\"\\",\\n      prefixLength: f,\\n      suffixLength: 0,\\n      promptChoices: t,\\n      promptBackground: n,\\n      promptElementRanges: g,\\n    };\\n  }\\n};\\nclass Priorities {\\n  constructor() {\\n    this.registeredPriorities = [0, 1];\\n  }\\n  register(e) {\\n    if (e > Priorities.TOP || e < Priorities.BOTTOM)\\n      throw new Error(\\"Priority must be between 0 and 1\\");\\n    this.registeredPriorities.push(e);\\n    return e;\\n  }\\n  justAbove(...e) {\\n    const t = Math.max(...e),\\n      n = Math.min(...this.registeredPriorities.filter((e) => e > t));\\n    return this.register((n + t) / 2);\\n  }\\n  justBelow(...e) {\\n    const t = Math.min(...e),\\n      n = Math.max(...this.registeredPriorities.filter((e) => e < t));\\n    return this.register((n + t) / 2);\\n  }\\n  between(e, t) {\\n    if (\\n      this.registeredPriorities.some((n) => n > e && n < t) ||\\n      !this.registeredPriorities.includes(e) ||\\n      !this.registeredPriorities.includes(t)\\n    )\\n      throw new Error(\\"Priorities must be adjacent in the list of priorities\\");\\n    return this.register((e + t) / 2);\\n  }\\n}\\nexports.Priorities = Priorities;\\nPriorities.TOP = 1;\\nPriorities.BOTTOM = 0;","module-code-7625":"var r = require(\\"url\\"),\\n  o = require(9253),\\n  i = require(4470),\\n  s = require(5290),\\n  a = require(3504),\\n  c = require(9428),\\n  l = require(\\"correlation-context-manager\\"),\\n  u = require(2588),\\n  d = require(5740),\\n  p = require(5282),\\n  h = require(9813),\\n  f = (function () {\\n    function e(e) {\\n      this._telemetryProcessors = [];\\n      var t = new o(e);\\n      this.config = t;\\n      this.context = new i();\\n      this.commonProperties = {};\\n      var n = new u(this.config);\\n      this.channel = new a(\\n        function () {\\n          return t.disableAppInsights;\\n        },\\n        function () {\\n          return t.maxBatchSize;\\n        },\\n        function () {\\n          return t.maxBatchIntervalMs;\\n        },\\n        n\\n      );\\n    }\\n    e.prototype.trackAvailability = function (e) {\\n      this.track(e, s.TelemetryType.Availability);\\n    };\\n    e.prototype.trackTrace = function (e) {\\n      this.track(e, s.TelemetryType.Trace);\\n    };\\n    e.prototype.trackMetric = function (e) {\\n      this.track(e, s.TelemetryType.Metric);\\n    };\\n    e.prototype.trackException = function (e) {\\n      if (e && e.exception && !d.isError(e.exception)) {\\n        e.exception = new Error(e.exception.toString());\\n      }\\n      this.track(e, s.TelemetryType.Exception);\\n    };\\n    e.prototype.trackEvent = function (e) {\\n      this.track(e, s.TelemetryType.Event);\\n    };\\n    e.prototype.trackRequest = function (e) {\\n      this.track(e, s.TelemetryType.Request);\\n    };\\n    e.prototype.trackDependency = function (e) {\\n      if (e && !e.target && e.data) {\\n        e.target = r.parse(e.data).host;\\n      }\\n      this.track(e, s.TelemetryType.Dependency);\\n    };\\n    e.prototype.flush = function (e) {\\n      this.channel.triggerSend(\\n        !!e && !!e.isAppCrashing,\\n        e ? e.callback : undefined\\n      );\\n    };\\n    e.prototype.track = function (e, t) {\\n      if (e && s.telemetryTypeToBaseType(t)) {\\n        var n = h.createEnvelope(\\n          e,\\n          t,\\n          this.commonProperties,\\n          this.context,\\n          this.config\\n        );\\n        if (e.time) {\\n          n.time = e.time.toISOString();\\n        }\\n        var r = this.runTelemetryProcessors(n, e.contextObjects);\\n        r =\\n          r &&\\n          c.samplingTelemetryProcessor(n, {\\n            correlationContext: l.CorrelationContextManager.getCurrentContext(),\\n          });\\n        c.performanceMetricsTelemetryProcessor(n, this.quickPulseClient);\\n        if (r) {\\n          this.channel.send(n);\\n        }\\n      } else\\n        p.warn(\\n          \\"track() requires telemetry object and telemetryType to be specified.\\"\\n        );\\n    };\\n    e.prototype.addTelemetryProcessor = function (e) {\\n      this._telemetryProcessors.push(e);\\n    };\\n    e.prototype.clearTelemetryProcessors = function () {\\n      this._telemetryProcessors = [];\\n    };\\n    e.prototype.runTelemetryProcessors = function (e, t) {\\n      var n = !0,\\n        r = this._telemetryProcessors.length;\\n      if (0 === r) return n;\\n      (t = t || {}).correlationContext =\\n        l.CorrelationContextManager.getCurrentContext();\\n      for (var o = 0; o < r; ++o)\\n        try {\\n          var i = this._telemetryProcessors[o];\\n          if (i && !1 === i.apply(null, [e, t])) {\\n            n = !1;\\n            break;\\n          }\\n        } catch (t) {\\n          n = !0;\\n          p.warn(\\n            \\"One of telemetry processors failed, telemetry item will be sent.\\",\\n            t,\\n            e\\n          );\\n        }\\n      return n;\\n    };\\n    return e;\\n  })();\\nmodule.exports = f;","module-label-464":"get-prompt-parsing-utils","module-label-2277":"uuid-utils","module-code-9899":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.logger =\\n  exports.toPlainText =\\n  exports.Logger =\\n  exports.MultiLog =\\n  exports.OutputChannelLog =\\n  exports.ConsoleLog =\\n  exports.LogTarget =\\n  exports.verboseLogging =\\n  exports.LogVerbose =\\n  exports.LogLevel =\\n    undefined;\\nconst r = require(\\"clock\\"),\\n  o = require(\\"config-stuff\\"),\\n  i = require(\\"telemetry-stuff\\");\\nvar s;\\n!(function (e) {\\n  e[(e.DEBUG = 0)] = \\"DEBUG\\";\\n  e[(e.INFO = 1)] = \\"INFO\\";\\n  e[(e.WARN = 2)] = \\"WARN\\";\\n  e[(e.ERROR = 3)] = \\"ERROR\\";\\n})((s = exports.LogLevel || (exports.LogLevel = {})));\\nclass LogVerbose {\\n  constructor(e) {\\n    this.logVerbose = e;\\n  }\\n}\\nfunction verboseLogging(e) {\\n  return e.get(LogVerbose).logVerbose;\\n}\\nexports.LogVerbose = LogVerbose;\\nexports.verboseLogging = verboseLogging;\\nclass LogTarget {\\n  shouldLog(e, t) {}\\n}\\nexports.LogTarget = LogTarget;\\nexports.ConsoleLog = class extends LogTarget {\\n  constructor(e) {\\n    super();\\n    this.console = e;\\n  }\\n  logIt(e, t, n, ...r) {\\n    if (verboseLogging(e) || t == s.ERROR) {\\n      this.console.error(n, ...r);\\n    } else {\\n      if (t == s.WARN) {\\n        this.console.warn(n, ...r);\\n      }\\n    }\\n  }\\n};\\nexports.OutputChannelLog = class extends LogTarget {\\n  constructor(e) {\\n    super();\\n    this.output = e;\\n  }\\n  logIt(e, t, n, ...r) {\\n    this.output.appendLine(`${n} ${r.map(toPlainText)}`);\\n  }\\n};\\nexports.MultiLog = class extends LogTarget {\\n  constructor(e) {\\n    super();\\n    this.targets = e;\\n  }\\n  logIt(e, t, n, ...r) {\\n    this.targets.forEach((o) => o.logIt(e, t, n, ...r));\\n  }\\n};\\nclass Logger {\\n  constructor(e, t) {\\n    this.minLoggedLevel = e;\\n    this.context = t;\\n  }\\n  setLevel(e) {\\n    this.minLoggedLevel = e;\\n  }\\n  stringToLevel(e) {\\n    return s[e];\\n  }\\n  log(e, t, n, ...o) {\\n    const a = s[t];\\n    if (t == s.ERROR) {\\n      i.telemetryError(\\n        e,\\n        \\"log\\",\\n        i.TelemetryData.createAndMarkAsIssued({\\n          context: this.context,\\n          level: a,\\n          message: o.length > 0 ? JSON.stringify(o) : \\"no msg\\",\\n        }),\\n        n\\n      );\\n    }\\n    const c = e.get(LogTarget),\\n      u = c.shouldLog(e, t);\\n    if (!1 === u) return;\\n    if (undefined === u && !this.shouldLog(e, t, this.context)) return;\\n    const d = e.get(r.Clock).now().toISOString(),\\n      p = `[${a}] [${this.context}] [${d}]`;\\n    c.logIt(e, t, p, ...o);\\n  }\\n  shouldLog(e, t, n) {\\n    var r, i;\\n    if (verboseLogging(e)) return !0;\\n    const s = o.getConfig(e, o.ConfigKey.DebugFilterLogCategories);\\n    if (s.length > 0 && !s.includes(n)) return !1;\\n    if (o.isProduction(e)) return t >= this.minLoggedLevel;\\n    const a = o.getConfig(e, o.ConfigKey.DebugOverrideLogLevels);\\n    return (\\n      t >=\\n      (null !==\\n        (i =\\n          null !== (r = this.stringToLevel(a[\\"*\\"])) && undefined !== r\\n            ? r\\n            : this.stringToLevel(a[this.context])) && undefined !== i\\n        ? i\\n        : this.minLoggedLevel)\\n    );\\n  }\\n  debug(e, ...t) {\\n    this.log(e, s.DEBUG, !1, ...t);\\n  }\\n  info(e, ...t) {\\n    this.log(e, s.INFO, !1, ...t);\\n  }\\n  warn(e, ...t) {\\n    this.log(e, s.WARN, !1, ...t);\\n  }\\n  error(e, ...t) {\\n    this.log(e, s.ERROR, !1, ...t);\\n  }\\n  secureError(e, t, ...n) {\\n    this.log(e, s.ERROR, !1, t);\\n    this.log(e, s.ERROR, !0, t, ...n);\\n  }\\n}\\nfunction toPlainText(e) {\\n  return \\"object\\" == typeof e ? JSON.stringify(e) : String(e);\\n}\\nexports.Logger = Logger;\\nexports.toPlainText = toPlainText;\\nexports.logger = new Logger(s.INFO, \\"default\\");","module-label-7254":"copilot-status-bar","module-label-3055250":"window-delineator","module-code-8129":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ExtensionLocationFactory = undefined;\\nconst r = require(\\"vscode\\"),\\n  o = require(\\"location-factory\\");\\nclass ExtensionLocationFactory extends o.LocationFactory {\\n  range(e, t, n, o) {\\n    return undefined !== n && undefined !== o\\n      ? new r.Range(e, t, n, o)\\n      : new r.Range(e, t);\\n  }\\n  position(e, t) {\\n    return new r.Position(e, t);\\n  }\\n}\\nexports.ExtensionLocationFactory = ExtensionLocationFactory;","module-label-2218":"completion-from-ghost-text","module-label-8965":"contextual-filter-manager","module-label-9408":"nightly-telemetry-stuff","module-code-4428":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.activate = undefined;\\nconst r = require(\\"telemetry-sender\\"),\\n  o = require(\\"config-stuff\\"),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(9380);\\nfunction a(e, t, n, o, a) {\\n  const c = new r.default(t, n, o);\\n  s.setupExperimentationService(e);\\n  i.configureReporter(e, c);\\n  return c;\\n}\\nexports.activate = function (e, t) {\\n  const n = t.extension.packageJSON.name,\\n    r = o.getVersion(e),\\n    s = a(e, n, r, i.APP_INSIGHTS_KEY, t.globalState),\\n    c = a(e, n, r, i.APP_INSIGHTS_KEY_SECURE, t.globalState);\\n  t.subscriptions.push(s);\\n  t.subscriptions.push(c);\\n  return new i.TelemetryReporters(s, c);\\n};","module-code-6333":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.forceSendingTelemetry =\\n  exports.dropTelemetryConfig =\\n  exports.setTelemetryConfig =\\n  exports.logEnginePrompt =\\n  exports.logEngineCompletion =\\n  exports.telemetryError =\\n  exports.telemetryException =\\n  exports.telemetryRaw =\\n  exports.telemetryExpProblem =\\n  exports.telemetry =\\n  exports.configureReporter =\\n  exports.TelemetryEndpointUrl =\\n  exports.now =\\n  exports.telemetrizePromptLength =\\n  exports.TelemetryData =\\n  exports.setupEmptyReporters =\\n  exports.setupStandardReporters =\\n  exports.TelemetryReporters =\\n  exports.APP_INSIGHTS_KEY_SECURE =\\n  exports.APP_INSIGHTS_KEY =\\n    undefined;\\nconst r = require(\\"json-schema-stuff\\"),\\n  o = require(\\"telemetry-sender\\"),\\n  i = require(\\"config-stuff\\"),\\n  s = require(9189),\\n  a = require(6500),\\n  c = require(70),\\n  l = require(2499);\\nexports.APP_INSIGHTS_KEY = \\"7d7048df-6dd0-4048-bb23-b716c1461f8f\\";\\nexports.APP_INSIGHTS_KEY_SECURE = \\"3fdd7f28-937a-48c8-9a21-ba337db23bd1\\";\\nclass TelemetryReporters {\\n  constructor(e, t) {\\n    this.reporter = e;\\n    this.reporterSecure = t;\\n  }\\n  getReporter(e) {\\n    return this.reporter;\\n  }\\n  getSecureReporter(e) {\\n    if (y()) return this.reporterSecure;\\n    if (c.shouldFailForDebugPurposes(e))\\n      throw new Error(\\"Internal error: telemetry opt-out\\");\\n  }\\n  setReporter(e) {\\n    this.reporter = e;\\n  }\\n  setSecureReporter(e) {\\n    this.reporterSecure = e;\\n  }\\n  async deactivate() {\\n    let e = Promise.resolve();\\n    if (this.reporter) {\\n      e = this.reporter.dispose();\\n      this.reporter = undefined;\\n    }\\n    let t = Promise.resolve();\\n    if (this.reporterSecure) {\\n      t = this.reporterSecure.dispose();\\n      this.reporterSecure = undefined;\\n    }\\n    await Promise.all([e, t]);\\n  }\\n  hackOptOutListener() {\\n    this.reporter.optOutListener = {\\n      dispose() {},\\n    };\\n    this.reporterSecure.optOutListener = {\\n      dispose() {},\\n    };\\n  }\\n  setToken(e) {\\n    if (this.reporter) {\\n      this.configureToken(this.reporter, e);\\n    }\\n    if (this.reporterSecure) {\\n      this.configureToken(this.reporterSecure, e);\\n    }\\n  }\\n  configureToken(e, t) {\\n    const n = e;\\n    if (n && n.appInsightsClient) {\\n      n.appInsightsClient.context.tags.github_telemetry_token = t.token;\\n    }\\n  }\\n}\\nlet d;\\nfunction p(e, t, n, r) {\\n  const i = new o.default(t, n, r);\\n  configureReporter(e, i);\\n  return i;\\n}\\nexports.TelemetryReporters = TelemetryReporters;\\nexports.setupStandardReporters = function (e, n) {\\n  const r = i.getVersion(e),\\n    o = p(e, n, r, exports.APP_INSIGHTS_KEY),\\n    s = p(e, n, r, exports.APP_INSIGHTS_KEY_SECURE),\\n    a = e.get(TelemetryReporters);\\n  a.setReporter(o);\\n  a.setSecureReporter(s);\\n  return a;\\n};\\nexports.setupEmptyReporters = function () {\\n  return new TelemetryReporters();\\n};\\nclass TelemetryData {\\n  constructor(e, t, n) {\\n    this.properties = e;\\n    this.measurements = t;\\n    this.issuedTime = n;\\n  }\\n  static createAndMarkAsIssued(e, t) {\\n    return new TelemetryData(e || {}, t || {}, now());\\n  }\\n  extendedBy(e, t) {\\n    const n = {\\n        ...this.properties,\\n        ...e,\\n      },\\n      r = {\\n        ...this.measurements,\\n        ...t,\\n      },\\n      o = new TelemetryData(n, r, this.issuedTime);\\n    o.displayedTime = this.displayedTime;\\n    o.filtersAndExp = this.filtersAndExp;\\n    return o;\\n  }\\n  markAsDisplayed() {\\n    if (undefined === this.displayedTime) {\\n      this.displayedTime = now();\\n    }\\n  }\\n  async extendWithExpTelemetry(e) {\\n    if (this.filtersAndExp) {\\n      await e.get(s.Features).addExpAndFilterToTelemetry(this);\\n    }\\n    this.filtersAndExp.exp.addToTelemetry(this);\\n    this.filtersAndExp.filters.addToTelemetry(this);\\n  }\\n  extendWithEditorAgnosticFields(e) {\\n    this.properties.editor_version = i.formatNameAndVersion(\\n      e.get(i.EditorAndPluginInfo).getEditorInfo(e)\\n    );\\n    this.properties.editor_plugin_version = i.formatNameAndVersion(\\n      e.get(i.EditorAndPluginInfo).getEditorPluginInfo(e)\\n    );\\n    const t = e.get(i.VscInfo);\\n    this.properties.client_machineid = t.machineId;\\n    this.properties.client_sessionid = t.sessionId;\\n    this.properties.copilot_version = `copilot/${i.getVersion(e)}`;\\n    this.properties.common_extname = e\\n      .get(i.EditorAndPluginInfo)\\n      .getEditorPluginInfo(e).name;\\n    this.properties.common_extversion = e\\n      .get(i.EditorAndPluginInfo)\\n      .getEditorPluginInfo(e).version;\\n  }\\n  extendWithConfigProperties(e) {\\n    const t = i.dumpConfig(e);\\n    try {\\n      t[\\"copilot.build\\"] = i.getBuild(e);\\n      t[\\"copilot.buildType\\"] = i.getBuildType(e);\\n    } catch (e) {}\\n    if (d) {\\n      t[\\"copilot.trackingId\\"] = d.trackingId;\\n    }\\n    this.properties = {\\n      ...this.properties,\\n      ...t,\\n    };\\n  }\\n  extendWithRequestId(e) {\\n    const t = {\\n      completionId: e.completionId,\\n      created: e.created.toString(),\\n      headerRequestId: e.headerRequestId,\\n      serverExperiments: e.serverExperiments,\\n      deploymentId: e.deploymentId,\\n    };\\n    this.properties = {\\n      ...this.properties,\\n      ...t,\\n    };\\n  }\\n  static maybeRemoveRepoInfoFromPropertiesHack(e, t) {\\n    if (e) return t;\\n    const n = {};\\n    for (const e in t)\\n      if (TelemetryData.keysToRemoveFromStandardTelemetryHack.includes(e)) {\\n        n[e] = t[e];\\n      }\\n    return n;\\n  }\\n  sanitizeKeys() {\\n    this.properties = TelemetryData.sanitizeKeys(this.properties);\\n    this.measurements = TelemetryData.sanitizeKeys(this.measurements);\\n  }\\n  static sanitizeKeys(e) {\\n    e = e || {};\\n    const t = {};\\n    for (const n in e)\\n      t[\\n        TelemetryData.keysExemptedFromSanitization.includes(n)\\n          ? n\\n          : n.replace(/\\\\./g, \\"_\\")\\n      ] = e[n];\\n    return t;\\n  }\\n  updateTimeSinceIssuedAndDisplayed() {\\n    const e = now() - this.issuedTime;\\n    this.measurements.timeSinceIssuedMs = e;\\n    if (void 0 !== this.displayedTime) {\\n      const e = now() - this.displayedTime;\\n      this.measurements.timeSinceDisplayedMs = e;\\n    }\\n  }\\n  validateData(e, t) {\\n    var n;\\n    let r;\\n    if (TelemetryData.validateTelemetryProperties(this.properties)) {\\n      r = {\\n        problem: \\"properties\\",\\n        error: JSON.stringify(TelemetryData.validateTelemetryProperties.errors),\\n      };\\n    }\\n    if (!TelemetryData.validateTelemetryMeasurements(this.measurements)) {\\n      const e = JSON.stringify(\\n        TelemetryData.validateTelemetryMeasurements.errors\\n      );\\n      void 0 === r\\n        ? (r = {\\n            problem: \\"measurements\\",\\n            error: e,\\n          })\\n        : ((r.problem = \\"both\\"), (r.error += `; ${e}`));\\n    }\\n    if (undefined === r) return !0;\\n    if (c.shouldFailForDebugPurposes(e))\\n      throw new Error(\\n        `Invalid telemetry data: ${r.problem} ${\\n          r.error\\n        } properties=${JSON.stringify(\\n          this.properties\\n        )} measurements=${JSON.stringify(this.measurements)}`\\n      );\\n    telemetryError(\\n      e,\\n      \\"invalidTelemetryData\\",\\n      TelemetryData.createAndMarkAsIssued({\\n        properties: JSON.stringify(this.properties),\\n        measurements: JSON.stringify(this.measurements),\\n        problem: r.problem,\\n        validationError: r.error,\\n      }),\\n      t\\n    );\\n    if (t) {\\n      telemetryError(\\n        e,\\n        \\"invalidTelemetryData_in_secure\\",\\n        TelemetryData.createAndMarkAsIssued({\\n          problem: r.problem,\\n          requestId:\\n            null !== (n = this.properties.requestId) && undefined !== n\\n              ? n\\n              : \\"unknown\\",\\n        }),\\n        !1\\n      );\\n    }\\n    return !1;\\n  }\\n  async makeReadyForSending(e, t, n) {\\n    this.extendWithConfigProperties(e);\\n    this.extendWithEditorAgnosticFields(e);\\n    this.sanitizeKeys();\\n    if (\\"IncludeExp\\" === n) {\\n      await this.extendWithExpTelemetry(e);\\n    }\\n    this.updateTimeSinceIssuedAndDisplayed();\\n    if (this.validateData(e, t)) {\\n      this.properties.telemetry_failed_validation = \\"true\\";\\n    }\\n  }\\n}\\nfunction f(e, t, n, r) {\\n  const o = t\\n    ? e.get(TelemetryReporters).getSecureReporter(e)\\n    : e.get(TelemetryReporters).getReporter(e);\\n  if (o) {\\n    o.sendTelemetryEvent(\\n      n,\\n      TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(t, r.properties),\\n      r.measurements\\n    );\\n  }\\n}\\nfunction now() {\\n  return new Date().getTime();\\n}\\nexports.TelemetryData = TelemetryData;\\nTelemetryData.ajv = new r.default({\\n  strictNumbers: !1,\\n});\\nTelemetryData.validateTelemetryProperties = TelemetryData.ajv.compile({\\n  type: \\"object\\",\\n  additionalProperties: {\\n    type: \\"string\\",\\n  },\\n  required: [],\\n});\\nTelemetryData.validateTelemetryMeasurements = TelemetryData.ajv.compile({\\n  type: \\"object\\",\\n  properties: {\\n    meanLogProb: {\\n      type: \\"number\\",\\n      nullable: !0,\\n    },\\n    meanAlternativeLogProb: {\\n      type: \\"number\\",\\n      nullable: !0,\\n    },\\n  },\\n  additionalProperties: {\\n    type: \\"number\\",\\n  },\\n  required: [],\\n});\\nTelemetryData.keysExemptedFromSanitization = [\\n  a.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName,\\n  a.ExpServiceTelemetryNames.featuresTelemetryPropertyName,\\n];\\nTelemetryData.keysToRemoveFromStandardTelemetryHack = [\\n  \\"gitRepoHost\\",\\n  \\"gitRepoName\\",\\n  \\"gitRepoOwner\\",\\n  \\"gitRepoUrl\\",\\n  \\"gitRepoPath\\",\\n  \\"repo\\",\\n  \\"request_option_nwo\\",\\n];\\nexports.telemetrizePromptLength = function (e) {\\n  return e.isFimEnabled\\n    ? {\\n        promptPrefixCharLen: e.prefix.length,\\n        promptSuffixCharLen: e.suffix.length,\\n      }\\n    : {\\n        promptCharLen: e.prefix.length,\\n      };\\n};\\nexports.now = now;\\nclass TelemetryEndpointUrl {\\n  constructor(e = \\"https://copilot-telemetry.githubusercontent.com/telemetry\\") {\\n    this.url = e;\\n  }\\n  getUrl() {\\n    return this.url;\\n  }\\n  setUrlForTesting(e) {\\n    this.url = e;\\n  }\\n}\\nfunction configureReporter(e, t) {\\n  const n = t;\\n  if (n.appInsightsClient) {\\n    const t = n.appInsightsClient.commonProperties,\\n      r = TelemetryData.sanitizeKeys(t);\\n    n.appInsightsClient.commonProperties = r;\\n    n.appInsightsClient.context.tags[\\n      n.appInsightsClient.context.keys.cloudRoleInstance\\n    ] = \\"REDACTED\\";\\n    const o = e.get(TelemetryEndpointUrl).getUrl();\\n    n.appInsightsClient.config.endpointUrl = o;\\n  }\\n}\\nfunction y() {\\n  var e;\\n  return (\\n    null !== (e = null == d ? undefined : d.optedIn) && undefined !== e && e\\n  );\\n}\\nasync function telemetry(e, t, n, r) {\\n  if (r && !y()) return;\\n  const o = n || TelemetryData.createAndMarkAsIssued({}, {});\\n  await o.makeReadyForSending(e, null != r && r, \\"IncludeExp\\");\\n  f(e, null != r && r, t, o);\\n}\\nasync function telemetryError(e, t, n, r) {\\n  if (r && !y()) return;\\n  const o = n || TelemetryData.createAndMarkAsIssued({}, {});\\n  await o.makeReadyForSending(e, null != r && r, \\"IncludeExp\\");\\n  (function (e, t, n, r) {\\n    const o = t\\n      ? e.get(TelemetryReporters).getSecureReporter(e)\\n      : e.get(TelemetryReporters).getReporter(e);\\n    if (o) {\\n      o.sendTelemetryErrorEvent(\\n        n,\\n        TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(t, r.properties),\\n        r.measurements\\n      );\\n    }\\n  })(e, null != r && r, t, o);\\n}\\nexports.TelemetryEndpointUrl = TelemetryEndpointUrl;\\nexports.configureReporter = configureReporter;\\nexports.telemetry = telemetry;\\nexports.telemetryExpProblem = async function (e, t) {\\n  const n = TelemetryData.createAndMarkAsIssued(t, {});\\n  await n.makeReadyForSending(e, !1, \\"SkipExp\\");\\n  f(e, !1, \\"expProblem\\", n);\\n};\\nexports.telemetryRaw = async function (e, t, n, r) {\\n  f(e, !1, t, {\\n    properties: n,\\n    measurements: r,\\n  });\\n};\\nexports.telemetryException = async function (e, t, n, r) {\\n  const o = t instanceof Error ? t : new Error(\\"Non-error thrown: \\" + t),\\n    i = y(),\\n    s = TelemetryData.createAndMarkAsIssued({\\n      origin: l.redactPaths(n),\\n      reason: i\\n        ? \\"Exception logged to restricted telemetry\\"\\n        : \\"Exception, not logged due to opt-out\\",\\n      ...r,\\n    });\\n  await s.makeReadyForSending(e, !1, \\"IncludeExp\\");\\n  f(e, !1, \\"exception\\", s);\\n  if (!i) return;\\n  const a = TelemetryData.createAndMarkAsIssued({\\n    origin: n,\\n    ...r,\\n  });\\n  await a.makeReadyForSending(e, !0, \\"IncludeExp\\");\\n  (function (e, t, n, r) {\\n    const o = e.get(TelemetryReporters).getSecureReporter(e);\\n    if (o) {\\n      o.sendTelemetryException(\\n        n,\\n        TelemetryData.maybeRemoveRepoInfoFromPropertiesHack(true, r.properties),\\n        r.measurements\\n      );\\n    }\\n  })(e, 0, o, a);\\n};\\nexports.telemetryError = telemetryError;\\nexports.logEngineCompletion = async function (e, t, n, r, o) {\\n  var i;\\n  const s = TelemetryData.createAndMarkAsIssued({\\n    completionTextJson: JSON.stringify(t),\\n    choiceIndex: o.toString(),\\n  });\\n  if (n.logprobs)\\n    for (const [e, t] of Object.entries(n.logprobs))\\n      s.properties[\\"logprobs_\\" + e] =\\n        null !== (i = JSON.stringify(t)) && undefined !== i ? i : \\"unset\\";\\n  s.extendWithRequestId(r);\\n  await telemetry(e, \\"engine.completion\\", s, !0);\\n};\\nexports.logEnginePrompt = async function (e, t, n) {\\n  let r;\\n  r = t.isFimEnabled\\n    ? {\\n        promptPrefixJson: JSON.stringify(t.prefix),\\n        promptSuffixJson: JSON.stringify(t.suffix),\\n        promptElementRanges: JSON.stringify(t.promptElementRanges),\\n      }\\n    : {\\n        promptJson: JSON.stringify(t.prefix),\\n        promptElementRanges: JSON.stringify(t.promptElementRanges),\\n      };\\n  const o = n.extendedBy(r);\\n  await telemetry(e, \\"engine.prompt\\", o, !0);\\n};\\nexports.setTelemetryConfig = function (e) {\\n  d = e;\\n};\\nexports.dropTelemetryConfig = function () {\\n  d = undefined;\\n};\\nexports.forceSendingTelemetry = function (e, n) {\\n  const r = n.getReporter(e);\\n  if (r) {\\n    const n = r;\\n    n.userOptIn = !0;\\n    n.createAppInsightsClient(exports.APP_INSIGHTS_KEY);\\n    configureReporter(e, r);\\n  }\\n  try {\\n    const r = n.getSecureReporter(e);\\n    if (r) {\\n      const n = r;\\n      n.userOptIn = !0;\\n      n.createAppInsightsClient(exports.APP_INSIGHTS_KEY_SECURE);\\n      configureReporter(e, r);\\n    }\\n  } catch (e) {}\\n};","module-label-3055271":"fs-wrapper","module-label-4419":"live-openai-fetcher","module-label-3055395":"edit-distance","module-code-1839":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.registerDocumentTracker = exports.sortByAccessTimes = undefined;\\nconst r = require(\\"text-doc-relative-path\\"),\\n  o = new Map();\\nexports.sortByAccessTimes = function (e) {\\n  return [...e].sort((e, t) => {\\n    var n, r;\\n    const i = null !== (n = o.get(e.uri.toString())) && undefined !== n ? n : 0;\\n    return (\\n      (null !== (r = o.get(t.uri.toString())) && undefined !== r ? r : 0) - i\\n    );\\n  });\\n};\\nexports.registerDocumentTracker = (e) =>\\n  e.get(r.TextDocumentManager).onDidFocusTextDocument((e) => {\\n    if (e) {\\n      o.set(e.document.uri.toString(), Date.now());\\n    }\\n  });","module-code-731":"var r = require(\\"http\\"),\\n  o = require(\\"https\\"),\\n  i = require(5282),\\n  s = require(5740),\\n  a = require(9036),\\n  c = require(6694),\\n  l = require(\\"correlation-context-manager\\"),\\n  u = require(4350),\\n  d = (function () {\\n    function e(t) {\\n      if (e.INSTANCE)\\n        throw new Error(\\n          \\"Server request tracking should be configured from the applicationInsights object\\"\\n        );\\n      e.INSTANCE = this;\\n      this._client = t;\\n    }\\n    e.prototype.enable = function (e) {\\n      this._isEnabled = e;\\n      if (\\n        (this._isAutoCorrelating || this._isEnabled || u.isEnabled()) &&\\n        !this._isInitialized\\n      ) {\\n        this.useAutoCorrelation(this._isAutoCorrelating);\\n        this._initialize();\\n      }\\n    };\\n    e.prototype.useAutoCorrelation = function (e, t) {\\n      if (e && !this._isAutoCorrelating) {\\n        l.CorrelationContextManager.enable(t);\\n      } else {\\n        if (!e && this._isAutoCorrelating) {\\n          l.CorrelationContextManager.disable();\\n        }\\n      }\\n      this._isAutoCorrelating = e;\\n    };\\n    e.prototype.isInitialized = function () {\\n      return this._isInitialized;\\n    };\\n    e.prototype.isAutoCorrelating = function () {\\n      return this._isAutoCorrelating;\\n    };\\n    e.prototype._generateCorrelationContext = function (e) {\\n      if (this._isAutoCorrelating)\\n        return l.CorrelationContextManager.generateContextObject(\\n          e.getOperationId(this._client.context.tags),\\n          e.getRequestId(),\\n          e.getOperationName(this._client.context.tags),\\n          e.getCorrelationContextHeader(),\\n          e.getTraceparent(),\\n          e.getTracestate()\\n        );\\n    };\\n    e.prototype._initialize = function () {\\n      var t = this;\\n      this._isInitialized = !0;\\n      var n = function (n) {\\n          if (n) {\\n            if (\\"function\\" != typeof n)\\n              throw new Error(\\"onRequest handler must be a function\\");\\n            return function (r, o) {\\n              l.CorrelationContextManager.wrapEmitter(r);\\n              l.CorrelationContextManager.wrapEmitter(o);\\n              var i = r && !r[e.alreadyAutoCollectedFlag];\\n              if (r && i) {\\n                var s = new c(r),\\n                  a = t._generateCorrelationContext(s);\\n                l.CorrelationContextManager.runWithContext(a, function () {\\n                  if (t._isEnabled) {\\n                    r[e.alreadyAutoCollectedFlag] = !0;\\n                    e.trackRequest(\\n                      t._client,\\n                      {\\n                        request: r,\\n                        response: o,\\n                      },\\n                      s\\n                    );\\n                  }\\n                  if (\\"function\\" == typeof n) {\\n                    n(r, o);\\n                  }\\n                });\\n              } else if (\\"function\\" == typeof n) {\\n                n(r, o);\\n              }\\n            };\\n          }\\n        },\\n        i = function (e) {\\n          var t = e.addListener.bind(e);\\n          e.addListener = function (e, r) {\\n            switch (e) {\\n              case \\"request\\":\\n              case \\"checkContinue\\":\\n                return t(e, n(r));\\n              default:\\n                return t(e, r);\\n            }\\n          };\\n          e.on = e.addListener;\\n        },\\n        s = r.createServer;\\n      r.createServer = function (e) {\\n        var t = s(n(e));\\n        i(t);\\n        return t;\\n      };\\n      var a = o.createServer;\\n      o.createServer = function (e, t) {\\n        var r = a(e, n(t));\\n        i(r);\\n        return r;\\n      };\\n    };\\n    e.trackRequestSync = function (t, n) {\\n      if (n.request && n.response && t) {\\n        e.addResponseCorrelationIdHeader(t, n.response);\\n        var r = l.CorrelationContextManager.getCurrentContext(),\\n          o = new c(n.request, r && r.operation.parentId);\\n        if (r) {\\n          r.operation.id = o.getOperationId(t.context.tags) || r.operation.id;\\n          r.operation.name =\\n            o.getOperationName(t.context.tags) || r.operation.name;\\n          r.operation.parentId = o.getRequestId() || r.operation.parentId;\\n          r.customProperties.addHeaderData(o.getCorrelationContextHeader());\\n        }\\n        e.endRequest(t, o, n, n.duration, n.error);\\n      } else\\n        i.info(\\n          \\"AutoCollectHttpRequests.trackRequestSync was called with invalid parameters: \\",\\n          !n.request,\\n          !n.response,\\n          !t\\n        );\\n    };\\n    e.trackRequest = function (t, n, r) {\\n      if (n.request && n.response && t) {\\n        var o = l.CorrelationContextManager.getCurrentContext(),\\n          a = r || new c(n.request, o && o.operation.parentId);\\n        if (s.canIncludeCorrelationHeader(t, a.getUrl())) {\\n          e.addResponseCorrelationIdHeader(t, n.response);\\n        }\\n        if (o && !r) {\\n          o.operation.id = a.getOperationId(t.context.tags) || o.operation.id;\\n          o.operation.name =\\n            a.getOperationName(t.context.tags) || o.operation.name;\\n          o.operation.parentId =\\n            a.getOperationParentId(t.context.tags) || o.operation.parentId;\\n          o.customProperties.addHeaderData(a.getCorrelationContextHeader());\\n        }\\n        if (n.response.once) {\\n          n.response.once(\\"finish\\", function () {\\n            e.endRequest(t, a, n, null, null);\\n          });\\n        }\\n        if (n.request.on) {\\n          n.request.on(\\"error\\", function (r) {\\n            e.endRequest(t, a, n, null, r);\\n          });\\n        }\\n      } else\\n        i.info(\\n          \\"AutoCollectHttpRequests.trackRequest was called with invalid parameters: \\",\\n          !n.request,\\n          !n.response,\\n          !t\\n        );\\n    };\\n    e.addResponseCorrelationIdHeader = function (e, t) {\\n      if (\\n        e.config &&\\n        e.config.correlationId &&\\n        t.getHeader &&\\n        t.setHeader &&\\n        !t.headersSent\\n      ) {\\n        var n = t.getHeader(a.requestContextHeader);\\n        s.safeIncludeCorrelationHeader(e, t, n);\\n      }\\n    };\\n    e.endRequest = function (e, t, n, r, o) {\\n      if (o) {\\n        t.onError(o, r);\\n      } else {\\n        t.onResponse(n.response, r);\\n      }\\n      var i = t.getRequestTelemetry(n);\\n      i.tagOverrides = t.getRequestTags(e.context.tags);\\n      if (n.tagOverrides)\\n        for (var s in n.tagOverrides) i.tagOverrides[s] = n.tagOverrides[s];\\n      var a = t.getLegacyRootId();\\n      if (a) {\\n        i.properties.ai_legacyRootId = a;\\n      }\\n      i.contextObjects = i.contextObjects || {};\\n      i.contextObjects[\\"http.ServerRequest\\"] = n.request;\\n      i.contextObjects[\\"http.ServerResponse\\"] = n.response;\\n      e.trackRequest(i);\\n    };\\n    e.prototype.dispose = function () {\\n      e.INSTANCE = null;\\n      this.enable(!1);\\n      this._isInitialized = !1;\\n      l.CorrelationContextManager.disable();\\n      this._isAutoCorrelating = !1;\\n    };\\n    e.alreadyAutoCollectedFlag = \\"_appInsightsAutoCollected\\";\\n    return e;\\n  })();\\nmodule.exports = d;","module-code-3055179":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.extractLocalImportContext = exports.getDocComment = undefined;\\nconst r = require(\\"path\\"),\\n  o = require(\\"get-prompt-parsing-utils\\");\\nfunction i(e, t) {\\n  var n;\\n  let o =\\n    null === (n = t.namedChild(1)) || undefined === n\\n      ? undefined\\n      : n.text.slice(1, -1);\\n  if (!o || !o.startsWith(\\".\\")) return null;\\n  if (\\"\\" === r.extname(o)) o += \\".ts\\";\\n  else if (\\".ts\\" !== r.extname(o)) return null;\\n  return r.join(r.dirname(e), o);\\n}\\nfunction s(e) {\\n  var t, n, r, o, i;\\n  let s = [];\\n  if (\\n    \\"import_clause\\" ===\\n    (null === (t = e.namedChild(0)) || undefined === t ? undefined : t.type)\\n  ) {\\n    let t = e.namedChild(0);\\n    if (\\n      \\"named_imports\\" ===\\n      (null === (n = null == t ? undefined : t.namedChild(0)) || undefined === n\\n        ? undefined\\n        : n.type)\\n    ) {\\n      let e = t.namedChild(0);\\n      for (let t of null !== (r = null == e ? undefined : e.namedChildren) &&\\n      undefined !== r\\n        ? r\\n        : [])\\n        if (\\"import_specifier\\" === t.type) {\\n          const e =\\n            null === (o = t.childForFieldName(\\"name\\")) || undefined === o\\n              ? undefined\\n              : o.text;\\n          if (e) {\\n            const n =\\n              null === (i = t.childForFieldName(\\"alias\\")) || undefined === i\\n                ? undefined\\n                : i.text;\\n            s.push({\\n              name: e,\\n              alias: n,\\n            });\\n          }\\n        }\\n    }\\n  }\\n  return s;\\n}\\nconst a = new Map();\\nfunction c(e, t) {\\n  var n, r;\\n  let o =\\n    null !==\\n      (r =\\n        null === (n = null == t ? undefined : t.childForFieldName(\\"name\\")) ||\\n        undefined === n\\n          ? undefined\\n          : n.text) && undefined !== r\\n      ? r\\n      : \\"\\";\\n  switch (null == t ? undefined : t.type) {\\n    case \\"ambient_declaration\\":\\n      return c(e, t.namedChild(0));\\n    case \\"interface_declaration\\":\\n    case \\"enum_declaration\\":\\n    case \\"type_alias_declaration\\":\\n      return {\\n        name: o,\\n        decl: t.text,\\n      };\\n    case \\"function_declaration\\":\\n    case \\"function_signature\\":\\n      return {\\n        name: o,\\n        decl: l(e, t),\\n      };\\n    case \\"class_declaration\\": {\\n      let n = (function (e, t) {\\n          let n = t.childForFieldName(\\"body\\");\\n          if (n) return n.namedChildren.map((t) => d(e, t)).filter((e) => e);\\n        })(e, t),\\n        r = \\"\\";\\n      if (n) {\\n        let o = t.childForFieldName(\\"body\\");\\n        r = `declare ${e.substring(t.startIndex, o.startIndex + 1)}`;\\n        r += n.map((e) => \\"\\\\n\\" + e).join(\\"\\");\\n        r += \\"\\\\n}\\";\\n      }\\n      return {\\n        name: o,\\n        decl: r,\\n      };\\n    }\\n  }\\n  return {\\n    name: o,\\n    decl: \\"\\",\\n  };\\n}\\nfunction l(e, t) {\\n  var n, r, o;\\n  const i =\\n    null !==\\n      (r =\\n        null === (n = t.childForFieldName(\\"return_type\\")) || undefined === n\\n          ? undefined\\n          : n.endIndex) && undefined !== r\\n      ? r\\n      : null === (o = t.childForFieldName(\\"parameters\\")) || undefined === o\\n      ? undefined\\n      : o.endIndex;\\n  if (undefined !== i) {\\n    let n = e.substring(t.startIndex, i) + \\";\\";\\n    return \\"function_declaration\\" === t.type || \\"function_signature\\" === t.type\\n      ? \\"declare \\" + n\\n      : n;\\n  }\\n  return \\"\\";\\n}\\nfunction getDocComment(e, t) {\\n  const n = o.getFirstPrecedingComment(t);\\n  return n ? e.substring(n.startIndex, t.startIndex) : \\"\\";\\n}\\nfunction d(e, t) {\\n  var n, r, i, s, a;\\n  if (\\n    \\"accessibility_modifier\\" ===\\n      (null === (n = null == t ? undefined : t.firstChild) || undefined === n\\n        ? undefined\\n        : n.type) &&\\n    \\"private\\" === t.firstChild.text\\n  )\\n    return \\"\\";\\n  const c = o.getFirstPrecedingComment(t),\\n    p =\\n      null !==\\n        (r = (function (e, t) {\\n          let n = t.startIndex - 1;\\n          for (; n >= 0 && (\\" \\" === e[n] || \\"\\\\t\\" === e[n]); ) n--;\\n          if (n < 0 || \\"\\\\n\\" === e[n]) return e.substring(n + 1, t.startIndex);\\n        })(e, null != c ? c : t)) && undefined !== r\\n        ? r\\n        : \\"  \\",\\n    h = getDocComment(e, t);\\n  switch (t.type) {\\n    case \\"ambient_declaration\\":\\n      const n = t.namedChild(0);\\n      return n ? p + h + d(e, n) : \\"\\";\\n    case \\"method_definition\\":\\n    case \\"method_signature\\":\\n      return p + h + l(e, t);\\n    case \\"public_field_definition\\": {\\n      let n =\\n        null !==\\n          (s =\\n            null === (i = t.childForFieldName(\\"type\\")) || undefined === i\\n              ? undefined\\n              : i.endIndex) && undefined !== s\\n          ? s\\n          : null === (a = t.childForFieldName(\\"name\\")) || undefined === a\\n          ? undefined\\n          : a.endIndex;\\n      if (undefined !== n) return p + h + e.substring(t.startIndex, n) + \\";\\";\\n    }\\n  }\\n  return \\"\\";\\n}\\nasync function p(e, t, n) {\\n  let r = new Map(),\\n    i = -1;\\n  try {\\n    i = await n.mtime(e);\\n  } catch {\\n    return r;\\n  }\\n  let s = a.get(e);\\n  if (s && s.mtime === i) return s.exports;\\n  if (\\"typescript\\" === t) {\\n    let i = null;\\n    try {\\n      let s = (await n.readFile(e)).toString();\\n      i = await o.parseTree(t, s);\\n      for (let e of o.queryExports(t, i.rootNode))\\n        for (let t of e.captures) {\\n          let e = t.node;\\n          if (\\"export_statement\\" === e.type) {\\n            let t = e.childForFieldName(\\"declaration\\");\\n            if (null == t ? undefined : t.hasError()) continue;\\n            let { name: n, decl: o } = c(s, t);\\n            if (n) {\\n              o = getDocComment(s, e) + o;\\n              let t = r.get(n);\\n              if (t) {\\n                t = [];\\n                r.set(n, t);\\n              }\\n              t.push(o);\\n            }\\n          }\\n        }\\n    } catch {\\n    } finally {\\n      if (i) {\\n        i.delete();\\n      }\\n    }\\n  }\\n  if (a.size > 2e3)\\n    for (let e of a.keys()) {\\n      a.delete(e);\\n      if (r.size <= 1e3) break;\\n    }\\n  a.set(e, {\\n    mtime: i,\\n    exports: r,\\n  });\\n  return r;\\n}\\nexports.getDocComment = getDocComment;\\nconst h = /^\\\\s*import\\\\s*(type|)\\\\s*\\\\{[^}]*\\\\}\\\\s*from\\\\s*[\'\\"]\\\\./gm;\\nexports.extractLocalImportContext = async function (e, t) {\\n  let { source: n, uri: r, languageId: a } = e;\\n  return t && \\"typescript\\" === a\\n    ? (async function (e, t, n) {\\n        let r = \\"typescript\\",\\n          a = [];\\n        const c = (function (e) {\\n          let t,\\n            n = -1;\\n          h.lastIndex = -1;\\n          do {\\n            t = h.exec(e);\\n            if (t) {\\n              n = h.lastIndex + t.length;\\n            }\\n          } while (t);\\n          if (-1 === n) return -1;\\n          const r = e.indexOf(\\"\\\\n\\", n);\\n          return -1 !== r ? r : e.length;\\n        })(e);\\n        if (-1 === c) return a;\\n        e = e.substring(0, c);\\n        let l = await o.parseTree(r, e);\\n        try {\\n          for (let e of (function (e) {\\n            let t = [];\\n            for (let n of e.namedChildren)\\n              if (\\"import_statement\\" === n.type) {\\n                t.push(n);\\n              }\\n            return t;\\n          })(l.rootNode)) {\\n            let o = i(t, e);\\n            if (!o) continue;\\n            let c = s(e);\\n            if (0 === c.length) continue;\\n            let l = await p(o, r, n);\\n            for (let e of c)\\n              if (l.has(e.name)) {\\n                a.push(...l.get(e.name));\\n              }\\n          }\\n        } finally {\\n          l.delete();\\n        }\\n        return a;\\n      })(n, r, t)\\n    : [];\\n};","module-code-4540":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ignoreDocument = undefined;\\nconst r = require(\\"config-stuff\\"),\\n  o = require(\\"copilot-scheme\\");\\nexports.ignoreDocument = function (e, t) {\\n  const n = t.languageId;\\n  return (\\n    !r.getEnabledConfig(e, n) ||\\n    !![o.CopilotScheme, \\"output\\", \\"search-editor\\"].includes(t.uri.scheme)\\n  );\\n};","module-code-3507":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.extractLocalImportContext = exports.getDocComment = undefined;\\nconst r = require(\\"path\\"),\\n  o = require(\\"get-prompt-parsing-utils\\");\\nfunction i(e, t) {\\n  var n;\\n  let o =\\n    null === (n = t.namedChild(1)) || undefined === n\\n      ? undefined\\n      : n.text.slice(1, -1);\\n  if (!o || !o.startsWith(\\".\\")) return null;\\n  if (\\"\\" === r.extname(o)) o += \\".ts\\";\\n  else if (\\".ts\\" !== r.extname(o)) return null;\\n  return r.join(r.dirname(e), o);\\n}\\nfunction s(e) {\\n  var t, n, r, o, i;\\n  let s = [];\\n  if (\\n    \\"import_clause\\" ===\\n    (null === (t = e.namedChild(0)) || undefined === t ? undefined : t.type)\\n  ) {\\n    let t = e.namedChild(0);\\n    if (\\n      \\"named_imports\\" ===\\n      (null === (n = null == t ? undefined : t.namedChild(0)) || undefined === n\\n        ? undefined\\n        : n.type)\\n    ) {\\n      let e = t.namedChild(0);\\n      for (let t of null !== (r = null == e ? undefined : e.namedChildren) &&\\n      undefined !== r\\n        ? r\\n        : [])\\n        if (\\"import_specifier\\" === t.type) {\\n          const e =\\n            null === (o = t.childForFieldName(\\"name\\")) || undefined === o\\n              ? undefined\\n              : o.text;\\n          if (e) {\\n            const n =\\n              null === (i = t.childForFieldName(\\"alias\\")) || undefined === i\\n                ? undefined\\n                : i.text;\\n            s.push({\\n              name: e,\\n              alias: n,\\n            });\\n          }\\n        }\\n    }\\n  }\\n  return s;\\n}\\nconst a = new Map();\\nfunction c(e, t) {\\n  var n, r;\\n  let o =\\n    null !==\\n      (r =\\n        null === (n = null == t ? undefined : t.childForFieldName(\\"name\\")) ||\\n        undefined === n\\n          ? undefined\\n          : n.text) && undefined !== r\\n      ? r\\n      : \\"\\";\\n  switch (null == t ? undefined : t.type) {\\n    case \\"ambient_declaration\\":\\n      return c(e, t.namedChild(0));\\n    case \\"interface_declaration\\":\\n    case \\"enum_declaration\\":\\n    case \\"type_alias_declaration\\":\\n      return {\\n        name: o,\\n        decl: t.text,\\n      };\\n    case \\"function_declaration\\":\\n    case \\"function_signature\\":\\n      return {\\n        name: o,\\n        decl: l(e, t),\\n      };\\n    case \\"class_declaration\\": {\\n      let n = (function (e, t) {\\n          let n = t.childForFieldName(\\"body\\");\\n          if (n) return n.namedChildren.map((t) => d(e, t)).filter((e) => e);\\n        })(e, t),\\n        r = \\"\\";\\n      if (n) {\\n        let o = t.childForFieldName(\\"body\\");\\n        r = `declare ${e.substring(t.startIndex, o.startIndex + 1)}`;\\n        r += n.map((e) => \\"\\\\n\\" + e).join(\\"\\");\\n        r += \\"\\\\n}\\";\\n      }\\n      return {\\n        name: o,\\n        decl: r,\\n      };\\n    }\\n  }\\n  return {\\n    name: o,\\n    decl: \\"\\",\\n  };\\n}\\nfunction l(e, t) {\\n  var n, r, o;\\n  const i =\\n    null !==\\n      (r =\\n        null === (n = t.childForFieldName(\\"return_type\\")) || undefined === n\\n          ? undefined\\n          : n.endIndex) && undefined !== r\\n      ? r\\n      : null === (o = t.childForFieldName(\\"parameters\\")) || undefined === o\\n      ? undefined\\n      : o.endIndex;\\n  if (undefined !== i) {\\n    let n = e.substring(t.startIndex, i) + \\";\\";\\n    return \\"function_declaration\\" === t.type || \\"function_signature\\" === t.type\\n      ? \\"declare \\" + n\\n      : n;\\n  }\\n  return \\"\\";\\n}\\nfunction getDocComment(e, t) {\\n  const n = o.getFirstPrecedingComment(t);\\n  return n ? e.substring(n.startIndex, t.startIndex) : \\"\\";\\n}\\nfunction d(e, t) {\\n  var n, r, i, s, a;\\n  if (\\n    \\"accessibility_modifier\\" ===\\n      (null === (n = null == t ? undefined : t.firstChild) || undefined === n\\n        ? undefined\\n        : n.type) &&\\n    \\"private\\" === t.firstChild.text\\n  )\\n    return \\"\\";\\n  const c = o.getFirstPrecedingComment(t),\\n    p =\\n      null !==\\n        (r = (function (e, t) {\\n          let n = t.startIndex - 1;\\n          for (; n >= 0 && (\\" \\" === e[n] || \\"\\\\t\\" === e[n]); ) n--;\\n          if (n < 0 || \\"\\\\n\\" === e[n]) return e.substring(n + 1, t.startIndex);\\n        })(e, null != c ? c : t)) && undefined !== r\\n        ? r\\n        : \\"  \\",\\n    h = getDocComment(e, t);\\n  switch (t.type) {\\n    case \\"ambient_declaration\\":\\n      const n = t.namedChild(0);\\n      return n ? p + h + d(e, n) : \\"\\";\\n    case \\"method_definition\\":\\n    case \\"method_signature\\":\\n      return p + h + l(e, t);\\n    case \\"public_field_definition\\": {\\n      let n =\\n        null !==\\n          (s =\\n            null === (i = t.childForFieldName(\\"type\\")) || undefined === i\\n              ? undefined\\n              : i.endIndex) && undefined !== s\\n          ? s\\n          : null === (a = t.childForFieldName(\\"name\\")) || undefined === a\\n          ? undefined\\n          : a.endIndex;\\n      if (undefined !== n) return p + h + e.substring(t.startIndex, n) + \\";\\";\\n    }\\n  }\\n  return \\"\\";\\n}\\nasync function p(e, t, n) {\\n  let r = new Map(),\\n    i = -1;\\n  try {\\n    i = await n.mtime(e);\\n  } catch {\\n    return r;\\n  }\\n  let s = a.get(e);\\n  if (s && s.mtime === i) return s.exports;\\n  if (\\"typescript\\" === t) {\\n    let i = null;\\n    try {\\n      let s = (await n.readFile(e)).toString();\\n      i = await o.parseTree(t, s);\\n      for (let e of o.queryExports(t, i.rootNode))\\n        for (let t of e.captures) {\\n          let e = t.node;\\n          if (\\"export_statement\\" === e.type) {\\n            let t = e.childForFieldName(\\"declaration\\");\\n            if (null == t ? undefined : t.hasError()) continue;\\n            let { name: n, decl: o } = c(s, t);\\n            if (n) {\\n              o = getDocComment(s, e) + o;\\n              let t = r.get(n);\\n              if (t) {\\n                t = [];\\n                r.set(n, t);\\n              }\\n              t.push(o);\\n            }\\n          }\\n        }\\n    } catch {\\n    } finally {\\n      if (i) {\\n        i.delete();\\n      }\\n    }\\n  }\\n  if (a.size > 2e3)\\n    for (let e of a.keys()) {\\n      a.delete(e);\\n      if (r.size <= 1e3) break;\\n    }\\n  a.set(e, {\\n    mtime: i,\\n    exports: r,\\n  });\\n  return r;\\n}\\nexports.getDocComment = getDocComment;\\nconst h = /^\\\\s*import\\\\s*(type|)\\\\s*\\\\{[^}]*\\\\}\\\\s*from\\\\s*[\'\\"]\\\\./gm;\\nexports.extractLocalImportContext = async function (e, t) {\\n  let { source: n, uri: r, languageId: a } = e;\\n  return t && \\"typescript\\" === a\\n    ? (async function (e, t, n) {\\n        let r = \\"typescript\\",\\n          a = [];\\n        const c = (function (e) {\\n          let t,\\n            n = -1;\\n          h.lastIndex = -1;\\n          do {\\n            t = h.exec(e);\\n            if (t) {\\n              n = h.lastIndex + t.length;\\n            }\\n          } while (t);\\n          if (-1 === n) return -1;\\n          const r = e.indexOf(\\"\\\\n\\", n);\\n          return -1 !== r ? r : e.length;\\n        })(e);\\n        if (-1 === c) return a;\\n        e = e.substring(0, c);\\n        let l = await o.parseTree(r, e);\\n        try {\\n          for (let e of (function (e) {\\n            let t = [];\\n            for (let n of e.namedChildren)\\n              if (\\"import_statement\\" === n.type) {\\n                t.push(n);\\n              }\\n            return t;\\n          })(l.rootNode)) {\\n            let o = i(t, e);\\n            if (!o) continue;\\n            let c = s(e);\\n            if (0 === c.length) continue;\\n            let l = await p(o, r, n);\\n            for (let e of c)\\n              if (l.has(e.name)) {\\n                a.push(...l.get(e.name));\\n              }\\n          }\\n        } finally {\\n          l.delete();\\n        }\\n        return a;\\n      })(n, r, t)\\n    : [];\\n};","module-label-1133":"config-stuff","module-code-4398":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nprocess.env.APPLICATION_INSIGHTS_NO_DIAGNOSTIC_CHANNEL = !0;\\nvar r = require(\\"fs\\"),\\n  o = require(\\"os\\"),\\n  i = require(\\"path\\"),\\n  s = require(\\"vscode\\"),\\n  a = require(\\"telemetry-client-manager\\"),\\n  c = (function () {\\n    function e(e, t, n, o) {\\n      var a = this;\\n      this.extensionId = e;\\n      this.extensionVersion = t;\\n      this.firstParty = !1;\\n      this.userOptIn = !1;\\n      this.firstParty = !!o;\\n      var c = process.env.VSCODE_LOGS || \\"\\";\\n      if (c && e && \\"trace\\" === process.env.VSCODE_LOG_LEVEL) {\\n        c = i.join(c, e + \\".txt\\");\\n        this.logStream = r.createWriteStream(c, {\\n          flags: \\"a\\",\\n          encoding: \\"utf8\\",\\n          autoClose: !0,\\n        });\\n      }\\n      this.updateUserOptIn(n);\\n      if (undefined !== s.env.onDidChangeTelemetryEnabled) {\\n        this.optOutListener = s.env.onDidChangeTelemetryEnabled(function () {\\n          return a.updateUserOptIn(n);\\n        });\\n      } else {\\n        this.optOutListener = s.workspace.onDidChangeConfiguration(function () {\\n          return a.updateUserOptIn(n);\\n        });\\n      }\\n    }\\n    e.prototype.updateUserOptIn = function (t) {\\n      var n = s.workspace.getConfiguration(e.TELEMETRY_CONFIG_ID),\\n        r =\\n          undefined === s.env.isTelemetryEnabled\\n            ? n.get(e.TELEMETRY_CONFIG_ENABLED_ID, !0)\\n            : s.env.isTelemetryEnabled;\\n      if (this.userOptIn !== r) {\\n        this.userOptIn = r;\\n        if (this.userOptIn) {\\n          this.createAppInsightsClient(t);\\n        } else {\\n          this.dispose();\\n        }\\n      }\\n    };\\n    e.prototype.createAppInsightsClient = function (e) {\\n      if (a.defaultClient) {\\n        this.appInsightsClient = new a.TelemetryClient(e);\\n        this.appInsightsClient.channel.setUseDiskRetryCaching(!0);\\n      } else {\\n        a.setup(e)\\n          .setAutoCollectRequests(!1)\\n          .setAutoCollectPerformance(!1)\\n          .setAutoCollectExceptions(!1)\\n          .setAutoCollectDependencies(!1)\\n          .setAutoDependencyCorrelation(!1)\\n          .setAutoCollectConsole(!1)\\n          .setUseDiskRetryCaching(!0)\\n          .start();\\n        this.appInsightsClient = a.defaultClient;\\n      }\\n      this.appInsightsClient.commonProperties = this.getCommonProperties();\\n      if (s && s.env) {\\n        this.appInsightsClient.context.tags[\\n          this.appInsightsClient.context.keys.userId\\n        ] = s.env.machineId;\\n        this.appInsightsClient.context.tags[\\n          this.appInsightsClient.context.keys.sessionId\\n        ] = s.env.sessionId;\\n      }\\n      if (e && 0 === e.indexOf(\\"AIF-\\")) {\\n        this.appInsightsClient.config.endpointUrl =\\n          \\"https://vortex.data.microsoft.com/collect/v1\\";\\n        this.firstParty = !0;\\n      }\\n    };\\n    e.prototype.getCommonProperties = function () {\\n      var e = Object.create(null);\\n      e[\\"common.os\\"] = o.platform();\\n      e[\\"common.platformversion\\"] = (o.release() || \\"\\").replace(\\n        /^(\\\\d+)(\\\\.\\\\d+)?(\\\\.\\\\d+)?(.*)/,\\n        \\"$1$2$3\\"\\n      );\\n      e[\\"common.extname\\"] = this.extensionId;\\n      e[\\"common.extversion\\"] = this.extensionVersion;\\n      if (s && s.env) {\\n        switch (\\n          ((e[\\"common.vscodemachineid\\"] = s.env.machineId),\\n          (e[\\"common.vscodesessionid\\"] = s.env.sessionId),\\n          (e[\\"common.vscodeversion\\"] = s.version),\\n          (e[\\"common.isnewappinstall\\"] = s.env.isNewAppInstall),\\n          s.env.uiKind)\\n        ) {\\n          case s.UIKind.Web:\\n            e[\\"common.uikind\\"] = \\"web\\";\\n            break;\\n          case s.UIKind.Desktop:\\n            e[\\"common.uikind\\"] = \\"desktop\\";\\n            break;\\n          default:\\n            e[\\"common.uikind\\"] = \\"unknown\\";\\n        }\\n        e[\\"common.remotename\\"] = this.cleanRemoteName(s.env.remoteName);\\n      }\\n      return e;\\n    };\\n    e.prototype.cleanRemoteName = function (e) {\\n      if (!e) return \\"none\\";\\n      var t = \\"other\\";\\n      [\\"ssh-remote\\", \\"dev-container\\", \\"attached-container\\", \\"wsl\\"].forEach(\\n        function (n) {\\n          if (0 === e.indexOf(n + \\"+\\")) {\\n            t = n;\\n          }\\n        }\\n      );\\n      return t;\\n    };\\n    e.prototype.shouldSendErrorTelemetry = function () {\\n      return (\\n        !this.firstParty ||\\n        \\"other\\" !== this.cleanRemoteName(s.env.remoteName) ||\\n        (undefined !== this.extension &&\\n          this.extension.extensionKind !== s.ExtensionKind.Workspace &&\\n          s.env.uiKind !== s.UIKind.Web)\\n      );\\n    };\\n    Object.defineProperty(e.prototype, \\"extension\\", {\\n      get: function () {\\n        if (undefined === this._extension) {\\n          this._extension = s.extensions.getExtension(this.extensionId);\\n        }\\n        return this._extension;\\n      },\\n      enumerable: !1,\\n      configurable: !0,\\n    });\\n    e.prototype.cloneAndChange = function (e, t) {\\n      if (null === e || \\"object\\" != typeof e) return e;\\n      if (\\"function\\" != typeof t) return e;\\n      var n = {};\\n      for (var r in e) n[r] = t(r, e[r]);\\n      return n;\\n    };\\n    e.prototype.anonymizeFilePaths = function (e, t) {\\n      if (null == e) return \\"\\";\\n      var n = [\\n        new RegExp(s.env.appRoot.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, \\"\\\\\\\\$&\\"), \\"gi\\"),\\n      ];\\n      if (this.extension) {\\n        n.push(\\n          new RegExp(\\n            this.extension.extensionPath.replace(/[.*+?^${}()|[\\\\]\\\\\\\\]/g, \\"\\\\\\\\$&\\"),\\n            \\"gi\\"\\n          )\\n        );\\n      }\\n      var r = e;\\n      if (t) {\\n        for (var o = [], i = 0, a = n; i < a.length; i++)\\n          for (var c = a[i]; ; ) {\\n            var l = c.exec(e);\\n            if (!l) break;\\n            o.push([l.index, c.lastIndex]);\\n          }\\n        var u = /^[\\\\\\\\\\\\/]?(node_modules|node_modules\\\\.asar)[\\\\\\\\\\\\/]/,\\n          d =\\n            /(file:\\\\/\\\\/)?([a-zA-Z]:(\\\\\\\\\\\\\\\\|\\\\\\\\|\\\\/)|(\\\\\\\\\\\\\\\\|\\\\\\\\|\\\\/))?([\\\\w-\\\\._]+(\\\\\\\\\\\\\\\\|\\\\\\\\|\\\\/))+[\\\\w-\\\\._]*/g,\\n          p = 0;\\n        r = \\"\\";\\n        for (\\n          var h = function () {\\n            var t = d.exec(e);\\n            if (!t) return \\"break\\";\\n            if (\\n              !u.test(t[0]) &&\\n              o.every(function (e) {\\n                var n = e[0],\\n                  r = e[1];\\n                return t.index < n || t.index >= r;\\n              })\\n            ) {\\n              r += e.substring(p, t.index) + \\"<REDACTED: user-file-path>\\";\\n              p = d.lastIndex;\\n            }\\n          };\\n          \\"break\\" !== h();\\n\\n        );\\n        if (p < e.length) {\\n          r += e.substr(p);\\n        }\\n      }\\n      for (var f = 0, m = n; f < m.length; f++) {\\n        c = m[f];\\n        r = r.replace(c, \\"\\");\\n      }\\n      return r;\\n    };\\n    e.prototype.sendTelemetryEvent = function (e, t, n) {\\n      var r = this;\\n      if (this.userOptIn && e && this.appInsightsClient) {\\n        var o = this.cloneAndChange(t, function (e, t) {\\n          return r.anonymizeFilePaths(t, r.firstParty);\\n        });\\n        this.appInsightsClient.trackEvent({\\n          name: this.extensionId + \\"/\\" + e,\\n          properties: o,\\n          measurements: n,\\n        });\\n        if (this.logStream) {\\n          this.logStream.write(\\n            \\"telemetry/\\" +\\n              e +\\n              \\" \\" +\\n              JSON.stringify({\\n                properties: t,\\n                measurements: n,\\n              }) +\\n              \\"\\\\n\\"\\n          );\\n        }\\n      }\\n    };\\n    e.prototype.sendTelemetryErrorEvent = function (e, t, n, r) {\\n      var o = this;\\n      if (this.userOptIn && e && this.appInsightsClient) {\\n        var i = this.cloneAndChange(t, function (e, t) {\\n          return o.shouldSendErrorTelemetry()\\n            ? o.anonymizeFilePaths(t, o.firstParty)\\n            : undefined === r || -1 !== r.indexOf(e)\\n            ? \\"REDACTED\\"\\n            : o.anonymizeFilePaths(t, o.firstParty);\\n        });\\n        this.appInsightsClient.trackEvent({\\n          name: this.extensionId + \\"/\\" + e,\\n          properties: i,\\n          measurements: n,\\n        });\\n        if (this.logStream) {\\n          this.logStream.write(\\n            \\"telemetry/\\" +\\n              e +\\n              \\" \\" +\\n              JSON.stringify({\\n                properties: t,\\n                measurements: n,\\n              }) +\\n              \\"\\\\n\\"\\n          );\\n        }\\n      }\\n    };\\n    e.prototype.sendTelemetryException = function (e, t, n) {\\n      var r = this;\\n      if (\\n        this.shouldSendErrorTelemetry() &&\\n        this.userOptIn &&\\n        e &&\\n        this.appInsightsClient\\n      ) {\\n        var o = this.cloneAndChange(t, function (e, t) {\\n          return r.anonymizeFilePaths(t, r.firstParty);\\n        });\\n        this.appInsightsClient.trackException({\\n          exception: e,\\n          properties: o,\\n          measurements: n,\\n        });\\n        if (this.logStream) {\\n          this.logStream.write(\\n            \\"telemetry/\\" +\\n              e.name +\\n              \\" \\" +\\n              e.message +\\n              \\" \\" +\\n              JSON.stringify({\\n                properties: t,\\n                measurements: n,\\n              }) +\\n              \\"\\\\n\\"\\n          );\\n        }\\n      }\\n    };\\n    e.prototype.dispose = function () {\\n      var e = this;\\n      this.optOutListener.dispose();\\n      var t = new Promise(function (t) {\\n          if (!e.logStream) return t(undefined);\\n          e.logStream.on(\\"finish\\", t);\\n          e.logStream.end();\\n        }),\\n        n = new Promise(function (t) {\\n          if (e.appInsightsClient) {\\n            e.appInsightsClient.flush({\\n              callback: function () {\\n                e.appInsightsClient = undefined;\\n                t(undefined);\\n              },\\n            });\\n          } else {\\n            t(undefined);\\n          }\\n        });\\n      return Promise.all([n, t]);\\n    };\\n    e.TELEMETRY_CONFIG_ID = \\"telemetry\\";\\n    e.TELEMETRY_CONFIG_ENABLED_ID = \\"enableTelemetry\\";\\n    return e;\\n  })();\\nexports.default = c;","module-label-9899":"logging-utils","module-label-305587":"maybe-wasm-utils","module-label-9425":"vscode-utils","module-label-6333":"telemetry-stuff","module-label-4428":"telemetry-wrapper","module-code-766":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ComputationStatus =\\n  exports.getRepoUrlFromConfigText =\\n  exports.parseRepoUrl =\\n  exports.extractRepoInfoForTesting =\\n  exports.extractRepoInfoInBackground =\\n  exports.tryGetGitHubNWO =\\n  exports.getDogFood =\\n  exports.Dogfood =\\n  exports.getUserKind =\\n  exports.isNotRepo =\\n  exports.isRepoInfo =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"git-url-parser\\"),\\n  i = require(\\"path\\"),\\n  s = require(\\"copilot-github-auth-stuff\\"),\\n  a = require(\\"prompt-cache\\");\\nvar c;\\nfunction tryGetGitHubNWO(e) {\\n  if (undefined !== e && e !== f.PENDING)\\n    return \\"github.com\\" === e.hostname ? e.owner + \\"/\\" + e.repo : undefined;\\n}\\nexports.isRepoInfo = function (e) {\\n  return undefined !== e && e !== f.PENDING;\\n};\\nexports.isNotRepo = function (e) {\\n  return undefined === e;\\n};\\nexports.getUserKind = async function (e) {\\n  var t, n;\\n  const r =\\n    null !==\\n      (t = (await e.get(s.CopilotTokenManager).getCopilotToken(e, !1))\\n        .organization_list) && undefined !== t\\n      ? t\\n      : [];\\n  return null !==\\n    (n = [\\n      \\"a5db0bcaae94032fe715fb34a5e4bce2\\",\\n      \\"4535c7beffc844b46bb1ed4aa04d759a\\",\\n    ].find((e) => r.includes(e))) && undefined !== n\\n    ? n\\n    : \\"\\";\\n};\\n(function (e) {\\n  e.GITHUB = \\"github\\";\\n  e.MICROSOFT = \\"microsoft\\";\\n  e.UNKNOWN = \\"\\";\\n})((c = exports.Dogfood || (exports.Dogfood = {})));\\nexports.getDogFood = function (e) {\\n  return undefined === e || e === f.PENDING\\n    ? c.UNKNOWN\\n    : \\"github/github\\" === tryGetGitHubNWO(e)\\n    ? c.GITHUB\\n    : \\"ssh.dev.azure.com\\" === e.hostname ||\\n      \\"vs-ssh.visualstudio.com\\" === e.hostname ||\\n      \\"dev.azure.com\\" === e.hostname ||\\n      \\"domoreexp.visualstudio.com\\" === e.hostname ||\\n      \\"office.visualstudio.com\\" === e.hostname\\n    ? c.MICROSOFT\\n    : c.UNKNOWN;\\n};\\nexports.tryGetGitHubNWO = tryGetGitHubNWO;\\nexports.extractRepoInfoInBackground = function (e, t) {\\n  if (!t) return;\\n  const n = i.dirname(t);\\n  return u(e, n);\\n};\\nconst u = (function (e, t) {\\n  const n = new a.LRUCache(1e4),\\n    r = new Set();\\n  return (t, ...o) => {\\n    const i = JSON.stringify(o),\\n      s = n.get(i);\\n    if (s) return s.result;\\n    if (r.has(i)) return f.PENDING;\\n    const a = e(t, ...o);\\n    r.add(i);\\n    a.then((e) => {\\n      n.put(i, new m(e));\\n      r.delete(i);\\n    });\\n    return f.PENDING;\\n  };\\n})(d);\\nasync function d(e, t) {\\n  var n;\\n  const o = await (async function (e, t) {\\n    let n = t + \\"_add_to_make_longer\\";\\n    const o = e.get(r.FileSystem);\\n    for (; t.length > 1 && t.length < n.length; ) {\\n      const e = i.join(t, \\".git\\", \\"config\\");\\n      let r = !1;\\n      try {\\n        await o.stat(e);\\n        r = !0;\\n      } catch (e) {\\n        r = !1;\\n      }\\n      if (r) return t;\\n      n = t;\\n      t = i.dirname(t);\\n    }\\n  })(e, t);\\n  if (!o) return;\\n  const s = e.get(r.FileSystem),\\n    a = i.join(o, \\".git\\", \\"config\\"),\\n    c =\\n      null !==\\n        (n = getRepoUrlFromConfigText((await s.readFile(a)).toString())) &&\\n      undefined !== n\\n        ? n\\n        : \\"\\",\\n    l = parseRepoUrl(c);\\n  return undefined === l\\n    ? {\\n        baseFolder: o,\\n        url: c,\\n        hostname: \\"\\",\\n        owner: \\"\\",\\n        repo: \\"\\",\\n        pathname: \\"\\",\\n      }\\n    : {\\n        baseFolder: o,\\n        url: c,\\n        ...l,\\n      };\\n}\\nfunction parseRepoUrl(e) {\\n  let t = {};\\n  try {\\n    t = o(e);\\n    if (\\"\\" == t.host || \\"\\" == t.owner || \\"\\" == t.name || \\"\\" == t.pathname)\\n      return;\\n  } catch (e) {\\n    return;\\n  }\\n  return {\\n    hostname: t.host,\\n    owner: t.owner,\\n    repo: t.name,\\n    pathname: t.pathname,\\n  };\\n}\\nfunction getRepoUrlFromConfigText(e) {\\n  var t;\\n  const n = /^\\\\s*\\\\[\\\\s*remote\\\\s+\\"((\\\\\\\\\\\\\\\\|\\\\\\\\\\"|[^\\\\\\\\\\"])+)\\"/,\\n    r = /^\\\\s*\\\\[remote.([^\\"\\\\s]+)/,\\n    o = /^\\\\s*url\\\\s*=\\\\s*([^\\\\s#;]+)/,\\n    i = /^\\\\s*\\\\[/;\\n  let s,\\n    a,\\n    c = !1;\\n  for (const l of e.split(\\"\\\\n\\"))\\n    if (c && undefined !== s) {\\n      s += l;\\n      if (l.endsWith(\\"\\\\\\\\\\")) s = s.substring(0, s.length - 1);\\n      else if (((c = !1), \\"origin\\" === a)) return s;\\n    } else {\\n      const e = null !== (t = l.match(n)) && undefined !== t ? t : l.match(r);\\n      if (e) a = e[1];\\n      else if (l.match(i)) a = undefined;\\n      else {\\n        if (s && \\"origin\\" !== a) continue;\\n        {\\n          const e = l.match(o);\\n          if (e) {\\n            s = e[1];\\n            if (s.endsWith(\\"\\\\\\\\\\")) {\\n              s = s.substring(0, s.length - 1);\\n              c = !0;\\n            } else if (\\"origin\\" === a) return s;\\n          }\\n        }\\n      }\\n    }\\n  return s;\\n}\\nvar f;\\nexports.extractRepoInfoForTesting = async function (e, t) {\\n  return d(e, t);\\n};\\nexports.parseRepoUrl = parseRepoUrl;\\nexports.getRepoUrlFromConfigText = getRepoUrlFromConfigText;\\n(function (e) {\\n  e[(e.PENDING = 0)] = \\"PENDING\\";\\n})((f = exports.ComputationStatus || (exports.ComputationStatus = {})));\\nclass m {\\n  constructor(e) {\\n    this.result = e;\\n  }\\n}","module-code-2388":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.launchSolutions = exports.normalizeCompletionText = undefined;\\nconst r = require(\\"uuid-utils\\"),\\n  o = require(6932),\\n  i = require(\\"config-stuff\\"),\\n  s = require(\\"completion-context\\"),\\n  a = require(\\"logging-utils\\"),\\n  c = require(\\"openai_conn_utils\\"),\\n  l = require(\\"openai-choices-utils\\"),\\n  u = require(6722),\\n  d = require(\\"context-extractor-from-identation-maybe\\"),\\n  p = require(\\"prompt-extractor\\"),\\n  h = require(2533),\\n  f = require(\\"background-context-provider\\"),\\n  m = require(\\"postprocess-choice\\"),\\n  g = require(\\"telemetry-stuff\\"),\\n  _ = require(\\"location-factory\\"),\\n  y = new a.Logger(a.LogLevel.INFO, \\"solutions\\");\\nfunction v(e, t, n, r) {\\n  return async (o) => {\\n    if (r instanceof Array) {\\n      const [i, s] = r;\\n      return d.isBlockBodyFinishedWithPrefix(e, t, n, o, s);\\n    }\\n    return d.isBlockBodyFinished(e, t, n, o);\\n  };\\n}\\nasync function b(e, t, n) {\\n  if (t.isCancellationRequested) {\\n    e.removeProgress();\\n    return {\\n      status: \\"FinishedWithError\\",\\n      error: \\"Cancelled\\",\\n    };\\n  }\\n  const r = await n.next();\\n  return !0 === r.done\\n    ? (e.removeProgress(),\\n      {\\n        status: \\"FinishedNormally\\",\\n      })\\n    : {\\n        status: \\"Solution\\",\\n        solution: r.value,\\n        next: b(e, t, n),\\n      };\\n}\\nexports.normalizeCompletionText = function (e) {\\n  return e.replace(/\\\\s+/g, \\"\\");\\n};\\nexports.launchSolutions = async function (e, t) {\\n  var n, a, w;\\n  const x = t.completionContext.insertPosition,\\n    E = t.completionContext.prependToCompletion,\\n    C = t.completionContext.indentation,\\n    S = e.get(_.LocationFactory),\\n    T = await t.getDocument(),\\n    k = await p.extractPrompt(e, T, x);\\n  if (\\"contextTooShort\\" === k.type) {\\n    t.reportCancelled();\\n    return {\\n      status: \\"FinishedWithError\\",\\n      error: \\"Context too short\\",\\n    };\\n  }\\n  const I = k.prompt,\\n    P = k.trailingWs;\\n  if (P.length > 0) {\\n    t.startPosition = S.position(\\n      t.startPosition.line,\\n      t.startPosition.character - P.length\\n    );\\n  }\\n  const A = t.getCancellationToken(),\\n    O = r.v4();\\n  t.savedTelemetryData = g.TelemetryData.createAndMarkAsIssued(\\n    {\\n      headerRequestId: O,\\n      languageId: T.languageId,\\n      source: s.completionTypeToString(t.completionContext.completionType),\\n    },\\n    {\\n      ...g.telemetrizePromptLength(I),\\n      solutionCount: t.solutionCountTarget,\\n      promptEndPos: T.offsetAt(x),\\n    }\\n  );\\n  if (t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX) {\\n    const e = I.prefix.split(\\"\\\\n\\"),\\n      t = e.pop(),\\n      n = e.pop();\\n    if (n) {\\n      const r = /^\\\\W+(todo:?\\\\s+)/i.exec(n);\\n      if (r) {\\n        const o = r[1],\\n          i = n.replace(o, \\"\\");\\n        I.prefix = e.join(\\"\\\\n\\") + \\"\\\\n\\" + i + \\"\\\\n\\" + t;\\n      }\\n    }\\n  }\\n  if (\\n    t.completionContext.completionType ===\\n    s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\\n  ) {\\n    I.prefix += t.completionContext.prependToCompletion;\\n  }\\n  y.info(e, `prompt: ${JSON.stringify(I)}`);\\n  y.debug(e, `prependToCompletion: ${E}`);\\n  g.telemetry(e, \\"solution.requested\\", t.savedTelemetryData);\\n  const N = await e.get(i.BlockModeConfig).forLanguage(e, T.languageId),\\n    R = h.isSupportedLanguageId(T.languageId),\\n    M = d.contextIndentation(T, x),\\n    L = {\\n      stream: !0,\\n      extra: {\\n        language: T.languageId,\\n        next_indent: null !== (n = M.next) && undefined !== n ? n : 0,\\n      },\\n    };\\n  if (\\"parsing\\" !== N || R) {\\n    L.stop = [\\"\\\\n\\\\n\\", \\"\\\\r\\\\n\\\\r\\\\n\\"];\\n  }\\n  const $ = f.extractRepoInfoInBackground(e, T.fileName),\\n    D = {\\n      prompt: I,\\n      languageId: T.languageId,\\n      repoInfo: $,\\n      ourRequestId: O,\\n      engineUrl: await c.getEngineURL(\\n        e,\\n        f.tryGetGitHubNWO($),\\n        T.languageId,\\n        f.getDogFood($),\\n        await f.getUserKind(e),\\n        t.savedTelemetryData\\n      ),\\n      count: t.solutionCountTarget,\\n      uiKind: l.CopilotUiKind.Panel,\\n      postOptions: L,\\n      requestLogProbs: !0,\\n    };\\n  let F;\\n  const j =\\n    t.completionContext.completionType ===\\n    s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\\n      ? [\\n          s.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX,\\n          t.completionContext.prependToCompletion,\\n        ]\\n      : t.completionContext.completionType;\\n  switch (N) {\\n    case i.BlockMode.Server:\\n      F = async (e) => {};\\n      L.extra.force_indent = null !== (a = M.prev) && undefined !== a ? a : -1;\\n      L.extra.trim_by_indentation = !0;\\n      break;\\n    case i.BlockMode.ParsingAndServer:\\n      F = R ? v(e, T, t.startPosition, j) : async (e) => {};\\n      L.extra.force_indent = null !== (w = M.prev) && undefined !== w ? w : -1;\\n      L.extra.trim_by_indentation = !0;\\n      break;\\n    case i.BlockMode.Parsing:\\n    default:\\n      F = R ? v(e, T, t.startPosition, j) : async (e) => {};\\n  }\\n  e.get(u.StatusReporter).setProgress();\\n  const q = await e\\n    .get(l.OpenAIFetcher)\\n    .fetchAndStreamCompletions(\\n      e,\\n      D,\\n      g.TelemetryData.createAndMarkAsIssued(),\\n      F,\\n      A\\n    );\\n  if (\\"failed\\" === q.type || \\"canceled\\" === q.type) {\\n    t.reportCancelled();\\n    e.get(u.StatusReporter).removeProgress();\\n    return {\\n      status: \\"FinishedWithError\\",\\n      error: `${q.type}: ${q.reason}`,\\n    };\\n  }\\n  let B = q.choices;\\n  B = (async function* (e, t) {\\n    for await (const n of e) {\\n      const e = {\\n        ...n,\\n      };\\n      e.completionText = t + e.completionText.trimRight();\\n      yield e;\\n    }\\n  })(B, E);\\n  if (null !== C) {\\n    B = l.cleanupIndentChoices(B, C);\\n  }\\n  B = o.asyncIterableMapFilter(B, async (t) =>\\n    m.postProcessChoice(e, \\"solution\\", T, x, t, !1, y)\\n  );\\n  const U = o.asyncIterableMapFilter(B, async (n) => {\\n    let r = n.completionText;\\n    y.info(e, `Open Copilot completion: [${n.completionText}]`);\\n    if (\\n      t.completionContext.completionType === s.CompletionType.OPEN_COPILOT ||\\n      t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX\\n    ) {\\n      let t = \\"\\";\\n      const o = await (0, d.getNodeStart)(e, T, x, n.completionText);\\n      if (o)\\n        [t] = (0, p.trimLastLine)(\\n          T.getText(S.range(S.position(o.line, o.character), x))\\n        );\\n      else {\\n        const e = S.position(x.line, 0);\\n        t = T.getText(S.range(e, x));\\n      }\\n      r = t + r;\\n    }\\n    let o = n.completionText;\\n    if (\\n      t.completionContext.completionType === s.CompletionType.TODO_QUICK_FIX\\n    ) {\\n      if (T.lineAt(x.line).isEmptyOrWhitespace) {\\n        o += \\"\\\\n\\";\\n      }\\n    }\\n    if (P.length > 0 && o.startsWith(P)) {\\n      o = o.substring(P.length);\\n    }\\n    const i = n.meanLogProb;\\n    return {\\n      displayText: r,\\n      meanProb: undefined !== i ? Math.exp(i) : 0,\\n      meanLogProb: i || 0,\\n      completionText: o,\\n      requestId: n.requestId,\\n      choiceIndex: n.choiceIndex,\\n      prependToCompletion: E,\\n    };\\n  });\\n  return b(e.get(u.StatusReporter), A, U[Symbol.asyncIterator]());\\n};","module-label-6881":"change-tracker","module-label-8129":"extension-location-factory","module-code-3055467":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.splitIntoWords =\\n  exports.WindowedMatcher =\\n  exports.SortOptions =\\n    undefined;\\nconst r = require(\\"get-prompt-actual\\");\\nvar o;\\n!(function (e) {\\n  e.Ascending = \\"ascending\\";\\n  e.Descending = \\"descending\\";\\n  e.None = \\"none\\";\\n})((o = exports.SortOptions || (exports.SortOptions = {})));\\nclass i {\\n  constructor(e) {\\n    var t;\\n    this.stopsForLanguage =\\n      null !== (t = u.get(e.languageId)) && undefined !== t ? t : l;\\n  }\\n  tokenize(e) {\\n    return new Set(\\n      splitIntoWords(e).filter((e) => !this.stopsForLanguage.has(e))\\n    );\\n  }\\n}\\nconst s = new (class {\\n  constructor(e) {\\n    this.keys = [];\\n    this.cache = {};\\n    this.size = e;\\n  }\\n  put(e, t) {\\n    var n;\\n    this.cache[e] = t;\\n    if (this.keys.length > this.size) {\\n      this.keys.push(e);\\n      const t = null !== (n = this.keys.shift()) && void 0 !== n ? n : \\"\\";\\n      delete this.cache[t];\\n    }\\n  }\\n  get(e) {\\n    return this.cache[e];\\n  }\\n})(20);\\nfunction splitIntoWords(e) {\\n  return e.split(/[^a-zA-Z0-9]/).filter((e) => e.length > 0);\\n}\\nexports.WindowedMatcher = class {\\n  constructor(e) {\\n    this.tokenizer = new i(e);\\n    this.referenceTokens = this.tokenizer.tokenize(this.trimDocument(e));\\n  }\\n  sortScoredSnippets(e, t = o.Descending) {\\n    return t == o.Ascending\\n      ? e.sort((e, t) => (e.score > t.score ? 1 : -1))\\n      : t == o.Descending\\n      ? e.sort((e, t) => (e.score > t.score ? -1 : 1))\\n      : e;\\n  }\\n  retrieveAllSnippets(e, t = o.Descending) {\\n    var n;\\n    const r = [];\\n    if (0 === e.source.length || 0 === this.referenceTokens.size) return r;\\n    const i = e.source.split(\\"\\\\n\\"),\\n      a = this.id() + \\":\\" + e.source,\\n      c = null !== (n = s.get(a)) && undefined !== n ? n : [],\\n      l = 0 == c.length,\\n      u = l ? i.map(this.tokenizer.tokenize, this.tokenizer) : [];\\n    for (const [e, [t, n]] of this.getWindowsDelineations(i).entries()) {\\n      if (l) {\\n        const e = new Set();\\n        u.slice(t, n).forEach((t) => t.forEach(e.add, e));\\n        c.push(e);\\n      }\\n      const o = c[e],\\n        i = this.similarityScore(o, this.referenceTokens);\\n      r.push({\\n        score: i,\\n        startLine: t,\\n        endLine: n,\\n      });\\n    }\\n    if (l) {\\n      s.put(a, c);\\n    }\\n    return this.sortScoredSnippets(r, t);\\n  }\\n  findMatches(e, t = r.SnippetSelectionOption.BestMatch, n) {\\n    if (t == r.SnippetSelectionOption.BestMatch) {\\n      const t = this.findBestMatch(e);\\n      return t ? [t] : [];\\n    }\\n    return (\\n      (t == r.SnippetSelectionOption.TopK && this.findTopKMatches(e, n)) || []\\n    );\\n  }\\n  findBestMatch(e) {\\n    if (0 === e.source.length || 0 === this.referenceTokens.size) return;\\n    const t = e.source.split(\\"\\\\n\\"),\\n      n = this.retrieveAllSnippets(e, o.Descending);\\n    return 0 !== n.length && 0 !== n[0].score\\n      ? {\\n          snippet: t.slice(n[0].startLine, n[0].endLine).join(\\"\\\\n\\"),\\n          ...n[0],\\n        }\\n      : undefined;\\n  }\\n  findTopKMatches(e, t = 1) {\\n    if (0 === e.source.length || 0 === this.referenceTokens.size || t < 1)\\n      return;\\n    const n = e.source.split(\\"\\\\n\\"),\\n      r = this.retrieveAllSnippets(e, o.Descending);\\n    if (0 === r.length || 0 === r[0].score) return;\\n    const i = [r[0]];\\n    for (let e = 1; e < r.length && i.length < t; e++)\\n      if (\\n        -1 ==\\n        i.findIndex(\\n          (t) => r[e].startLine < t.endLine && r[e].endLine > t.startLine\\n        )\\n      ) {\\n        i.push(r[e]);\\n      }\\n    return i.map((e) => ({\\n      snippet: n.slice(e.startLine, e.endLine).join(\\"\\\\n\\"),\\n      ...e,\\n    }));\\n  }\\n};\\nexports.splitIntoWords = splitIntoWords;\\nconst c = new Set([\\n    \\"we\\",\\n    \\"our\\",\\n    \\"you\\",\\n    \\"it\\",\\n    \\"its\\",\\n    \\"they\\",\\n    \\"them\\",\\n    \\"their\\",\\n    \\"this\\",\\n    \\"that\\",\\n    \\"these\\",\\n    \\"those\\",\\n    \\"is\\",\\n    \\"are\\",\\n    \\"was\\",\\n    \\"were\\",\\n    \\"be\\",\\n    \\"been\\",\\n    \\"being\\",\\n    \\"have\\",\\n    \\"has\\",\\n    \\"had\\",\\n    \\"having\\",\\n    \\"do\\",\\n    \\"does\\",\\n    \\"did\\",\\n    \\"doing\\",\\n    \\"can\\",\\n    \\"don\\",\\n    \\"t\\",\\n    \\"s\\",\\n    \\"will\\",\\n    \\"would\\",\\n    \\"should\\",\\n    \\"what\\",\\n    \\"which\\",\\n    \\"who\\",\\n    \\"when\\",\\n    \\"where\\",\\n    \\"why\\",\\n    \\"how\\",\\n    \\"a\\",\\n    \\"an\\",\\n    \\"the\\",\\n    \\"and\\",\\n    \\"or\\",\\n    \\"not\\",\\n    \\"no\\",\\n    \\"but\\",\\n    \\"because\\",\\n    \\"as\\",\\n    \\"until\\",\\n    \\"again\\",\\n    \\"further\\",\\n    \\"then\\",\\n    \\"once\\",\\n    \\"here\\",\\n    \\"there\\",\\n    \\"all\\",\\n    \\"any\\",\\n    \\"both\\",\\n    \\"each\\",\\n    \\"few\\",\\n    \\"more\\",\\n    \\"most\\",\\n    \\"other\\",\\n    \\"some\\",\\n    \\"such\\",\\n    \\"above\\",\\n    \\"below\\",\\n    \\"to\\",\\n    \\"during\\",\\n    \\"before\\",\\n    \\"after\\",\\n    \\"of\\",\\n    \\"at\\",\\n    \\"by\\",\\n    \\"about\\",\\n    \\"between\\",\\n    \\"into\\",\\n    \\"through\\",\\n    \\"from\\",\\n    \\"up\\",\\n    \\"down\\",\\n    \\"in\\",\\n    \\"out\\",\\n    \\"on\\",\\n    \\"off\\",\\n    \\"over\\",\\n    \\"under\\",\\n    \\"only\\",\\n    \\"own\\",\\n    \\"same\\",\\n    \\"so\\",\\n    \\"than\\",\\n    \\"too\\",\\n    \\"very\\",\\n    \\"just\\",\\n    \\"now\\",\\n  ]),\\n  l = new Set([\\n    \\"if\\",\\n    \\"then\\",\\n    \\"else\\",\\n    \\"for\\",\\n    \\"while\\",\\n    \\"with\\",\\n    \\"def\\",\\n    \\"function\\",\\n    \\"return\\",\\n    \\"TODO\\",\\n    \\"import\\",\\n    \\"try\\",\\n    \\"catch\\",\\n    \\"raise\\",\\n    \\"finally\\",\\n    \\"repeat\\",\\n    \\"switch\\",\\n    \\"case\\",\\n    \\"match\\",\\n    \\"assert\\",\\n    \\"continue\\",\\n    \\"break\\",\\n    \\"const\\",\\n    \\"class\\",\\n    \\"enum\\",\\n    \\"struct\\",\\n    \\"static\\",\\n    \\"new\\",\\n    \\"super\\",\\n    \\"this\\",\\n    \\"var\\",\\n    ...c,\\n  ]),\\n  u = new Map([]);","module-code-4969":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.extractPrompt =\\n  exports.trimLastLine =\\n  exports._contextTooShort =\\n  exports.MIN_PROMPT_CHARS =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"config-stuff\\"),\\n  i = require(\\"doc-tracker\\"),\\n  s = require(9189),\\n  a = require(\\"text-doc-relative-path\\"),\\n  c = require(2533),\\n  l = require(\\"background-context-provider\\");\\nfunction trimLastLine(e) {\\n  const t = e.split(\\"\\\\n\\"),\\n    n = t[t.length - 1],\\n    r = n.length - n.trimRight().length,\\n    o = e.slice(0, e.length - r),\\n    i = e.substr(o.length);\\n  return [n.length == r ? o : e, i];\\n}\\nasync function d(e, n, d, p, h, f) {\\n  var m;\\n  const g =\\n      null !==\\n        (m = l.tryGetGitHubNWO(l.extractRepoInfoInBackground(e, h.fsPath))) &&\\n      undefined !== m\\n        ? m\\n        : \\"\\",\\n    _ = await o.suffixPercent(e, g, f),\\n    y = await o.fimSuffixLengthThreshold(e, g, f);\\n  if ((_ > 0 ? n.length : d) < exports.MIN_PROMPT_CHARS)\\n    return exports._contextTooShort;\\n  const v = Date.now(),\\n    {\\n      prefix: b,\\n      suffix: w,\\n      promptChoices: x,\\n      promptBackground: E,\\n      promptElementRanges: C,\\n    } = await (async function (e, t, n, u, d, p) {\\n      var h;\\n      let f = [];\\n      f = await (async function (e, t, n) {\\n        const r = [],\\n          o = i.sortByAccessTimes(e.get(a.TextDocumentManager).textDocuments);\\n        let s = 0;\\n        for (const i of o) {\\n          if (r.length + 1 > 20 || s + i.getText().length > 2e5) break;\\n          if (\\n            \\"file\\" == i.uri.scheme &&\\n            i.fileName !== t &&\\n            i.languageId === n\\n          ) {\\n            r.push({\\n              uri: i.uri.toString(),\\n              relativePath: await e\\n                .get(a.TextDocumentManager)\\n                .getRelativePath(i),\\n              languageId: i.languageId,\\n              source: i.getText(),\\n            });\\n            s += i.getText().length;\\n          }\\n        }\\n        return r;\\n      })(e, d.fsPath, p);\\n      const m = {\\n          uri: d.toString(),\\n          source: t,\\n          offset: n,\\n          relativePath: u,\\n          languageId: p,\\n        },\\n        g =\\n          null !==\\n            (h = l.tryGetGitHubNWO(\\n              l.extractRepoInfoInBackground(e, d.fsPath)\\n            )) && undefined !== h\\n            ? h\\n            : \\"\\";\\n      let _ = {\\n        maxPromptLength: 2048 - o.getConfig(e, o.ConfigKey.SolutionLength),\\n        neighboringTabs: await e.get(s.Features).neighboringTabsOption(g, p),\\n        suffixStartMode: await e.get(s.Features).suffixStartMode(g, p),\\n      };\\n      const y = await o.suffixPercent(e, g, p),\\n        v = await o.suffixMatchThreshold(e, g, p),\\n        b = await o.fimSuffixLengthThreshold(e, g, p);\\n      if (y > 0) {\\n        _ = {\\n          ..._,\\n          includeSiblingFunctions: r.SiblingOption.NoSiblings,\\n          suffixPercent: y,\\n          suffixMatchThreshold: v,\\n          fimSuffixLengthThreshold: b,\\n        };\\n      }\\n      const w = e.get(r.FileSystem);\\n      return await c.getPrompt(w, m, _, f);\\n    })(e, n, d, p, h, f),\\n    [S, T] = trimLastLine(b),\\n    k = Date.now();\\n  return {\\n    type: \\"prompt\\",\\n    prompt: {\\n      prefix: S,\\n      suffix: w,\\n      isFimEnabled: _ > 0 && w.length > y,\\n      promptElementRanges: C.ranges,\\n    },\\n    trailingWs: T,\\n    promptChoices: x,\\n    computeTimeMs: k - v,\\n    promptBackground: E,\\n  };\\n}\\nasync function p(e, t, n) {\\n  const r = await e.get(a.TextDocumentManager).getRelativePath(t);\\n  return d(e, t.getText(), t.offsetAt(n), r, t.uri, t.languageId);\\n}\\nexports.MIN_PROMPT_CHARS = 10;\\nexports._contextTooShort = {\\n  type: \\"contextTooShort\\",\\n};\\nexports.trimLastLine = trimLastLine;\\nexports.extractPrompt = function (e, t, n) {\\n  const r = e.get(a.TextDocumentManager).findNotebook(t);\\n  return undefined === r\\n    ? p(e, t, n)\\n    : (async function (e, t, n, r) {\\n        const o = n.getCells().find((e) => e.document.uri === t.uri);\\n        if (o) {\\n          const i = n\\n              .getCells()\\n              .filter(\\n                (e) =>\\n                  e.index < o.index &&\\n                  e.document.languageId === o.document.languageId\\n              ),\\n            s =\\n              i.length > 0\\n                ? i.map((e) => e.document.getText()).join(\\"\\\\n\\\\n\\") + \\"\\\\n\\\\n\\"\\n                : \\"\\",\\n            c = s + t.getText(),\\n            l = s.length + t.offsetAt(r),\\n            u = await e.get(a.TextDocumentManager).getRelativePath(t);\\n          return d(e, c, l, u, t.uri, o.document.languageId);\\n        }\\n        return p(e, t, r);\\n      })(e, t, r, n);\\n};","module-label-4398":"telemetry-sender","module-label-362":"copilot-github-auth-stuff","module-label-7727":"context-extractor-from-identation-maybe","module-label-3136":"text-doc-relative-path","module-label-4969":"prompt-extractor","module-code-3197":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.registerGhostText =\\n  exports.handleGhostTextPostInsert =\\n  exports.handleGhostTextShown =\\n  exports.provideInlineCompletions =\\n  exports.ghostTextLogger =\\n  exports.getInsertionTextFromCompletion =\\n    undefined;\\nconst r = require(9496),\\n  o = require(\\"config-stuff\\"),\\n  i = require(\\"completion-from-ghost-text\\"),\\n  s = require(\\"ghost-text-provider\\"),\\n  a = require(\\"ghost-text-telemetry\\"),\\n  c = require(\\"logging-utils\\"),\\n  l = require(\\"post-accept-or-reject-tasks\\"),\\n  u = require(\\"telemetry-stuff\\"),\\n  d = require(\\"ignore-document-or-not\\"),\\n  p = \\"_ghostTextPostInsert\\";\\nfunction getInsertionTextFromCompletion(e) {\\n  return e.insertText;\\n}\\nlet f, m;\\nexports.getInsertionTextFromCompletion = getInsertionTextFromCompletion;\\nexports.ghostTextLogger = new c.Logger(c.LogLevel.INFO, \\"ghostText\\");\\nlet g,\\n  _ = [];\\nasync function provideInlineCompletions(e, n, c, h, y) {\\n  const v = await (async function (e, n, a, c, h) {\\n    const y = u.TelemetryData.createAndMarkAsIssued();\\n    if (\\n      !(function (e) {\\n        return o.getConfig(e, o.ConfigKey.InlineSuggestEnable);\\n      })(e)\\n    )\\n      return {\\n        type: \\"abortedBeforeIssued\\",\\n        reason: \\"ghost text is disabled\\",\\n      };\\n    if (d.ignoreDocument(e, n))\\n      return {\\n        type: \\"abortedBeforeIssued\\",\\n        reason: \\"document is ignored\\",\\n      };\\n    exports.ghostTextLogger.debug(\\n      e,\\n      `Ghost text called at [${a.line}, ${a.character}], with triggerKind ${c.triggerKind}`\\n    );\\n    if (h.isCancellationRequested)\\n      return (\\n        exports.ghostTextLogger.info(e, \\"Cancelled before extractPrompt\\"),\\n        {\\n          type: \\"abortedBeforeIssued\\",\\n          reason: \\"cancelled before extractPrompt\\",\\n        }\\n      );\\n    if (c.selectedCompletionInfo) {\\n      exports.ghostTextLogger.debug(\\n        e,\\n        \\"Not showing ghost text because autocomplete widget is displayed\\"\\n      );\\n      return {\\n        type: \\"abortedBeforeIssued\\",\\n        reason: \\"autocomplete widget is displayed\\",\\n      };\\n    }\\n    const v = await s.getGhostText(\\n      e,\\n      n,\\n      a,\\n      c.triggerKind === r.InlineCompletionTriggerKind.Invoke,\\n      y,\\n      h\\n    );\\n    if (\\"success\\" !== v.type) {\\n      exports.ghostTextLogger.debug(\\n        e,\\n        \\"Breaking, no results from getGhostText -- \\" + v.type + \\": \\" + v.reason\\n      );\\n      return v;\\n    }\\n    const [b, w] = v.value;\\n    if (\\n      f &&\\n      m &&\\n      (!f.isEqual(a) || m !== n.uri) &&\\n      w !== s.ResultType.TypingAsSuggested\\n    ) {\\n      const t = _.flatMap((e) =>\\n        e.displayText && e.telemetry\\n          ? [\\n              {\\n                completionText: e.displayText,\\n                completionTelemetryData: e.telemetry,\\n              },\\n            ]\\n          : []\\n      );\\n      if (t.length > 0) {\\n        l.postRejectionTasks(e, \\"ghostText\\", n.offsetAt(f), m, t);\\n      }\\n    }\\n    f = a;\\n    m = n.uri;\\n    _ = [];\\n    if (h.isCancellationRequested)\\n      return (\\n        exports.ghostTextLogger.info(e, \\"Cancelled after getGhostText\\"),\\n        {\\n          type: \\"canceled\\",\\n          reason: \\"after getGhostText\\",\\n          telemetryData: {\\n            telemetryBlob: v.telemetryBlob,\\n          },\\n        }\\n      );\\n    const x = i.completionsFromGhostTextResults(\\n      e,\\n      b,\\n      w,\\n      n,\\n      a,\\n      (function (e) {\\n        const t = r.window.visibleTextEditors.find((t) => t.document === e);\\n        return null == t ? undefined : t.options;\\n      })(n),\\n      g\\n    );\\n    exports.ghostTextLogger.debug(e, \\"Completions\\", x);\\n    const E = x.map((e) => {\\n      const { text: t, range: o } = e,\\n        i = new r.Range(\\n          new r.Position(o.start.line, o.start.character),\\n          new r.Position(o.end.line, o.end.character)\\n        ),\\n        s = new r.InlineCompletionItem(t, i);\\n      s.index = e.index;\\n      s.telemetry = e.telemetry;\\n      s.displayText = e.displayText;\\n      s.resultType = e.resultType;\\n      s.uri = n.uri;\\n      s.insertOffset = n.offsetAt(\\n        new r.Position(e.position.line, e.position.character)\\n      );\\n      s.command = {\\n        title: \\"PostInsertTask\\",\\n        command: p,\\n        arguments: [s],\\n      };\\n      return s;\\n    });\\n    return 0 === E.length\\n      ? {\\n          type: \\"empty\\",\\n          reason: \\"no completions in final result\\",\\n          telemetryData: v.telemetryData,\\n        }\\n      : {\\n          ...v,\\n          value: E,\\n        };\\n  })(e, n, c, h, y);\\n  return await a.handleGhostTextResultTelemetry(e, v);\\n}\\nexports.provideInlineCompletions = provideInlineCompletions;\\nclass v {\\n  constructor(e) {\\n    this.ctx = e;\\n  }\\n  async provideInlineCompletionItems(e, t, n, r) {\\n    return provideInlineCompletions(this.ctx, e, t, n, r);\\n  }\\n  handleDidShowCompletionItem(e) {\\n    handleGhostTextShown(this.ctx, e);\\n  }\\n}\\nfunction handleGhostTextShown(e, n) {\\n  g = n.index;\\n  if (!_.find((e) => e.index === n.index) && (_.push(n), n.telemetry)) {\\n    const r = !(n.resultType === s.ResultType.Network);\\n    exports.ghostTextLogger.debug(\\n      e,\\n      `[${n.telemetry.properties.headerRequestId}] shown choiceIndex: ${n.telemetry.properties.choiceIndex}, fromCache ${r}`\\n    ),\\n      (0, a.telemetryShown)(e, \\"ghostText\\", n.telemetry, r);\\n  }\\n}\\nasync function handleGhostTextPostInsert(e, n) {\\n  _ = [];\\n  m = undefined;\\n  f = undefined;\\n  exports.ghostTextLogger.debug(e, \\"Ghost text post insert\\");\\n  if (\\n    n.telemetry &&\\n    n.uri &&\\n    n.displayText &&\\n    undefined !== n.insertOffset &&\\n    n.range\\n  ) {\\n    n.telemetry.measurements.compCharLen =\\n      getInsertionTextFromCompletion(n).length;\\n    await l.postInsertionTasks(\\n      e,\\n      \\"ghostText\\",\\n      n.displayText,\\n      n.insertOffset,\\n      n.uri,\\n      n.telemetry\\n    );\\n  }\\n}\\nexports.handleGhostTextShown = handleGhostTextShown;\\nexports.handleGhostTextPostInsert = handleGhostTextPostInsert;\\nexports.registerGhostText = function (e) {\\n  const t = new v(e);\\n  return [\\n    r.languages.registerInlineCompletionItemProvider(\\n      {\\n        pattern: \\"**\\",\\n      },\\n      t\\n    ),\\n    r.commands.registerCommand(p, async (t) => handleGhostTextPostInsert(e, t)),\\n  ];\\n};","module-code-385":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ExtensionTextDocumentManager = undefined;\\nconst r = require(\\"path\\"),\\n  o = require(\\"vscode\\"),\\n  i = require(\\"text-doc-relative-path\\");\\nclass ExtensionTextDocumentManager extends i.TextDocumentManager {\\n  constructor() {\\n    super(...arguments);\\n    this.onDidFocusTextDocument = o.window.onDidChangeActiveTextEditor;\\n    this.onDidChangeTextDocument = o.workspace.onDidChangeTextDocument;\\n  }\\n  get textDocuments() {\\n    return o.workspace.textDocuments;\\n  }\\n  async getTextDocument(e) {\\n    return o.workspace.openTextDocument(e);\\n  }\\n  async getRelativePath(e) {\\n    var t, n, s;\\n    const a = e;\\n    if (a) {\\n      if (a.isUntitled) return;\\n      return null !==\\n        (s = i.getRelativePath(\\n          null !==\\n            (n =\\n              null === (t = o.workspace.workspaceFolders) || undefined === t\\n                ? undefined\\n                : t.map((e) => e.uri)) && undefined !== n\\n            ? n\\n            : [],\\n          a.fileName\\n        )) && undefined !== s\\n        ? s\\n        : r.basename(a.fileName);\\n    }\\n  }\\n  findNotebook(e) {\\n    const t = e;\\n    return o.workspace.notebookDocuments.find((e) =>\\n      e.getCells().some((e) => e.document === t)\\n    );\\n  }\\n}\\nexports.ExtensionTextDocumentManager = ExtensionTextDocumentManager;","module-code-3055125":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getNeighborSnippets = exports.neighborOptionToSelection = undefined;\\nconst r = require(\\"language-marker-constants\\"),\\n  o = require(\\"jaccard-scorer\\");\\nfunction i(e) {\\n  return [\\n    e.relativePath\\n      ? \\"Compare this snippet from \\" + e.relativePath + \\":\\"\\n      : \\"Compare this snippet:\\",\\n  ].concat(e.snippet.split(\\"\\\\n\\"));\\n}\\nexports.neighborOptionToSelection = {\\n  none: {\\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(1),\\n    threshold: -1,\\n    numberOfSnippets: 0,\\n  },\\n  conservative: {\\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\\n    threshold: 0.3,\\n    numberOfSnippets: 1,\\n  },\\n  medium: {\\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(20),\\n    threshold: 0.1,\\n    numberOfSnippets: 2,\\n  },\\n  eager: {\\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(60),\\n    threshold: 0,\\n    numberOfSnippets: 4,\\n  },\\n  eagerButLittle: {\\n    matcherFactory: o.FixedWindowSizeJaccardMatcher.FACTORY(10),\\n    threshold: 0,\\n    numberOfSnippets: 1,\\n  },\\n};\\nexports.getNeighborSnippets = async function (e, n, s, a, c, l, u) {\\n  const d = exports.neighborOptionToSelection[s],\\n    p = (function (e, n, r, i) {\\n      const s = {\\n        ...exports.neighborOptionToSelection[n],\\n      };\\n      if (undefined !== r && undefined !== i) {\\n        s.matcherFactory = o.IndentationBasedJaccardMatcher.FACTORY(r, i);\\n      }\\n      return s.matcherFactory.to(e);\\n    })(e, s, a, c);\\n  return n\\n    .filter((e) => e.source.length < 1e4 && e.source.length > 0)\\n    .slice(0, 20)\\n    .reduce(\\n      (e, t) =>\\n        e.concat(\\n          p.findMatches(t, l, u).map((e) => ({\\n            relativePath: t.relativePath,\\n            ...e,\\n          }))\\n        ),\\n      []\\n    )\\n    .filter((e) => e.score && e.snippet && e.score > d.threshold)\\n    .sort((e, t) => e.score - t.score)\\n    .slice(-d.numberOfSnippets)\\n    .map((t) => ({\\n      score: t.score,\\n      snippet: i(t)\\n        .map((t) => r.comment(t, e.languageId) + \\"\\\\n\\")\\n        .join(\\"\\"),\\n      startLine: t.startLine,\\n      endLine: t.endLine,\\n    }));\\n};","module-code-7017":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.postInsertionTasks =\\n  exports.postRejectionTasks =\\n  exports.captureCode =\\n    undefined;\\nconst r = require(\\"change-tracker\\"),\\n  o = require(\\"ghost-text-telemetry\\"),\\n  i = require(\\"logging-utils\\"),\\n  s = require(\\"context-extractor-from-identation-maybe\\"),\\n  a = require(\\"prompt-extractor\\"),\\n  c = require(5120),\\n  l = require(\\"telemetry-stuff\\"),\\n  u = require(\\"text-doc-relative-path\\"),\\n  d = new i.Logger(i.LogLevel.INFO, \\"post-insertion\\"),\\n  p = [\\n    {\\n      seconds: 15,\\n      captureCode: !1,\\n      captureRejection: !1,\\n    },\\n    {\\n      seconds: 30,\\n      captureCode: !0,\\n      captureRejection: !0,\\n    },\\n    {\\n      seconds: 120,\\n      captureCode: !1,\\n      captureRejection: !1,\\n    },\\n    {\\n      seconds: 300,\\n      captureCode: !1,\\n      captureRejection: !1,\\n    },\\n    {\\n      seconds: 600,\\n      captureCode: !1,\\n      captureRejection: !1,\\n    },\\n  ];\\nasync function captureCode(e, t, n) {\\n  const r = await e.get(u.TextDocumentManager).getTextDocument(t);\\n  if (!r) {\\n    d.info(\\n      e,\\n      `Could not get document for ${t.fsPath}. Maybe it was closed by the editor.`\\n    );\\n    return {\\n      prompt: {\\n        prefix: \\"\\",\\n        suffix: \\"\\",\\n        isFimEnabled: !1,\\n        promptElementRanges: [],\\n      },\\n      capturedCode: \\"\\",\\n      terminationOffset: 0,\\n    };\\n  }\\n  const o = r.getText(),\\n    i = o.substring(0, n),\\n    c = r.positionAt(n),\\n    l = await a.extractPrompt(e, r, c),\\n    p =\\n      \\"prompt\\" === l.type\\n        ? l.prompt\\n        : {\\n            prefix: i,\\n            suffix: \\"\\",\\n            isFimEnabled: !1,\\n            promptElementRanges: [],\\n          },\\n    h = o.substring(n),\\n    f = s.contextIndentationFromText(i, n, r.languageId),\\n    m = s.indentationBlockFinished(f, undefined),\\n    g = await m(h),\\n    _ = Math.min(o.length, n + (g ? 2 * g : 500));\\n  return {\\n    prompt: p,\\n    capturedCode: o.substring(n, _),\\n    terminationOffset: null != g ? g : -1,\\n  };\\n}\\nfunction f(e, t, n, r) {\\n  const o = e.substring(\\n      Math.max(0, r - n),\\n      Math.min(e.length, r + t.length + n)\\n    ),\\n    i = c.lexEditDistance(o, t),\\n    s = i.lexDistance / i.needleLexLength,\\n    { distance: a } = c.editDistance(\\n      o.substring(i.startOffset, i.endOffset),\\n      t\\n    );\\n  return {\\n    relativeLexEditDistance: s,\\n    charEditDistance: a,\\n    completionLexLength: i.needleLexLength,\\n    foundOffset: i.startOffset + Math.max(0, r - n),\\n    lexEditDistance: i.lexDistance,\\n    stillInCodeHeuristic: s <= 0.5 ? 1 : 0,\\n  };\\n}\\nexports.captureCode = captureCode;\\nexports.postRejectionTasks = function (e, t, n, i, s) {\\n  s.forEach(({ completionText: n, completionTelemetryData: r }) => {\\n    d.debug(e, `${t}.rejected choiceIndex: ${r.properties.choiceIndex}`);\\n    o.telemetryRejected(e, t, r);\\n  });\\n  const a = new r.ChangeTracker(e, i, n);\\n  p.filter((e) => e.captureRejection).map((r) => {\\n    a.push(async () => {\\n      d.debug(e, `Original offset: ${n}, Tracked offset: ${a.offset}`);\\n      const { completionTelemetryData: o } = s[0],\\n        {\\n          prompt: c,\\n          capturedCode: u,\\n          terminationOffset: p,\\n        } = await captureCode(e, i, a.offset);\\n      let f;\\n      f = c.isFimEnabled\\n        ? {\\n            hypotheticalPromptPrefixJson: JSON.stringify(c.prefix),\\n            hypotheticalPromptSuffixJson: JSON.stringify(c.suffix),\\n          }\\n        : {\\n            hypotheticalPromptJson: JSON.stringify(c.prefix),\\n          };\\n      const m = o.extendedBy(\\n        {\\n          ...f,\\n          capturedCodeJson: JSON.stringify(u),\\n        },\\n        {\\n          timeout: r.seconds,\\n          insertionOffset: n,\\n          trackedOffset: a.offset,\\n          terminationOffsetInCapturedCode: p,\\n        }\\n      );\\n      d.debug(\\n        e,\\n        `${t}.capturedAfterRejected choiceIndex: ${o.properties.choiceIndex}`,\\n        m\\n      );\\n      l.telemetry(e, t + \\".capturedAfterRejected\\", m, !0);\\n    }, 1e3 * r.seconds);\\n  });\\n};\\nexports.postInsertionTasks = async function (e, t, n, i, s, a) {\\n  d.debug(e, `${t}.accepted choiceIndex: ${a.properties.choiceIndex}`);\\n  o.telemetryAccepted(e, t, a);\\n  const c = new r.ChangeTracker(e, s, i),\\n    m = n.trim();\\n  p.map((n) =>\\n    c.push(\\n      () =>\\n        (async function (e, t, n, r, o, i, s, a) {\\n          const c = await e.get(u.TextDocumentManager).getTextDocument(o);\\n          if (c) {\\n            const u = c.getText();\\n            let p = f(u, n, 50, a.offset);\\n            if (p.stillInCodeHeuristic) {\\n              p = f(u, n, 1500, a.offset);\\n            }\\n            d.debug(\\n              e,\\n              `stillInCode: ${\\n                p.stillInCodeHeuristic ? \\"Found\\" : \\"Not found\\"\\n              }! Completion \'${n}\' in file ${\\n                o.fsPath\\n              }. lexEditDistance fraction was ${\\n                p.relativeLexEditDistance\\n              }. Char edit distance was ${\\n                p.charEditDistance\\n              }. Inserted at ${r}, tracked at ${a.offset}, found at ${\\n                p.foundOffset\\n              }. choiceIndex: ${s.properties.choiceIndex}`\\n            );\\n            const m = s\\n              .extendedBy(\\n                {},\\n                {\\n                  timeout: i.seconds,\\n                  insertionOffset: r,\\n                  trackedOffset: a.offset,\\n                }\\n              )\\n              .extendedBy({}, p);\\n            l.telemetry(e, t + \\".stillInCode\\", m);\\n            if (i.captureCode) {\\n              const {\\n                prompt: n,\\n                capturedCode: c,\\n                terminationOffset: u,\\n              } = await captureCode(e, o, a.offset);\\n              let p;\\n              p = n.isFimEnabled\\n                ? {\\n                    hypotheticalPromptPrefixJson: JSON.stringify(n.prefix),\\n                    hypotheticalPromptSuffixJson: JSON.stringify(n.suffix),\\n                  }\\n                : {\\n                    hypotheticalPromptJson: JSON.stringify(n.prefix),\\n                  };\\n              const f = s.extendedBy(\\n                {\\n                  ...p,\\n                  capturedCodeJson: JSON.stringify(c),\\n                },\\n                {\\n                  timeout: i.seconds,\\n                  insertionOffset: r,\\n                  trackedOffset: a.offset,\\n                  terminationOffsetInCapturedCode: u,\\n                }\\n              );\\n              d.debug(\\n                e,\\n                `${t}.capturedAfterAccepted choiceIndex: ${s.properties.choiceIndex}`,\\n                m\\n              ),\\n                (0, l.telemetry)(e, t + \\".capturedAfterAccepted\\", f, !0);\\n            }\\n          }\\n        })(e, t, m, i, s, n, a, c),\\n      1e3 * n.seconds\\n    )\\n  );\\n};","module-code-1929":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.OpenCopilotActionProvider = undefined;\\nconst r = require(9496),\\n  o = require(\\"completion-context\\"),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(\\"copilot-vscode-cmds\\"),\\n  a = require(\\"ignore-document-or-not\\");\\nexports.OpenCopilotActionProvider = class {\\n  constructor(e) {\\n    this.ctx = e;\\n    this.lastVersion = 0;\\n    this.lastRange = undefined;\\n  }\\n  indexOfGroup(e, t) {\\n    let n = e.index;\\n    for (let r = 1; r < t; r++) n += e[r].length;\\n    return n;\\n  }\\n  telemetryCodeAction(e, t) {\\n    const n = {\\n      languageId: e.languageId,\\n      codeActionType: o.completionTypeToString(t),\\n    };\\n    i.telemetry(\\n      this.ctx,\\n      \\"codeAction.displayed\\",\\n      i.TelemetryData.createAndMarkAsIssued(n)\\n    );\\n  }\\n  async provideCodeActions(e, t, n, i) {\\n    var c;\\n    if (a.ignoreDocument(this.ctx, e)) return;\\n    const l = e.lineAt(t.start);\\n    if (\\n      e.version === this.lastVersion &&\\n      this.lastRange &&\\n      this.lastRange.isEqual(t)\\n    )\\n      return;\\n    this.lastVersion = e.version;\\n    this.lastRange = t;\\n    const u = /^(\\\\W+)(todo)/i.exec(l.text);\\n    if (u) {\\n      const n = u[u.length - 1],\\n        i = this.indexOfGroup(u, u.length - 1);\\n      if (\\n        new r.Range(\\n          new r.Position(t.start.line, i),\\n          new r.Position(t.start.line, i + n.length)\\n        ).contains(t.start)\\n      ) {\\n        const t = new r.CodeAction(\\n            \\"Implement with GitHub Copilot\\",\\n            r.CodeActionKind.QuickFix\\n          ),\\n          n = {\\n            title: \\"Implement with GitHub Copilot\\",\\n            command: s.CMDOpenPanelForRange,\\n            arguments: [\\n              new o.CompletionContext(\\n                this.ctx,\\n                l.rangeIncludingLineBreak.end,\\n                o.CompletionType.TODO_QUICK_FIX\\n              ),\\n            ],\\n          };\\n        t.command = n;\\n        this.telemetryCodeAction(e, o.CompletionType.TODO_QUICK_FIX);\\n        return [t];\\n      }\\n    }\\n    const d = n.diagnostics.find((e) => \\"ts\\" === e.source && 2304 === e.code);\\n    if (d) {\\n      const t = await r.commands.executeCommand(\\n          \\"vscode.executeCodeActionProvider\\",\\n          e.uri,\\n          d.range\\n        ),\\n        n =\\n          null == t\\n            ? undefined\\n            : t.find((e) =>\\n                e.title.startsWith(\\"Add missing function declaration\\")\\n              ),\\n        i =\\n          null === (c = null == n ? undefined : n.edit) || undefined === c\\n            ? undefined\\n            : c.get(e.uri).pop();\\n      if (i) {\\n        const t = new r.CodeAction(\\n            \\"Implement with GitHub Copilot\\",\\n            r.CodeActionKind.QuickFix\\n          ),\\n          n = new o.CompletionContext(\\n            this.ctx,\\n            i.range.start,\\n            o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\\n          ),\\n          a = i.newText.trim().split(\\"\\\\n\\")[0];\\n        n.prependToCompletion = \\"\\\\n\\" + a;\\n        const c = {\\n          title: \\"Implement with GitHub Copilot\\",\\n          command: s.CMDOpenPanelForRange,\\n          arguments: [n],\\n        };\\n        t.command = c;\\n        this.telemetryCodeAction(\\n          e,\\n          o.CompletionType.UNKNOWN_FUNCTION_QUICK_FIX\\n        );\\n        return [t];\\n      }\\n    }\\n  }\\n};","module-code-3055610":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getNodeStart =\\n  exports.isBlockBodyFinished =\\n  exports.isEmptyBlockStart =\\n  exports.getBlockParser =\\n    undefined;\\nconst r = require(\\"get-prompt-parsing-utils\\");\\nclass o {\\n  constructor(e, t, n) {\\n    this.languageId = e;\\n    this.nodeMatch = t;\\n    this.nodeTypesWithBlockOrStmtChild = n;\\n  }\\n  async getNodeMatchAtPosition(e, t, n) {\\n    const o = await r.parseTree(this.languageId, e);\\n    try {\\n      let e = o.rootNode.descendantForIndex(t);\\n      for (; e; ) {\\n        const t = this.nodeMatch[e.type];\\n        if (t) {\\n          if (!this.nodeTypesWithBlockOrStmtChild.has(e.type)) break;\\n          const n = this.nodeTypesWithBlockOrStmtChild.get(e.type),\\n            r = \\"\\" == n ? e.namedChildren[0] : e.childForFieldName(n);\\n          if ((null == r ? undefined : r.type) == t) break;\\n        }\\n        e = e.parent;\\n      }\\n      if (!e) return;\\n      return n(e);\\n    } finally {\\n      o.delete();\\n    }\\n  }\\n  getNextBlockAtPosition(e, t, n) {\\n    return this.getNodeMatchAtPosition(e, t, (e) => {\\n      let t = e.children\\n        .reverse()\\n        .find((t) => t.type == this.nodeMatch[e.type]);\\n      if (t) {\\n        if (\\"python\\" == this.languageId && t.parent) {\\n          const e = \\":\\" == t.parent.type ? t.parent.parent : t.parent;\\n          let n = null == e ? undefined : e.nextSibling;\\n          for (; n && \\"comment\\" == n.type; ) {\\n            const r =\\n                n.startPosition.row == t.endPosition.row &&\\n                n.startPosition.column >= t.endPosition.column,\\n              o =\\n                n.startPosition.row > e.endPosition.row &&\\n                n.startPosition.column > e.startPosition.column;\\n            if (!r && !o) break;\\n            t = n;\\n            n = n.nextSibling;\\n          }\\n        }\\n        if (\\n          !(\\n            t.endIndex >= t.tree.rootNode.endIndex - 1 &&\\n            (t.hasError() || t.parent.hasError())\\n          )\\n        )\\n          return n(t);\\n      }\\n    });\\n  }\\n  async isBlockBodyFinished(e, t, n) {\\n    const r = (e + t).trimEnd(),\\n      o = await this.getNextBlockAtPosition(r, n, (e) => e.endIndex);\\n    if (undefined !== o && o < r.length) {\\n      const t = o - e.length;\\n      return t > 0 ? t : undefined;\\n    }\\n  }\\n  getNodeStart(e, t) {\\n    const n = e.trimEnd();\\n    return this.getNodeMatchAtPosition(n, t, (e) => e.startIndex);\\n  }\\n}\\nclass i extends o {\\n  constructor(e, t, n, r, o) {\\n    super(e, r, o);\\n    this.blockEmptyMatch = t;\\n    this.lineMatch = n;\\n  }\\n  isBlockStart(e) {\\n    return this.lineMatch.test(e.trimStart());\\n  }\\n  async isBlockBodyEmpty(e, t) {\\n    const n = await this.getNextBlockAtPosition(e, t, (n) => {\\n      if (n.startIndex < t) {\\n        t = n.startIndex;\\n      }\\n      let r = e.substring(t, n.endIndex).trim();\\n      return \\"\\" == r || r.replace(/\\\\s/g, \\"\\") == this.blockEmptyMatch;\\n    });\\n    return undefined === n || n;\\n  }\\n  async isEmptyBlockStart(e, t) {\\n    t = s(e, t);\\n    return (\\n      this.isBlockStart(\\n        (function (e, t) {\\n          const n = e.lastIndexOf(\\"\\\\n\\", t - 1);\\n          let r = e.indexOf(\\"\\\\n\\", t);\\n          if (r < 0) {\\n            r = e.length;\\n          }\\n          return e.slice(n + 1, r);\\n        })(e, t)\\n      ) && this.isBlockBodyEmpty(e, t)\\n    );\\n  }\\n}\\nfunction s(e, t) {\\n  let n = t;\\n  for (; n > 0 && /\\\\s/.test(e.charAt(n - 1)); ) n--;\\n  return n;\\n}\\nfunction a(e, t) {\\n  const n = e.startIndex,\\n    r = e.startIndex - e.startPosition.column,\\n    o = t.substring(r, n);\\n  if (/^\\\\s*$/.test(o)) return o;\\n}\\nfunction c(e, t, n) {\\n  if (t.startPosition.row <= e.startPosition.row) return !1;\\n  const r = a(e, n),\\n    o = a(t, n);\\n  return undefined !== r && undefined !== o && r.startsWith(o);\\n}\\nclass l extends o {\\n  constructor(e, t, n, r, o, i, s) {\\n    super(e, t, n);\\n    this.startKeywords = r;\\n    this.blockNodeType = o;\\n    this.emptyStatementType = i;\\n    this.curlyBraceLanguage = s;\\n  }\\n  isBlockEmpty(e, t) {\\n    var n, o;\\n    let i = e.text.trim();\\n    if (this.curlyBraceLanguage) {\\n      if (i.startsWith(\\"{\\")) {\\n        i = i.slice(1);\\n      }\\n      if (i.endsWith(\\"}\\")) {\\n        i = i.slice(0, -1);\\n      }\\n      i = i.trim();\\n    }\\n    return (\\n      0 == i.length ||\\n      !(\\n        \\"python\\" != this.languageId ||\\n        (\\"class_definition\\" !=\\n          (null === (n = e.parent) || undefined === n ? undefined : n.type) &&\\n          \\"function_definition\\" !=\\n            (null === (o = e.parent) || undefined === o\\n              ? undefined\\n              : o.type)) ||\\n        1 != e.children.length ||\\n        !r.queryPythonIsDocstring(e.parent)\\n      )\\n    );\\n  }\\n  async isEmptyBlockStart(e, t) {\\n    var n, o, i;\\n    if (t > e.length) throw new RangeError(\\"Invalid offset\\");\\n    for (let n = t; n < e.length && \\"\\\\n\\" != e.charAt(n); n++)\\n      if (/\\\\S/.test(e.charAt(n))) return !1;\\n    t = s(e, t);\\n    const a = await r.parseTree(this.languageId, e);\\n    try {\\n      const r = a.rootNode.descendantForIndex(t - 1);\\n      if (null == r) return !1;\\n      if (this.curlyBraceLanguage && \\"}\\" == r.type) return !1;\\n      if (\\n        (\\"javascript\\" == this.languageId || \\"typescript\\" == this.languageId) &&\\n        r.parent &&\\n        \\"object\\" == r.parent.type &&\\n        \\"{\\" == r.parent.text.trim()\\n      )\\n        return !0;\\n      if (\\"typescript\\" == this.languageId) {\\n        let n = r;\\n        for (; n.parent; ) {\\n          if (\\"function_signature\\" == n.type || \\"method_signature\\" == n.type) {\\n            const o = r.nextSibling;\\n            return (\\n              !!(o && n.hasError() && c(n, o, e)) ||\\n              (!n.children.find((e) => \\";\\" == e.type) && n.endIndex <= t)\\n            );\\n          }\\n          n = n.parent;\\n        }\\n      }\\n      let s = null,\\n        l = null,\\n        u = null,\\n        d = r;\\n      for (; null != d; ) {\\n        if (d.type == this.blockNodeType) {\\n          l = d;\\n          break;\\n        }\\n        if (this.nodeMatch[d.type]) {\\n          u = d;\\n          break;\\n        }\\n        if (\\"ERROR\\" == d.type) {\\n          s = d;\\n          break;\\n        }\\n        d = d.parent;\\n      }\\n      if (null != l) {\\n        if (!l.parent || !this.nodeMatch[l.parent.type]) return !1;\\n        if (\\"python\\" == this.languageId) {\\n          const e = l.previousSibling;\\n          if (\\n            null != e &&\\n            e.hasError() &&\\n            (e.text.startsWith(\'\\"\\"\\"\') || e.text.startsWith(\\"\'\'\'\\"))\\n          )\\n            return !0;\\n        }\\n        return this.isBlockEmpty(l, t);\\n      }\\n      if (null != s) {\\n        if (\\n          \\"module\\" ==\\n            (null === (n = s.previousSibling) || undefined === n\\n              ? undefined\\n              : n.type) ||\\n          \\"internal_module\\" ==\\n            (null === (o = s.previousSibling) || undefined === o\\n              ? undefined\\n              : o.type)\\n        )\\n          return !0;\\n        const e = [...s.children].reverse(),\\n          a = e.find((e) => this.startKeywords.includes(e.type));\\n        let c = e.find((e) => e.type == this.blockNodeType);\\n        if (a) {\\n          switch (this.languageId) {\\n            case \\"python\\": {\\n              if (\\n                \\"try\\" == a.type &&\\n                \\"identifier\\" == r.type &&\\n                r.text.length > 4\\n              ) {\\n                c =\\n                  null === (i = e.find((e) => e.hasError())) || undefined === i\\n                    ? undefined\\n                    : i.children.find((e) => \\"block\\" == e.type);\\n              }\\n              const t = e.find((e) => \\":\\" == e.type);\\n              if (t && a.endIndex <= t.startIndex && t.nextSibling) {\\n                if (\\"def\\" == a.type) {\\n                  const e = t.nextSibling;\\n                  if (\'\\"\' == e.type || \\"\'\\" == e.type) return !0;\\n                  if (\\"ERROR\\" == e.type && (\'\\"\\"\\"\' == e.text || \\"\'\'\'\\" == e.text))\\n                    return !0;\\n                }\\n                return !1;\\n              }\\n              break;\\n            }\\n            case \\"javascript\\": {\\n              const t = e.find((e) => \\"formal_parameters\\" == e.type);\\n              if (\\"class\\" == a.type && t) return !0;\\n              const n = e.find((e) => \\"{\\" == e.type);\\n              if (n && n.startIndex > a.endIndex && null != n.nextSibling)\\n                return !1;\\n              if (e.find((e) => \\"do\\" == e.type) && \\"while\\" == a.type) return !1;\\n              if (\\"=>\\" == a.type && a.nextSibling && \\"{\\" != a.nextSibling.type)\\n                return !1;\\n              break;\\n            }\\n            case \\"typescript\\": {\\n              const t = e.find((e) => \\"{\\" == e.type);\\n              if (t && t.startIndex > a.endIndex && null != t.nextSibling)\\n                return !1;\\n              if (e.find((e) => \\"do\\" == e.type) && \\"while\\" == a.type) return !1;\\n              if (\\"=>\\" == a.type && a.nextSibling && \\"{\\" != a.nextSibling.type)\\n                return !1;\\n              break;\\n            }\\n          }\\n          return !(c && c.startIndex > a.endIndex) || this.isBlockEmpty(c, t);\\n        }\\n      }\\n      if (null != u) {\\n        const e = this.nodeMatch[u.type],\\n          n = u.children\\n            .slice()\\n            .reverse()\\n            .find((t) => t.type == e);\\n        if (n) return this.isBlockEmpty(n, t);\\n        if (this.nodeTypesWithBlockOrStmtChild.has(u.type)) {\\n          const e = this.nodeTypesWithBlockOrStmtChild.get(u.type),\\n            t = \\"\\" == e ? u.children[0] : u.childForFieldName(e);\\n          if (\\n            t &&\\n            t.type != this.blockNodeType &&\\n            t.type != this.emptyStatementType\\n          )\\n            return !1;\\n        }\\n        return !0;\\n      }\\n      return !1;\\n    } finally {\\n      a.delete();\\n    }\\n  }\\n}\\nconst u = {\\n  python: new l(\\n    \\"python\\",\\n    {\\n      class_definition: \\"block\\",\\n      elif_clause: \\"block\\",\\n      else_clause: \\"block\\",\\n      except_clause: \\"block\\",\\n      finally_clause: \\"block\\",\\n      for_statement: \\"block\\",\\n      function_definition: \\"block\\",\\n      if_statement: \\"block\\",\\n      try_statement: \\"block\\",\\n      while_statement: \\"block\\",\\n      with_statement: \\"block\\",\\n    },\\n    new Map(),\\n    [\\n      \\"def\\",\\n      \\"class\\",\\n      \\"if\\",\\n      \\"elif\\",\\n      \\"else\\",\\n      \\"for\\",\\n      \\"while\\",\\n      \\"try\\",\\n      \\"except\\",\\n      \\"finally\\",\\n      \\"with\\",\\n    ],\\n    \\"block\\",\\n    null,\\n    !1\\n  ),\\n  javascript: new l(\\n    \\"javascript\\",\\n    {\\n      arrow_function: \\"statement_block\\",\\n      catch_clause: \\"statement_block\\",\\n      do_statement: \\"statement_block\\",\\n      else_clause: \\"statement_block\\",\\n      finally_clause: \\"statement_block\\",\\n      for_in_statement: \\"statement_block\\",\\n      for_statement: \\"statement_block\\",\\n      function: \\"statement_block\\",\\n      function_declaration: \\"statement_block\\",\\n      generator_function: \\"statement_block\\",\\n      generator_function_declaration: \\"statement_block\\",\\n      if_statement: \\"statement_block\\",\\n      method_definition: \\"statement_block\\",\\n      try_statement: \\"statement_block\\",\\n      while_statement: \\"statement_block\\",\\n      with_statement: \\"statement_block\\",\\n      class: \\"class_body\\",\\n      class_declaration: \\"class_body\\",\\n    },\\n    new Map([\\n      [\\"arrow_function\\", \\"body\\"],\\n      [\\"do_statement\\", \\"body\\"],\\n      [\\"else_clause\\", \\"\\"],\\n      [\\"for_in_statement\\", \\"body\\"],\\n      [\\"for_statement\\", \\"body\\"],\\n      [\\"if_statement\\", \\"consequence\\"],\\n      [\\"while_statement\\", \\"body\\"],\\n      [\\"with_statement\\", \\"body\\"],\\n    ]),\\n    [\\n      \\"=>\\",\\n      \\"try\\",\\n      \\"catch\\",\\n      \\"finally\\",\\n      \\"do\\",\\n      \\"for\\",\\n      \\"if\\",\\n      \\"else\\",\\n      \\"while\\",\\n      \\"with\\",\\n      \\"function\\",\\n      \\"function*\\",\\n      \\"class\\",\\n    ],\\n    \\"statement_block\\",\\n    \\"empty_statement\\",\\n    !0\\n  ),\\n  typescript: new l(\\n    \\"typescript\\",\\n    {\\n      ambient_declaration: \\"statement_block\\",\\n      arrow_function: \\"statement_block\\",\\n      catch_clause: \\"statement_block\\",\\n      do_statement: \\"statement_block\\",\\n      else_clause: \\"statement_block\\",\\n      finally_clause: \\"statement_block\\",\\n      for_in_statement: \\"statement_block\\",\\n      for_statement: \\"statement_block\\",\\n      function: \\"statement_block\\",\\n      function_declaration: \\"statement_block\\",\\n      generator_function: \\"statement_block\\",\\n      generator_function_declaration: \\"statement_block\\",\\n      if_statement: \\"statement_block\\",\\n      internal_module: \\"statement_block\\",\\n      method_definition: \\"statement_block\\",\\n      module: \\"statement_block\\",\\n      try_statement: \\"statement_block\\",\\n      while_statement: \\"statement_block\\",\\n      abstract_class_declaration: \\"class_body\\",\\n      class: \\"class_body\\",\\n      class_declaration: \\"class_body\\",\\n    },\\n    new Map([\\n      [\\"arrow_function\\", \\"body\\"],\\n      [\\"do_statement\\", \\"body\\"],\\n      [\\"else_clause\\", \\"\\"],\\n      [\\"for_in_statement\\", \\"body\\"],\\n      [\\"for_statement\\", \\"body\\"],\\n      [\\"if_statement\\", \\"consequence\\"],\\n      [\\"while_statement\\", \\"body\\"],\\n      [\\"with_statement\\", \\"body\\"],\\n    ]),\\n    [\\n      \\"declare\\",\\n      \\"=>\\",\\n      \\"try\\",\\n      \\"catch\\",\\n      \\"finally\\",\\n      \\"do\\",\\n      \\"for\\",\\n      \\"if\\",\\n      \\"else\\",\\n      \\"while\\",\\n      \\"with\\",\\n      \\"function\\",\\n      \\"function*\\",\\n      \\"class\\",\\n    ],\\n    \\"statement_block\\",\\n    \\"empty_statement\\",\\n    !0\\n  ),\\n  go: new i(\\n    \\"go\\",\\n    \\"{}\\",\\n    /\\\\b(func|if|else|for)\\\\b/,\\n    {\\n      communication_case: \\"block\\",\\n      default_case: \\"block\\",\\n      expression_case: \\"block\\",\\n      for_statement: \\"block\\",\\n      func_literal: \\"block\\",\\n      function_declaration: \\"block\\",\\n      if_statement: \\"block\\",\\n      labeled_statement: \\"block\\",\\n      method_declaration: \\"block\\",\\n      type_case: \\"block\\",\\n    },\\n    new Map()\\n  ),\\n  ruby: new i(\\n    \\"ruby\\",\\n    \\"end\\",\\n    /\\\\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\\\\b|->/,\\n    {\\n      begin_block: \\"}\\",\\n      block: \\"}\\",\\n      end_block: \\"}\\",\\n      lambda: \\"block\\",\\n      for: \\"do\\",\\n      until: \\"do\\",\\n      while: \\"do\\",\\n      case: \\"end\\",\\n      do: \\"end\\",\\n      if: \\"end\\",\\n      method: \\"end\\",\\n      module: \\"end\\",\\n      unless: \\"end\\",\\n      do_block: \\"end\\",\\n    },\\n    new Map()\\n  ),\\n};\\nfunction getBlockParser(e) {\\n  return u[r.languageIdToWasmLanguage(e)];\\n}\\nexports.getBlockParser = getBlockParser;\\nexports.isEmptyBlockStart = async function (e, t, n) {\\n  return (\\n    !!r.isSupportedLanguageId(e) && getBlockParser(e).isEmptyBlockStart(t, n)\\n  );\\n};\\nexports.isBlockBodyFinished = async function (e, t, n, o) {\\n  if (r.isSupportedLanguageId(e))\\n    return getBlockParser(e).isBlockBodyFinished(t, n, o);\\n};\\nexports.getNodeStart = async function (e, t, n) {\\n  if (r.isSupportedLanguageId(e)) return getBlockParser(e).getNodeStart(t, n);\\n};","module-code-1862":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.VSCodeCopilotTokenManager =\\n  exports.ExtensionNotificationSender =\\n  exports.setExtensionContext =\\n  exports.telemetryAcceptanceKey =\\n    undefined;\\nconst r = require(9496),\\n  o = require(\\"copilot-github-auth-stuff\\"),\\n  i = require(6794),\\n  s = require(\\"logging-utils\\"),\\n  a = require(\\"telemetry-stuff\\"),\\n  c = require(47);\\nexports.telemetryAcceptanceKey = `github.copilot.telemetryAccepted.${i.LAST_TELEMETRY_TERMS_UPDATE}`;\\nconst l = new s.Logger(s.LogLevel.INFO, \\"auth\\");\\nlet u,\\n  d = !1;\\nexports.setExtensionContext = function (e) {\\n  u = e;\\n};\\nexports.ExtensionNotificationSender = class {\\n  async showWarningMessage(e, ...t) {\\n    return {\\n      title: await r.window.showWarningMessage(e, ...t.map((e) => e.title)),\\n    };\\n  }\\n};\\nclass VSCodeCopilotTokenManager extends o.CopilotTokenManager {\\n  constructor() {\\n    super();\\n    this.copilotToken = undefined;\\n  }\\n  async getGitHubToken() {\\n    const e = await c.getSession();\\n    return null == e ? undefined : e.accessToken;\\n  }\\n  async getCopilotToken(e, n) {\\n    if (\\n      !this.copilotToken ||\\n      this.copilotToken.expires_at < o.nowSeconds() ||\\n      n\\n    ) {\\n      this.copilotToken = await (async function (e) {\\n        var n;\\n        const s = await (async function (e) {\\n          const t = await c.getSession();\\n          if (!t) {\\n            l.info(e, \\"GitHub login failed\\");\\n            a.telemetryError(e, \\"auth.github_login_failed\\");\\n            return {\\n              kind: \\"failure\\",\\n              reason: \\"GitHubLoginFailed\\",\\n            };\\n          }\\n          l.debug(\\n            e,\\n            `Logged in as ${t.account.label}, oauth token ${t.accessToken}`\\n          );\\n          const n = await o.authFromGitHubToken(e, {\\n            token: t.accessToken,\\n          });\\n          if (\\"success\\" == n.kind) {\\n            const r = n.token;\\n            l.debug(e, `Copilot HMAC for ${t.account.label}: ${r}`);\\n          }\\n          return n;\\n        })(e);\\n        if (\\"failure\\" === s.kind && \\"NotAuthorized\\" === s.reason)\\n          throw Error(\\n            null !== (n = s.message) && undefined !== n\\n              ? n\\n              : \\"User not authorized\\"\\n          );\\n        if (\\"failure\\" === s.kind && \\"HTTP401\\" === s.reason) {\\n          const e =\\n            \\"Your GitHub token is invalid. Please sign out from your GitHub account using VSCode UI and try again.\\";\\n          throw (d || ((d = !0), r.window.showWarningMessage(e)), Error(e));\\n        }\\n        if (\\"failure\\" === s.kind) throw Error(\\"Failed to get copilot token\\");\\n        if (\\n          \\"unconfigured\\" === s.telemetry &&\\n          !(await (async function (e) {\\n            var n;\\n            const o = null == u ? undefined : u.globalState;\\n            if (!o) return !1;\\n            const s =\\n              null === (n = c.getGithubAccount()) || undefined === n\\n                ? undefined\\n                : n.label;\\n            if (!s) return !1;\\n            const l = s,\\n              d = o.get(exports.telemetryAcceptanceKey, undefined);\\n            if (d && d === s) return !0;\\n            const p = await r.window.showWarningMessage(\\n              `I agree to these [telemetry terms](${i.TELEMETRY_TERMS_URL}) as part of the GitHub Copilot technical preview.`,\\n              \\"Cancel\\",\\n              \\"Agree\\"\\n            );\\n            if (\\"Agree\\" !== p) {\\n              const t = a.TelemetryData.createAndMarkAsIssued({\\n                choice: null != p ? p : \\"undefined\\",\\n              });\\n              a.telemetry(e, \\"auth.telemetry_terms_rejected\\", t);\\n              return !1;\\n            }\\n            o.update(exports.telemetryAcceptanceKey, l);\\n            const h = a.TelemetryData.createAndMarkAsIssued({\\n              terms_date: i.LAST_TELEMETRY_TERMS_UPDATE,\\n            });\\n            a.telemetry(e, \\"auth.telemetry_terms_accepted\\", h);\\n            return !0;\\n          })(e))\\n        )\\n          throw Error(\\"User did not agree to telemetry\\");\\n        return s;\\n      })(e);\\n      o.refreshToken(e, this, this.copilotToken.refresh_in);\\n    }\\n    return this.copilotToken;\\n  }\\n  resetCopilotToken(e, t) {\\n    if (undefined !== t) {\\n      a.telemetry(e, \\"auth.reset_token_\\" + t);\\n    }\\n    l.debug(e, `Resetting copilot token on HTTP error ${t || \\"unknown\\"}`);\\n    this.copilotToken = undefined;\\n  }\\n}\\nexports.VSCodeCopilotTokenManager = VSCodeCopilotTokenManager;","module-code-2533":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.parsesWithoutError =\\n  exports.getPrompt =\\n  exports.getNodeStart =\\n  exports.getFunctionPositions =\\n  exports.getBlockCloseToken =\\n  exports.isSupportedLanguageId =\\n  exports.isBlockBodyFinished =\\n  exports.isEmptyBlockStart =\\n  exports.terminate =\\n  exports.init =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\");\\nlet o = null;\\nconst i = new Map();\\nlet s = 0;\\nexports.init = function (t, u, d) {\\n  if (!u) {\\n    const t = require(\\"worker-utils-and-other-prompt-collection-stuff\\");\\n    for (const n of [...a, ...c]) module.exports[n] = t[n];\\n    return;\\n  }\\n  for (const n of a) module.exports[n] = l(t, d, n);\\n  module.exports.getPrompt = (function (e, t) {\\n    return function (n, ...r) {\\n      const a = s++;\\n      return new Promise((n, s) => {\\n        i.set(a, {\\n          resolve: n,\\n          reject: s,\\n        });\\n        t.debug(e, `Proxy getPrompt - ${a}`);\\n        if (null == o) {\\n          o.postMessage({\\n            id: a,\\n            fn: \\"getPrompt\\",\\n            args: r,\\n          });\\n        }\\n      });\\n    };\\n  })(t, d);\\n  o = r.createWorker();\\n  i.clear();\\n  s = 0;\\n  const p = t.get(r.FileSystem);\\n  function h(e) {\\n    d.error(t, e);\\n    for (const t of i.values()) t.reject(e);\\n    i.clear();\\n  }\\n  o.on(\\"message\\", ({ id: e, err: n, res: r }) => {\\n    const o = i.get(e);\\n    d.debug(t, `Response ${e} - ${r}, ${n}`);\\n    if (o) {\\n      i.delete(e);\\n      if (n) {\\n        o.reject(n);\\n      } else {\\n        o.resolve(r);\\n      }\\n    }\\n  });\\n  o.on(\\"error\\", h);\\n  o.on(\\"exit\\", (e) => {\\n    if (0 !== e) {\\n      h(new Error(`Worker thread exited with code ${e}.`));\\n    }\\n  });\\n  o.on(\\"readFileReq\\", (e) => {\\n    d.debug(t, `READ_FILE_REQ - ${e}`);\\n    p.readFile(e)\\n      .then((e) => {\\n        if (null == o) {\\n          o.emit(\\"readFileRes\\", e);\\n        }\\n      })\\n      .catch(h);\\n  });\\n  o.on(\\"mtimeRes\\", (e) => {\\n    d.debug(t, `mTime_REQ - ${e}`);\\n    p.mtime(e)\\n      .then((e) => {\\n        if (null == o) {\\n          o.emit(\\"mtimeRes\\", e);\\n        }\\n      })\\n      .catch(h);\\n  });\\n};\\nexports.terminate = function () {\\n  if (o) {\\n    o.removeAllListeners();\\n    o.terminate();\\n    o = null;\\n    i.clear();\\n  }\\n};\\nconst a = [\\n    \\"getFunctionPositions\\",\\n    \\"isEmptyBlockStart\\",\\n    \\"isBlockBodyFinished\\",\\n    \\"getNodeStart\\",\\n    \\"parsesWithoutError\\",\\n  ],\\n  c = [\\"isSupportedLanguageId\\", \\"getBlockCloseToken\\"];\\nfunction l(e, t, n) {\\n  return function (...r) {\\n    const a = s++;\\n    return new Promise((s, c) => {\\n      i.set(a, {\\n        resolve: s,\\n        reject: c,\\n      });\\n      t.debug(e, `Proxy ${n}`);\\n      if (null == o) {\\n        o.postMessage({\\n          id: a,\\n          fn: n,\\n          args: r,\\n        });\\n      }\\n    });\\n  };\\n}\\nexports.isEmptyBlockStart = r.isEmptyBlockStart;\\nexports.isBlockBodyFinished = r.isBlockBodyFinished;\\nexports.isSupportedLanguageId = r.isSupportedLanguageId;\\nexports.getBlockCloseToken = r.getBlockCloseToken;\\nexports.getFunctionPositions = r.getFunctionPositions;\\nexports.getNodeStart = r.getNodeStart;\\nexports.getPrompt = r.getPrompt;\\nexports.parsesWithoutError = r.parsesWithoutError;","module-code-3055395":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.findEditDistanceScore = undefined;\\nconst r = require(\\"tokenizer\\");\\nexports.findEditDistanceScore = function (e, t) {\\n  if (\\"string\\" == typeof e) {\\n    e = r.tokenize(e);\\n  }\\n  if (\\"string\\" == typeof t) {\\n    t = r.tokenize(t);\\n  }\\n  if (0 === e.length || 0 === t.length)\\n    return {\\n      score: e.length + t.length,\\n    };\\n  const n = Array.from({\\n    length: e.length,\\n  }).map(() =>\\n    Array.from({\\n      length: t.length,\\n    }).map(() => 0)\\n  );\\n  for (let t = 0; t < e.length; t++) n[t][0] = t;\\n  for (let e = 0; e < t.length; e++) n[0][e] = e;\\n  for (let r = 0; r < t.length; r++)\\n    for (let o = 0; o < e.length; o++)\\n      n[o][r] = Math.min(\\n        (0 == o ? r : n[o - 1][r]) + 1,\\n        (0 == r ? o : n[o][r - 1]) + 1,\\n        (0 == o || 0 == r ? Math.max(o, r) : n[o - 1][r - 1]) +\\n          (e[o] == t[r] ? 0 : 1)\\n      );\\n  return {\\n    score: n[e.length - 1][t.length - 1],\\n  };\\n};","module-code-1133":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.editorVersionHeaders =\\n  exports.EditorAndPluginInfo =\\n  exports.formatNameAndVersion =\\n  exports.getTestVscInfo =\\n  exports.VscInfo =\\n  exports.getVersion =\\n  exports.getBuild =\\n  exports.getBuildType =\\n  exports.isProduction =\\n  exports.BuildInfo =\\n  exports.fimSuffixLengthThreshold =\\n  exports.suffixMatchThreshold =\\n  exports.suffixPercent =\\n  exports.getEnabledConfig =\\n  exports.getLanguageConfig =\\n  exports.dumpConfig =\\n  exports.getHiddenConfig =\\n  exports.isDefaultSettingOverwritten =\\n  exports.getConfig =\\n  exports.getConfigDefaultForObjectKey =\\n  exports.getConfigDefaultForKey =\\n  exports.InMemoryConfigProvider =\\n  exports.DefaultsOnlyConfigProvider =\\n  exports.ConfigProvider =\\n  exports.ConfigBlockModeConfig =\\n  exports.BlockModeConfig =\\n  exports.BuildType =\\n  exports.shouldDoServerTrimming =\\n  exports.shouldDoParsingTrimming =\\n  exports.BlockMode =\\n  exports.ConfigKey =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"copilot-scheme\\"),\\n  i = require(9189),\\n  s = require(4147);\\nvar a, c;\\nexports.ConfigKey = {\\n  Enable: \\"enable\\",\\n  InlineSuggestEnable: \\"inlineSuggest.enable\\",\\n  ShowEditorCompletions: [\\"editor\\", \\"showEditorCompletions\\"],\\n  EnableAutoCompletions: [\\"editor\\", \\"enableAutoCompletions\\"],\\n  DelayCompletions: [\\"editor\\", \\"delayCompletions\\"],\\n  FilterCompletions: [\\"editor\\", \\"filterCompletions\\"],\\n  DisplayStyle: [\\"advanced\\", \\"displayStyle\\"],\\n  SecretKey: [\\"advanced\\", \\"secret_key\\"],\\n  SolutionLength: [\\"advanced\\", \\"length\\"],\\n  Stops: [\\"advanced\\", \\"stops\\"],\\n  Temperature: [\\"advanced\\", \\"temperature\\"],\\n  TopP: [\\"advanced\\", \\"top_p\\"],\\n  IndentationMode: [\\"advanced\\", \\"indentationMode\\"],\\n  InlineSuggestCount: [\\"advanced\\", \\"inlineSuggestCount\\"],\\n  ListCount: [\\"advanced\\", \\"listCount\\"],\\n  DebugOverrideProxyUrl: [\\"advanced\\", \\"debug.overrideProxyUrl\\"],\\n  DebugTestOverrideProxyUrl: [\\"advanced\\", \\"debug.testOverrideProxyUrl\\"],\\n  DebugOverrideEngine: [\\"advanced\\", \\"debug.overrideEngine\\"],\\n  DebugShowScores: [\\"advanced\\", \\"debug.showScores\\"],\\n  DebugOverrideLogLevels: [\\"advanced\\", \\"debug.overrideLogLevels\\"],\\n  DebugFilterLogCategories: [\\"advanced\\", \\"debug.filterLogCategories\\"],\\n  DebugUseSuffix: [\\"advanced\\", \\"debug.useSuffix\\"],\\n};\\n(function (e) {\\n  e.Parsing = \\"parsing\\";\\n  e.Server = \\"server\\";\\n  e.ParsingAndServer = \\"parsingandserver\\";\\n})((a = exports.BlockMode || (exports.BlockMode = {})));\\nexports.shouldDoParsingTrimming = function (e) {\\n  return [a.Parsing, a.ParsingAndServer].includes(e);\\n};\\nexports.shouldDoServerTrimming = function (e) {\\n  return [a.Server, a.ParsingAndServer].includes(e);\\n};\\n(c = exports.BuildType || (exports.BuildType = {})).DEV = \\"dev\\";\\nc.PROD = \\"prod\\";\\nc.NIGHTLY = \\"nightly\\";\\nclass BlockModeConfig {}\\nfunction u(e, t) {\\n  return e !== a.ParsingAndServer || r.isSupportedLanguageId(t) ? e : a.Server;\\n}\\nexports.BlockModeConfig = BlockModeConfig;\\nexports.ConfigBlockModeConfig = class extends BlockModeConfig {\\n  async forLanguage(e, n) {\\n    if (\\n      e\\n        .get(ConfigProvider)\\n        .isDefaultSettingOverwritten(exports.ConfigKey.IndentationMode)\\n    )\\n      switch (\\n        e\\n          .get(ConfigProvider)\\n          .getLanguageConfig(exports.ConfigKey.IndentationMode, n)\\n      ) {\\n        case \\"client\\":\\n        case !0:\\n        case \\"server\\":\\n          return a.Server;\\n        case \\"clientandserver\\":\\n          return u(a.ParsingAndServer, n);\\n        default:\\n          return a.Parsing;\\n      }\\n    const o = await e.get(i.Features).overrideBlockMode();\\n    return o ? u(o, n) : r.isSupportedLanguageId(n) ? a.Parsing : a.Server;\\n  }\\n};\\nclass ConfigProvider {}\\nfunction getConfigDefaultForKey(e) {\\n  try {\\n    const t =\\n      s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`]\\n        .default;\\n    if (undefined === t)\\n      throw new Error(\\n        `Missing config default value: ${o.CopilotConfigPrefix}.${e}`\\n      );\\n    return t;\\n  } catch (t) {\\n    throw new Error(\\n      `Error inspecting config default value ${o.CopilotConfigPrefix}.${e}: ${t}`\\n    );\\n  }\\n}\\nfunction getConfigDefaultForObjectKey(e, t) {\\n  try {\\n    const n =\\n      s.contributes.configuration[0].properties[`${o.CopilotConfigPrefix}.${e}`]\\n        .properties[t].default;\\n    if (undefined === n)\\n      throw new Error(\\n        `Missing config default value: ${o.CopilotConfigPrefix}.${e}`\\n      );\\n    return n;\\n  } catch (n) {\\n    throw new Error(\\n      `Error inspecting config default value ${o.CopilotConfigPrefix}.${e}.${t}: ${n}`\\n    );\\n  }\\n}\\nfunction getConfig(e, t) {\\n  return e.get(ConfigProvider).getConfig(t);\\n}\\nfunction isDefaultSettingOverwritten(e, t) {\\n  return e.get(ConfigProvider).isDefaultSettingOverwritten(t);\\n}\\nfunction getHiddenConfig(e, t, n) {\\n  return isDefaultSettingOverwritten(e, t) ? getConfig(e, t) : n.default;\\n}\\nfunction getLanguageConfig(e, t, n) {\\n  return e.get(ConfigProvider).getLanguageConfig(t, n);\\n}\\nexports.ConfigProvider = ConfigProvider;\\nexports.DefaultsOnlyConfigProvider = class extends ConfigProvider {\\n  getConfig(e) {\\n    return Array.isArray(e)\\n      ? getConfigDefaultForObjectKey(e[0], e[1])\\n      : getConfigDefaultForKey(e);\\n  }\\n  isDefaultSettingOverwritten(e) {\\n    return !1;\\n  }\\n  dumpConfig() {\\n    return {};\\n  }\\n  getLanguageConfig(e, t) {\\n    const n = this.getConfig(e);\\n    return t && t in n ? n[t] : n[\\"*\\"];\\n  }\\n};\\nexports.InMemoryConfigProvider = class {\\n  constructor(e, t) {\\n    this.baseConfigProvider = e;\\n    this.overrides = t;\\n  }\\n  getConfig(e) {\\n    const t = this.overrides.get(e);\\n    return undefined !== t ? t : this.baseConfigProvider.getConfig(e);\\n  }\\n  setConfig(e, t) {\\n    if (undefined !== t) {\\n      this.overrides.set(e, t);\\n    } else {\\n      this.overrides.delete(e);\\n    }\\n  }\\n  setLanguageEnablement(e, n) {\\n    this.overrides.set(exports.ConfigKey.Enable, {\\n      [e]: n,\\n    });\\n  }\\n  isDefaultSettingOverwritten(e) {\\n    return (\\n      !!this.overrides.has(e) ||\\n      this.baseConfigProvider.isDefaultSettingOverwritten(e)\\n    );\\n  }\\n  keyAsString(e) {\\n    return Array.isArray(e) ? e.join(\\".\\") : e;\\n  }\\n  dumpConfig() {\\n    const e = this.baseConfigProvider.dumpConfig();\\n    this.overrides.forEach((t, n) => {\\n      e[this.keyAsString(n)] = JSON.stringify(t);\\n    });\\n    return e;\\n  }\\n  getLanguageConfig(e, t) {\\n    const n = this.overrides.get(e);\\n    return undefined !== n\\n      ? undefined !== t\\n        ? n[t]\\n        : n[\\"*\\"]\\n      : this.baseConfigProvider.getLanguageConfig(e, t);\\n  }\\n};\\nexports.getConfigDefaultForKey = getConfigDefaultForKey;\\nexports.getConfigDefaultForObjectKey = getConfigDefaultForObjectKey;\\nexports.getConfig = getConfig;\\nexports.isDefaultSettingOverwritten = isDefaultSettingOverwritten;\\nexports.getHiddenConfig = getHiddenConfig;\\nexports.dumpConfig = function (e) {\\n  return e.get(ConfigProvider).dumpConfig();\\n};\\nexports.getLanguageConfig = getLanguageConfig;\\nexports.getEnabledConfig = function (e, n) {\\n  return getLanguageConfig(e, exports.ConfigKey.Enable, n);\\n};\\nexports.suffixPercent = async function (e, n, r) {\\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\\n    default: !1,\\n  })\\n    ? 15\\n    : e.get(i.Features).suffixPercent(n, r);\\n};\\nexports.suffixMatchThreshold = async function (e, n, r) {\\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\\n    default: !1,\\n  })\\n    ? 0\\n    : e.get(i.Features).suffixMatchThreshold(n, r);\\n};\\nexports.fimSuffixLengthThreshold = async function (e, n, r) {\\n  return getHiddenConfig(e, exports.ConfigKey.DebugUseSuffix, {\\n    default: !1,\\n  })\\n    ? -1\\n    : e.get(i.Features).fimSuffixLengthThreshold(n, r);\\n};\\nclass BuildInfo {\\n  constructor() {\\n    this.packageJson = s;\\n  }\\n  isProduction() {\\n    return \\"dev\\" != this.getBuildType();\\n  }\\n  getBuildType() {\\n    return this.packageJson.buildType;\\n  }\\n  getVersion() {\\n    return this.packageJson.version;\\n  }\\n  getBuild() {\\n    return this.packageJson.build;\\n  }\\n  getName() {\\n    return this.packageJson.name;\\n  }\\n}\\nexports.BuildInfo = BuildInfo;\\nexports.isProduction = function (e) {\\n  return e.get(BuildInfo).isProduction();\\n};\\nexports.getBuildType = function (e) {\\n  return e.get(BuildInfo).getBuildType();\\n};\\nexports.getBuild = function (e) {\\n  return e.get(BuildInfo).getBuild();\\n};\\nexports.getVersion = function (e) {\\n  return e.get(BuildInfo).getVersion();\\n};\\nclass VscInfo {\\n  constructor(e, t, n) {\\n    this.sessionId = e;\\n    this.machineId = t;\\n    this.vsCodeVersion = n;\\n  }\\n}\\nfunction formatNameAndVersion({ name: e, version: t }) {\\n  return `${e}/${t}`;\\n}\\nexports.VscInfo = VscInfo;\\nexports.getTestVscInfo = function () {\\n  return new VscInfo(\\n    \\"test-session-id\\",\\n    \\"test-machine-id\\",\\n    \\"test-vscode-version\\"\\n  );\\n};\\nexports.formatNameAndVersion = formatNameAndVersion;\\nclass EditorAndPluginInfo {}\\nexports.EditorAndPluginInfo = EditorAndPluginInfo;\\nexports.editorVersionHeaders = function (e) {\\n  const t = e.get(EditorAndPluginInfo);\\n  return {\\n    \\"Editor-Version\\": formatNameAndVersion(t.getEditorInfo(e)),\\n    \\"Editor-Plugin-Version\\": formatNameAndVersion(t.getEditorPluginInfo(e)),\\n  };\\n};","module-code-3055250":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getWindowsDelineations = undefined;\\nconst r = require(\\"parser-utils\\"),\\n  o = require(\\"parse-tree-utils2\\");\\nexports.getWindowsDelineations = function (e, t, n, i) {\\n  if (e.length < n || 0 == i) return [];\\n  const s = [],\\n    a = o.clearLabels(r.parseTree(e.join(\\"\\\\n\\"), t));\\n  o.visitTree(\\n    a,\\n    (e) => {\\n      if (\\"blank\\" === e.type)\\n        return void (e.label = {\\n          totalLength: 1,\\n          firstLineAfter: e.lineNumber + 1,\\n        });\\n      let t = \\"line\\" === e.type ? 1 : 0,\\n        r = \\"line\\" === e.type ? e.lineNumber + 1 : NaN;\\n      function o(n) {\\n        return -1 == n\\n          ? r - t\\n          : e.subs[n].label.firstLineAfter - e.subs[n].label.totalLength;\\n      }\\n      function a(t, n) {\\n        return 0 == t ? n + 1 : e.subs[t - 1].label.firstLineAfter;\\n      }\\n      let c = \\"line\\" === e.type ? -1 : 0,\\n        l = \\"line\\" === e.type ? 1 : 0,\\n        u = 0;\\n      for (let d = 0; d < e.subs.length; d++) {\\n        for (; c >= 0 && c < e.subs.length && \\"blank\\" === e.subs[c].type; ) {\\n          l -= e.subs[c].label.totalLength;\\n          c++;\\n        }\\n        if (\\"blank\\" !== e.subs[d].type) {\\n          u = d;\\n        }\\n        r = e.subs[d].label.firstLineAfter;\\n        t += e.subs[d].label.totalLength;\\n        l += e.subs[d].label.totalLength;\\n        if (l > i) {\\n          const t = o(c),\\n            r = a(d, t),\\n            p = u == d ? r : a(u, t);\\n          for (n <= r - t && s.push([t, p]); l > i; )\\n            (l -=\\n              -1 == c\\n                ? \\"line\\" == e.type\\n                  ? 1\\n                  : 0\\n                : e.subs[c].label.totalLength),\\n              c++;\\n        }\\n      }\\n      if (c < e.subs.length) {\\n        const t = o(c),\\n          i = r,\\n          a = -1 == c ? i : e.subs[u].label.firstLineAfter;\\n        if (n <= i - t) {\\n          s.push([t, a]);\\n        }\\n      }\\n      e.label = {\\n        totalLength: t,\\n        firstLineAfter: r,\\n      };\\n    },\\n    \\"bottomUp\\"\\n  );\\n  return s\\n    .sort((e, t) => e[0] - t[0] || e[1] - t[1])\\n    .filter((e, t, n) => 0 == t || e[0] != n[t - 1][0] || e[1] != n[t - 1][1]);\\n};","module-label-3055610":"ast-utils","module-label-3055179":"imports-and-docs-extractor","module-code-9748":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ExpConfigNone =\\n  exports.ExpConfigFromTAS =\\n  exports.ExpConfigMaker =\\n    undefined;\\nconst r = require(\\"helix-fetcher-and-network-stuff\\"),\\n  o = require(219);\\nclass ExpConfigMaker {}\\nexports.ExpConfigMaker = ExpConfigMaker;\\nexports.ExpConfigFromTAS = class extends ExpConfigMaker {\\n  async fetchExperiments(e, t) {\\n    var n;\\n    const i = e.get(r.Fetcher);\\n    let s;\\n    try {\\n      s = await i.fetch(\\"https://default.exp-tas.com/vscode/ab\\", {\\n        method: \\"GET\\",\\n        headers: t,\\n      });\\n    } catch (t) {\\n      return o.ExpConfig.createFallbackConfig(\\n        e,\\n        `Error fetching ExP config: ${t}`\\n      );\\n    }\\n    if (!s.ok)\\n      return o.ExpConfig.createFallbackConfig(\\n        e,\\n        `ExP responded with ${s.status}`\\n      );\\n    const a = await s.json(),\\n      c =\\n        null !== (n = a.Configs.find((e) => \\"vscode\\" === e.Id)) &&\\n        undefined !== n\\n          ? n\\n          : {\\n              Id: \\"vscode\\",\\n              Parameters: {},\\n            },\\n      l = Object.entries(c.Parameters).map(([e, t]) => e + (t ? \\"\\" : \\"cf\\"));\\n    return new o.ExpConfig(c.Parameters, a.AssignmentContext, l.join(\\";\\"));\\n  }\\n};\\nexports.ExpConfigNone = class extends ExpConfigMaker {\\n  async fetchExperiments(e, t) {\\n    return o.ExpConfig.createEmptyConfig();\\n  }\\n};","module-code-1124":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.checkSuffix = exports.postProcessChoice = undefined;\\nconst r = require(9189),\\n  o = require(2533),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(70),\\n  a = require(9657);\\nexports.postProcessChoice = async function (e, t, n, c, l, u, d) {\\n  if (\\n    a.isRepetitive(l.tokens, await e.get(r.Features).repetitionFilterMode())\\n  ) {\\n    const t = i.TelemetryData.createAndMarkAsIssued();\\n    t.extendWithRequestId(l.requestId);\\n    i.telemetry(e, \\"repetition.detected\\", t, !0);\\n    return void d.info(e, \\"Filtered out repetitive solution\\");\\n  }\\n  const p = {\\n    ...l,\\n  };\\n  if (\\n    (function (e, t, n) {\\n      let r = \\"\\",\\n        o = t.line + 1;\\n      for (; \\"\\" === r && o < e.lineCount; ) {\\n        r = e.lineAt(o).text.trim();\\n        if (r === n.trim()) return !0;\\n        o++;\\n      }\\n      return !1;\\n    })(n, c, p.completionText)\\n  ) {\\n    const t = i.TelemetryData.createAndMarkAsIssued();\\n    t.extendWithRequestId(l.requestId);\\n    i.telemetry(e, \\"completion.alreadyInDocument\\", t);\\n    i.telemetry(\\n      e,\\n      \\"completion.alreadyInDocument\\",\\n      t.extendedBy({\\n        completionTextJson: JSON.stringify(p.completionText),\\n      }),\\n      !0\\n    );\\n    return void d.info(e, \\"Filtered out solution matching next line\\");\\n  }\\n  p.completionText = await (async function (e, t, n, r, i) {\\n    var a;\\n    if (\\"\\" === r) return r;\\n    let c = \\"}\\";\\n    try {\\n      c =\\n        null !== (a = o.getBlockCloseToken(t.languageId)) && undefined !== a\\n          ? a\\n          : \\"}\\";\\n    } catch (e) {}\\n    let l = r.length;\\n    do {\\n      const o = r.lastIndexOf(\\"\\\\n\\", l - 2) + 1,\\n        a = r.substring(o, l);\\n      if (a.trim() === c) {\\n        for (let e = n.line; e < t.lineCount; e++) {\\n          let s = t.lineAt(e).text;\\n          if (e === n.line) {\\n            s = s.substr(n.character);\\n          }\\n          if (s.startsWith(a.trimRight()))\\n            return r.substring(0, Math.max(0, i ? o : o - 1));\\n          if (\\"\\" !== s.trim()) break;\\n        }\\n        break;\\n      }\\n      if (l === o) {\\n        if (s.shouldFailForDebugPurposes(e))\\n          throw Error(\\n            `Aborting: maybeSnipCompletion would have looped on completion: ${r}`\\n          );\\n        break;\\n      }\\n      l = o;\\n    } while (l > 1);\\n    return r;\\n  })(e, n, c, p.completionText, u);\\n  return p.completionText ? p : undefined;\\n};\\nexports.checkSuffix = function (e, t, n) {\\n  const r = e.lineAt(t.line).text.substring(t.character);\\n  if (r.length > 0) {\\n    if (-1 !== n.completionText.indexOf(r)) return !0;\\n    {\\n      let e = 0;\\n      for (const t of r) {\\n        const r = n.completionText.indexOf(t, e + 1);\\n        if (!(r > e)) {\\n          e = -1;\\n          break;\\n        }\\n        e = r;\\n      }\\n      return -1 !== e;\\n    }\\n  }\\n  return !1;\\n};","module-label-3":"openai_conn_utils","module-label-4197":"copilot-scheme","module-label-937":"openai-choices-utils","module-label-3055404":"jaccard-scorer","module-code-2218":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.completionsFromGhostTextResults = undefined;\\nconst r = require(\\"uuid-utils\\"),\\n  o = require(\\"location-factory\\"),\\n  i = require(\\"ghost-text-provider\\"),\\n  s = require(3286);\\nexports.completionsFromGhostTextResults = function (e, t, n, a, c, l, u) {\\n  const d = e.get(o.LocationFactory),\\n    p = a.lineAt(c);\\n  let h = t.map((e) => {\\n    let t,\\n      o = \\"\\";\\n    if (l) {\\n      e.completion = s.normalizeIndentCharacter(\\n        l,\\n        e.completion,\\n        p.isEmptyOrWhitespace\\n      );\\n    }\\n    if (e.completion.displayNeedsWsOffset && p.isEmptyOrWhitespace)\\n      (t = d.range(d.position(c.line, 0), c)),\\n        (o = e.completion.completionText);\\n    else if (\\n      p.isEmptyOrWhitespace &&\\n      e.completion.completionText.startsWith(p.text)\\n    )\\n      (t = d.range(d.position(c.line, 0), c)),\\n        (o = e.completion.completionText);\\n    else {\\n      const n = a.getWordRangeAtPosition(c);\\n      if (e.isMiddleOfTheLine) {\\n        const n = a.lineAt(c),\\n          r = d.range(d.position(c.line, 0), c),\\n          i = a.getText(r);\\n        (t = e.coversSuffix ? n.range : r), (o = i + e.completion.displayText);\\n      } else if (n) {\\n        const r = a.getText(n);\\n        (t = d.range(n.start, c)), (o = r + e.completion.completionText);\\n      } else {\\n        const n = d.range(d.position(c.line, 0), c);\\n        (t = n), (o = a.getText(n) + e.completion.displayText);\\n      }\\n    }\\n    return {\\n      uuid: r.v4(),\\n      text: o,\\n      range: t,\\n      file: a.uri,\\n      index: e.completion.completionIndex,\\n      telemetry: e.telemetry,\\n      displayText: e.completion.displayText,\\n      position: c,\\n      offset: a.offsetAt(c),\\n      resultType: n,\\n    };\\n  });\\n  if (n === i.ResultType.TypingAsSuggested && undefined !== u) {\\n    const e = h.find((e) => e.index === u);\\n    if (e) {\\n      const t = h.filter((e) => e.index !== u);\\n      h = [e, ...t];\\n    }\\n  }\\n  return h;\\n};","module-code-9574":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nvar r,\\n  o = require(\\"correlation-context-manager\\"),\\n  i = require(6281),\\n  s = require(6639),\\n  a = require(4350),\\n  c = require(8723),\\n  l = require(731),\\n  u = require(9962),\\n  d = require(5282),\\n  p = require(3668),\\n  h = require(1629);\\nexports.TelemetryClient = require(\\"telemetry-client\\");\\nexports.Contracts = require(5290);\\n(function (e) {\\n  e[(e.AI = 0)] = \\"AI\\";\\n  e[(e.AI_AND_W3C = 1)] = \\"AI_AND_W3C\\";\\n})(\\n  (r =\\n    exports.DistributedTracingModes || (exports.DistributedTracingModes = {}))\\n);\\nvar f,\\n  m,\\n  g,\\n  _,\\n  y,\\n  v,\\n  b,\\n  w,\\n  x,\\n  E = !0,\\n  C = !1,\\n  S = !0,\\n  T = !0,\\n  k = !0,\\n  I = !0,\\n  P = !0,\\n  A = !0,\\n  O = !1,\\n  N = !0,\\n  R = undefined,\\n  M = undefined,\\n  L = !1;\\nfunction start() {\\n  if (exports.defaultClient) {\\n    L = !0;\\n    g.enable(E, C);\\n    _.enable(S);\\n    y.enable(T);\\n    v.enable(N, m);\\n    b.useAutoCorrelation(A, f);\\n    b.enable(k);\\n    w.enable(I);\\n    if (exports.liveMetricsClient && O) {\\n      exports.liveMetricsClient.enable(O);\\n    }\\n  } else {\\n    d.warn(\\"Start cannot be called before setup\\");\\n  }\\n  return Configuration;\\n}\\nexports.setup = function (e) {\\n  if (exports.defaultClient) {\\n    d.info(\\"The default client is already setup\\");\\n  } else {\\n    exports.defaultClient = new exports.TelemetryClient(e);\\n    g = new i(exports.defaultClient);\\n    _ = new s(exports.defaultClient);\\n    y = new a(exports.defaultClient);\\n    b = new l(exports.defaultClient);\\n    w = new c(exports.defaultClient);\\n    if (v) {\\n      v = new h.AutoCollectNativePerformance(exports.defaultClient);\\n    }\\n  }\\n  if (exports.defaultClient && exports.defaultClient.channel) {\\n    exports.defaultClient.channel.setUseDiskRetryCaching(P, R, M);\\n  }\\n  return Configuration;\\n};\\nexports.start = start;\\nexports.getCorrelationContext = function () {\\n  return A ? o.CorrelationContextManager.getCurrentContext() : null;\\n};\\nexports.wrapWithCorrelationContext = function (e) {\\n  return o.CorrelationContextManager.wrapCallback(e);\\n};\\nvar Configuration = (function () {\\n  function e() {}\\n  e.setDistributedTracingMode = function (t) {\\n    u.w3cEnabled = t === r.AI_AND_W3C;\\n    return e;\\n  };\\n  e.setAutoCollectConsole = function (t, n) {\\n    if (undefined === n) {\\n      n = !1;\\n    }\\n    E = t;\\n    C = n;\\n    if (L) {\\n      g.enable(t, n);\\n    }\\n    return e;\\n  };\\n  e.setAutoCollectExceptions = function (t) {\\n    S = t;\\n    if (L) {\\n      _.enable(t);\\n    }\\n    return e;\\n  };\\n  e.setAutoCollectPerformance = function (t, n) {\\n    if (undefined === n) {\\n      n = !0;\\n    }\\n    T = t;\\n    var r = h.AutoCollectNativePerformance.parseEnabled(n);\\n    N = r.isEnabled;\\n    m = r.disabledMetrics;\\n    if (L) {\\n      y.enable(t);\\n      v.enable(r.isEnabled, r.disabledMetrics);\\n    }\\n    return e;\\n  };\\n  e.setAutoCollectRequests = function (t) {\\n    k = t;\\n    if (L) {\\n      b.enable(t);\\n    }\\n    return e;\\n  };\\n  e.setAutoCollectDependencies = function (t) {\\n    I = t;\\n    if (L) {\\n      w.enable(t);\\n    }\\n    return e;\\n  };\\n  e.setAutoDependencyCorrelation = function (t, n) {\\n    A = t;\\n    f = n;\\n    if (L) {\\n      b.useAutoCorrelation(t, n);\\n    }\\n    return e;\\n  };\\n  e.setUseDiskRetryCaching = function (n, r, o) {\\n    P = n;\\n    R = r;\\n    M = o;\\n    if (exports.defaultClient && exports.defaultClient.channel) {\\n      exports.defaultClient.channel.setUseDiskRetryCaching(n, r, o);\\n    }\\n    return e;\\n  };\\n  e.setInternalLogging = function (t, n) {\\n    if (undefined === t) {\\n      t = !1;\\n    }\\n    if (undefined === n) {\\n      n = !0;\\n    }\\n    d.enableDebug = t;\\n    d.disableWarnings = !n;\\n    return e;\\n  };\\n  e.setSendLiveMetrics = function (n) {\\n    if (undefined === n) {\\n      n = !1;\\n    }\\n    return exports.defaultClient\\n      ? (!exports.liveMetricsClient && n\\n          ? ((exports.liveMetricsClient = new p(\\n              exports.defaultClient.config.instrumentationKey\\n            )),\\n            (x = new a(exports.liveMetricsClient, 1e3, !0)),\\n            exports.liveMetricsClient.addCollector(x),\\n            (exports.defaultClient.quickPulseClient =\\n              exports.liveMetricsClient))\\n          : exports.liveMetricsClient && exports.liveMetricsClient.enable(n),\\n        (O = n),\\n        e)\\n      : (d.warn(\\n          \\"Live metrics client cannot be setup without the default client\\"\\n        ),\\n        e);\\n  };\\n  e.start = start;\\n  return e;\\n})();\\nexports.Configuration = Configuration;\\nexports.dispose = function () {\\n  exports.defaultClient = null;\\n  L = !1;\\n  if (g) {\\n    g.dispose();\\n  }\\n  if (_) {\\n    _.dispose();\\n  }\\n  if (y) {\\n    y.dispose();\\n  }\\n  if (v) {\\n    v.dispose();\\n  }\\n  if (b) {\\n    b.dispose();\\n  }\\n  if (w) {\\n    w.dispose();\\n  }\\n  if (exports.liveMetricsClient) {\\n    exports.liveMetricsClient.enable(!1);\\n    O = !1;\\n    exports.liveMetricsClient = undefined;\\n  }\\n};","module-label-2990":"copilot-panel","module-code-6881":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ChangeTracker = undefined;\\nconst r = require(\\"text-doc-relative-path\\");\\nexports.ChangeTracker = class {\\n  constructor(e, t, n) {\\n    this._referenceCount = 0;\\n    this._isDisposed = !1;\\n    this._offset = n;\\n    const o = e.get(r.TextDocumentManager);\\n    this._tracker = o.onDidChangeTextDocument(async (e) => {\\n      if (e.document.uri === t)\\n        for (const t of e.contentChanges)\\n          if (t.rangeOffset + t.rangeLength <= this.offset) {\\n            const e = t.text.length - t.rangeLength;\\n            this._offset = this._offset + e;\\n          }\\n    });\\n  }\\n  get offset() {\\n    return this._offset;\\n  }\\n  push(e, t) {\\n    if (this._isDisposed)\\n      throw new Error(\\"Unable to push new actions to a disposed ChangeTracker\\");\\n    this._referenceCount++;\\n    setTimeout(() => {\\n      e();\\n      this._referenceCount--;\\n      if (0 === this._referenceCount) {\\n        this._tracker.dispose();\\n        this._isDisposed = !0;\\n      }\\n    }, t);\\n  }\\n};","module-code-3055469":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.parseTree =\\n  exports.registerLanguageSpecificParser =\\n  exports.flattenVirtual =\\n  exports.groupBlocks =\\n  exports.combineClosersAndOpeners =\\n  exports.buildLabelRules =\\n  exports.labelVirtualInherited =\\n  exports.labelLines =\\n  exports.parseRaw =\\n    undefined;\\nconst r = require(\\"parse-tree-utils\\"),\\n  o = require(\\"parse-tree-utils2\\");\\nfunction parseRaw(e) {\\n  const t = e.split(\\"\\\\n\\"),\\n    n = t.map((e) => e.match(/^\\\\s*/)[0].length),\\n    o = t.map((e) => e.trimLeft());\\n  function i(e) {\\n    const [t, i] = s(e + 1, n[e]);\\n    return [r.lineNode(n[e], e, o[e], t), i];\\n  }\\n  function s(e, t) {\\n    let s;\\n    const a = [];\\n    let c,\\n      l = e;\\n    for (; l < o.length && (\\"\\" === o[l] || n[l] > t); )\\n      if (\\"\\" === o[l]) {\\n        if (undefined === c) {\\n          c = l;\\n        }\\n        l += 1;\\n      } else {\\n        if (undefined !== c) {\\n          for (let e = c; e < l; e++) a.push(r.blankNode(e));\\n          c = undefined;\\n        }\\n        [s, l] = i(l);\\n        a.push(s);\\n      }\\n    if (undefined !== c) {\\n      l = c;\\n    }\\n    return [a, l];\\n  }\\n  const [a, c] = s(0, -1);\\n  let l = c;\\n  for (; l < o.length && \\"\\" === o[l]; ) {\\n    a.push(r.blankNode(l));\\n    l += 1;\\n  }\\n  if (l < o.length)\\n    throw new Error(\\n      `Parsing did not go to end of file. Ended at ${l} out of ${o.length}`\\n    );\\n  return r.topNode(a);\\n}\\nfunction labelLines(e, t) {\\n  o.visitTree(\\n    e,\\n    function (e) {\\n      if (r.isLine(e)) {\\n        const n = t.find((t) => t.matches(e.sourceLine));\\n        if (n) {\\n          e.label = n.label;\\n        }\\n      }\\n    },\\n    \\"bottomUp\\"\\n  );\\n}\\nfunction buildLabelRules(e) {\\n  return Object.keys(e).map((t) => {\\n    let n;\\n    n = e[t].test ? (n) => e[t].test(n) : e[t];\\n    return {\\n      matches: n,\\n      label: t,\\n    };\\n  });\\n}\\nfunction combineClosersAndOpeners(e) {\\n  const t = o.rebuildTree(e, function (e) {\\n    if (\\n      0 === e.subs.length ||\\n      -1 ===\\n        e.subs.findIndex((e) => \\"closer\\" === e.label || \\"opener\\" === e.label)\\n    )\\n      return e;\\n    const t = [];\\n    let n;\\n    for (let o = 0; o < e.subs.length; o++) {\\n      const i = e.subs[o],\\n        s = e.subs[o - 1];\\n      if (\\"opener\\" === i.label && undefined !== s && r.isLine(s)) {\\n        s.subs.push(i);\\n        i.subs.forEach((e) => s.subs.push(e));\\n        i.subs = [];\\n      } else if (\\n        \\"closer\\" === i.label &&\\n        undefined !== n &&\\n        (r.isLine(i) || r.isVirtual(i)) &&\\n        i.indentation >= n.indentation\\n      ) {\\n        let e = t.length - 1;\\n        for (; e > 0 && r.isBlank(t[e]); ) e -= 1;\\n        n.subs.push(...t.splice(e + 1));\\n        if (i.subs.length > 0) {\\n          const e = n.subs.findIndex((e) => \\"newVirtual\\" !== e.label),\\n            t = n.subs.slice(0, e),\\n            o = n.subs.slice(e),\\n            s =\\n              o.length > 0\\n                ? [r.virtualNode(i.indentation, o, \\"newVirtual\\")]\\n                : [];\\n          n.subs = [...t, ...s, i];\\n        } else n.subs.push(i);\\n      } else {\\n        t.push(i);\\n        if (r.isBlank(i)) {\\n          n = i;\\n        }\\n      }\\n    }\\n    e.subs = t;\\n    return e;\\n  });\\n  o.clearLabelsIf(e, (e) => \\"newVirtual\\" === e);\\n  return t;\\n}\\nexports.parseRaw = parseRaw;\\nexports.labelLines = labelLines;\\nexports.labelVirtualInherited = function (e) {\\n  o.visitTree(\\n    e,\\n    function (e) {\\n      if (r.isVirtual(e) && undefined === e.label) {\\n        const t = e.subs.filter((e) => !r.isBlank(e));\\n        if (1 === t.length) {\\n          e.label = t[0].label;\\n        }\\n      }\\n    },\\n    \\"bottomUp\\"\\n  );\\n};\\nexports.buildLabelRules = buildLabelRules;\\nexports.combineClosersAndOpeners = combineClosersAndOpeners;\\nexports.groupBlocks = function (e, t = r.isBlank, n) {\\n  return o.rebuildTree(e, function (e) {\\n    if (e.subs.length <= 1) return e;\\n    const o = [];\\n    let i,\\n      s = [],\\n      a = !1;\\n    function c(e = !1) {\\n      if (undefined !== i && (o.length > 0 || !e)) {\\n        const e = r.virtualNode(i, s, n);\\n        o.push(e);\\n      } else s.forEach((e) => o.push(e));\\n    }\\n    for (let n = 0; n < e.subs.length; n++) {\\n      const o = e.subs[n],\\n        l = t(o);\\n      if (!l && a) {\\n        c();\\n        s = [];\\n      }\\n      a = l;\\n      s.push(o);\\n      if (r.isBlank(o)) {\\n        i = null != i ? i : o.indentation;\\n      }\\n    }\\n    c(!0);\\n    e.subs = o;\\n    return e;\\n  });\\n};\\nexports.flattenVirtual = function (e) {\\n  return o.rebuildTree(e, function (e) {\\n    return r.isVirtual(e) && undefined === e.label && e.subs.length <= 1\\n      ? 0 === e.subs.length\\n        ? undefined\\n        : e.subs[0]\\n      : (1 === e.subs.length &&\\n          r.isVirtual(e.subs[0]) &&\\n          undefined === e.subs[0].label &&\\n          (e.subs = e.subs[0].subs),\\n        e);\\n  });\\n};\\nconst l = buildLabelRules({\\n    opener: /^[\\\\[({]/,\\n    closer: /^[\\\\])}]/,\\n  }),\\n  u = {};\\nexports.registerLanguageSpecificParser = function (e, t) {\\n  u[e] = t;\\n};\\nexports.parseTree = function (e, t) {\\n  const n = parseRaw(e),\\n    r = u[null != t ? t : \\"\\"];\\n  return r ? r(n) : (labelLines(n, l), combineClosersAndOpeners(n));\\n};","module-code-2279":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.postRequest =\\n  exports.Response =\\n  exports.HelixFetcher =\\n  exports.isAbortError =\\n  exports.Fetcher =\\n  exports.init =\\n    undefined;\\nconst r = require(9825),\\n  o = require(6149),\\n  i = require(3837),\\n  s = require(\\"config-stuff\\"),\\n  a = require(5413),\\n  c = require(\\"telemetry-stuff\\");\\nlet l,\\n  u = !1;\\nexports.init = function (e) {\\n  if (u) {\\n    if (e !== l)\\n      throw new Error(\\n        `Networking re-initialized with mismatched version (old: ${l}, new: ${e})`\\n      );\\n  } else {\\n    l = e;\\n    u = !0;\\n  }\\n};\\nclass Fetcher {}\\nexports.Fetcher = Fetcher;\\nexports.isAbortError = function (e) {\\n  return e instanceof r.AbortError;\\n};\\nexports.HelixFetcher = class extends Fetcher {\\n  constructor(e) {\\n    super();\\n    this.ctx = e;\\n    this.createSocketFactory = (e) => {\\n      const t = o.httpOverHttp({\\n        proxy: e,\\n      });\\n      return (e) =>\\n        new Promise((n) => {\\n          t.createSocket(e, (e) => {\\n            n(e);\\n          });\\n        });\\n    };\\n    this.fetchApi = this.createFetchApi(e);\\n  }\\n  set proxySettings(e) {\\n    this._proxySettings = e;\\n    this.fetchApi = this.createFetchApi(this.ctx);\\n  }\\n  get proxySettings() {\\n    return this._proxySettings;\\n  }\\n  createFetchApi(e) {\\n    var t;\\n    const n = e.get(s.BuildInfo);\\n    if (\\n      !1 ===\\n      (null === (t = this._proxySettings) || undefined === t\\n        ? undefined\\n        : t.rejectUnauthorized)\\n    ) {\\n      process.env.NODE_TLS_REJECT_UNAUTHORIZED = \\"0\\";\\n    }\\n    return r.context({\\n      userAgent: `GithubCopilot/${n.getVersion()}`,\\n      socketFactory: this._proxySettings\\n        ? this.createSocketFactory(this._proxySettings)\\n        : undefined,\\n    });\\n  }\\n  async fetch(e, t) {\\n    const n = {\\n        ...t,\\n        body: t.body ? t.body : t.json,\\n        signal: t.signal,\\n      },\\n      r = await this.fetchApi.fetch(e, n);\\n    return new Response(\\n      r.status,\\n      r.statusText,\\n      r.headers,\\n      () => r.text(),\\n      () => r.json(),\\n      async () => r.body\\n    );\\n  }\\n  disconnectAll() {\\n    return this.fetchApi.reset();\\n  }\\n  makeAbortController() {\\n    return new r.AbortController();\\n  }\\n};\\nclass Response {\\n  constructor(e, t, n, r, o, i) {\\n    this.status = e;\\n    this.statusText = t;\\n    this.headers = n;\\n    this.getText = r;\\n    this.getJson = o;\\n    this.getBody = i;\\n    this.ok = this.status >= 200 && this.status < 300;\\n  }\\n  async text() {\\n    return this.getText();\\n  }\\n  async json() {\\n    return this.getJson();\\n  }\\n  async body() {\\n    return this.getBody();\\n  }\\n}\\nexports.Response = Response;\\nexports.postRequest = function (e, t, n, r, o, l, p) {\\n  if (!u) throw new Error(\\"Networking must be initialized before being used\\");\\n  const h = {\\n    Authorization: i.format(\\"Bearer %s\\", n),\\n    \\"X-Request-Id\\": o,\\n    \\"Openai-Organization\\": \\"github-copilot\\",\\n    \\"VScode-SessionId\\": e.get(s.VscInfo).sessionId,\\n    \\"VScode-MachineId\\": e.get(s.VscInfo).machineId,\\n    ...s.editorVersionHeaders(e),\\n  };\\n  if (r) {\\n    h[\\"OpenAI-Intent\\"] = r;\\n  }\\n  const f = e.get(a.GhostTextDebounceManager).forceDelayMs;\\n  if (f) {\\n    h[\\"X-Copilot-Force-Delay\\"] = f.toString();\\n  }\\n  const m = {\\n      method: \\"POST\\",\\n      headers: h,\\n      json: l,\\n      timeout: 3e4,\\n    },\\n    g = e.get(Fetcher);\\n  if (p) {\\n    const t = g.makeAbortController();\\n    p.onCancellationRequested(() => {\\n      c.telemetry(\\n        e,\\n        \\"networking.cancelRequest\\",\\n        c.TelemetryData.createAndMarkAsIssued({\\n          headerRequestId: o,\\n        })\\n      );\\n      t.abort();\\n    });\\n    m.signal = t.signal;\\n  }\\n  return g.fetch(t, m).catch((n) => {\\n    if (\\n      \\"ECONNRESET\\" == n.code ||\\n      \\"ETIMEDOUT\\" == n.code ||\\n      \\"ERR_HTTP2_INVALID_SESSION\\" == n.code ||\\n      \\"ERR_HTTP2_GOAWAY_SESSION\\" == n.message\\n    ) {\\n      c.telemetry(e, \\"networking.disconnectAll\\");\\n      return g.disconnectAll().then(() => g.fetch(t, m));\\n    }\\n    throw n;\\n  });\\n};","module-label-7870":"context","module-code-362":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.refreshToken =\\n  exports.CopilotTokenManagerFromGitHubToken =\\n  exports.FixedCopilotTokenManager =\\n  exports.CopilotTokenManager =\\n  exports.setTelemetryConfigFromTokenInfo =\\n  exports.extractTrackingIdFromToken =\\n  exports.authFromGitHubToken =\\n  exports.nowSeconds =\\n  exports.TOKEN_REFRESHED_EVENT =\\n    undefined;\\nconst r = require(2361),\\n  o = require(\\"config-stuff\\"),\\n  i = require(\\"logging-utils\\"),\\n  s = require(\\"helix-fetcher-and-network-stuff\\"),\\n  a = require(1547),\\n  c = require(\\"telemetry-stuff\\"),\\n  l = require(\\"url-opener\\"),\\n  u = new i.Logger(i.LogLevel.INFO, \\"auth\\");\\nlet d = 0;\\nfunction nowSeconds() {\\n  return Math.floor(Date.now() / 1e3);\\n}\\nasync function authFromGitHubToken(e, t) {\\n  var n, r;\\n  c.telemetry(e, \\"auth.new_login\\");\\n  const i =\\n      null !==\\n        (r =\\n          null === (n = t.devOverride) || undefined === n\\n            ? undefined\\n            : n.copilotTokenUrl) && undefined !== r\\n        ? r\\n        : \\"https://api.github.com/copilot_internal/v2/token\\",\\n    a = await e.get(s.Fetcher).fetch(i, {\\n      headers: {\\n        Authorization: `token ${t.token}`,\\n        ...o.editorVersionHeaders(e),\\n      },\\n    });\\n  if (!a) {\\n    u.info(e, \\"Failed to get copilot token\\");\\n    c.telemetryError(e, \\"auth.request_failed\\");\\n    return {\\n      kind: \\"failure\\",\\n      reason: \\"FailedToGetToken\\",\\n    };\\n  }\\n  const l = await a.json();\\n  if (!l) {\\n    u.info(e, \\"Failed to get copilot token\\");\\n    c.telemetryError(e, \\"auth.request_read_failed\\");\\n    return {\\n      kind: \\"failure\\",\\n      reason: \\"FailedToGetToken\\",\\n    };\\n  }\\n  m(e, l.user_notification, t);\\n  if (401 === a.status)\\n    return (\\n      u.info(e, \\"Failed to get copilot token due to 401 status\\"),\\n      (0, c.telemetryError)(e, \\"auth.unknown_401\\"),\\n      {\\n        kind: \\"failure\\",\\n        reason: \\"HTTP401\\",\\n      }\\n    );\\n  if (!a.ok || !l.token) {\\n    u.info(\\n      e,\\n      `Invalid copilot token: missing token: ${a.status} ${a.statusText}`\\n    );\\n    c.telemetryError(\\n      e,\\n      \\"auth.invalid_token\\",\\n      c.TelemetryData.createAndMarkAsIssued({\\n        status: a.status.toString(),\\n        status_text: a.statusText,\\n      })\\n    );\\n    const n = l.error_details;\\n    m(e, n, t);\\n    return {\\n      kind: \\"failure\\",\\n      reason: \\"NotAuthorized\\",\\n      ...n,\\n    };\\n  }\\n  const d = l.expires_at;\\n  l.expires_at = nowSeconds() + l.refresh_in + 60;\\n  e.get(c.TelemetryReporters).setToken(l);\\n  setTelemetryConfigFromTokenInfo(l);\\n  c.telemetry(\\n    e,\\n    \\"auth.new_token\\",\\n    c.TelemetryData.createAndMarkAsIssued(\\n      {},\\n      {\\n        adjusted_expires_at: l.expires_at,\\n        expires_at: d,\\n        current_time: nowSeconds(),\\n      }\\n    )\\n  );\\n  return {\\n    kind: \\"success\\",\\n    ...l,\\n  };\\n}\\nexports.TOKEN_REFRESHED_EVENT = \\"token_refreshed\\";\\nexports.nowSeconds = nowSeconds;\\nexports.authFromGitHubToken = authFromGitHubToken;\\nconst f = new Map();\\nfunction m(e, t, n) {\\n  if (!t) return;\\n  const r = nowSeconds();\\n  if (f.get(t.message)) {\\n    f.set(t.message, r);\\n    e.get(a.NotificationSender)\\n      .showWarningMessage(\\n        t.message,\\n        {\\n          title: t.title,\\n        },\\n        {\\n          title: \\"Dismiss\\",\\n        }\\n      )\\n      .catch((t) => {\\n        console.error(t);\\n        u.error(e, `Error while sending notification: ${t.message}`);\\n      })\\n      .then(async (r) => {\\n        const i = (null == r ? undefined : r.title) === t.title,\\n          a = i || \\"Dismiss\\" === (null == r ? undefined : r.title);\\n        if (i) {\\n          const n = e.get(o.EditorAndPluginInfo).getEditorPluginInfo(e),\\n            r = t.url.replace(\\n              \\"{EDITOR}\\",\\n              encodeURIComponent(n.name + \\"_\\" + n.version)\\n            );\\n          await e.get(l.UrlOpener).open(r);\\n        }\\n        if (\\"notification_id\\" in t && a) {\\n          await (async function (e, t, n) {\\n            var r, i;\\n            const a =\\n                null !==\\n                  (i =\\n                    null === (r = n.devOverride) || undefined === r\\n                      ? undefined\\n                      : r.notificationUrl) && undefined !== i\\n                  ? i\\n                  : \\"https://api.github.com/copilot_internal/notification\\",\\n              c = await e.get(s.Fetcher).fetch(a, {\\n                headers: {\\n                  Authorization: `token ${n.token}`,\\n                  ...o.editorVersionHeaders(e),\\n                },\\n                method: \\"POST\\",\\n                body: JSON.stringify({\\n                  notification_id: t,\\n                }),\\n              });\\n            if (c && c.ok) {\\n              u.error(\\n                e,\\n                `Failed to send notification result to GitHub: ${\\n                  null == c ? undefined : c.status\\n                } ${null == c ? undefined : c.statusText}`\\n              );\\n            }\\n          })(e, t.notification_id, n);\\n        }\\n      });\\n  }\\n}\\nfunction extractTrackingIdFromToken(e) {\\n  const t = null == e ? undefined : e.split(\\":\\")[0],\\n    n = null == t ? undefined : t.split(\\";\\");\\n  for (const e of n) {\\n    const [t, n] = e.split(\\"=\\");\\n    if (\\"tid\\" === t) return n;\\n  }\\n}\\nfunction setTelemetryConfigFromTokenInfo(e) {\\n  const t = extractTrackingIdFromToken(e.token);\\n  if (undefined !== t) {\\n    c.setTelemetryConfig({\\n      trackingId: t,\\n      optedIn: \\"enabled\\" === e.telemetry || \\"unconfigured\\" === e.telemetry,\\n    });\\n  }\\n}\\nexports.extractTrackingIdFromToken = extractTrackingIdFromToken;\\nexports.setTelemetryConfigFromTokenInfo = setTelemetryConfigFromTokenInfo;\\nclass CopilotTokenManager {\\n  constructor() {\\n    this.tokenRefreshEventEmitter = new r.EventEmitter();\\n  }\\n}\\nfunction refreshToken(e, n, r) {\\n  const o = nowSeconds();\\n  if (d > 0) {\\n    d++;\\n    setTimeout(async () => {\\n      let r,\\n        i = \\"\\";\\n      try {\\n        d--;\\n        await n.getCopilotToken(e, !0);\\n        r = \\"success\\";\\n        n.tokenRefreshEventEmitter.emit(exports.TOKEN_REFRESHED_EVENT);\\n      } catch (e) {\\n        r = \\"failure\\";\\n        i = e.toString();\\n      }\\n      const s = c.TelemetryData.createAndMarkAsIssued(\\n        {\\n          result: r,\\n        },\\n        {\\n          time_taken: nowSeconds() - o,\\n          refresh_count: d,\\n        }\\n      );\\n      if (i) {\\n        s.properties.reason = i;\\n      }\\n      c.telemetry(e, \\"auth.token_refresh\\", s);\\n    }, 1e3 * r);\\n  }\\n}\\nexports.CopilotTokenManager = CopilotTokenManager;\\nexports.FixedCopilotTokenManager = class extends CopilotTokenManager {\\n  constructor(e) {\\n    super();\\n    this.tokenInfo = e;\\n    this.wasReset = !1;\\n    setTelemetryConfigFromTokenInfo(e);\\n  }\\n  async getGitHubToken() {\\n    return Promise.resolve(\\"token\\");\\n  }\\n  async getCopilotToken(e, t) {\\n    return this.tokenInfo;\\n  }\\n  resetCopilotToken(e, t) {\\n    this.wasReset = !0;\\n  }\\n  async checkCopilotToken(e) {\\n    return {\\n      status: \\"OK\\",\\n      telemetry: this.tokenInfo.telemetry,\\n    };\\n  }\\n};\\nexports.CopilotTokenManagerFromGitHubToken = class extends CopilotTokenManager {\\n  constructor(e) {\\n    super();\\n    this.githubToken = e;\\n    this.copilotToken = undefined;\\n  }\\n  async getGitHubToken() {\\n    return Promise.resolve(this.githubToken.token);\\n  }\\n  async getCopilotToken(e, t) {\\n    var n;\\n    if (\\n      !this.copilotToken ||\\n      this.copilotToken.expires_at < nowSeconds() ||\\n      t\\n    ) {\\n      const t = await authFromGitHubToken(e, this.githubToken);\\n      if (\\"failure\\" === t.kind)\\n        throw Error(\\n          `Failed to get copilot token: ${t.reason.toString()} ${\\n            null !== (n = t.message) && undefined !== n ? n : \\"\\"\\n          }`\\n        );\\n      this.copilotToken = {\\n        ...t,\\n      };\\n      refreshToken(e, this, t.refresh_in);\\n    }\\n    return this.copilotToken;\\n  }\\n  async checkCopilotToken(e) {\\n    if (!this.copilotToken || this.copilotToken.expires_at < nowSeconds()) {\\n      const t = await authFromGitHubToken(e, this.githubToken);\\n      if (\\"failure\\" === t.kind) return t;\\n      this.copilotToken = {\\n        ...t,\\n      };\\n      refreshToken(e, this, t.refresh_in);\\n    }\\n    return {\\n      status: \\"OK\\",\\n      telemetry: this.copilotToken.telemetry,\\n    };\\n  }\\n  resetCopilotToken(e, t) {\\n    if (undefined !== t) {\\n      c.telemetry(e, \\"auth.reset_token_\\" + t);\\n    }\\n    u.debug(e, `Resetting copilot token on HTTP error ${t || \\"unknown\\"}`);\\n    this.copilotToken = undefined;\\n  }\\n};\\nexports.refreshToken = refreshToken;","module-label-894":"correlation-context-manager","module-code-9425":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.VSCodeEditorInfo =\\n  exports.makeVscInfo =\\n  exports.getExtension =\\n  exports.setExtension =\\n  exports.VSCodeConfigProvider =\\n    undefined;\\nconst r = require(9496),\\n  o = require(\\"config-stuff\\"),\\n  i = require(\\"copilot-scheme\\"),\\n  s = require(70),\\n  a = require(4147);\\nfunction c(e) {\\n  return \\"string\\" == typeof e ? e : JSON.stringify(e);\\n}\\nclass VSCodeConfigProvider extends o.ConfigProvider {\\n  constructor() {\\n    super();\\n    this.config = r.workspace.getConfiguration(i.CopilotConfigPrefix);\\n    r.workspace.onDidChangeConfiguration((e) => {\\n      if (e.affectsConfiguration(i.CopilotConfigPrefix)) {\\n        this.config = r.workspace.getConfiguration(i.CopilotConfigPrefix);\\n      }\\n    });\\n  }\\n  getConfigKeyFromObject(e, t) {\\n    const n = this.config[e][t];\\n    return undefined === n ? o.getConfigDefaultForObjectKey(e, t) : n;\\n  }\\n  getConfig(e) {\\n    if (Array.isArray(e)) return this.getConfigKeyFromObject(e[0], e[1]);\\n    const t = this.config.get(e);\\n    if (undefined === t)\\n      throw new Error(\\n        `Missing config default value: ${i.CopilotConfigPrefix}.${e}`\\n      );\\n    return t;\\n  }\\n  isDefaultSettingOverwritten(e) {\\n    if (Array.isArray(e)) return undefined !== this.config[e[0]][e[1]];\\n    const t = this.config.inspect(e);\\n    return (\\n      !!t &&\\n      !!(\\n        t.globalValue ||\\n        t.workspaceValue ||\\n        t.workspaceFolderValue ||\\n        t.defaultLanguageValue ||\\n        t.globalLanguageValue ||\\n        t.workspaceLanguageValue ||\\n        t.workspaceFolderLanguageValue\\n      )\\n    );\\n  }\\n  dumpConfig() {\\n    const e = {};\\n    try {\\n      const t = a.contributes.configuration[0].properties;\\n      for (const n in t) {\\n        const t = n\\n          .replace(`${i.CopilotConfigPrefix}.`, \\"\\")\\n          .split(\\".\\")\\n          .reduce((e, t) => e[t], this.config);\\n        if (\\"object\\" == typeof t && null !== t) {\\n          Object.keys(t)\\n            .filter((e) => \\"secret_key\\" !== e)\\n            .forEach((r) => (e[`${n}.${r}`] = c(t[r])));\\n        } else {\\n          e[n] = c(t);\\n        }\\n      }\\n    } catch (e) {\\n      console.error(`Failed to retrieve configuration properties ${e}`);\\n    }\\n    return e;\\n  }\\n  getLanguageConfig(e, t) {\\n    const n = this.getConfig(e);\\n    if (undefined === t) {\\n      const e = r.window.activeTextEditor;\\n      t = e && e.document.languageId;\\n    }\\n    return t && t in n ? n[t] : n[\\"*\\"];\\n  }\\n  updateEnabledConfig(e, t, n) {\\n    const r = e.get(o.ConfigProvider).getConfig(o.ConfigKey.Enable);\\n    r[t] = n;\\n    return this.config.update(o.ConfigKey.Enable, r, !0);\\n  }\\n}\\nlet u;\\nexports.VSCodeConfigProvider = VSCodeConfigProvider;\\nexports.setExtension = function (e) {\\n  u = e;\\n};\\nexports.getExtension = function (e) {\\n  if (!u && s.isRunningInTest(e)) {\\n    u = r.extensions.all.find((e) => e.id.startsWith(\\"GitHub.copilot\\"));\\n  }\\n  if (!u) throw new Error(\\"No GitHub.copilot extension found\\");\\n  return u;\\n};\\nexports.makeVscInfo = function () {\\n  return new o.VscInfo(r.env.sessionId, r.env.machineId, r.version);\\n};\\nclass VSCodeEditorInfo extends o.EditorAndPluginInfo {\\n  getEditorInfo(e) {\\n    return {\\n      name: \\"vscode\\",\\n      version: r.version,\\n    };\\n  }\\n  getEditorPluginInfo(e) {\\n    return {\\n      name: \\"copilot\\",\\n      version: o.getVersion(e),\\n    };\\n  }\\n}\\nexports.VSCodeEditorInfo = VSCodeEditorInfo;","module-code-3":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getEngineURL =\\n  exports.TEST_ENGINE_PATHS =\\n  exports.OPENAI_PROXY_HOST =\\n    undefined;\\nconst r = require(\\"config-stuff\\"),\\n  o = require(9189),\\n  i = require(70);\\nexports.OPENAI_PROXY_HOST = \\"https://copilot-proxy.githubusercontent.com\\";\\nconst s = \\"/v1/engines/copilot-codex\\";\\nexports.TEST_ENGINE_PATHS = [s];\\nexports.getEngineURL = async function (e, n = \\"\\", a, c = \\"\\", l = \\"\\", u) {\\n  return (function (e, n) {\\n    let o = (function (e) {\\n      return i.isRunningInTest(e)\\n        ? r.getConfig(e, r.ConfigKey.DebugTestOverrideProxyUrl)\\n        : r.getConfig(e, r.ConfigKey.DebugOverrideProxyUrl);\\n    })(e);\\n    if (0 == o.length) {\\n      o = exports.OPENAI_PROXY_HOST;\\n    }\\n    return `${o}${n}`;\\n  })(\\n    e,\\n    await (async function (e, t, n, i, a, c) {\\n      const l = r.getConfig(e, r.ConfigKey.DebugOverrideEngine);\\n      if (l) return `/v1/engines/${l}`;\\n      const u = await e.get(o.Features).customEngine(t, n, i, a, c);\\n      return \\"\\" !== u ? `/v1/engines/${u}` : s;\\n    })(e, n, a, c, l, u)\\n  );\\n};","module-code-4723":"var r =\\n    (this && this.__createBinding) ||\\n    (Object.create\\n      ? function (e, t, n, r) {\\n          if (undefined === r) {\\n            r = n;\\n          }\\n          Object.defineProperty(e, r, {\\n            enumerable: !0,\\n            get: function () {\\n              return t[n];\\n            },\\n          });\\n        }\\n      : function (e, t, n, r) {\\n          if (undefined === r) {\\n            r = n;\\n          }\\n          e[r] = t[n];\\n        }),\\n  o =\\n    (this && this.__exportStar) ||\\n    function (e, t) {\\n      for (var n in e)\\n        if (\\"default\\" === n || Object.prototype.hasOwnProperty.call(t, n)) {\\n          r(t, e, n);\\n        }\\n    };\\nObject.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.createWorker =\\n  exports.FileSystem =\\n  exports.comment =\\n  exports.languageCommentMarkers =\\n    undefined;\\nconst i = require(\\"path\\"),\\n  s = require(\\"worker_threads\\");\\no(require(\\"get-prompt-parsing-utils\\"), exports);\\no(require(9940), exports);\\no(require(1747), exports);\\no(require(9852), exports);\\nvar a = require(1788);\\nexports.languageCommentMarkers = a.languageCommentMarkers;\\nexports.comment = a.comment;\\nvar c = require(5012);\\nexports.FileSystem = c.FileSystem;\\nexports.createWorker = function () {\\n  return new s.Worker(i.resolve(__dirname, \\"..\\", \\"dist\\", \\"worker.js\\"));\\n};","module-label-4540":"ignore-document-or-not","module-code-9189":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.Features = exports.Task = undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"clock\\"),\\n  i = require(\\"prompt-cache\\"),\\n  s = require(\\"config-stuff\\"),\\n  a = require(\\"contextual-filter-constants\\"),\\n  c = require(9657),\\n  l = require(219),\\n  u = require(9748),\\n  d = require(8142),\\n  p = require(9030);\\nclass h {\\n  constructor(e) {\\n    this.ctx = e;\\n    this.cache = new i.LRUCache(200);\\n  }\\n  async fetchExpConfig(e) {\\n    let t = this.cache.get(e.stringify());\\n    if (t) {\\n      t = new Task(\\n        () =>\\n          this.ctx\\n            .get(u.ExpConfigMaker)\\n            .fetchExperiments(this.ctx, e.toHeaders()),\\n        36e5\\n      );\\n      this.cache.put(e.stringify(), t);\\n    }\\n    return t.run();\\n  }\\n  getCachedExpConfig(e) {\\n    const t = this.cache.get(e.stringify());\\n    return null == t ? undefined : t.value();\\n  }\\n}\\nclass Task {\\n  constructor(e, t = 1 / 0) {\\n    this.producer = e;\\n    this.expirationMs = t;\\n  }\\n  async run() {\\n    if (undefined === this.promise) {\\n      this.promise = this.producer();\\n      this.storeResult(this.promise).then(() => {\\n        if (this.expirationMs < 1 / 0 && undefined !== this.promise) {\\n          setTimeout(() => (this.promise = undefined), this.expirationMs);\\n        }\\n      });\\n    }\\n    return this.promise;\\n  }\\n  async storeResult(e) {\\n    try {\\n      this.result = await e;\\n    } finally {\\n      if (undefined === this.result) {\\n        this.promise = undefined;\\n      }\\n    }\\n  }\\n  value() {\\n    return this.result;\\n  }\\n}\\nexports.Task = Task;\\nclass Features {\\n  constructor(e) {\\n    this.ctx = e;\\n    this.staticFilters = {};\\n    this.dynamicFilters = {};\\n    this.upcomingDynamicFilters = {};\\n    this.assignments = new h(this.ctx);\\n    this.granularityDirectory = new p.GranularityDirectory(\\n      \\"unspecified\\",\\n      e.get(o.Clock)\\n    );\\n  }\\n  setPrefix(e) {\\n    this.granularityDirectory = new p.GranularityDirectory(\\n      e,\\n      this.ctx.get(o.Clock)\\n    );\\n  }\\n  registerStaticFilters(e) {\\n    Object.assign(this.staticFilters, e);\\n  }\\n  registerDynamicFilter(e, t) {\\n    this.dynamicFilters[e] = t;\\n  }\\n  getDynamicFilterValues() {\\n    const e = {};\\n    for (const [t, n] of Object.entries(this.dynamicFilters)) e[t] = n();\\n    return e;\\n  }\\n  registerUpcomingDynamicFilter(e, t) {\\n    this.upcomingDynamicFilters[e] = t;\\n  }\\n  async getAssignment(e, t = {}, n) {\\n    var r, o;\\n    const i = this.makeFilterSettings(t),\\n      s = this.granularityDirectory.extendFilters(i),\\n      a = await this.getExpConfig(s.newFilterSettings);\\n    this.granularityDirectory.update(\\n      i,\\n      +(null !==\\n        (r = a.variables[l.ExpTreatmentVariables.GranularityByCallBuckets]) &&\\n      undefined !== r\\n        ? r\\n        : NaN),\\n      +(null !==\\n        (o =\\n          a.variables[l.ExpTreatmentVariables.GranularityTimePeriodSizeInH]) &&\\n      undefined !== o\\n        ? o\\n        : NaN)\\n    );\\n    const c = this.granularityDirectory.extendFilters(i),\\n      u = c.newFilterSettings,\\n      d = await this.getExpConfig(u);\\n    let p = new Promise((e) =>\\n      setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\\n    );\\n    for (const e of c.otherFilterSettingsToPrefetch)\\n      p = p.then(async () => {\\n        await new Promise((e) =>\\n          setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\\n        );\\n        this.getExpConfig(e);\\n      });\\n    this.prepareForUpcomingFilters(u);\\n    if (n) {\\n      n.filtersAndExp = {\\n        exp: d,\\n        filters: u,\\n      };\\n    }\\n    return d.variables[e];\\n  }\\n  makeFilterSettings(e) {\\n    return new d.FilterSettings({\\n      ...this.staticFilters,\\n      ...this.getDynamicFilterValues(),\\n      ...e,\\n    });\\n  }\\n  async getExpConfig(e) {\\n    try {\\n      return this.assignments.fetchExpConfig(e);\\n    } catch (e) {\\n      return l.ExpConfig.createFallbackConfig(\\n        this.ctx,\\n        `Error fetching ExP config: ${e}`\\n      );\\n    }\\n  }\\n  async prepareForUpcomingFilters(e) {\\n    if (!(new Date().getMinutes() < 60 - Features.upcomingTimeBucketMinutes))\\n      for (const [t, n] of Object.entries(this.upcomingDynamicFilters)) {\\n        await new Promise((e) =>\\n          setTimeout(e, Features.upcomingDynamicFilterCheckDelayMs)\\n        );\\n        this.getExpConfig(e.withChange(t, n()));\\n      }\\n  }\\n  stringify() {\\n    var e;\\n    const t = this.assignments.getCachedExpConfig(new d.FilterSettings({}));\\n    return JSON.stringify(\\n      null !== (e = null == t ? undefined : t.variables) && undefined !== e\\n        ? e\\n        : {}\\n    );\\n  }\\n  async customEngine(e, t, n, r, o) {\\n    var i;\\n    const s = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n      [d.Filter.CopilotDogfood]: n,\\n      [d.Filter.CopilotUserKind]: r,\\n    };\\n    return null !==\\n      (i = await this.getAssignment(\\n        l.ExpTreatmentVariables.CustomEngine,\\n        s,\\n        o\\n      )) && undefined !== i\\n      ? i\\n      : \\"\\";\\n  }\\n  async beforeRequestWaitMs(e, t, n) {\\n    var r;\\n    const o = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return null !==\\n      (r = await this.getAssignment(\\n        l.ExpTreatmentVariables.BeforeRequestWaitMs,\\n        o,\\n        n\\n      )) && undefined !== r\\n      ? r\\n      : 0;\\n  }\\n  async multiLogitBias(e, t, n) {\\n    var r;\\n    const o = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return (\\n      null !==\\n        (r = await this.getAssignment(\\n          l.ExpTreatmentVariables.MultiLogitBias,\\n          o,\\n          n\\n        )) &&\\n      undefined !== r &&\\n      r\\n    );\\n  }\\n  async debounceMs() {\\n    var e;\\n    return null !==\\n      (e = await this.getAssignment(l.ExpTreatmentVariables.DebounceMs)) &&\\n      undefined !== e\\n      ? e\\n      : 0;\\n  }\\n  async debouncePredict() {\\n    var e;\\n    return (\\n      null !==\\n        (e = await this.getAssignment(\\n          l.ExpTreatmentVariables.DebouncePredict\\n        )) &&\\n      undefined !== e &&\\n      e\\n    );\\n  }\\n  async contextualFilterEnable() {\\n    var e;\\n    return (\\n      null ===\\n        (e = await this.getAssignment(\\n          l.ExpTreatmentVariables.ContextualFilterEnable\\n        )) ||\\n      undefined === e ||\\n      e\\n    );\\n  }\\n  async contextualFilterAcceptThreshold() {\\n    var e;\\n    return null !==\\n      (e = await this.getAssignment(\\n        l.ExpTreatmentVariables.ContextualFilterAcceptThreshold\\n      )) && undefined !== e\\n      ? e\\n      : a.contextualFilterAcceptThreshold;\\n  }\\n  async disableLogProb() {\\n    var e;\\n    return (\\n      null !==\\n        (e = await this.getAssignment(\\n          l.ExpTreatmentVariables.disableLogProb\\n        )) &&\\n      undefined !== e &&\\n      e\\n    );\\n  }\\n  async overrideBlockMode() {\\n    return await this.getAssignment(l.ExpTreatmentVariables.OverrideBlockMode);\\n  }\\n  async overrideNumGhostCompletions() {\\n    return await this.getAssignment(\\n      l.ExpTreatmentVariables.OverrideNumGhostCompletions\\n    );\\n  }\\n  async suffixPercent(e, t) {\\n    var n;\\n    const r = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return s.getConfig(this.ctx, s.ConfigKey.DebugOverrideEngine)\\n      ? 0\\n      : null !==\\n          (n = await this.getAssignment(\\n            l.ExpTreatmentVariables.SuffixPercent,\\n            r\\n          )) && undefined !== n\\n      ? n\\n      : 0;\\n  }\\n  async suffixMatchThreshold(e, t) {\\n    var n;\\n    const r = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return null !==\\n      (n = await this.getAssignment(\\n        l.ExpTreatmentVariables.SuffixMatchThreshold,\\n        r\\n      )) && undefined !== n\\n      ? n\\n      : 0;\\n  }\\n  async fimSuffixLengthThreshold(e, t) {\\n    var n;\\n    const r = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    return null !==\\n      (n = await this.getAssignment(\\n        l.ExpTreatmentVariables.FimSuffixLengthThreshold,\\n        r\\n      )) && undefined !== n\\n      ? n\\n      : 0;\\n  }\\n  async suffixStartMode(e, t) {\\n    const n = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    switch (\\n      await this.getAssignment(l.ExpTreatmentVariables.SuffixStartMode, n)\\n    ) {\\n      default:\\n        return r.SuffixStartMode.Cursor;\\n      case \\"cursortrimstart\\":\\n        return r.SuffixStartMode.CursorTrimStart;\\n      case \\"siblingblock\\":\\n        return r.SuffixStartMode.SiblingBlock;\\n      case \\"siblingblocktrimstart\\":\\n        return r.SuffixStartMode.SiblingBlockTrimStart;\\n    }\\n  }\\n  async neighboringTabsOption(e, t) {\\n    const n = {\\n      [d.Filter.CopilotRepository]: e,\\n      [d.Filter.CopilotFileType]: t,\\n    };\\n    switch (\\n      await this.getAssignment(l.ExpTreatmentVariables.NeighboringTabsOption, n)\\n    ) {\\n      case \\"none\\":\\n        return r.NeighboringTabsOption.None;\\n      case \\"conservative\\":\\n        return r.NeighboringTabsOption.Conservative;\\n      case \\"medium\\":\\n        return r.NeighboringTabsOption.Medium;\\n      default:\\n        return r.NeighboringTabsOption.Eager;\\n      case \\"eagerbutlittle\\":\\n        return r.NeighboringTabsOption.EagerButLittle;\\n    }\\n  }\\n  async repetitionFilterMode() {\\n    switch (\\n      await this.getAssignment(l.ExpTreatmentVariables.RepetitionFilterMode)\\n    ) {\\n      case \\"proxy\\":\\n        return c.RepetitionFilterMode.PROXY;\\n      case \\"both\\":\\n        return c.RepetitionFilterMode.BOTH;\\n      default:\\n        return c.RepetitionFilterMode.CLIENT;\\n    }\\n  }\\n  async addExpAndFilterToTelemetry(e) {\\n    const t = this.makeFilterSettings({});\\n    e.filtersAndExp = {\\n      filters: t,\\n      exp: await this.getExpConfig(t),\\n    };\\n  }\\n}\\nexports.Features = Features;\\nFeatures.upcomingDynamicFilterCheckDelayMs = 20;\\nFeatures.upcomingTimeBucketMinutes = 5 + Math.floor(11 * Math.random());","module-code-3055670":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getSiblingFunctionStart = exports.getSiblingFunctions = undefined;\\nconst r = require(\\"get-prompt-actual\\"),\\n  o = require(\\"get-prompt-parsing-utils\\");\\nexports.getSiblingFunctions = async function ({\\n  source: e,\\n  offset: t,\\n  languageId: n,\\n}) {\\n  var i, s;\\n  const a = [];\\n  let c = \\"\\",\\n    l = e.substring(0, t);\\n  if (o.isSupportedLanguageId(n)) {\\n    const u = await o.parseTree(n, e);\\n    try {\\n      let d = t;\\n      for (; d >= 0 && /\\\\s/.test(e[d]); ) d--;\\n      const p = u.rootNode.descendantForIndex(d),\\n        h = o.getAncestorWithSiblingFunctions(n, p);\\n      if (h) {\\n        const u = o.getFirstPrecedingComment(h),\\n          d =\\n            null !== (i = null == u ? undefined : u.startIndex) &&\\n            undefined !== i\\n              ? i\\n              : h.startIndex;\\n        let p,\\n          f = 0;\\n        for (; \\" \\" == (p = e[d - f - 1]) || \\"\\\\t\\" == p; ) f++;\\n        const m = e.substring(d - f, d);\\n        for (let i = h.nextSibling; i; i = i.nextSibling)\\n          if (o.isFunctionDefinition(n, i)) {\\n            const n = o.getFirstPrecedingComment(i),\\n              c =\\n                null !== (s = null == n ? undefined : n.startIndex) &&\\n                undefined !== s\\n                  ? s\\n                  : i.startIndex;\\n            if (c < t) continue;\\n            const l = e.substring(c, i.endIndex),\\n              u = r.newLineEnded(l) + \\"\\\\n\\" + m;\\n            a.push(u);\\n          }\\n        c = e.substring(0, d);\\n        l = e.substring(d, t);\\n      }\\n    } finally {\\n      u.delete();\\n    }\\n  }\\n  return {\\n    siblings: a,\\n    beforeInsertion: c,\\n    afterInsertion: l,\\n  };\\n};\\nexports.getSiblingFunctionStart = async function ({\\n  source: e,\\n  offset: t,\\n  languageId: n,\\n}) {\\n  var r;\\n  if (o.isSupportedLanguageId(n)) {\\n    const i = await o.parseTree(n, e);\\n    try {\\n      let s = t;\\n      for (; s >= 0 && /\\\\s/.test(e[s]); ) s--;\\n      const a = i.rootNode.descendantForIndex(s),\\n        c = o.getAncestorWithSiblingFunctions(n, a);\\n      if (c) {\\n        for (let e = c.nextSibling; e; e = e.nextSibling)\\n          if (o.isFunctionDefinition(n, e)) {\\n            const n = o.getFirstPrecedingComment(e),\\n              i =\\n                null !== (r = null == n ? undefined : n.startIndex) &&\\n                undefined !== r\\n                  ? r\\n                  : e.startIndex;\\n            if (i < t) continue;\\n            return i;\\n          }\\n        if (c.endIndex >= t) return c.endIndex;\\n      }\\n    } finally {\\n      i.delete();\\n    }\\n  }\\n  return t;\\n};","module-label-3055617":"parse-tree-utils2","module-code-3055404":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.computeScore =\\n  exports.IndentationBasedJaccardMatcher =\\n  exports.FixedWindowSizeJaccardMatcher =\\n    undefined;\\nconst r = require(\\"window-delineator\\"),\\n  o = require(\\"window-matcher\\");\\nclass FixedWindowSizeJaccardMatcher extends o.WindowedMatcher {\\n  constructor(e, t) {\\n    super(e);\\n    this.windowLength = t;\\n  }\\n  id() {\\n    return \\"fixed:\\" + this.windowLength;\\n  }\\n  getWindowsDelineations(e) {\\n    const t = [],\\n      n = e.length;\\n    for (let e = 0; 0 == e || e < n - this.windowLength; e++) {\\n      const r = Math.min(e + this.windowLength, n);\\n      t.push([e, r]);\\n    }\\n    return t;\\n  }\\n  trimDocument(e) {\\n    return e.source\\n      .slice(0, e.offset)\\n      .split(\\"\\\\n\\")\\n      .slice(-this.windowLength)\\n      .join(\\"\\\\n\\");\\n  }\\n  similarityScore(e, t) {\\n    return computeScore(e, t);\\n  }\\n}\\nexports.FixedWindowSizeJaccardMatcher = FixedWindowSizeJaccardMatcher;\\nFixedWindowSizeJaccardMatcher.FACTORY = (e) => ({\\n  to: (t) => new FixedWindowSizeJaccardMatcher(t, e),\\n});\\nclass IndentationBasedJaccardMatcher extends o.WindowedMatcher {\\n  constructor(e, t, n) {\\n    super(e);\\n    this.indentationMinLength = t;\\n    this.indentationMaxLength = n;\\n    this.languageId = e.languageId;\\n  }\\n  id() {\\n    return `indent:${this.indentationMinLength}:${this.indentationMaxLength}:${this.languageId}`;\\n  }\\n  getWindowsDelineations(e) {\\n    return r.getWindowsDelineations(\\n      e,\\n      this.languageId,\\n      this.indentationMinLength,\\n      this.indentationMaxLength\\n    );\\n  }\\n  trimDocument(e) {\\n    return e.source\\n      .slice(0, e.offset)\\n      .split(\\"\\\\n\\")\\n      .slice(-this.indentationMaxLength)\\n      .join(\\"\\\\n\\");\\n  }\\n  similarityScore(e, t) {\\n    return computeScore(e, t);\\n  }\\n}\\nfunction computeScore(e, t) {\\n  const n = new Set();\\n  e.forEach((e) => {\\n    if (t.has(e)) {\\n      n.add(e);\\n    }\\n  });\\n  return n.size / (e.size + t.size - n.size);\\n}\\nexports.IndentationBasedJaccardMatcher = IndentationBasedJaccardMatcher;\\nIndentationBasedJaccardMatcher.FACTORY = (e, t) => ({\\n  to: (n) => new IndentationBasedJaccardMatcher(n, e, t),\\n});\\nexports.computeScore = computeScore;","module-label-3197":"inline-completion-provider","module-code-3055563":"var r =\\n    (this && this.__createBinding) ||\\n    (Object.create\\n      ? function (e, t, n, r) {\\n          if (undefined === r) {\\n            r = n;\\n          }\\n          Object.defineProperty(e, r, {\\n            enumerable: !0,\\n            get: function () {\\n              return t[n];\\n            },\\n          });\\n        }\\n      : function (e, t, n, r) {\\n          if (undefined === r) {\\n            r = n;\\n          }\\n          e[r] = t[n];\\n        }),\\n  o =\\n    (this && this.__exportStar) ||\\n    function (e, t) {\\n      for (var n in e)\\n        if (\\"default\\" === n || Object.prototype.hasOwnProperty.call(t, n)) {\\n          r(t, e, n);\\n        }\\n    };\\nObject.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.createWorker =\\n  exports.FileSystem =\\n  exports.comment =\\n  exports.languageCommentMarkers =\\n    undefined;\\nconst i = require(\\"path\\"),\\n  s = require(\\"worker_threads\\");\\no(require(\\"get-prompt-parsing-utils\\"), exports);\\no(require(\\"ast-utils\\"), exports);\\no(require(\\"get-prompt-actual\\"), exports);\\no(require(\\"tokenizer\\"), exports);\\nvar a = require(\\"language-marker-constants\\");\\nexports.languageCommentMarkers = a.languageCommentMarkers;\\nexports.comment = a.comment;\\nvar c = require(\\"fs-wrapper\\");\\nexports.FileSystem = c.FileSystem;\\nexports.createWorker = function () {\\n  return new s.Worker(i.resolve(__dirname, \\"..\\", \\"dist\\", \\"worker.js\\"));\\n};","module-code-3055306":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getFunctionPositions =\\n  exports.getFirstPrecedingComment =\\n  exports.isFunctionDefinition =\\n  exports.isFunction =\\n  exports.getAncestorWithSiblingFunctions =\\n  exports.queryPythonIsDocstring =\\n  exports.queryGlobalVars =\\n  exports.queryExports =\\n  exports.queryImports =\\n  exports.queryFunctions =\\n  exports.getBlockCloseToken =\\n  exports.parsesWithoutError =\\n  exports.parseTree =\\n  exports.getLanguage =\\n  exports.languageIdToWasmLanguage =\\n  exports.isSupportedLanguageId =\\n  exports.WASMLanguage =\\n    undefined;\\nconst r = require(\\"path\\"),\\n  o = require(\\"maybe-wasm-utils\\"),\\n  i = require(\\"maybe-wasm-utils\\");\\nvar s;\\n!(function (e) {\\n  e.Python = \\"python\\";\\n  e.JavaScript = \\"javascript\\";\\n  e.TypeScript = \\"typescript\\";\\n  e.Go = \\"go\\";\\n  e.Ruby = \\"ruby\\";\\n})((s = exports.WASMLanguage || (exports.WASMLanguage = {})));\\nconst a = {\\n  python: s.Python,\\n  javascript: s.JavaScript,\\n  javascriptreact: s.JavaScript,\\n  jsx: s.JavaScript,\\n  typescript: s.TypeScript,\\n  typescriptreact: s.TypeScript,\\n  go: s.Go,\\n  ruby: s.Ruby,\\n};\\nfunction languageIdToWasmLanguage(e) {\\n  if (!(e in a)) throw new Error(`Unrecognized language: ${e}`);\\n  return a[e];\\n}\\nexports.isSupportedLanguageId = function (e) {\\n  return e in a;\\n};\\nexports.languageIdToWasmLanguage = languageIdToWasmLanguage;\\nconst l = {\\n    python: [\\n      [\\n        \\"(function_definition body: (block\\\\n             (expression_statement (string))? @docstring) @body) @function\\",\\n      ],\\n      [\'(ERROR (\\"def\\" (identifier) (parameters))) @function\'],\\n    ],\\n    javascript: [\\n      [\\n        \\"[\\\\n            (function body: (statement_block) @body)\\\\n            (function_declaration body: (statement_block) @body)\\\\n            (generator_function body: (statement_block) @body)\\\\n            (generator_function_declaration body: (statement_block) @body)\\\\n            (method_definition body: (statement_block) @body)\\\\n          ] @function\\",\\n      ],\\n    ],\\n    typescript: [\\n      [\\n        \\"[\\\\n            (function body: (statement_block) @body)\\\\n            (function_declaration body: (statement_block) @body)\\\\n            (generator_function body: (statement_block) @body)\\\\n            (generator_function_declaration body: (statement_block) @body)\\\\n            (method_definition body: (statement_block) @body)\\\\n          ] @function\\",\\n      ],\\n    ],\\n    go: [\\n      [\\n        \\"[\\\\n            (function_declaration body: (block) @body)\\\\n            (method_declaration body: (block) @body)\\\\n          ] @function\\",\\n      ],\\n    ],\\n    ruby: [\\n      [\\n        \'[\\\\n            (method name: (_) parameters: (method_parameters)? @params [(_)+ \\"end\\"] @body)\\\\n            (singleton_method name: (_) parameters: (method_parameters)? @params [(_)+ \\"end\\"] @body)\\\\n          ] @function\',\\n      ],\\n    ],\\n  },\\n  u =\\n    \'(variable_declarator value: (call_expression function: ((identifier) @req (#eq? @req \\"require\\"))))\',\\n  d = `\\\\n    (lexical_declaration ${u}+)\\\\n    (variable_declaration ${u}+)\\\\n`,\\n  p = {\\n    python: [\\n      [\\"(module (future_import_statement) @import)\\"],\\n      [\\"(module (import_statement) @import)\\"],\\n      [\\"(module (import_from_statement) @import)\\"],\\n    ],\\n    javascript: [\\n      [`(program [ ${d} ] @import)`],\\n      [\\"(program [ (import_statement) ] @import)\\"],\\n    ],\\n    typescript: [\\n      [`(program [ ${d} ] @import)`],\\n      [\\"(program [ (import_statement) (import_alias) ] @import)\\"],\\n    ],\\n    go: [],\\n    ruby: [],\\n  },\\n  h = {\\n    python: [],\\n    javascript: [[\\"(program (export_statement) @export)\\"]],\\n    typescript: [[\\"(program (export_statement) @export)\\"]],\\n    go: [],\\n    ruby: [],\\n  },\\n  f = {\\n    python: [\\n      [\\"(module (global_statement) @globalVar)\\"],\\n      [\\"(module (expression_statement) @globalVar)\\"],\\n    ],\\n    javascript: [],\\n    typescript: [],\\n    go: [],\\n    ruby: [],\\n  },\\n  m = {\\n    python: new Set([\\"function_definition\\"]),\\n    javascript: new Set([\\n      \\"function\\",\\n      \\"function_declaration\\",\\n      \\"generator_function\\",\\n      \\"generator_function_declaration\\",\\n      \\"method_definition\\",\\n      \\"arrow_function\\",\\n    ]),\\n    typescript: new Set([\\n      \\"function\\",\\n      \\"function_declaration\\",\\n      \\"generator_function\\",\\n      \\"generator_function_declaration\\",\\n      \\"method_definition\\",\\n      \\"arrow_function\\",\\n    ]),\\n    go: new Set([\\"function_declaration\\", \\"method_declaration\\"]),\\n    ruby: new Set([\\"method\\", \\"singleton_method\\"]),\\n  },\\n  g = {\\n    python: (e) => {\\n      var t;\\n      return (\\n        \\"module\\" === e.type ||\\n        (\\"block\\" === e.type &&\\n          \\"class_definition\\" ===\\n            (null === (t = e.parent) || undefined === t ? undefined : t.type))\\n      );\\n    },\\n    javascript: (e) => \\"program\\" === e.type || \\"class_body\\" === e.type,\\n    typescript: (e) => \\"program\\" === e.type || \\"class_body\\" === e.type,\\n    go: (e) => \\"source_file\\" === e.type,\\n    ruby: (e) => \\"program\\" === e.type || \\"class\\" === e.type,\\n  },\\n  _ = new Map();\\nasync function getLanguage(e) {\\n  const t = languageIdToWasmLanguage(e);\\n  if (!_.has(t)) {\\n    const e = await (async function (e) {\\n      await o.init();\\n      const t = r.resolve(__dirname, \\"..\\", \\"dist\\", `tree-sitter-${e}.wasm`);\\n      return i.Language.load(t);\\n    })(t);\\n    _.set(t, e);\\n  }\\n  return _.get(t);\\n}\\nasync function parseTree(e, t) {\\n  let n = await getLanguage(e);\\n  const r = new o();\\n  r.setLanguage(n);\\n  const i = r.parse(t);\\n  r.delete();\\n  return i;\\n}\\nfunction b(e, t) {\\n  const n = [];\\n  for (const r of e) {\\n    if (!r[1]) {\\n      const e = t.tree.getLanguage();\\n      r[1] = e.query(r[0]);\\n    }\\n    n.push(...r[1].matches(t));\\n  }\\n  return n;\\n}\\nfunction queryFunctions(e, t) {\\n  return b(l[languageIdToWasmLanguage(e)], t);\\n}\\nexports.getLanguage = getLanguage;\\nexports.parseTree = parseTree;\\nexports.parsesWithoutError = async function (e, t) {\\n  const n = await parseTree(e, t),\\n    r = !n.rootNode.hasError();\\n  n.delete();\\n  return r;\\n};\\nexports.getBlockCloseToken = function (e) {\\n  switch (languageIdToWasmLanguage(e)) {\\n    case s.Python:\\n      return null;\\n    case s.JavaScript:\\n    case s.TypeScript:\\n    case s.Go:\\n      return \\"}\\";\\n    case s.Ruby:\\n      return \\"end\\";\\n  }\\n};\\nexports.queryFunctions = queryFunctions;\\nexports.queryImports = function (e, t) {\\n  return b(p[languageIdToWasmLanguage(e)], t);\\n};\\nexports.queryExports = function (e, t) {\\n  return b(h[languageIdToWasmLanguage(e)], t);\\n};\\nexports.queryGlobalVars = function (e, t) {\\n  return b(f[languageIdToWasmLanguage(e)], t);\\n};\\nconst x = [\\n  \\"[\\\\n    (class_definition (block (expression_statement (string))))\\\\n    (function_definition (block (expression_statement (string))))\\\\n]\\",\\n];\\nfunction isFunction(e, t) {\\n  return m[languageIdToWasmLanguage(e)].has(t.type);\\n}\\nexports.queryPythonIsDocstring = function (e) {\\n  return 1 == b([x], e).length;\\n};\\nexports.getAncestorWithSiblingFunctions = function (e, t) {\\n  const n = g[languageIdToWasmLanguage(e)];\\n  for (; t.parent; ) {\\n    if (n(t.parent)) return t;\\n    t = t.parent;\\n  }\\n  return t.parent ? t : null;\\n};\\nexports.isFunction = isFunction;\\nexports.isFunctionDefinition = function (e, t) {\\n  switch (languageIdToWasmLanguage(e)) {\\n    case s.Python:\\n    case s.Go:\\n    case s.Ruby:\\n      return isFunction(e, t);\\n    case s.JavaScript:\\n    case s.TypeScript:\\n      if (\\n        \\"function_declaration\\" === t.type ||\\n        \\"generator_function_declaration\\" === t.type ||\\n        \\"method_definition\\" === t.type\\n      )\\n        return !0;\\n      if (\\n        \\"lexical_declaration\\" === t.type ||\\n        \\"variable_declaration\\" === t.type\\n      ) {\\n        if (t.namedChildCount > 1) return !1;\\n        let n = t.namedChild(0);\\n        if (null == n) return !1;\\n        let r = n.namedChild(1);\\n        return null !== r && isFunction(e, r);\\n      }\\n      if (\\"expression_statement\\" === t.type) {\\n        let n = t.namedChild(0);\\n        if (\\"assignment_expression\\" === (null == n ? undefined : n.type)) {\\n          let t = n.namedChild(1);\\n          return null !== t && isFunction(e, t);\\n        }\\n      }\\n      return !1;\\n  }\\n};\\nexports.getFirstPrecedingComment = function (e) {\\n  var t;\\n  let n = e;\\n  for (\\n    ;\\n    \\"comment\\" ===\\n    (null === (t = n.previousSibling) || undefined === t ? undefined : t.type);\\n\\n  ) {\\n    let e = n.previousSibling;\\n    if (e.endPosition.row < n.startPosition.row - 1) break;\\n    n = e;\\n  }\\n  return \\"comment\\" === (null == n ? undefined : n.type) ? n : null;\\n};\\nexports.getFunctionPositions = async function (e, t) {\\n  return queryFunctions(e, (await parseTree(e, t)).rootNode).map((e) => {\\n    const t = e.captures.find((e) => \\"function\\" === e.name).node;\\n    return {\\n      startIndex: t.startIndex,\\n      endIndex: t.endIndex,\\n    };\\n  });\\n};","module-label-2279":"helix-fetcher-and-network-stuff","module-code-3055617":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.rebuildTree =\\n  exports.foldTree =\\n  exports.visitTreeConditionally =\\n  exports.visitTree =\\n  exports.resetLineNumbers =\\n  exports.mapLabels =\\n  exports.clearLabelsIf =\\n  exports.clearLabels =\\n    undefined;\\nconst r = require(\\"parse-tree-utils\\");\\nfunction visitTree(e, t, n) {\\n  !(function e(r) {\\n    if (\\"topDown\\" === n) {\\n      t(r);\\n    }\\n    r.subs.forEach((t) => {\\n      e(t);\\n    });\\n    if (\\"bottomUp\\" === n) {\\n      t(r);\\n    }\\n  })(e);\\n}\\nexports.clearLabels = function (e) {\\n  visitTree(\\n    e,\\n    (e) => {\\n      e.label = undefined;\\n    },\\n    \\"bottomUp\\"\\n  );\\n  return e;\\n};\\nexports.clearLabelsIf = function (e, t) {\\n  visitTree(\\n    e,\\n    (e) => {\\n      e.label = e.label ? (t(e.label) ? undefined : e.label) : undefined;\\n    },\\n    \\"bottomUp\\"\\n  );\\n  return e;\\n};\\nexports.mapLabels = function e(t, n) {\\n  switch (t.type) {\\n    case \\"line\\":\\n    case \\"virtual\\":\\n      const r = t.subs.map((t) => e(t, n));\\n      return {\\n        ...t,\\n        subs: r,\\n        label: t.label ? n(t.label) : undefined,\\n      };\\n    case \\"blank\\":\\n      return {\\n        ...t,\\n        label: t.label ? n(t.label) : undefined,\\n      };\\n    case \\"top\\":\\n      return {\\n        ...t,\\n        subs: t.subs.map((t) => e(t, n)),\\n        label: t.label ? n(t.label) : undefined,\\n      };\\n  }\\n};\\nexports.resetLineNumbers = function (e) {\\n  let t = 0;\\n  visitTree(\\n    e,\\n    function (e) {\\n      if (r.isVirtual(e) || r.isTop(e)) {\\n        e.lineNumber = t;\\n        t++;\\n      }\\n    },\\n    \\"topDown\\"\\n  );\\n};\\nexports.visitTree = visitTree;\\nexports.visitTreeConditionally = function (e, t, n) {\\n  !(function e(r) {\\n    if (\\"topDown\\" === n && !t(r)) return !1;\\n    let o = !0;\\n    r.subs.forEach((t) => {\\n      o = o && e(t);\\n    });\\n    if (\\"bottomUp\\" === n) {\\n      o = o && t(r);\\n    }\\n    return o;\\n  })(e);\\n};\\nexports.foldTree = function (e, t, n, r) {\\n  let i = t;\\n  visitTree(\\n    e,\\n    function (e) {\\n      i = n(e, i);\\n    },\\n    r\\n  );\\n  return i;\\n};\\nexports.rebuildTree = function (e, t, n) {\\n  const o = (e) => {\\n      if (undefined !== n && n(e)) return e;\\n      {\\n        const n = e.subs.map(o).filter((e) => undefined !== e);\\n        e.subs = n;\\n        return t(e);\\n      }\\n    },\\n    i = o(e);\\n  return undefined !== i ? i : r.topNode();\\n};","module-label-106":"debouncer","module-label-3055125":"neighbor-snippet-selector","module-label-3055467":"window-matcher","module-code-956":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.readTestingGitHubToken = exports.makeTestingCopilotTokenManager =\\n  undefined;\\nconst r = require(\\"fs\\"),\\n  o = require(\\"copilot-github-auth-stuff\\");\\nfunction readTestingGitHubToken() {\\n  const e = `${process.env.HOME}/.copilot-testing-gh-token`;\\n  if (r.existsSync(e)) return r.readFileSync(e).toString();\\n  throw new Error(\\n    `Tests: either GH_COPILOT_TOKEN, or GITHUB_TOKEN, must be set, or there must be a GitHub token from an app with access to Copilot in ${e}. Run \\"npm run get_token\\" to get one.`\\n  );\\n}\\nexports.makeTestingCopilotTokenManager = function () {\\n  if (process.env.GH_COPILOT_TOKEN)\\n    return new o.FixedCopilotTokenManager({\\n      token: process.env.GH_COPILOT_TOKEN,\\n      telemetry: \\"enabled\\",\\n    });\\n  if (process.env.GITHUB_TOKEN)\\n    return new o.CopilotTokenManagerFromGitHubToken({\\n      token: process.env.GITHUB_TOKEN,\\n    });\\n  const e = readTestingGitHubToken();\\n  process.env.GITHUB_TOKEN = e;\\n  return new o.CopilotTokenManagerFromGitHubToken({\\n    token: e,\\n  });\\n};\\nexports.readTestingGitHubToken = readTestingGitHubToken;","module-label-1839":"doc-tracker","module-code-3055312":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getPrompt =\\n  exports.newLineEnded =\\n  exports.normalizeLanguageId =\\n  exports.PromptOptions =\\n  exports.SuffixStartMode =\\n  exports.SuffixMatchOption =\\n  exports.SuffixOption =\\n  exports.LineEndingOptions =\\n  exports.LocalImportContextOption =\\n  exports.SnippetSelectionOption =\\n  exports.NeighboringTabsPositionOption =\\n  exports.NeighboringTabsOption =\\n  exports.SiblingOption =\\n  exports.PathMarkerOption =\\n  exports.LanguageMarkerOption =\\n  exports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING =\\n  exports.MAX_EDIT_DISTANCE_LENGTH =\\n  exports.MAX_PROMPT_LENGTH =\\n    undefined;\\nconst r = require(\\"language-marker-constants\\"),\\n  o = require(\\"imports-and-docs-extractor\\"),\\n  i = require(\\"neighbor-snippet-selector\\"),\\n  s = require(\\"sibling-function-fetcher\\"),\\n  a = require(\\"tokenizer\\"),\\n  c = require(\\"prompt-choices-and-wishlist\\"),\\n  l = require(\\"edit-distance\\");\\nlet u = {\\n  text: \\"\\",\\n  tokens: [],\\n};\\nvar d, p, h, f, m, g, _, y, v, b, w;\\nexports.MAX_PROMPT_LENGTH = 1500;\\nexports.MAX_EDIT_DISTANCE_LENGTH = 50;\\nexports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING = 5;\\n(function (e) {\\n  e.NoMarker = \\"nomarker\\";\\n  e.Top = \\"top\\";\\n  e.Always = \\"always\\";\\n})((d = exports.LanguageMarkerOption || (exports.LanguageMarkerOption = {})));\\n(function (e) {\\n  e.NoMarker = \\"nomarker\\";\\n  e.Top = \\"top\\";\\n  e.Always = \\"always\\";\\n})((p = exports.PathMarkerOption || (exports.PathMarkerOption = {})));\\n(function (e) {\\n  e.NoSiblings = \\"nosiblings\\";\\n  e.SiblingsOverContext = \\"siblingabove\\";\\n  e.ContextOverSiblings = \\"contextabove\\";\\n})((h = exports.SiblingOption || (exports.SiblingOption = {})));\\n(function (e) {\\n  e.None = \\"none\\";\\n  e.Conservative = \\"conservative\\";\\n  e.Medium = \\"medium\\";\\n  e.Eager = \\"eager\\";\\n  e.EagerButLittle = \\"eagerButLittle\\";\\n})((f = exports.NeighboringTabsOption || (exports.NeighboringTabsOption = {})));\\n(function (e) {\\n  e.TopOfText = \\"top\\";\\n  e.DirectlyAboveCursor = \\"aboveCursor\\";\\n  e.AfterSiblings = \\"afterSiblings\\";\\n})(\\n  (m =\\n    exports.NeighboringTabsPositionOption ||\\n    (exports.NeighboringTabsPositionOption = {}))\\n);\\n(function (e) {\\n  e.BestMatch = \\"bestMatch\\";\\n  e.TopK = \\"topK\\";\\n})(\\n  (g = exports.SnippetSelectionOption || (exports.SnippetSelectionOption = {}))\\n);\\n(function (e) {\\n  e.NoContext = \\"nocontext\\";\\n  e.Declarations = \\"declarations\\";\\n})(\\n  (_ =\\n    exports.LocalImportContextOption || (exports.LocalImportContextOption = {}))\\n);\\n(function (e) {\\n  e.ConvertToUnix = \\"unix\\";\\n  e.KeepOriginal = \\"keep\\";\\n})((y = exports.LineEndingOptions || (exports.LineEndingOptions = {})));\\n(w = exports.SuffixOption || (exports.SuffixOption = {})).None = \\"none\\";\\nw.FifteenPercent = \\"fifteenPercent\\";\\n(function (e) {\\n  e.Equal = \\"equal\\";\\n  e.Levenshtein = \\"levenshteineditdistance\\";\\n})((v = exports.SuffixMatchOption || (exports.SuffixMatchOption = {})));\\n(function (e) {\\n  e.Cursor = \\"cursor\\";\\n  e.CursorTrimStart = \\"cursortrimstart\\";\\n  e.SiblingBlock = \\"siblingblock\\";\\n  e.SiblingBlockTrimStart = \\"siblingblocktrimstart\\";\\n})((b = exports.SuffixStartMode || (exports.SuffixStartMode = {})));\\nclass PromptOptions {\\n  constructor(e, n) {\\n    this.fs = e;\\n    this.maxPromptLength = exports.MAX_PROMPT_LENGTH;\\n    this.languageMarker = d.Top;\\n    this.pathMarker = p.Top;\\n    this.includeSiblingFunctions = h.ContextOverSiblings;\\n    this.localImportContext = _.Declarations;\\n    this.neighboringTabs = f.Eager;\\n    this.neighboringTabsPosition = m.TopOfText;\\n    this.lineEnding = y.ConvertToUnix;\\n    this.suffixPercent = 0;\\n    this.suffixStartMode = b.Cursor;\\n    this.suffixMatchThreshold = 0;\\n    this.suffixMatchCriteria = v.Levenshtein;\\n    this.fimSuffixLengthThreshold = 0;\\n    if (n) for (const e in n) this[e] = n[e];\\n    if (this.suffixPercent < 0 || this.suffixPercent > 100)\\n      throw new Error(\\n        `suffixPercent must be between 0 and 100, but was ${this.suffixPercent}`\\n      );\\n    if (this.suffixPercent > 0 && this.includeSiblingFunctions != h.NoSiblings)\\n      throw new Error(\\n        `Invalid option combination. Cannot set suffixPercent > 0 (${this.suffixPercent}) and includeSiblingFunctions ${this.includeSiblingFunctions}`\\n      );\\n    if (this.suffixMatchThreshold < 0 || this.suffixMatchThreshold > 100)\\n      throw new Error(\\n        `suffixMatchThreshold must be at between 0 and 100, but was ${this.suffixMatchThreshold}`\\n      );\\n    if (this.fimSuffixLengthThreshold < -1)\\n      throw new Error(\\n        `fimSuffixLengthThreshold must be at least -1, but was ${this.fimSuffixLengthThreshold}`\\n      );\\n    if (\\n      null != this.indentationMinLength &&\\n      null != this.indentationMaxLength &&\\n      this.indentationMinLength > this.indentationMaxLength\\n    )\\n      throw new Error(\\n        `indentationMinLength must be less than or equal to indentationMaxLength, but was ${this.indentationMinLength} and ${this.indentationMaxLength}`\\n      );\\n    if (\\n      this.snippetSelection === g.TopK &&\\n      undefined === this.snippetSelectionK\\n    )\\n      throw new Error(\\"snippetSelectionK must be defined.\\");\\n    if (\\n      this.snippetSelection === g.TopK &&\\n      this.snippetSelectionK &&\\n      this.snippetSelectionK <= 0\\n    )\\n      throw new Error(\\n        `snippetSelectionK must be greater than 0, but was ${this.snippetSelectionK}`\\n      );\\n  }\\n}\\nexports.PromptOptions = PromptOptions;\\nconst E = {\\n  javascriptreact: \\"javascript\\",\\n  jsx: \\"javascript\\",\\n  typescriptreact: \\"typescript\\",\\n  jade: \\"pug\\",\\n  cshtml: \\"razor\\",\\n};\\nfunction normalizeLanguageId(e) {\\n  var t;\\n  e = e.toLowerCase();\\n  return null !== (t = E[e]) && undefined !== t ? t : e;\\n}\\nfunction newLineEnded(e) {\\n  return \\"\\" == e || e.endsWith(\\"\\\\n\\") ? e : e + \\"\\\\n\\";\\n}\\nexports.normalizeLanguageId = normalizeLanguageId;\\nexports.newLineEnded = newLineEnded;\\nexports.getPrompt = async function (e, n, g = {}, y = []) {\\n  var w;\\n  const E = new PromptOptions(e, g);\\n  let T = !1;\\n  const { source: k, offset: I } = n;\\n  if (I < 0 || I > k.length) throw new Error(`Offset ${I} is out of range.`);\\n  n.languageId = normalizeLanguageId(n.languageId);\\n  const P = new c.Priorities(),\\n    A = P.justBelow(c.Priorities.TOP),\\n    O =\\n      E.languageMarker == d.Always\\n        ? P.justBelow(c.Priorities.TOP)\\n        : P.justBelow(A),\\n    N =\\n      E.pathMarker == p.Always ? P.justBelow(c.Priorities.TOP) : P.justBelow(A),\\n    R =\\n      E.includeSiblingFunctions == h.ContextOverSiblings\\n        ? P.justBelow(A)\\n        : P.justAbove(A),\\n    M = P.justBelow(A, R),\\n    L = P.justBelow(M),\\n    $ = new c.PromptWishlist(E.lineEnding);\\n  let D, F;\\n  if (E.languageMarker != d.NoMarker) {\\n    const e = newLineEnded(r.getLanguageMarker(n));\\n    D = $.append(e, c.PromptElementKind.LanguageMarker, O);\\n  }\\n  if (E.pathMarker != p.NoMarker) {\\n    const e = newLineEnded(r.getPathMarker(n));\\n    if (e.length > 0) {\\n      F = $.append(e, c.PromptElementKind.PathMarker, N);\\n    }\\n  }\\n  if (E.localImportContext != _.NoContext)\\n    for (const e of await o.extractLocalImportContext(n, E.fs))\\n      $.append(newLineEnded(e), c.PromptElementKind.ImportedFile, M);\\n  const j =\\n    E.neighboringTabs == f.None || 0 == y.length\\n      ? []\\n      : await i.getNeighborSnippets(\\n          n,\\n          y,\\n          E.neighboringTabs,\\n          E.indentationMinLength,\\n          E.indentationMaxLength,\\n          E.snippetSelectionOption,\\n          E.snippetSelectionK\\n        );\\n  function q() {\\n    j.forEach((e) =>\\n      $.append(\\n        e.snippet,\\n        c.PromptElementKind.SimilarFile,\\n        L,\\n        a.tokenLength(e.snippet),\\n        e.score\\n      )\\n    );\\n  }\\n  if (E.neighboringTabsPosition == m.TopOfText) {\\n    q();\\n  }\\n  const B = [];\\n  let U;\\n  if (E.includeSiblingFunctions == h.NoSiblings) U = k.substring(0, I);\\n  else {\\n    const {\\n      siblings: e,\\n      beforeInsertion: t,\\n      afterInsertion: r,\\n    } = await s.getSiblingFunctions(n);\\n    $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\\n      B.push(e)\\n    );\\n    let o = R;\\n    e.forEach((e) => {\\n      $.append(e, c.PromptElementKind.AfterCursor, o);\\n      o = P.justBelow(o);\\n    });\\n    if (E.neighboringTabsPosition == m.AfterSiblings) {\\n      q();\\n    }\\n    U = r;\\n  }\\n  if (E.neighboringTabsPosition == m.DirectlyAboveCursor) {\\n    const e = U.lastIndexOf(\\"\\\\n\\") + 1,\\n      t = U.substring(0, e),\\n      n = U.substring(e);\\n    $.appendLineForLine(t, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\\n      B.push(e)\\n    );\\n    q();\\n    if (n.length > 0) {\\n      B.push($.append(n, c.PromptElementKind.AfterCursor, A));\\n      if (B.length > 1) {\\n        $.require(B[B.length - 2], B[B.length - 1]);\\n      }\\n    }\\n  } else\\n    $.appendLineForLine(U, c.PromptElementKind.BeforeCursor, A).forEach((e) =>\\n      B.push(e)\\n    );\\n  if (d.Top == E.languageMarker && B.length > 0 && undefined !== D) {\\n    $.require(D, B[0]);\\n  }\\n  if (p.Top == E.pathMarker && B.length > 0 && undefined !== F) {\\n    if (D) {\\n      $.require(F, D);\\n    } else {\\n      $.require(F, B[0]);\\n    }\\n  }\\n  if (undefined !== D && undefined !== F) {\\n    $.exclude(F, D);\\n  }\\n  let H = k.slice(I);\\n  if (0 == E.suffixPercent || H.length <= E.fimSuffixLengthThreshold)\\n    return $.fulfill(E.maxPromptLength);\\n  {\\n    let e = n.offset;\\n    if (\\n      E.suffixStartMode !== b.Cursor &&\\n      E.suffixStartMode !== b.CursorTrimStart\\n    ) {\\n      e = await s.getSiblingFunctionStart(n);\\n    }\\n    const r = E.maxPromptLength - exports.TOKENS_RESERVED_FOR_SUFFIX_ENCODING;\\n    let o = Math.floor((r * (100 - E.suffixPercent)) / 100),\\n      i = $.fulfill(o);\\n    const c = r - i.prefixLength;\\n    let d = k.slice(e);\\n    if (\\n      E.suffixStartMode != b.SiblingBlockTrimStart &&\\n      E.suffixStartMode != b.CursorTrimStart\\n    ) {\\n      d = d.trimStart();\\n    }\\n    const p = a.takeFirstTokens(d, c);\\n    if (p.tokens.length <= c - 3) {\\n      o = r - p.tokens.length;\\n      i = $.fulfill(o);\\n    }\\n    if (E.suffixMatchCriteria == v.Equal) {\\n      if (\\n        p.tokens.length === u.tokens.length &&\\n        p.tokens.every((e, t) => e === u.tokens[t])\\n      ) {\\n        T = !0;\\n      }\\n    } else {\\n      if (\\n        E.suffixMatchCriteria == v.Levenshtein &&\\n        p.tokens.length > 0 &&\\n        E.suffixMatchThreshold > 0 &&\\n        100 *\\n          (null ===\\n            (w = l.findEditDistanceScore(\\n              p.tokens.slice(0, exports.MAX_EDIT_DISTANCE_LENGTH),\\n              u.tokens.slice(0, exports.MAX_EDIT_DISTANCE_LENGTH)\\n            )) || undefined === w\\n            ? undefined\\n            : w.score) <\\n          E.suffixMatchThreshold *\\n            Math.min(exports.MAX_EDIT_DISTANCE_LENGTH, p.tokens.length)\\n      ) {\\n        T = !0;\\n      }\\n    }\\n    if (!0 === T && u.tokens.length <= c) {\\n      if (u.tokens.length <= c - 3) {\\n        o = r - u.tokens.length;\\n        i = $.fulfill(o);\\n      }\\n      i.suffix = u.text;\\n      i.suffixLength = u.tokens.length;\\n    } else {\\n      i.suffix = p.text;\\n      i.suffixLength = p.tokens.length;\\n      u = p;\\n    }\\n    return i;\\n  }\\n};","module-label-385":"text-doc-manager","module-code-9408":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.registerDefaultHandlers = undefined;\\nconst r = require(\\"helix-fetcher-and-network-stuff\\"),\\n  o = require(\\"telemetry-stuff\\");\\nexports.registerDefaultHandlers = function (e, t) {\\n  process.addListener(\\"uncaughtException\\", (t) => {\\n    console.error(\\"uncaughtException\\", t);\\n    o.telemetryException(e, t, \\"uncaughtException\\");\\n  });\\n  let n = !1;\\n  process.addListener(\\"unhandledRejection\\", (i, s) => {\\n    if (n) return;\\n    n = !0;\\n    if (\\"vscode\\" === t && !i) return;\\n    if (\\"aborted\\" === i.type || r.isAbortError(i)) return;\\n    if (\\n      \\"vscode\\" === t &&\\n      [\\n        \\"ENOTFOUND\\",\\n        \\"ECONNREFUSED\\",\\n        \\"ECONNRESET\\",\\n        \\"ETIMEDOUT\\",\\n        \\"ENETDOWN\\",\\n        \\"ENETUNREACH\\",\\n        \\"EADDRNOTAVAIL\\",\\n      ].includes(i.code)\\n    )\\n      return;\\n    if (\\"ENOENT\\" == i.code) return;\\n    let a = \\"\\";\\n    try {\\n      a = `${i.message} (${i.code})`;\\n      a = JSON.stringify(i);\\n    } catch (e) {\\n      a = \\"[actual reason JSON was cyclic]\\";\\n    }\\n    if (\\"vscode\\" === t && \\"{}\\" === a) {\\n      console.error(\\"unhandledRejection\\", a);\\n      o.telemetryError(\\n        e,\\n        \\"unhandledRejection\\",\\n        o.TelemetryData.createAndMarkAsIssued({\\n          origin: \\"unhandledRejection\\",\\n          reason: \\"Unhandled rejection logged to restricted telemetry\\",\\n        }),\\n        !1\\n      );\\n      o.telemetryError(\\n        e,\\n        \\"unhandledRejection\\",\\n        o.TelemetryData.createAndMarkAsIssued({\\n          origin: \\"unhandledRejection\\",\\n          reason: a,\\n        }),\\n        !0\\n      );\\n      n = !1;\\n    }\\n  });\\n};","module-label-299":"clock","module-label-3076":"prompt-cache","module-label-1929":"open-copilot-action-provider","module-label-7744":"contextual-filter-constants","module-label-305594":"tokenizer","module-label-1124":"postprocess-choice","module-label-893":"copilot-list-doc","module-label-3055563":"getPrompt-main-stuff","module-label-3055469":"parser-utils","module-label-7017":"post-accept-or-reject-tasks","module-code-9334":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getGhostText =\\n  exports.completionCache =\\n  exports.ResultType =\\n  exports.ghostTextLogger =\\n    undefined;\\nconst r = require(\\"getPrompt-main-stuff\\"),\\n  o = require(\\"uuid-utils\\"),\\n  i = require(\\"prompt-cache\\"),\\n  s = require(\\"debouncer\\"),\\n  a = require(6932),\\n  c = require(\\"config-stuff\\"),\\n  l = require(9189),\\n  u = require(\\"logging-utils\\"),\\n  d = require(\\"helix-fetcher-and-network-stuff\\"),\\n  p = require(\\"openai_conn_utils\\"),\\n  h = require(\\"live-openai-fetcher\\"),\\n  f = require(\\"openai-choices-utils\\"),\\n  m = require(6722),\\n  g = require(\\"context-extractor-from-identation-maybe\\"),\\n  _ = require(\\"prompt-extractor\\"),\\n  y = require(\\"background-context-provider\\"),\\n  v = require(1006),\\n  b = require(\\"postprocess-choice\\"),\\n  w = require(\\"telemetry-stuff\\"),\\n  x = require(70),\\n  E = require(\\"location-factory\\"),\\n  C = require(\\"contextual-filter-manager\\"),\\n  S = require(5413),\\n  T = require(\\"ghost-text-telemetry\\");\\nvar k;\\nlet I, P;\\nasync function A(e, n, r, o, i, s, a) {\\n  var u, p, m;\\n  exports.ghostTextLogger.debug(e, `Getting ${s} from network`);\\n  r = r.extendedBy();\\n  const g = await (async function (e, t) {\\n      const n = await e.get(l.Features).overrideNumGhostCompletions();\\n      return n\\n        ? t.isCycling\\n          ? Math.max(0, 3 - n)\\n          : n\\n        : c.shouldDoParsingTrimming(t.blockMode) && t.multiline\\n        ? c.getConfig(e, c.ConfigKey.InlineSuggestCount)\\n        : t.isCycling\\n        ? 2\\n        : 1;\\n    })(e, n),\\n    _ = f.getTemperatureForSamples(e, g),\\n    y = {\\n      stream: !0,\\n      n: g,\\n      temperature: _,\\n      extra: {\\n        language: n.languageId,\\n        next_indent:\\n          null !== (u = n.indentation.next) && undefined !== u ? u : 0,\\n        trim_by_indentation: c.shouldDoServerTrimming(n.blockMode),\\n      },\\n    };\\n  if (n.multiline) {\\n    y.stop = [\\"\\\\n\\"];\\n  }\\n  if (n.multiline && n.multiLogitBias) {\\n    y.logit_bias = {\\n      50256: -100,\\n    };\\n  }\\n  const v = Date.now(),\\n    b = {\\n      endpoint: \\"completions\\",\\n      uiKind: h.CopilotUiKind.GhostText,\\n      isCycling: JSON.stringify(n.isCycling),\\n      temperature: JSON.stringify(_),\\n      n: JSON.stringify(g),\\n      stop:\\n        null !== (p = JSON.stringify(y.stop)) && undefined !== p ? p : \\"unset\\",\\n      logit_bias: JSON.stringify(\\n        null !== (m = y.logit_bias) && undefined !== m ? m : null\\n      ),\\n    },\\n    E = w.telemetrizePromptLength(n.prompt);\\n  Object.assign(r.properties, b);\\n  Object.assign(r.measurements, E);\\n  try {\\n    const s = {\\n      prompt: n.prompt,\\n      languageId: n.languageId,\\n      repoInfo: n.repoInfo,\\n      ourRequestId: n.ourRequestId,\\n      engineUrl: n.engineURL,\\n      count: g,\\n      uiKind: h.CopilotUiKind.GhostText,\\n      postOptions: y,\\n    };\\n    if (n.delayMs > 0) {\\n      await new Promise((e) => setTimeout(e, n.delayMs));\\n    }\\n    const c = await e\\n      .get(h.OpenAIFetcher)\\n      .fetchAndStreamCompletions(e, s, r, i, o);\\n    return \\"failed\\" === c.type\\n      ? {\\n          type: \\"failed\\",\\n          reason: c.reason,\\n          telemetryData: T.mkBasicResultTelemetry(r),\\n        }\\n      : \\"canceled\\" === c.type\\n      ? (exports.ghostTextLogger.debug(\\n          e,\\n          \\"Cancelled after awaiting fetchCompletions\\"\\n        ),\\n        {\\n          type: \\"canceled\\",\\n          reason: c.reason,\\n          telemetryData: T.mkCanceledResultTelemetry(r),\\n        })\\n      : a(g, v, c.getProcessingTime(), c.choices);\\n  } catch (n) {\\n    if (d.isAbortError(n))\\n      return {\\n        type: \\"canceled\\",\\n        reason: \\"network request aborted\\",\\n        telemetryData: T.mkCanceledResultTelemetry(r, {\\n          cancelledNetworkRequest: !0,\\n        }),\\n      };\\n    exports.ghostTextLogger.error(e, `Error on ghost text request ${n}`);\\n    if ((0, x.shouldFailForDebugPurposes)(e)) throw n;\\n    return {\\n      type: \\"failed\\",\\n      reason: \\"non-abort error on ghost text request\\",\\n      telemetryData: T.mkBasicResultTelemetry(r),\\n    };\\n  }\\n}\\nfunction O(e, t) {\\n  const n = {\\n    ...e,\\n  };\\n  n.completionText = e.completionText.trimEnd();\\n  if (t.forceSingleLine) {\\n    n.completionText = n.completionText.split(\\"\\\\n\\")[0];\\n  }\\n  return n;\\n}\\nexports.ghostTextLogger = new u.Logger(u.LogLevel.INFO, \\"ghostText\\");\\n(function (e) {\\n  e[(e.Network = 0)] = \\"Network\\";\\n  e[(e.Cache = 1)] = \\"Cache\\";\\n  e[(e.TypingAsSuggested = 2)] = \\"TypingAsSuggested\\";\\n  e[(e.Cycling = 3)] = \\"Cycling\\";\\n})((k = exports.ResultType || (exports.ResultType = {})));\\nexports.completionCache = new i.LRUCache(100);\\nconst N = new s.Debouncer();\\nfunction R(e, t) {\\n  I = e;\\n  P = t;\\n}\\nfunction M(e, n, r) {\\n  const o = i.keyForPrompt(n.prompt),\\n    s = exports.completionCache.get(o);\\n  if (s && s.multiline === r.multiline) {\\n    exports.completionCache.put(o, {\\n      multiline: s.multiline,\\n      choices: s.choices.concat(r.choices),\\n    });\\n  } else {\\n    exports.completionCache.put(o, r);\\n  }\\n  exports.ghostTextLogger.debug(\\n    e,\\n    `Appended cached ghost text for key: ${o}, multiline: ${r.multiline}, number of suggestions: ${r.choices.length}`\\n  );\\n}\\nfunction L(e, n) {\\n  const r = exports.completionCache.get(e);\\n  if (r && (!n || r.multiline)) return r.choices;\\n}\\nfunction $(e, t, n) {\\n  if (n.length > 0) {\\n    if (t.startsWith(n))\\n      return {\\n        completionIndex: e,\\n        completionText: t,\\n        displayText: t.substr(n.length),\\n        displayNeedsWsOffset: !1,\\n      };\\n    {\\n      const r = t.substr(0, t.length - t.trimLeft().length);\\n      return n.startsWith(r)\\n        ? {\\n            completionIndex: e,\\n            completionText: t,\\n            displayText: t.trimLeft(),\\n            displayNeedsWsOffset: !0,\\n          }\\n        : {\\n            completionIndex: e,\\n            completionText: t,\\n            displayText: t,\\n            displayNeedsWsOffset: !1,\\n          };\\n    }\\n  }\\n  return {\\n    completionIndex: e,\\n    completionText: t,\\n    displayText: t,\\n    displayNeedsWsOffset: !1,\\n  };\\n}\\nfunction D(e, n) {\\n  const r = n.requestId,\\n    o = {\\n      choiceIndex: n.choiceIndex.toString(),\\n    },\\n    i = {\\n      numTokens: n.numTokens,\\n      compCharLen: n.completionText.length,\\n      numLines: n.completionText.split(\\"\\\\n\\").length,\\n    };\\n  if (n.meanLogProb) {\\n    i.meanLogProb = n.meanLogProb;\\n  }\\n  if (n.meanAlternativeLogProb) {\\n    i.meanAlternativeLogProb = n.meanAlternativeLogProb;\\n  }\\n  const s = n.telemetryData.extendedBy(o, i);\\n  s.extendWithRequestId(r);\\n  s.measurements.confidence = v.ghostTextScoreConfidence(e, s);\\n  s.measurements.quantile = v.ghostTextScoreQuantile(e, s);\\n  exports.ghostTextLogger.debug(\\n    e,\\n    `Extended telemetry for ${n.telemetryData.properties.headerRequestId} with retention confidence ${s.measurements.confidence} (expected as good or better than about ${s.measurements.quantile} of all suggestions)`\\n  );\\n  return s;\\n}\\nfunction F(e, t, n, r, o) {\\n  const i = Date.now() - r,\\n    s = i - o,\\n    a = n.telemetryData.extendedBy(\\n      {},\\n      {\\n        completionCharLen: n.completionText.length,\\n        requestTimeMs: i,\\n        processingTimeMs: o,\\n        deltaMs: s,\\n        meanLogProb: n.meanLogProb || NaN,\\n        meanAlternativeLogProb: n.meanAlternativeLogProb || NaN,\\n        numTokens: n.numTokens,\\n      }\\n    );\\n  a.extendWithRequestId(n.requestId);\\n  w.telemetry(e, `ghostText.${t}`, a);\\n}\\nexports.getGhostText = async function (e, n, s, u, d, f) {\\n  var v, j;\\n  const q = await _.extractPrompt(e, n, s);\\n  if (\\"contextTooShort\\" === q.type) {\\n    exports.ghostTextLogger.debug(e, \\"Breaking, not enough context\\");\\n    return {\\n      type: \\"abortedBeforeIssued\\",\\n      reason: \\"Not enough context\\",\\n    };\\n  }\\n  if (null == f ? undefined : f.isCancellationRequested) {\\n    exports.ghostTextLogger.info(e, \\"Cancelled after extractPrompt\\");\\n    return {\\n      type: \\"abortedBeforeIssued\\",\\n      reason: \\"Cancelled after extractPrompt\\",\\n    };\\n  }\\n  const B = (function (e, t) {\\n    const n =\\n        ((o = t), 0 != e.lineAt(o).text.substr(o.character).trim().length),\\n      r = (function (e, t) {\\n        const n = t.lineAt(e).text.substr(e.character).trim();\\n        return /^\\\\s*[)}\\\\]\\"\'`]*\\\\s*[:{;,]?\\\\s*$/.test(n);\\n      })(t, e);\\n    var o;\\n    if (!n || r) return n && r;\\n  })(n, s);\\n  if (undefined === B) {\\n    exports.ghostTextLogger.debug(e, \\"Breaking, invalid middle of the line\\");\\n    return {\\n      type: \\"abortedBeforeIssued\\",\\n      reason: \\"Invalid middle of the line\\",\\n    };\\n  }\\n  const U = e.get(m.StatusReporter),\\n    H = e.get(E.LocationFactory),\\n    z = await (async function (e, t, n, o, i, s) {\\n      const a = await e.get(c.BlockModeConfig).forLanguage(e, t.languageId);\\n      switch (a) {\\n        case c.BlockMode.Server:\\n          return {\\n            blockMode: c.BlockMode.Server,\\n            requestMultiline: !0,\\n            isCyclingRequest: i,\\n            finishedCb: async (e) => {},\\n          };\\n        case c.BlockMode.Parsing:\\n        case c.BlockMode.ParsingAndServer:\\n        default: {\\n          const c = await (async function (e, t, n, o) {\\n            if (t.lineCount >= 8e3)\\n              w.telemetry(\\n                e,\\n                \\"ghostText.longFileMultilineSkip\\",\\n                w.TelemetryData.createAndMarkAsIssued({\\n                  languageId: t.languageId,\\n                  lineCount: String(t.lineCount),\\n                  currentLine: String(n.line),\\n                })\\n              );\\n            else {\\n              if (!o && r.isSupportedLanguageId(t.languageId))\\n                return await g.isEmptyBlockStart(t, n);\\n              if (o && r.isSupportedLanguageId(t.languageId))\\n                return (\\n                  (await g.isEmptyBlockStart(t, n)) ||\\n                  (await g.isEmptyBlockStart(t, t.lineAt(n).range.end))\\n                );\\n            }\\n            return !1;\\n          })(e, t, n, s);\\n          return c\\n            ? {\\n                blockMode: a,\\n                requestMultiline: !0,\\n                isCyclingRequest: !1,\\n                finishedCb: async (r) => {\\n                  let i;\\n                  i =\\n                    o.trailingWs.length > 0 &&\\n                    !o.prompt.prefix.endsWith(o.trailingWs)\\n                      ? e\\n                          .get(E.LocationFactory)\\n                          .position(\\n                            n.line,\\n                            Math.max(n.character - o.trailingWs.length, 0)\\n                          )\\n                      : n;\\n                  return g.isBlockBodyFinished(e, t, i, r);\\n                },\\n              }\\n            : {\\n                blockMode: a,\\n                requestMultiline: !1,\\n                isCyclingRequest: i,\\n                finishedCb: async (e) => {},\\n              };\\n        }\\n      }\\n    })(e, n, s, q, u, B);\\n  if (null == f ? undefined : f.isCancellationRequested) {\\n    exports.ghostTextLogger.info(e, \\"Cancelled after requestMultiline\\");\\n    return {\\n      type: \\"abortedBeforeIssued\\",\\n      reason: \\"Cancelled after requestMultiline\\",\\n    };\\n  }\\n  const [G] = _.trimLastLine(n.getText(H.range(H.position(0, 0), s)));\\n  let V = (function (e, n, r, o) {\\n    const s = (function (e, n, r) {\\n      if (!I || !P || !n.startsWith(I)) return;\\n      const o = L(P, r);\\n      if (!o) return;\\n      const i = n.substring(I.length);\\n      exports.ghostTextLogger.debug(\\n        e,\\n        `Getting completions for user-typing flow - remaining prefix: ${i}`\\n      );\\n      const s = [];\\n      o.forEach((e) => {\\n        const t = O(e, {\\n          forceSingleLine: !1,\\n        });\\n        if (t.completionText.startsWith(i)) {\\n          t.completionText = t.completionText.substring(i.length);\\n          s.push(t);\\n        }\\n      });\\n      return s;\\n    })(e, n, o);\\n    if (s && s.length > 0) return [s, k.TypingAsSuggested];\\n    const a = (function (e, n, r, o) {\\n      const s = i.keyForPrompt(r);\\n      exports.ghostTextLogger.debug(\\n        e,\\n        `Trying to get completions from cache for key: ${s}`\\n      );\\n      const a = L(s, o);\\n      if (a) {\\n        exports.ghostTextLogger.debug(\\n          e,\\n          `Got completions from cache for key: ${s}`\\n        );\\n        const r = [];\\n        a.forEach((e) => {\\n          const t = O(e, {\\n            forceSingleLine: !o,\\n          });\\n          r.push(t);\\n        });\\n        const i = r.filter((e) => e.completionText);\\n        if (i.length > 0) {\\n          R(n, s);\\n        }\\n        return i;\\n      }\\n    })(e, n, r, o);\\n    return a && a.length > 0 ? [a, k.Cache] : undefined;\\n  })(e, G, q.prompt, z.requestMultiline);\\n  const W = o.v4(),\\n    K = y.extractRepoInfoInBackground(e, n.fileName),\\n    J = await p.getEngineURL(\\n      e,\\n      y.tryGetGitHubNWO(K),\\n      n.languageId,\\n      y.getDogFood(K),\\n      await y.getUserKind(e),\\n      d\\n    ),\\n    X = await e\\n      .get(l.Features)\\n      .beforeRequestWaitMs(y.tryGetGitHubNWO(K) || \\"\\", n.languageId),\\n    Q = await e\\n      .get(l.Features)\\n      .multiLogitBias(y.tryGetGitHubNWO(K) || \\"\\", n.languageId),\\n    Y = {\\n      blockMode: z.blockMode,\\n      languageId: n.languageId,\\n      repoInfo: K,\\n      engineURL: J,\\n      ourRequestId: W,\\n      prefix: G,\\n      prompt: q.prompt,\\n      multiline: z.requestMultiline,\\n      indentation: g.contextIndentation(n, s),\\n      isCycling: u,\\n      delayMs: X,\\n      multiLogitBias: Q,\\n    },\\n    Z = await e.get(l.Features).debouncePredict(),\\n    ee = await e.get(l.Features).contextualFilterEnable(),\\n    te = await e.get(l.Features).contextualFilterAcceptThreshold();\\n  let ne = !1;\\n  if (Z || ee) {\\n    ne = !0;\\n  }\\n  const re = (function (e, t, n, r, o, i, s) {\\n    const a = e.get(E.LocationFactory),\\n      c = t.lineAt(r.line),\\n      l = t.getText(a.range(c.range.start, r)),\\n      u = t.getText(a.range(r, c.range.end)),\\n      d = {\\n        languageId: t.languageId,\\n        beforeCursorWhitespace: JSON.stringify(\\"\\" === l.trim()),\\n        afterCursorWhitespace: JSON.stringify(\\"\\" === u.trim()),\\n      },\\n      p = {\\n        ...w.telemetrizePromptLength(o.prompt),\\n        promptEndPos: t.offsetAt(r),\\n        documentLength: t.getText().length,\\n        delayMs: n.delayMs,\\n      },\\n      f = i.extendedBy(d, p);\\n    f.properties.promptChoices = JSON.stringify(o.promptChoices, (e, t) =>\\n      t instanceof Map\\n        ? Array.from(t.entries()).reduce(\\n            (e, [t, n]) => ({\\n              ...e,\\n              [t]: n,\\n            }),\\n            {}\\n          )\\n        : t\\n    );\\n    f.properties.promptBackground = JSON.stringify(o.promptBackground, (e, t) =>\\n      t instanceof Map ? Array.from(t.values()) : t\\n    );\\n    f.measurements.promptComputeTimeMs = o.computeTimeMs;\\n    if (s) {\\n      f.measurements.contextualFilterScore = C.contextualFilterScore(\\n        e,\\n        f,\\n        o.prompt\\n      );\\n    }\\n    const m = n.repoInfo;\\n    f.properties.gitRepoInformation =\\n      undefined === m\\n        ? \\"unavailable\\"\\n        : m === y.ComputationStatus.PENDING\\n        ? \\"pending\\"\\n        : \\"available\\";\\n    if (undefined !== m && m !== y.ComputationStatus.PENDING) {\\n      f.properties.gitRepoUrl = m.url;\\n      f.properties.gitRepoHost = m.hostname;\\n      f.properties.gitRepoOwner = m.owner;\\n      f.properties.gitRepoName = m.repo;\\n      f.properties.gitRepoPath = m.pathname;\\n    }\\n    f.properties.engineName = h.extractEngineName(e, n.engineURL);\\n    f.properties.isMultiline = JSON.stringify(n.multiline);\\n    f.properties.blockMode = n.blockMode;\\n    f.properties.isCycling = JSON.stringify(n.isCycling);\\n    f.properties.headerRequestId = n.ourRequestId;\\n    w.telemetry(e, \\"ghostText.issued\\", f);\\n    return f;\\n  })(e, n, Y, s, q, d, ne);\\n  if (\\n    (z.isCyclingRequest &&\\n      (null !== (v = null == V ? undefined : V[0].length) && undefined !== v\\n        ? v\\n        : 0) > 1) ||\\n    (!z.isCyclingRequest && undefined !== V)\\n  )\\n    exports.ghostTextLogger.info(e, \\"Found inline suggestions locally\\");\\n  else {\\n    if (null == U) {\\n      U.setProgress();\\n    }\\n    if (z.isCyclingRequest) {\\n      const n = await (async function (e, n, r, o, i) {\\n        return A(e, n, r, o, i, \\"all completions\\", async (i, s, a, c) => {\\n          const l = [];\\n          for await (const n of c) {\\n            if (null == o ? void 0 : o.isCancellationRequested)\\n              return (\\n                exports.ghostTextLogger.debug(\\n                  e,\\n                  \\"Cancelled after awaiting choices iterator\\"\\n                ),\\n                {\\n                  type: \\"canceled\\",\\n                  reason: \\"after awaiting choices iterator\\",\\n                  telemetryData: (0, T.mkCanceledResultTelemetry)(r),\\n                }\\n              );\\n            if (n.completionText.trimEnd()) {\\n              if (\\n                -1 !==\\n                l.findIndex(\\n                  (e) => e.completionText.trim() === n.completionText.trim()\\n                )\\n              )\\n                continue;\\n              l.push(n);\\n            }\\n          }\\n          return (\\n            l.length > 0 &&\\n              (M(e, n, {\\n                multiline: n.multiline,\\n                choices: l,\\n              }),\\n              F(e, \\"cyclingPerformance\\", l[0], s, a)),\\n            {\\n              type: \\"success\\",\\n              value: l,\\n              telemetryData: (0, T.mkBasicResultTelemetry)(r),\\n              telemetryBlob: r,\\n            }\\n          );\\n        });\\n      })(e, Y, re, f, z.finishedCb);\\n      if (\\"success\\" === n.type) {\\n        const e =\\n          null !== (j = null == V ? void 0 : V[0]) && void 0 !== j ? j : [];\\n        n.value.forEach((t) => {\\n          -1 ===\\n            e.findIndex(\\n              (e) => e.completionText.trim() === t.completionText.trim()\\n            ) && e.push(t);\\n        }),\\n          (V = [e, k.Cycling]);\\n      } else if (void 0 === V) return null == U || U.removeProgress(), n;\\n    } else {\\n      const n = await (0, S.getDebounceLimit)(e, re);\\n      try {\\n        await N.debounce(n);\\n      } catch {\\n        return {\\n          type: \\"canceled\\",\\n          reason: \\"by debouncer\\",\\n          telemetryData: (0, T.mkCanceledResultTelemetry)(re),\\n        };\\n      }\\n      if (null == f ? void 0 : f.isCancellationRequested)\\n        return (\\n          exports.ghostTextLogger.info(e, \\"Cancelled during debounce\\"),\\n          {\\n            type: \\"canceled\\",\\n            reason: \\"during debounce\\",\\n            telemetryData: (0, T.mkCanceledResultTelemetry)(re),\\n          }\\n        );\\n      if (\\n        ee &&\\n        re.measurements.contextualFilterScore &&\\n        re.measurements.contextualFilterScore < te / 100\\n      )\\n        return (\\n          exports.ghostTextLogger.info(e, \\"Cancelled by contextual filter\\"),\\n          {\\n            type: \\"canceled\\",\\n            reason: \\"contextualFilterScore below threshold\\",\\n            telemetryData: (0, T.mkCanceledResultTelemetry)(re),\\n          }\\n        );\\n      const r = await (async function (e, n, r, o, s) {\\n        return A(e, n, r, o, s, \\"completions\\", async (s, a, c, l) => {\\n          const u = l[Symbol.asyncIterator](),\\n            d = await u.next();\\n          if (d.done)\\n            return (\\n              exports.ghostTextLogger.debug(e, \\"All choices redacted\\"),\\n              {\\n                type: \\"empty\\",\\n                reason: \\"all choices redacted\\",\\n                telemetryData: (0, T.mkBasicResultTelemetry)(r),\\n              }\\n            );\\n          if (null == o ? void 0 : o.isCancellationRequested)\\n            return (\\n              exports.ghostTextLogger.debug(\\n                e,\\n                \\"Cancelled after awaiting redactedChoices iterator\\"\\n              ),\\n              {\\n                type: \\"canceled\\",\\n                reason: \\"after awaiting redactedChoices iterator\\",\\n                telemetryData: (0, T.mkCanceledResultTelemetry)(r),\\n              }\\n            );\\n          const p = d.value;\\n          if (void 0 === p)\\n            return (\\n              exports.ghostTextLogger.debug(\\n                e,\\n                \\"Got undefined choice from redactedChoices iterator\\"\\n              ),\\n              {\\n                type: \\"empty\\",\\n                reason: \\"got undefined choice from redactedChoices iterator\\",\\n                telemetryData: (0, T.mkBasicResultTelemetry)(r),\\n              }\\n            );\\n          F(e, \\"performance\\", p, a, c);\\n          const h = s - 1;\\n          exports.ghostTextLogger.debug(\\n            e,\\n            `Awaited first result, id:  ${p.choiceIndex}`\\n          ),\\n            (function (e, n, r) {\\n              const o = (0, i.keyForPrompt)(n.prompt);\\n              R(n.prefix, o),\\n                exports.completionCache.put(o, r),\\n                exports.ghostTextLogger.debug(\\n                  e,\\n                  `Cached ghost text for key: ${o}, multiline: ${r.multiline}, number of suggestions: ${r.choices.length}`\\n                );\\n            })(e, n, {\\n              multiline: n.multiline,\\n              choices: [p],\\n            });\\n          const f = [];\\n          for (let e = 0; e < h; e++) f.push(u.next());\\n          const m = Promise.all(f).then((r) => {\\n            exports.ghostTextLogger.debug(\\n              e,\\n              `Awaited remaining results, number of results: ${r.length}`\\n            );\\n            const o = [];\\n            for (const n of r) {\\n              const r = n.value;\\n              if (\\n                void 0 !== r &&\\n                (exports.ghostTextLogger.info(\\n                  e,\\n                  `GhostText later completion: [${r.completionText}]`\\n                ),\\n                r.completionText.trimEnd())\\n              ) {\\n                if (\\n                  -1 !==\\n                  o.findIndex(\\n                    (e) => e.completionText.trim() === r.completionText.trim()\\n                  )\\n                )\\n                  continue;\\n                if (r.completionText.trim() === p.completionText.trim())\\n                  continue;\\n                o.push(r);\\n              }\\n            }\\n            o.length > 0 &&\\n              M(e, n, {\\n                multiline: n.multiline,\\n                choices: o,\\n              });\\n          });\\n          return (\\n            (0, x.isRunningInTest)(e) && (await m),\\n            {\\n              type: \\"success\\",\\n              value: O(d.value, {\\n                forceSingleLine: !1,\\n              }),\\n              telemetryData: (0, T.mkBasicResultTelemetry)(r),\\n              telemetryBlob: r,\\n            }\\n          );\\n        });\\n      })(e, Y, re, f, z.finishedCb);\\n      if (\\"success\\" !== r.type) return null == U || U.removeProgress(), r;\\n      V = [[r.value], k.Network];\\n    }\\n    if (null == U) {\\n      U.removeProgress();\\n    }\\n  }\\n  if (undefined === V)\\n    return {\\n      type: \\"failed\\",\\n      reason: \\"internal error: choices should be defined after network call\\",\\n      telemetryData: T.mkBasicResultTelemetry(re),\\n    };\\n  const [oe, ie] = V,\\n    se = a.asyncIterableMapFilter(a.asyncIterableFromArray(oe), async (r) =>\\n      b.postProcessChoice(e, \\"ghostText\\", n, s, r, B, exports.ghostTextLogger)\\n    ),\\n    ae = [];\\n  for await (const r of se) {\\n    const o = B && b.checkSuffix(n, s, r);\\n    if (null == f ? undefined : f.isCancellationRequested) {\\n      exports.ghostTextLogger.info(\\n        e,\\n        \\"Cancelled after post processing completions\\"\\n      );\\n      return {\\n        type: \\"canceled\\",\\n        reason: \\"after post processing completions\\",\\n        telemetryData: T.mkCanceledResultTelemetry(re),\\n      };\\n    }\\n    const i = D(e, r),\\n      a = {\\n        completion: $(r.choiceIndex, r.completionText, q.trailingWs),\\n        telemetry: i,\\n        isMiddleOfTheLine: B,\\n        coversSuffix: o,\\n      };\\n    ae.push(a);\\n  }\\n  return {\\n    type: \\"success\\",\\n    value: [ae, ie],\\n    telemetryData: T.mkBasicResultTelemetry(re),\\n    telemetryBlob: re,\\n  };\\n};","module-code-7254":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.CopilotStatusBar = undefined;\\nconst r = require(9496),\\n  o = require(\\"debouncer\\"),\\n  i = require(\\"config-stuff\\"),\\n  s = require(\\"telemetry-stuff\\"),\\n  a = require(\\"copilot-vscode-cmds\\");\\nexports.CopilotStatusBar = class {\\n  constructor(e) {\\n    this.ctx = e;\\n    this.showingMessage = !1;\\n    this.status = \\"Normal\\";\\n    this.errorMessage = \\"\\";\\n    this.disabledColor = new r.ThemeColor(\\"statusBarItem.warningBackground\\");\\n    this.delayedUpdateDisplay = o.debounce(100, () => {\\n      this.updateDisplay();\\n    });\\n    this.enabled = this.checkEnabledForLanguage();\\n    this.item = r.window.createStatusBarItem(r.StatusBarAlignment.Right, 0);\\n    this.updateDisplay();\\n    this.item.show();\\n    r.window.onDidChangeActiveTextEditor(() => {\\n      this.updateStatusBarIndicator();\\n    });\\n    r.workspace.onDidCloseTextDocument(() => {\\n      this.updateStatusBarIndicator();\\n    });\\n    r.workspace.onDidOpenTextDocument(() => {\\n      this.updateStatusBarIndicator();\\n    });\\n  }\\n  updateStatusBarIndicator() {\\n    this.enabled = this.checkEnabledForLanguage();\\n    this.updateDisplay();\\n  }\\n  checkEnabledForLanguage() {\\n    return i.getEnabledConfig(this.ctx) || !1;\\n  }\\n  updateDisplay() {\\n    switch (this.status) {\\n      case \\"Error\\":\\n        this.item.text = \\"$(copilot-notconnected)\\";\\n        this.item.command = a.CMDShowActivationErrors;\\n        this.item.tooltip = \\"Copilot activation failed\\";\\n        break;\\n      case \\"Warning\\":\\n        this.item.text = \\"$(copilot-warning)\\";\\n        this.item.command = undefined;\\n        this.item.tooltip = \\"Copilot is encountering temporary issues\\";\\n        break;\\n      case \\"InProgress\\":\\n        this.item.text = \\"$(loading~spin)\\";\\n        break;\\n      case \\"Normal\\":\\n        this.item.text = \\"$(copilot-logo)\\";\\n        this.item.command = a.CMDToggleCopilot;\\n        this.item.tooltip = this.enabled\\n          ? \\"Deactivate Copilot\\"\\n          : \\"Activate Copilot\\";\\n        this.item.backgroundColor = this.enabled\\n          ? undefined\\n          : this.disabledColor;\\n    }\\n  }\\n  getStatusBarItem() {\\n    return this.item;\\n  }\\n  setProgress() {\\n    if (\\"Error\\" !== this.status) {\\n      this.status = \\"InProgress\\";\\n      this.delayedUpdateDisplay();\\n    }\\n  }\\n  removeProgress() {\\n    if (\\"Error\\" !== this.status && \\"Warning\\" !== this.status) {\\n      this.status = \\"Normal\\";\\n      this.delayedUpdateDisplay();\\n    }\\n  }\\n  setWarning() {\\n    if (\\"Error\\" !== this.status) {\\n      this.status = \\"Warning\\";\\n      this.updateDisplay();\\n    }\\n  }\\n  setError(e, t) {\\n    this.status = \\"Error\\";\\n    this.errorMessage = e;\\n    this.errorRetry = t;\\n    this.updateDisplay();\\n  }\\n  forceNormal() {\\n    this.status = \\"Normal\\";\\n    this.errorMessage = \\"\\";\\n    this.errorRetry = undefined;\\n    this.updateDisplay();\\n  }\\n  toggleStatusBar() {\\n    var e;\\n    const t = this.ctx.get(i.ConfigProvider),\\n      n = this.enabled,\\n      o =\\n        null === (e = r.window.activeTextEditor) || undefined === e\\n          ? undefined\\n          : e.document.languageId,\\n      a = \\"editor.action.inlineSuggest.hide\\";\\n    if (this.showingMessage) return;\\n    const c = s.TelemetryData.createAndMarkAsIssued({\\n      languageId: o || \\"*\\",\\n    });\\n    if (i.getEnabledConfig(this.ctx, \\"*\\") == i.getEnabledConfig(this.ctx, o)) {\\n      this.showingMessage = !0;\\n      setTimeout(() => {\\n        this.showingMessage = !1;\\n      }, 15e3);\\n      const e = n ? \\"Disable\\" : \\"Enable\\",\\n        i = `${e} Globally`,\\n        l = `${e} for ${o}`,\\n        u = o ? [i, l] : [i];\\n      r.window\\n        .showInformationMessage(\\n          `Would you like to ${n ? \\"disable\\" : \\"enable\\"} Copilot?`,\\n          ...u\\n        )\\n        .then((e) => {\\n          const l = e === i;\\n          this.showingMessage = !1;\\n          if (void 0 === e)\\n            return void (0, s.telemetry)(this.ctx, \\"statusBar.cancelToggle\\");\\n          s.telemetry(\\n            this.ctx,\\n            \\"statusBar\\" + (l ? \\".global\\" : \\".language\\") + (n ? \\"Off\\" : \\"On\\"),\\n            c\\n          );\\n          if (n) {\\n            r.commands.executeCommand(a);\\n          }\\n          const u = l ? \\"*\\" : o;\\n          t.updateEnabledConfig(this.ctx, u, !n).then(() => {\\n            this.enabled = !n;\\n            this.updateDisplay();\\n          });\\n        });\\n    } else {\\n      s.telemetry(this.ctx, \\"statusBar.language\\" + (n ? \\"Off\\" : \\"On\\"), c);\\n      if (n) {\\n        r.commands.executeCommand(a);\\n      }\\n      t.updateEnabledConfig(this.ctx, o || \\"*\\", !n).then(() => {\\n        this.enabled = !n;\\n        this.updateDisplay();\\n      });\\n    }\\n    this.updateDisplay();\\n  }\\n  showActivationErrors(e) {\\n    if (this.showingMessage) return;\\n    this.showingMessage = !0;\\n    const t = [\\"Show output log\\"];\\n    if (this.errorRetry) {\\n      t.push(\\"Retry\\");\\n    }\\n    r.window.showWarningMessage(this.errorMessage, ...t).then((t) => {\\n      this.showingMessage = !1;\\n      if (\\"Show Output log\\" === t) {\\n        e.show();\\n      }\\n      if (\\"Retry\\" === t && this.errorRetry) {\\n        this.errorRetry();\\n      }\\n    });\\n  }\\n};","module-label-256":"completion-context","module-code-937":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getTemperatureForSamples =\\n  exports.calculateMeanAlternativeLogProb =\\n  exports.calculateMeanLogProb =\\n  exports.cleanupIndentChoices =\\n  exports.convertToAPIChoice =\\n  exports.DEFAULT_CHARACTER_MULTIPLIER =\\n  exports.MAX_PROMPT_LENGTH =\\n  exports.OpenAIFetcher =\\n  exports.LiveOpenAIFetcher =\\n  exports.getRequestId =\\n  exports.CopilotUiKind =\\n    undefined;\\nconst r = require(\\"config-stuff\\"),\\n  o = require(\\"logging-utils\\"),\\n  i = require(\\"telemetry-stuff\\"),\\n  s = require(70);\\nvar a = require(\\"live-openai-fetcher\\");\\nfunction calculateMeanLogProb(e, t) {\\n  var n;\\n  if (\\n    null === (n = null == t ? undefined : t.logprobs) || undefined === n\\n      ? undefined\\n      : n.token_logprobs\\n  )\\n    try {\\n      let e = 0,\\n        n = 0,\\n        r = 50;\\n      for (\\n        let o = 0;\\n        o < t.logprobs.token_logprobs.length - 1 && r > 0;\\n        o++, r--\\n      ) {\\n        e += t.logprobs.token_logprobs[o];\\n        n += 1;\\n      }\\n      return n > 0 ? e / n : undefined;\\n    } catch (t) {\\n      o.logger.error(e, `Error calculating mean prob: ${t}`);\\n    }\\n}\\nfunction calculateMeanAlternativeLogProb(e, t) {\\n  var n;\\n  if (\\n    null === (n = null == t ? undefined : t.logprobs) || undefined === n\\n      ? undefined\\n      : n.top_logprobs\\n  )\\n    try {\\n      let e = 0,\\n        n = 0,\\n        r = 50;\\n      for (\\n        let o = 0;\\n        o < t.logprobs.token_logprobs.length - 1 && r > 0;\\n        o++, r--\\n      ) {\\n        const r = {\\n          ...t.logprobs.top_logprobs[o],\\n        };\\n        delete r[t.logprobs.tokens[o]];\\n        e += Math.max(...Object.values(r));\\n        n += 1;\\n      }\\n      return n > 0 ? e / n : undefined;\\n    } catch (t) {\\n      o.logger.error(e, `Error calculating mean prob: ${t}`);\\n    }\\n}\\nexports.CopilotUiKind = a.CopilotUiKind;\\nexports.getRequestId = a.getRequestId;\\nexports.LiveOpenAIFetcher = a.LiveOpenAIFetcher;\\nexports.OpenAIFetcher = a.OpenAIFetcher;\\nexports.MAX_PROMPT_LENGTH = 1500;\\nexports.DEFAULT_CHARACTER_MULTIPLIER = 3;\\nexports.convertToAPIChoice = function (e, t, n, r, o, s, a, u) {\\n  i.logEngineCompletion(e, t, n, o, r);\\n  return {\\n    completionText: t,\\n    meanLogProb: calculateMeanLogProb(e, n),\\n    meanAlternativeLogProb: calculateMeanAlternativeLogProb(e, n),\\n    choiceIndex: r,\\n    requestId: o,\\n    modelInfo: u,\\n    blockFinished: s,\\n    tokens: n.tokens,\\n    numTokens: n.tokens.length,\\n    telemetryData: a,\\n  };\\n};\\nexports.cleanupIndentChoices = async function* (e, t) {\\n  for await (const n of e) {\\n    const e = {\\n        ...n,\\n      },\\n      r = e.completionText.split(\\"\\\\n\\");\\n    for (let e = 0; e < r.length; ++e) {\\n      const n = r[e].trimLeft();\\n      r[e] = \\"\\" === n ? n : t + n;\\n    }\\n    e.completionText = r.join(\\"\\\\n\\");\\n    yield e;\\n  }\\n};\\nexports.calculateMeanLogProb = calculateMeanLogProb;\\nexports.calculateMeanAlternativeLogProb = calculateMeanAlternativeLogProb;\\nexports.getTemperatureForSamples = function (e, t) {\\n  if (s.isRunningInTest(e)) return 0;\\n  const n = parseFloat(r.getConfig(e, r.ConfigKey.Temperature));\\n  return n >= 0 && n <= 1 ? n : t <= 1 ? 0 : t < 10 ? 0.2 : t < 20 ? 0.4 : 0.8;\\n};","module-code-9940":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.getNodeStart =\\n  exports.isBlockBodyFinished =\\n  exports.isEmptyBlockStart =\\n  exports.getBlockParser =\\n    undefined;\\nconst r = require(\\"get-prompt-parsing-utils\\");\\nclass o {\\n  constructor(e, t, n) {\\n    this.languageId = e;\\n    this.nodeMatch = t;\\n    this.nodeTypesWithBlockOrStmtChild = n;\\n  }\\n  async getNodeMatchAtPosition(e, t, n) {\\n    const o = await r.parseTree(this.languageId, e);\\n    try {\\n      let e = o.rootNode.descendantForIndex(t);\\n      for (; e; ) {\\n        const t = this.nodeMatch[e.type];\\n        if (t) {\\n          if (!this.nodeTypesWithBlockOrStmtChild.has(e.type)) break;\\n          const n = this.nodeTypesWithBlockOrStmtChild.get(e.type),\\n            r = \\"\\" == n ? e.namedChildren[0] : e.childForFieldName(n);\\n          if ((null == r ? undefined : r.type) == t) break;\\n        }\\n        e = e.parent;\\n      }\\n      if (!e) return;\\n      return n(e);\\n    } finally {\\n      o.delete();\\n    }\\n  }\\n  getNextBlockAtPosition(e, t, n) {\\n    return this.getNodeMatchAtPosition(e, t, (e) => {\\n      let t = e.children\\n        .reverse()\\n        .find((t) => t.type == this.nodeMatch[e.type]);\\n      if (t) {\\n        if (\\"python\\" == this.languageId && t.parent) {\\n          const e = \\":\\" == t.parent.type ? t.parent.parent : t.parent;\\n          let n = null == e ? undefined : e.nextSibling;\\n          for (; n && \\"comment\\" == n.type; ) {\\n            const r =\\n                n.startPosition.row == t.endPosition.row &&\\n                n.startPosition.column >= t.endPosition.column,\\n              o =\\n                n.startPosition.row > e.endPosition.row &&\\n                n.startPosition.column > e.startPosition.column;\\n            if (!r && !o) break;\\n            t = n;\\n            n = n.nextSibling;\\n          }\\n        }\\n        if (\\n          !(\\n            t.endIndex >= t.tree.rootNode.endIndex - 1 &&\\n            (t.hasError() || t.parent.hasError())\\n          )\\n        )\\n          return n(t);\\n      }\\n    });\\n  }\\n  async isBlockBodyFinished(e, t, n) {\\n    const r = (e + t).trimEnd(),\\n      o = await this.getNextBlockAtPosition(r, n, (e) => e.endIndex);\\n    if (undefined !== o && o < r.length) {\\n      const t = o - e.length;\\n      return t > 0 ? t : undefined;\\n    }\\n  }\\n  getNodeStart(e, t) {\\n    const n = e.trimEnd();\\n    return this.getNodeMatchAtPosition(n, t, (e) => e.startIndex);\\n  }\\n}\\nclass i extends o {\\n  constructor(e, t, n, r, o) {\\n    super(e, r, o);\\n    this.blockEmptyMatch = t;\\n    this.lineMatch = n;\\n  }\\n  isBlockStart(e) {\\n    return this.lineMatch.test(e.trimStart());\\n  }\\n  async isBlockBodyEmpty(e, t) {\\n    const n = await this.getNextBlockAtPosition(e, t, (n) => {\\n      if (n.startIndex < t) {\\n        t = n.startIndex;\\n      }\\n      let r = e.substring(t, n.endIndex).trim();\\n      return \\"\\" == r || r.replace(/\\\\s/g, \\"\\") == this.blockEmptyMatch;\\n    });\\n    return undefined === n || n;\\n  }\\n  async isEmptyBlockStart(e, t) {\\n    t = s(e, t);\\n    return (\\n      this.isBlockStart(\\n        (function (e, t) {\\n          const n = e.lastIndexOf(\\"\\\\n\\", t - 1);\\n          let r = e.indexOf(\\"\\\\n\\", t);\\n          if (r < 0) {\\n            r = e.length;\\n          }\\n          return e.slice(n + 1, r);\\n        })(e, t)\\n      ) && this.isBlockBodyEmpty(e, t)\\n    );\\n  }\\n}\\nfunction s(e, t) {\\n  let n = t;\\n  for (; n > 0 && /\\\\s/.test(e.charAt(n - 1)); ) n--;\\n  return n;\\n}\\nfunction a(e, t) {\\n  const n = e.startIndex,\\n    r = e.startIndex - e.startPosition.column,\\n    o = t.substring(r, n);\\n  if (/^\\\\s*$/.test(o)) return o;\\n}\\nfunction c(e, t, n) {\\n  if (t.startPosition.row <= e.startPosition.row) return !1;\\n  const r = a(e, n),\\n    o = a(t, n);\\n  return undefined !== r && undefined !== o && r.startsWith(o);\\n}\\nclass l extends o {\\n  constructor(e, t, n, r, o, i, s) {\\n    super(e, t, n);\\n    this.startKeywords = r;\\n    this.blockNodeType = o;\\n    this.emptyStatementType = i;\\n    this.curlyBraceLanguage = s;\\n  }\\n  isBlockEmpty(e, t) {\\n    var n, o;\\n    let i = e.text.trim();\\n    if (this.curlyBraceLanguage) {\\n      if (i.startsWith(\\"{\\")) {\\n        i = i.slice(1);\\n      }\\n      if (i.endsWith(\\"}\\")) {\\n        i = i.slice(0, -1);\\n      }\\n      i = i.trim();\\n    }\\n    return (\\n      0 == i.length ||\\n      !(\\n        \\"python\\" != this.languageId ||\\n        (\\"class_definition\\" !=\\n          (null === (n = e.parent) || undefined === n ? undefined : n.type) &&\\n          \\"function_definition\\" !=\\n            (null === (o = e.parent) || undefined === o\\n              ? undefined\\n              : o.type)) ||\\n        1 != e.children.length ||\\n        !r.queryPythonIsDocstring(e.parent)\\n      )\\n    );\\n  }\\n  async isEmptyBlockStart(e, t) {\\n    var n, o, i;\\n    if (t > e.length) throw new RangeError(\\"Invalid offset\\");\\n    for (let n = t; n < e.length && \\"\\\\n\\" != e.charAt(n); n++)\\n      if (/\\\\S/.test(e.charAt(n))) return !1;\\n    t = s(e, t);\\n    const a = await r.parseTree(this.languageId, e);\\n    try {\\n      const r = a.rootNode.descendantForIndex(t - 1);\\n      if (null == r) return !1;\\n      if (this.curlyBraceLanguage && \\"}\\" == r.type) return !1;\\n      if (\\n        (\\"javascript\\" == this.languageId || \\"typescript\\" == this.languageId) &&\\n        r.parent &&\\n        \\"object\\" == r.parent.type &&\\n        \\"{\\" == r.parent.text.trim()\\n      )\\n        return !0;\\n      if (\\"typescript\\" == this.languageId) {\\n        let n = r;\\n        for (; n.parent; ) {\\n          if (\\"function_signature\\" == n.type || \\"method_signature\\" == n.type) {\\n            const o = r.nextSibling;\\n            return (\\n              !!(o && n.hasError() && c(n, o, e)) ||\\n              (!n.children.find((e) => \\";\\" == e.type) && n.endIndex <= t)\\n            );\\n          }\\n          n = n.parent;\\n        }\\n      }\\n      let s = null,\\n        l = null,\\n        u = null,\\n        d = r;\\n      for (; null != d; ) {\\n        if (d.type == this.blockNodeType) {\\n          l = d;\\n          break;\\n        }\\n        if (this.nodeMatch[d.type]) {\\n          u = d;\\n          break;\\n        }\\n        if (\\"ERROR\\" == d.type) {\\n          s = d;\\n          break;\\n        }\\n        d = d.parent;\\n      }\\n      if (null != l) {\\n        if (!l.parent || !this.nodeMatch[l.parent.type]) return !1;\\n        if (\\"python\\" == this.languageId) {\\n          const e = l.previousSibling;\\n          if (\\n            null != e &&\\n            e.hasError() &&\\n            (e.text.startsWith(\'\\"\\"\\"\') || e.text.startsWith(\\"\'\'\'\\"))\\n          )\\n            return !0;\\n        }\\n        return this.isBlockEmpty(l, t);\\n      }\\n      if (null != s) {\\n        if (\\n          \\"module\\" ==\\n            (null === (n = s.previousSibling) || undefined === n\\n              ? undefined\\n              : n.type) ||\\n          \\"internal_module\\" ==\\n            (null === (o = s.previousSibling) || undefined === o\\n              ? undefined\\n              : o.type)\\n        )\\n          return !0;\\n        const e = [...s.children].reverse(),\\n          a = e.find((e) => this.startKeywords.includes(e.type));\\n        let c = e.find((e) => e.type == this.blockNodeType);\\n        if (a) {\\n          switch (this.languageId) {\\n            case \\"python\\": {\\n              if (\\n                \\"try\\" == a.type &&\\n                \\"identifier\\" == r.type &&\\n                r.text.length > 4\\n              ) {\\n                c =\\n                  null === (i = e.find((e) => e.hasError())) || undefined === i\\n                    ? undefined\\n                    : i.children.find((e) => \\"block\\" == e.type);\\n              }\\n              const t = e.find((e) => \\":\\" == e.type);\\n              if (t && a.endIndex <= t.startIndex && t.nextSibling) {\\n                if (\\"def\\" == a.type) {\\n                  const e = t.nextSibling;\\n                  if (\'\\"\' == e.type || \\"\'\\" == e.type) return !0;\\n                  if (\\"ERROR\\" == e.type && (\'\\"\\"\\"\' == e.text || \\"\'\'\'\\" == e.text))\\n                    return !0;\\n                }\\n                return !1;\\n              }\\n              break;\\n            }\\n            case \\"javascript\\": {\\n              const t = e.find((e) => \\"formal_parameters\\" == e.type);\\n              if (\\"class\\" == a.type && t) return !0;\\n              const n = e.find((e) => \\"{\\" == e.type);\\n              if (n && n.startIndex > a.endIndex && null != n.nextSibling)\\n                return !1;\\n              if (e.find((e) => \\"do\\" == e.type) && \\"while\\" == a.type) return !1;\\n              if (\\"=>\\" == a.type && a.nextSibling && \\"{\\" != a.nextSibling.type)\\n                return !1;\\n              break;\\n            }\\n            case \\"typescript\\": {\\n              const t = e.find((e) => \\"{\\" == e.type);\\n              if (t && t.startIndex > a.endIndex && null != t.nextSibling)\\n                return !1;\\n              if (e.find((e) => \\"do\\" == e.type) && \\"while\\" == a.type) return !1;\\n              if (\\"=>\\" == a.type && a.nextSibling && \\"{\\" != a.nextSibling.type)\\n                return !1;\\n              break;\\n            }\\n          }\\n          return !(c && c.startIndex > a.endIndex) || this.isBlockEmpty(c, t);\\n        }\\n      }\\n      if (null != u) {\\n        const e = this.nodeMatch[u.type],\\n          n = u.children\\n            .slice()\\n            .reverse()\\n            .find((t) => t.type == e);\\n        if (n) return this.isBlockEmpty(n, t);\\n        if (this.nodeTypesWithBlockOrStmtChild.has(u.type)) {\\n          const e = this.nodeTypesWithBlockOrStmtChild.get(u.type),\\n            t = \\"\\" == e ? u.children[0] : u.childForFieldName(e);\\n          if (\\n            t &&\\n            t.type != this.blockNodeType &&\\n            t.type != this.emptyStatementType\\n          )\\n            return !1;\\n        }\\n        return !0;\\n      }\\n      return !1;\\n    } finally {\\n      a.delete();\\n    }\\n  }\\n}\\nconst u = {\\n  python: new l(\\n    \\"python\\",\\n    {\\n      class_definition: \\"block\\",\\n      elif_clause: \\"block\\",\\n      else_clause: \\"block\\",\\n      except_clause: \\"block\\",\\n      finally_clause: \\"block\\",\\n      for_statement: \\"block\\",\\n      function_definition: \\"block\\",\\n      if_statement: \\"block\\",\\n      try_statement: \\"block\\",\\n      while_statement: \\"block\\",\\n      with_statement: \\"block\\",\\n    },\\n    new Map(),\\n    [\\n      \\"def\\",\\n      \\"class\\",\\n      \\"if\\",\\n      \\"elif\\",\\n      \\"else\\",\\n      \\"for\\",\\n      \\"while\\",\\n      \\"try\\",\\n      \\"except\\",\\n      \\"finally\\",\\n      \\"with\\",\\n    ],\\n    \\"block\\",\\n    null,\\n    !1\\n  ),\\n  javascript: new l(\\n    \\"javascript\\",\\n    {\\n      arrow_function: \\"statement_block\\",\\n      catch_clause: \\"statement_block\\",\\n      do_statement: \\"statement_block\\",\\n      else_clause: \\"statement_block\\",\\n      finally_clause: \\"statement_block\\",\\n      for_in_statement: \\"statement_block\\",\\n      for_statement: \\"statement_block\\",\\n      function: \\"statement_block\\",\\n      function_declaration: \\"statement_block\\",\\n      generator_function: \\"statement_block\\",\\n      generator_function_declaration: \\"statement_block\\",\\n      if_statement: \\"statement_block\\",\\n      method_definition: \\"statement_block\\",\\n      try_statement: \\"statement_block\\",\\n      while_statement: \\"statement_block\\",\\n      with_statement: \\"statement_block\\",\\n      class: \\"class_body\\",\\n      class_declaration: \\"class_body\\",\\n    },\\n    new Map([\\n      [\\"arrow_function\\", \\"body\\"],\\n      [\\"do_statement\\", \\"body\\"],\\n      [\\"else_clause\\", \\"\\"],\\n      [\\"for_in_statement\\", \\"body\\"],\\n      [\\"for_statement\\", \\"body\\"],\\n      [\\"if_statement\\", \\"consequence\\"],\\n      [\\"while_statement\\", \\"body\\"],\\n      [\\"with_statement\\", \\"body\\"],\\n    ]),\\n    [\\n      \\"=>\\",\\n      \\"try\\",\\n      \\"catch\\",\\n      \\"finally\\",\\n      \\"do\\",\\n      \\"for\\",\\n      \\"if\\",\\n      \\"else\\",\\n      \\"while\\",\\n      \\"with\\",\\n      \\"function\\",\\n      \\"function*\\",\\n      \\"class\\",\\n    ],\\n    \\"statement_block\\",\\n    \\"empty_statement\\",\\n    !0\\n  ),\\n  typescript: new l(\\n    \\"typescript\\",\\n    {\\n      ambient_declaration: \\"statement_block\\",\\n      arrow_function: \\"statement_block\\",\\n      catch_clause: \\"statement_block\\",\\n      do_statement: \\"statement_block\\",\\n      else_clause: \\"statement_block\\",\\n      finally_clause: \\"statement_block\\",\\n      for_in_statement: \\"statement_block\\",\\n      for_statement: \\"statement_block\\",\\n      function: \\"statement_block\\",\\n      function_declaration: \\"statement_block\\",\\n      generator_function: \\"statement_block\\",\\n      generator_function_declaration: \\"statement_block\\",\\n      if_statement: \\"statement_block\\",\\n      internal_module: \\"statement_block\\",\\n      method_definition: \\"statement_block\\",\\n      module: \\"statement_block\\",\\n      try_statement: \\"statement_block\\",\\n      while_statement: \\"statement_block\\",\\n      abstract_class_declaration: \\"class_body\\",\\n      class: \\"class_body\\",\\n      class_declaration: \\"class_body\\",\\n    },\\n    new Map([\\n      [\\"arrow_function\\", \\"body\\"],\\n      [\\"do_statement\\", \\"body\\"],\\n      [\\"else_clause\\", \\"\\"],\\n      [\\"for_in_statement\\", \\"body\\"],\\n      [\\"for_statement\\", \\"body\\"],\\n      [\\"if_statement\\", \\"consequence\\"],\\n      [\\"while_statement\\", \\"body\\"],\\n      [\\"with_statement\\", \\"body\\"],\\n    ]),\\n    [\\n      \\"declare\\",\\n      \\"=>\\",\\n      \\"try\\",\\n      \\"catch\\",\\n      \\"finally\\",\\n      \\"do\\",\\n      \\"for\\",\\n      \\"if\\",\\n      \\"else\\",\\n      \\"while\\",\\n      \\"with\\",\\n      \\"function\\",\\n      \\"function*\\",\\n      \\"class\\",\\n    ],\\n    \\"statement_block\\",\\n    \\"empty_statement\\",\\n    !0\\n  ),\\n  go: new i(\\n    \\"go\\",\\n    \\"{}\\",\\n    /\\\\b(func|if|else|for)\\\\b/,\\n    {\\n      communication_case: \\"block\\",\\n      default_case: \\"block\\",\\n      expression_case: \\"block\\",\\n      for_statement: \\"block\\",\\n      func_literal: \\"block\\",\\n      function_declaration: \\"block\\",\\n      if_statement: \\"block\\",\\n      labeled_statement: \\"block\\",\\n      method_declaration: \\"block\\",\\n      type_case: \\"block\\",\\n    },\\n    new Map()\\n  ),\\n  ruby: new i(\\n    \\"ruby\\",\\n    \\"end\\",\\n    /\\\\b(BEGIN|END|case|class|def|do|else|elsif|for|if|module|unless|until|while)\\\\b|->/,\\n    {\\n      begin_block: \\"}\\",\\n      block: \\"}\\",\\n      end_block: \\"}\\",\\n      lambda: \\"block\\",\\n      for: \\"do\\",\\n      until: \\"do\\",\\n      while: \\"do\\",\\n      case: \\"end\\",\\n      do: \\"end\\",\\n      if: \\"end\\",\\n      method: \\"end\\",\\n      module: \\"end\\",\\n      unless: \\"end\\",\\n      do_block: \\"end\\",\\n    },\\n    new Map()\\n  ),\\n};\\nfunction getBlockParser(e) {\\n  return u[r.languageIdToWasmLanguage(e)];\\n}\\nexports.getBlockParser = getBlockParser;\\nexports.isEmptyBlockStart = async function (e, t, n) {\\n  return (\\n    !!r.isSupportedLanguageId(e) && getBlockParser(e).isEmptyBlockStart(t, n)\\n  );\\n};\\nexports.isBlockBodyFinished = async function (e, t, n, o) {\\n  if (r.isSupportedLanguageId(e))\\n    return getBlockParser(e).isBlockBodyFinished(t, n, o);\\n};\\nexports.getNodeStart = async function (e, t, n) {\\n  if (r.isSupportedLanguageId(e)) return getBlockParser(e).getNodeStart(t, n);\\n};","module-label-3055670":"sibling-function-fetcher","module-code-4419":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.LiveOpenAIFetcher =\\n  exports.postProcessChoices =\\n  exports.OpenAIFetcher =\\n  exports.extractEngineName =\\n  exports.getProcessingTime =\\n  exports.getRequestId =\\n  exports.CopilotUiKind =\\n    undefined;\\nconst r = require(\\"util\\"),\\n  o = require(\\"copilot-github-auth-stuff\\"),\\n  i = require(6932),\\n  s = require(\\"config-stuff\\"),\\n  a = require(9189),\\n  c = require(5413),\\n  l = require(\\"logging-utils\\"),\\n  u = require(\\"helix-fetcher-and-network-stuff\\"),\\n  d = require(6722),\\n  p = require(\\"background-context-provider\\"),\\n  h = require(9657),\\n  f = require(\\"telemetry-stuff\\"),\\n  m = require(\\"openai-choices-utils\\"),\\n  g = require(2901),\\n  _ = new l.Logger(l.LogLevel.INFO, \\"fetch\\");\\nvar y;\\nfunction getRequestId(e, t) {\\n  return {\\n    headerRequestId: e.headers.get(\\"x-request-id\\") || \\"\\",\\n    completionId: t && t.id ? t.id : \\"\\",\\n    created: t && t.created ? t.created : 0,\\n    serverExperiments: e.headers.get(\\"X-Copilot-Experiment\\") || \\"\\",\\n    deploymentId: e.headers.get(\\"azureml-model-deployment\\") || \\"\\",\\n  };\\n}\\nfunction getProcessingTime(e) {\\n  const t = e.headers.get(\\"openai-processing-ms\\");\\n  return t ? parseInt(t, 10) : 0;\\n}\\nfunction extractEngineName(e, t) {\\n  return t.split(\\"/\\").pop() || (_.error(e, \\"Malformed engine URL: \\" + t), t);\\n}\\n!(function (e) {\\n  e.GhostText = \\"ghostText\\";\\n  e.Panel = \\"synthesize\\";\\n})((y = exports.CopilotUiKind || (exports.CopilotUiKind = {})));\\nexports.getRequestId = getRequestId;\\nexports.getProcessingTime = getProcessingTime;\\nexports.extractEngineName = extractEngineName;\\nclass OpenAIFetcher {}\\nfunction postProcessChoices(e, t) {\\n  return null != t && t\\n    ? e\\n    : i.asyncIterableFilter(e, async (e) => e.completionText.trim().length > 0);\\n}\\nexports.OpenAIFetcher = OpenAIFetcher;\\nexports.postProcessChoices = postProcessChoices;\\nexports.LiveOpenAIFetcher = class extends OpenAIFetcher {\\n  async fetchAndStreamCompletions(e, t, n, r, o) {\\n    const s = e.get(d.StatusReporter),\\n      a = \\"completions\\",\\n      c = await this.fetchWithParameters(e, a, t, o);\\n    if (\\"not-sent\\" === c)\\n      return {\\n        type: \\"canceled\\",\\n        reason: \\"before fetch request\\",\\n      };\\n    if (null == o ? undefined : o.isCancellationRequested) {\\n      const t = await c.body();\\n      try {\\n        t.destroy();\\n      } catch (t) {\\n        l.logger.error(e, `Error destroying stream: ${t}`);\\n      }\\n      return {\\n        type: \\"canceled\\",\\n        reason: \\"after fetch request\\",\\n      };\\n    }\\n    if (undefined === c) {\\n      const n = this.createTelemetryData(a, e, t);\\n      s.setWarning();\\n      n.properties.error = \\"Response was undefined\\";\\n      f.telemetry(e, \\"request.shownWarning\\", n);\\n      return {\\n        type: \\"failed\\",\\n        reason: \\"fetch response was undefined\\",\\n      };\\n    }\\n    if (200 !== c.status) {\\n      const n = this.createTelemetryData(a, e, t);\\n      return this.handleError(e, s, n, c);\\n    }\\n    return {\\n      type: \\"success\\",\\n      choices: postProcessChoices(\\n        i.asyncIterableMap(g.processSSE(e, c, r, n, o), async (t) =>\\n          g.prepareSolutionForReturn(e, t, n)\\n        ),\\n        t.allowEmptyChoices\\n      ),\\n      getProcessingTime: () => getProcessingTime(c),\\n    };\\n  }\\n  createTelemetryData(e, t, n) {\\n    return f.TelemetryData.createAndMarkAsIssued({\\n      endpoint: e,\\n      engineName: extractEngineName(t, n.engineUrl),\\n      uiKind: n.uiKind,\\n      headerRequestId: n.ourRequestId,\\n    });\\n  }\\n  async fetchWithParameters(e, t, n, i) {\\n    var g;\\n    const _ = s.getLanguageConfig(e, s.ConfigKey.Stops),\\n      b = await e.get(a.Features).disableLogProb(),\\n      x = {\\n        prompt: n.prompt.prefix,\\n        suffix: n.prompt.suffix,\\n        max_tokens: s.getConfig(e, s.ConfigKey.SolutionLength),\\n        temperature: m.getTemperatureForSamples(e, n.count),\\n        top_p: s.getConfig(e, s.ConfigKey.TopP),\\n        n: n.count,\\n        stop: _,\\n      };\\n    if (!n.requestLogProbs && b) {\\n      x.logprobs = 2;\\n    }\\n    const E = p.tryGetGitHubNWO(n.repoInfo);\\n    if (undefined !== E) {\\n      x.nwo = E;\\n    }\\n    if (\\n      [h.RepetitionFilterMode.PROXY, h.RepetitionFilterMode.BOTH].includes(\\n        await e.get(a.Features).repetitionFilterMode()\\n      )\\n    ) {\\n      x.feature_flags = [\\n        ...(null !== (g = x.feature_flags) && undefined !== g ? g : []),\\n        \\"filter-repetitions\\",\\n      ];\\n    }\\n    if (n.postOptions) {\\n      Object.assign(x, n.postOptions);\\n    }\\n    return (null == i ? undefined : i.isCancellationRequested)\\n      ? \\"not-sent\\"\\n      : (l.logger.info(e, `[fetchCompletions] engine ${n.engineUrl}`),\\n        await (function (e, t, n, o, i, s, a, p, h) {\\n          var m;\\n          const g = e.get(d.StatusReporter),\\n            _ = r.format(\\"%s/%s\\", n, o);\\n          if (!a)\\n            return void l.logger.error(\\n              e,\\n              `Failed to send request to ${_} due to missing key`\\n            );\\n          const b = f.TelemetryData.createAndMarkAsIssued(\\n            {\\n              endpoint: o,\\n              engineName: extractEngineName(e, n),\\n              uiKind: p,\\n            },\\n            f.telemetrizePromptLength(t)\\n          );\\n          for (const [e, t] of Object.entries(s))\\n            if (\\"prompt\\" != e && \\"suffix\\" != e) {\\n              b.properties[`request.option.${e}`] =\\n                null !== (m = JSON.stringify(t)) && undefined !== m\\n                  ? m\\n                  : \\"undefined\\";\\n            }\\n          b.properties.headerRequestId = i;\\n          f.telemetry(e, \\"request.sent\\", b);\\n          const x = f.now(),\\n            E = (function (e) {\\n              switch (e) {\\n                case y.GhostText:\\n                  return \\"copilot-ghost\\";\\n                case y.Panel:\\n                  return \\"copilot-panel\\";\\n              }\\n            })(p);\\n          return u\\n            .postRequest(e, _, a, E, i, s, h)\\n            .then((n) => {\\n              const r = getRequestId(n, undefined);\\n              b.extendWithRequestId(r);\\n              const o = f.now() - x;\\n              b.measurements.totalTimeMs = o;\\n              l.logger.info(e, `request.response: [${_}] took ${o} ms`);\\n              l.logger.debug(e, \\"request.response properties\\", b.properties);\\n              l.logger.debug(\\n                e,\\n                \\"request.response measurements\\",\\n                b.measurements\\n              );\\n              l.logger.debug(e, `prompt: ${JSON.stringify(t)}`);\\n              f.telemetry(e, \\"request.response\\", b);\\n              const i = n.headers.get(\\"x-copilot-delay\\"),\\n                s = i ? parseInt(i, 10) : 0;\\n              e.get(c.GhostTextDebounceManager).extraDebounceMs = s;\\n              return n;\\n            })\\n            .catch((t) => {\\n              var n, r, o, i;\\n              if (u.isAbortError(t)) throw t;\\n              g.setWarning();\\n              const s = b.extendedBy({\\n                error: \\"Network exception\\",\\n              });\\n              f.telemetry(e, \\"request.shownWarning\\", s);\\n              b.properties.code = String(\\n                null !== (n = t.code) && undefined !== n ? n : \\"\\"\\n              );\\n              b.properties.errno = String(\\n                null !== (r = t.errno) && undefined !== r ? r : \\"\\"\\n              );\\n              b.properties.message = String(\\n                null !== (o = t.message) && undefined !== o ? o : \\"\\"\\n              );\\n              b.properties.type = String(\\n                null !== (i = t.type) && undefined !== i ? i : \\"\\"\\n              );\\n              const a = f.now() - x;\\n              throw (\\n                ((b.measurements.totalTimeMs = a),\\n                l.logger.debug(e, `request.response: [${_}] took ${a} ms`),\\n                l.logger.debug(e, \\"request.error properties\\", b.properties),\\n                l.logger.debug(e, \\"request.error measurements\\", b.measurements),\\n                l.logger.error(e, `Request Error: ${t.message}`),\\n                f.telemetry(e, \\"request.error\\", b),\\n                t)\\n              );\\n            })\\n            .finally(() => {\\n              f.logEnginePrompt(e, t, b);\\n            });\\n        })(\\n          e,\\n          n.prompt,\\n          n.engineUrl,\\n          t,\\n          n.ourRequestId,\\n          x,\\n          (\\n            await e.get(o.CopilotTokenManager).getCopilotToken(e)\\n          ).token,\\n          n.uiKind,\\n          i\\n        ));\\n  }\\n  async handleError(e, t, n, r) {\\n    t.setWarning();\\n    n.properties.error = `Response status was ${r.status}`;\\n    n.properties.status = String(r.status);\\n    f.telemetry(e, \\"request.shownWarning\\", n);\\n    if (401 === r.status || 403 === r.status)\\n      return (\\n        e.get(o.CopilotTokenManager).resetCopilotToken(e, r.status),\\n        {\\n          type: \\"failed\\",\\n          reason: `token expired or invalid: ${r.status}`,\\n        }\\n      );\\n    if (499 === r.status) {\\n      _.info(e, \\"Cancelled by server\\");\\n      return {\\n        type: \\"failed\\",\\n        reason: \\"canceled by server\\",\\n      };\\n    }\\n    const i = await r.text();\\n    return 466 === r.status\\n      ? (t.setError(i),\\n        _.info(e, i),\\n        {\\n          type: \\"failed\\",\\n          reason: `client not supported: ${i}`,\\n        })\\n      : (_.error(e, \\"Unhandled status from server:\\", r.status, i),\\n        {\\n          type: \\"failed\\",\\n          reason: `unhandled status from server: ${r.status} ${i}`,\\n        });\\n  }\\n};","module-code-750":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.handleGhostTextResultTelemetry =\\n  exports.mkBasicResultTelemetry =\\n  exports.mkCanceledResultTelemetry =\\n  exports.telemetryRejected =\\n  exports.telemetryAccepted =\\n  exports.telemetryShown =\\n    undefined;\\nconst r = require(\\"telemetry-stuff\\"),\\n  o = require(\\"contextual-filter-manager\\");\\nexports.telemetryShown = function (e, t, n, o) {\\n  n.markAsDisplayed();\\n  const i = o ? `${t}.shownFromCache` : `${t}.shown`;\\n  r.telemetry(e, i, n);\\n};\\nexports.telemetryAccepted = function (e, t, n) {\\n  const i = t + \\".accepted\\",\\n    s = e.get(o.ContextualFilterManager);\\n  s.previousLabel = 1;\\n  s.previousLabelTimestamp = Date.now();\\n  r.telemetry(e, i, n);\\n};\\nexports.telemetryRejected = function (e, t, n) {\\n  const i = t + \\".rejected\\",\\n    s = e.get(o.ContextualFilterManager);\\n  s.previousLabel = 0;\\n  s.previousLabelTimestamp = Date.now();\\n  r.telemetry(e, i, n);\\n};\\nexports.mkCanceledResultTelemetry = function (e, t = {}) {\\n  return {\\n    ...t,\\n    telemetryBlob: e,\\n  };\\n};\\nexports.mkBasicResultTelemetry = function (e) {\\n  return {\\n    headerRequestId: e.properties.headerRequestId,\\n    copilot_trackingId: e.properties.copilot_trackingId,\\n  };\\n};\\nexports.handleGhostTextResultTelemetry = async function (e, t) {\\n  if (\\"success\\" === t.type) {\\n    r.telemetryRaw(e, \\"ghostText.produced\\", t.telemetryData, {});\\n    return t.value;\\n  }\\n  if (\\"abortedBeforeIssued\\" !== t.type) {\\n    if (\\"canceled\\" !== t.type) {\\n      r.telemetryRaw(\\n        e,\\n        `ghostText.${t.type}`,\\n        {\\n          ...t.telemetryData,\\n          reason: t.reason,\\n        },\\n        {}\\n      );\\n    } else {\\n      r.telemetry(\\n        e,\\n        \\"ghostText.canceled\\",\\n        t.telemetryData.telemetryBlob.extendedBy({\\n          reason: t.reason,\\n          cancelledNetworkRequest: t.telemetryData.cancelledNetworkRequest\\n            ? \\"true\\"\\n            : \\"false\\",\\n        })\\n      );\\n    }\\n  }\\n};","module-label-7057":"url-opener","module-code-256":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.decodeLocation =\\n  exports.encodeLocation =\\n  exports.completionContextForDocument =\\n  exports.CompletionContext =\\n  exports.completionTypeToString =\\n  exports.CompletionType =\\n    undefined;\\nconst r = require(7373),\\n  o = require(\\"location-factory\\"),\\n  i = require(\\"copilot-scheme\\");\\nvar s;\\n!(function (e) {\\n  e[(e.OPEN_COPILOT = 2)] = \\"OPEN_COPILOT\\";\\n  e[(e.TODO_QUICK_FIX = 3)] = \\"TODO_QUICK_FIX\\";\\n  e[(e.UNKNOWN_FUNCTION_QUICK_FIX = 4)] = \\"UNKNOWN_FUNCTION_QUICK_FIX\\";\\n})((s = exports.CompletionType || (exports.CompletionType = {})));\\nexports.completionTypeToString = function (e) {\\n  switch (e) {\\n    case s.OPEN_COPILOT:\\n      return \\"open copilot\\";\\n    case s.TODO_QUICK_FIX:\\n      return \\"todo quick fix\\";\\n    case s.UNKNOWN_FUNCTION_QUICK_FIX:\\n      return \\"unknown function quick fix\\";\\n    default:\\n      return \\"unknown\\";\\n  }\\n};\\nclass CompletionContext {\\n  constructor(e, t, n) {\\n    this.prependToCompletion = \\"\\";\\n    this.appendToCompletion = \\"\\";\\n    this.indentation = null;\\n    this.completionType = s.OPEN_COPILOT;\\n    this.insertPosition = e\\n      .get(o.LocationFactory)\\n      .position(t.line, t.character);\\n    this.completionType = n;\\n  }\\n  static fromJSONParse(e, t) {\\n    const n = e\\n        .get(o.LocationFactory)\\n        .position(t.insertPosition.line, t.insertPosition.character),\\n      r = new CompletionContext(e, n, t.completionType);\\n    r.prependToCompletion = t.prependToCompletion;\\n    r.appendToCompletion = t.appendToCompletion;\\n    r.indentation = t.indentation;\\n    return r;\\n  }\\n}\\nexports.CompletionContext = CompletionContext;\\nexports.completionContextForDocument = function (e, t, n) {\\n  let r = n;\\n  const o = t.lineAt(n.line);\\n  if (o.isEmptyOrWhitespace) {\\n    r = o.range.end;\\n  }\\n  return new CompletionContext(e, r, s.OPEN_COPILOT);\\n};\\nlet c = 0;\\nexports.encodeLocation = function (e, t) {\\n  const n = e.toString().split(\\"#\\"),\\n    o = n.length > 1 ? n[1] : \\"\\",\\n    s = JSON.stringify([n[0], t, o]);\\n  return r.URI.parse(`${i.CopilotScheme}:GitHub%20Copilot?${s}#${c++}`);\\n};\\nexports.decodeLocation = function (e, t) {\\n  const [n, o, i] = JSON.parse(t.query);\\n  return [\\n    r.URI.parse(i.length > 0 ? n + \\"#\\" + i : n),\\n    CompletionContext.fromJSONParse(e, o),\\n  ];\\n};","module-code-9813":"var r = require(5290),\\n  o = require(5740),\\n  i = require(\\"correlation-context-manager\\"),\\n  s = (function () {\\n    function e() {}\\n    e.createEnvelope = function (t, n, i, s, a) {\\n      var c = null;\\n      switch (n) {\\n        case r.TelemetryType.Trace:\\n          c = e.createTraceData(t);\\n          break;\\n        case r.TelemetryType.Dependency:\\n          c = e.createDependencyData(t);\\n          break;\\n        case r.TelemetryType.Event:\\n          c = e.createEventData(t);\\n          break;\\n        case r.TelemetryType.Exception:\\n          c = e.createExceptionData(t);\\n          break;\\n        case r.TelemetryType.Request:\\n          c = e.createRequestData(t);\\n          break;\\n        case r.TelemetryType.Metric:\\n          c = e.createMetricData(t);\\n          break;\\n        case r.TelemetryType.Availability:\\n          c = e.createAvailabilityData(t);\\n      }\\n      if (i && r.domainSupportsProperties(c.baseData)) {\\n        if (c && c.baseData)\\n          if (c.baseData.properties) {\\n            for (var l in i)\\n              if (c.baseData.properties[l]) {\\n                c.baseData.properties[l] = i[l];\\n              }\\n          } else c.baseData.properties = i;\\n        c.baseData.properties = o.validateStringMap(c.baseData.properties);\\n      }\\n      var u = (a && a.instrumentationKey) || \\"\\",\\n        d = new r.Envelope();\\n      d.data = c;\\n      d.iKey = u;\\n      d.name =\\n        \\"Microsoft.ApplicationInsights.\\" +\\n        u.replace(/-/g, \\"\\") +\\n        \\".\\" +\\n        c.baseType.substr(0, c.baseType.length - 4);\\n      d.tags = this.getTags(s, t.tagOverrides);\\n      d.time = new Date().toISOString();\\n      d.ver = 1;\\n      d.sampleRate = a ? a.samplingPercentage : 100;\\n      if (n === r.TelemetryType.Metric) {\\n        d.sampleRate = 100;\\n      }\\n      return d;\\n    };\\n    e.createTraceData = function (e) {\\n      var t = new r.MessageData();\\n      t.message = e.message;\\n      t.properties = e.properties;\\n      if (isNaN(e.severity)) {\\n        t.severityLevel = r.SeverityLevel.Information;\\n      } else {\\n        t.severityLevel = e.severity;\\n      }\\n      var n = new r.Data();\\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Trace);\\n      n.baseData = t;\\n      return n;\\n    };\\n    e.createDependencyData = function (e) {\\n      var t = new r.RemoteDependencyData();\\n      if (\\"string\\" == typeof e.name) {\\n        t.name = e.name.length > 1024 ? e.name.slice(0, 1021) + \\"...\\" : e.name;\\n      }\\n      t.data = e.data;\\n      t.target = e.target;\\n      t.duration = o.msToTimeSpan(e.duration);\\n      t.success = e.success;\\n      t.type = e.dependencyTypeName;\\n      t.properties = e.properties;\\n      t.resultCode = e.resultCode ? e.resultCode + \\"\\" : \\"\\";\\n      if (e.id) {\\n        t.id = e.id;\\n      } else {\\n        t.id = o.w3cTraceId();\\n      }\\n      var n = new r.Data();\\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Dependency);\\n      n.baseData = t;\\n      return n;\\n    };\\n    e.createEventData = function (e) {\\n      var t = new r.EventData();\\n      t.name = e.name;\\n      t.properties = e.properties;\\n      t.measurements = e.measurements;\\n      var n = new r.Data();\\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Event);\\n      n.baseData = t;\\n      return n;\\n    };\\n    e.createExceptionData = function (e) {\\n      var t = new r.ExceptionData();\\n      t.properties = e.properties;\\n      if (isNaN(e.severity)) {\\n        t.severityLevel = r.SeverityLevel.Error;\\n      } else {\\n        t.severityLevel = e.severity;\\n      }\\n      t.measurements = e.measurements;\\n      t.exceptions = [];\\n      var n = e.exception.stack,\\n        i = new r.ExceptionDetails();\\n      i.message = e.exception.message;\\n      i.typeName = e.exception.name;\\n      i.parsedStack = this.parseStack(n);\\n      i.hasFullStack = o.isArray(i.parsedStack) && i.parsedStack.length > 0;\\n      t.exceptions.push(i);\\n      var s = new r.Data();\\n      s.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Exception);\\n      s.baseData = t;\\n      return s;\\n    };\\n    e.createRequestData = function (e) {\\n      var t = new r.RequestData();\\n      if (e.id) {\\n        t.id = e.id;\\n      } else {\\n        t.id = o.w3cTraceId();\\n      }\\n      t.name = e.name;\\n      t.url = e.url;\\n      t.source = e.source;\\n      t.duration = o.msToTimeSpan(e.duration);\\n      t.responseCode = e.resultCode ? e.resultCode + \\"\\" : \\"\\";\\n      t.success = e.success;\\n      t.properties = e.properties;\\n      var n = new r.Data();\\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Request);\\n      n.baseData = t;\\n      return n;\\n    };\\n    e.createMetricData = function (e) {\\n      var t = new r.MetricData();\\n      t.metrics = [];\\n      var n = new r.DataPoint();\\n      n.count = isNaN(e.count) ? 1 : e.count;\\n      n.kind = r.DataPointType.Aggregation;\\n      n.max = isNaN(e.max) ? e.value : e.max;\\n      n.min = isNaN(e.min) ? e.value : e.min;\\n      n.name = e.name;\\n      n.stdDev = isNaN(e.stdDev) ? 0 : e.stdDev;\\n      n.value = e.value;\\n      t.metrics.push(n);\\n      t.properties = e.properties;\\n      var o = new r.Data();\\n      o.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Metric);\\n      o.baseData = t;\\n      return o;\\n    };\\n    e.createAvailabilityData = function (e) {\\n      var t = new r.AvailabilityData();\\n      if (e.id) {\\n        t.id = e.id;\\n      } else {\\n        t.id = o.w3cTraceId();\\n      }\\n      t.name = e.name;\\n      t.duration = o.msToTimeSpan(e.duration);\\n      t.success = e.success;\\n      t.runLocation = e.runLocation;\\n      t.message = e.message;\\n      t.measurements = e.measurements;\\n      t.properties = e.properties;\\n      var n = new r.Data();\\n      n.baseType = r.telemetryTypeToBaseType(r.TelemetryType.Availability);\\n      n.baseData = t;\\n      return n;\\n    };\\n    e.getTags = function (e, t) {\\n      var n = i.CorrelationContextManager.getCurrentContext(),\\n        r = {};\\n      if (e && e.tags) for (var o in e.tags) r[o] = e.tags[o];\\n      if (t) for (var o in t) r[o] = t[o];\\n      if (n) {\\n        r[e.keys.operationId] = r[e.keys.operationId] || n.operation.id;\\n        r[e.keys.operationName] = r[e.keys.operationName] || n.operation.name;\\n        r[e.keys.operationParentId] =\\n          r[e.keys.operationParentId] || n.operation.parentId;\\n      }\\n      return r;\\n    };\\n    e.parseStack = function (e) {\\n      var t = undefined;\\n      if (\\"string\\" == typeof e) {\\n        var n = e.split(\\"\\\\n\\");\\n        t = [];\\n        for (var r = 0, o = 0, i = 0; i <= n.length; i++) {\\n          var s = n[i];\\n          if (a.regex.test(s)) {\\n            var c = new a(n[i], r++);\\n            o += c.sizeInBytes;\\n            t.push(c);\\n          }\\n        }\\n        if (o > 32768)\\n          for (var l = 0, u = t.length - 1, d = 0, p = l, h = u; l < u; ) {\\n            if ((d += t[l].sizeInBytes + t[u].sizeInBytes) > 32768) {\\n              var f = h - p + 1;\\n              t.splice(p, f);\\n              break;\\n            }\\n            p = l;\\n            h = u;\\n            l++;\\n            u--;\\n          }\\n      }\\n      return t;\\n    };\\n    return e;\\n  })(),\\n  a = (function () {\\n    function e(t, n) {\\n      this.sizeInBytes = 0;\\n      this.level = n;\\n      this.method = \\"<no_method>\\";\\n      this.assembly = o.trim(t);\\n      var r = t.match(e.regex);\\n      if (r && r.length >= 5) {\\n        this.method = o.trim(r[2]) || this.method;\\n        this.fileName = o.trim(r[4]) || \\"<no_filename>\\";\\n        this.line = parseInt(r[5]) || 0;\\n      }\\n      this.sizeInBytes += this.method.length;\\n      this.sizeInBytes += this.fileName.length;\\n      this.sizeInBytes += this.assembly.length;\\n      this.sizeInBytes += e.baseSize;\\n      this.sizeInBytes += this.level.toString().length;\\n      this.sizeInBytes += this.line.toString().length;\\n    }\\n    e.regex =\\n      /^([\\\\s]+at)?(.*?)(\\\\@|\\\\s\\\\(|\\\\s)([^\\\\(\\\\@\\\\n]+):([0-9]+):([0-9]+)(\\\\)?)$/;\\n    e.baseSize = 58;\\n    return e;\\n  })();\\nmodule.exports = s;","module-code-219":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ExpConfig = exports.ExpTreatmentVariables = undefined;\\nconst r = require(\\"telemetry-stuff\\"),\\n  o = require(6500);\\nvar i;\\n(i = exports.ExpTreatmentVariables || (exports.ExpTreatmentVariables = {})).AA =\\n  \\"copilotaa\\";\\ni.CustomEngine = \\"copilotcustomengine\\";\\ni.Fetcher = \\"copilotfetcher\\";\\ni.OverrideBlockMode = \\"copilotoverrideblockmode\\";\\ni.OverrideNumGhostCompletions = \\"copilotoverridednumghostcompletions\\";\\ni.SuffixPercent = \\"CopilotSuffixPercent\\";\\ni.BeforeRequestWaitMs = \\"copilotlms\\";\\ni.NeighboringTabsOption = \\"copilotneighboringtabs\\";\\ni.DebounceMs = \\"copilotdebouncems\\";\\ni.DebouncePredict = \\"copilotdebouncepredict\\";\\ni.ContextualFilterEnable = \\"copilotcontextualfilterenable\\";\\ni.ContextualFilterAcceptThreshold = \\"copilotcontextualfilteracceptthreshold\\";\\ni.disableLogProb = \\"copilotLogProb\\";\\ni.RepetitionFilterMode = \\"copilotrepetitionfiltermode\\";\\ni.GranularityTimePeriodSizeInH = \\"copilottimeperiodsizeinh\\";\\ni.GranularityByCallBuckets = \\"copilotbycallbuckets\\";\\ni.SuffixStartMode = \\"copilotsuffixstartmode\\";\\ni.SuffixMatchThreshold = \\"copilotsuffixmatchthreshold\\";\\ni.FimSuffixLengthThreshold = \\"copilotfimsuffixlenthreshold\\";\\ni.MultiLogitBias = \\"copilotlbeot\\";\\nclass ExpConfig {\\n  constructor(e, t, n) {\\n    this.variables = e;\\n    this.assignmentContext = t;\\n    this.features = n;\\n  }\\n  static createFallbackConfig(e, t) {\\n    r.telemetryExpProblem(e, {\\n      reason: t,\\n    });\\n    return this.createEmptyConfig();\\n  }\\n  static createEmptyConfig() {\\n    return new ExpConfig({}, \\"\\", \\"\\");\\n  }\\n  addToTelemetry(e) {\\n    e.properties[o.ExpServiceTelemetryNames.featuresTelemetryPropertyName] =\\n      this.features;\\n    e.properties[\\n      o.ExpServiceTelemetryNames.assignmentContextTelemetryPropertyName\\n    ] = this.assignmentContext;\\n  }\\n}\\nexports.ExpConfig = ExpConfig;","module-label-750":"ghost-text-telemetry","module-code-1006":"Object.defineProperty(exports, \\"__esModule\\", {\\n  value: !0,\\n});\\nexports.ghostTextScoreQuantile = exports.ghostTextScoreConfidence = undefined;\\nconst r = require(\\"logging-utils\\"),\\n  o = require(7481),\\n  i =\\n    (new r.Logger(r.LogLevel.INFO, \\"restraint\\"),\\n    {\\n      link: (e) => Math.exp(e) / (1 + Math.exp(e)),\\n      unlink: (e) => Math.log(e / (1 - e)),\\n    });\\nclass s {\\n  constructor(e, t, n) {\\n    this.name = e;\\n    this.coefficient = t;\\n    this.transformation = n || ((e) => e);\\n  }\\n  contribution(e) {\\n    return this.coefficient * this.transformation(e);\\n  }\\n}\\nconst a = new (class {\\n  constructor(e, t, n) {\\n    this.link = i;\\n    this.intercept = e;\\n    this.coefficients = t;\\n    this.logitsToQuantiles = new Map();\\n    this.logitsToQuantiles.set(0, 0);\\n    this.logitsToQuantiles.set(1, 1);\\n    if (n) for (const e in n) this.logitsToQuantiles.set(n[e], Number(e));\\n  }\\n  predict(e, t) {\\n    let n = this.intercept;\\n    for (const e of this.coefficients) {\\n      const r = t[e.name];\\n      if (undefined === r) return NaN;\\n      n += e.contribution(r);\\n    }\\n    return this.link.link(n);\\n  }\\n  quantile(e, t) {\\n    return (function (e, t) {\\n      const n = Math.min(...Array.from(t.keys()).filter((t) => t >= e)),\\n        r = Math.max(...Array.from(t.keys()).filter((t) => t < e)),\\n        o = t.get(n),\\n        i = t.get(r);\\n      return i + ((o - i) * (e - r)) / (n - r);\\n    })(this.predict(e, t), this.logitsToQuantiles);\\n  }\\n})(\\n  o.ghostTextDisplayInterceptParameter,\\n  [\\n    new s(\\"compCharLen\\", o.ghostTextDisplayLog1pcompCharLenParameter, (e) =>\\n      Math.log(1 + e)\\n    ),\\n    new s(\\"meanLogProb\\", o.ghostTextDisplayMeanLogProbParameter),\\n    new s(\\n      \\"meanAlternativeLogProb\\",\\n      o.ghostTextDisplayMeanAlternativeLogProbParameter\\n    ),\\n  ].concat(\\n    Object.entries(o.ghostTextDisplayLanguageParameters).map(\\n      (e) => new s(e[0], e[1])\\n    )\\n  ),\\n  o.ghostTextDisplayQuantiles\\n);\\nexports.ghostTextScoreConfidence = function (e, t) {\\n  const n = {\\n    ...t.measurements,\\n  };\\n  Object.keys(o.ghostTextDisplayLanguageParameters).forEach((e) => {\\n    n[e] = t.properties[\\"customDimensions.languageId\\"] == e ? 1 : 0;\\n  });\\n  return a.predict(e, n);\\n};\\nexports.ghostTextScoreQuantile = function (e, t) {\\n  const n = {\\n    ...t.measurements,\\n  };\\n  Object.keys(o.ghostTextDisplayLanguageParameters).forEach((e) => {\\n    n[e] = t.properties[\\"customDimensions.languageId\\"] == e ? 1 : 0;\\n  });\\n  return a.quantile(e, n);\\n};"}')